from __future__ import annotations

import datetime
import logging
import os
from enum import Enum
from typing import List, Set, Tuple, Union, Dict, Sequence, Iterator, Any, Optional

import pandas
from sqlalchemy import Column, String, Date, Float
from sqlalchemy.orm import Session
from sqlalchemy.sql.elements import BinaryExpression

from sylo.com import bpipe
from sylo.com.progress_bar import progress_bar
from sylo.db import filter_by
from sylo.db.timescale import BaseModel, session_context
from sylo.db.timescale.base import Mixin, save_bulk

logger = logging.getLogger(__name__)
PUSH_BATCH_SIZE = 500
BDP_TICKER_BATCH_SIZE = 100
BDP_FIELD_BATCH_SIZE = 1


def is_null(x: Any) -> bool:
    if pandas.isna(x):
        return True
    elif x == '':
        return True
    return False


def normalise_ticker(x: Any) -> str:
    if not isinstance(x, str):
        raise TypeError(x)
    _x: List[str] = [i.upper() for i in x.split(' ') if i]
    if not _x:
        raise ValueError('ticker cannot be an empty string')
    _x[-1] = _x[-1].title()
    return ' '.join(_x)


def normalise_field(x: Any) -> str:
    if not isinstance(x, str):
        raise TypeError(x)
    x = '_'.join(filter(None, x.split(' ')))
    if not x:
        raise ValueError('field cannot be an empty string')
    return x.upper()


class BondIssueBase(Mixin):
    __tablename__: str
    _as_type: str = 'O'
    ticker = Column(String, index=True)
    field = Column(String)
    value: Column
    Columns: Enum

    @classmethod
    def pull(
            cls,
            tickers: Union[str, Set[str]] = None,
            fields: Union[str, Set[str]] = None,
            extra_filters: Sequence[BinaryExpression] = (),
            asof: datetime.datetime = None,
            is_active: bool = True,
            session: Session = None,
    ) -> Dict[Tuple[str, str], Any]:
        cls.ticker: Column
        cls.field: Column
        raw: Dict[Tuple[str, str], Any] = {}
        with session_context(session=session, mode='r', auto_close=True) as sess:
            query = sess.query(cls.ticker, cls.field, cls.value)
            query = cls.filter(query, *extra_filters, asof=asof, is_active=is_active)
            if tickers:
                query = filter_by(cls.ticker, values=tickers, query=query)
            if fields:
                query = filter_by(cls.field, values=fields, query=query)
            for tkr, fld, v in query.order_by(cls._utc).all():
                raw[tkr, fld] = v
        return raw

    @classmethod
    def from_series(cls, raw: pandas.Series) -> Iterator[BondIssueBase]:
        for (ticker, field), value in raw.items():
            if not is_null(value):
                # noinspection PyArgumentList
                yield cls(
                    ticker=normalise_ticker(ticker),
                    field=normalise_field(field),
                    value=value,
                )

    @classmethod
    def push_series(cls, raw: pandas.Series, force: bool = False, session: Session = None) -> Sequence[BondIssueBase]:
        def unpack() -> Iterator[BondIssueBase]:
            items = list(cls.from_series(raw))
            with session_context(session=session, mode='w', auto_commit=True) as sess:
                if not force:
                    db_raw = cls.pull(
                        tickers={i.ticker for i in items},
                        fields={i.field for i in items},
                        session=sess,
                    )
                    items = [i for i in items if i.value != db_raw.get((i.ticker, i.field))]
            if items:
                yield from save_bulk(progress_bar(items), batch_size=PUSH_BATCH_SIZE, session=sess)

        pushed = list(unpack())
        if pushed:
            tickers = set(i.ticker for i in pushed)
            fields = set(i.field for i in pushed)
            logger.info(f'pushed {len(pushed)} entries with {len(tickers)} tickers and {len(fields)} fields...')
        return pushed

    @classmethod
    def bdp_reference(cls, tickers: Set[str], fields: Set[str] = None) -> pandas.Series:
        if fields is None:
            # noinspection PyTypeChecker
            fields = {i.value for i in cls.Columns}
        tickers, fields = list(tickers), list(fields)

        if tickers and fields:
            def unpack():
                kwd = [(fields[i:i + BDP_FIELD_BATCH_SIZE], tickers[j:j + BDP_TICKER_BATCH_SIZE])
                       for i in range(0, len(fields), BDP_FIELD_BATCH_SIZE)
                       for j in range(0, len(tickers), BDP_TICKER_BATCH_SIZE)]
                for _fields, _tickers in progress_bar(kwd):
                    try:
                        data = bpipe.bdp_reference(securities=_tickers, fields=_fields)
                    except bpipe.BpipeError as e:
                        logger.error(f'failed to fetch fields {_fields} in {len(_tickers)} tickers\n{e}')
                    else:
                        yield data.astype(cls._as_type)

            logger.debug(f'fetching {cls.__name__} for {len(tickers)} tickers and {len(fields)} fields ...')
            return pandas.concat(unpack())
        return pandas.Series(dtype=str)

    @classmethod
    def push_from_bpipe(cls, tickers: Set[str], fields: Set[str] = None, reload: bool = False, force: bool = False,
                        session: Session = None) -> Sequence[BondIssueBase]:
        if fields is None:
            # noinspection PyTypeChecker
            fields = {i.value for i in cls.Columns}

        def unpack() -> Iterator[BondIssueBase]:
            _fields = set(map(normalise_field, fields))
            _tickers = set(map(normalise_ticker, tickers))
            with session_context(session=session, mode='w', auto_commit=True) as sess:
                if not reload:
                    db_raw = cls.pull(tickers=_tickers, fields=_fields, session=sess)
                    _tickers -= {i for i, _ in db_raw}
                if _tickers:
                    raw = cls.bdp_reference(tickers=_tickers, fields=_fields)
                    yield from cls.push_series(raw, force=force, session=sess)

        return list(unpack())


class BondIssueString(BondIssueBase, BaseModel):
    __tablename__ = 'bond_issue_string'
    value = Column(String)

    class Columns(Enum):
        NAME = 'LONG_COMP_NAME'
        DOMICILE = 'CNTRY_OF_DOMICILE'
        CURRENCY = 'CRNCY'
        # SERIES = 'SERIES'
        MATURITY_TYPE = 'MTY_TYP'
        RATING = 'BB_COMPOSITE'

    @classmethod
    def find_tickers(
            cls,
            domicile_include: Set[str] = None,
            domicile_exclude: Set[str] = None,
            currency_include: Set[str] = None,
            currency_exclude: Set[str] = None,
            session: Session = None,
    ) -> Set[str]:
        cls.value: Column
        with session_context(session=session, mode='r', auto_close=True) as sess:
            tickers: Set[str] = set(j for i in sess.query(cls.ticker).distinct().all() for j in i)
            if tickers and domicile_include:
                query = sess.query(cls.ticker).filter(cls.field == cls.Columns.DOMICILE.value).filter(
                    cls.value.in_(domicile_include))
                tickers &= set(j for i in query.distinct().all() for j in i)
            if tickers and domicile_exclude:
                query = sess.query(cls.ticker).filter(cls.field == cls.Columns.DOMICILE.value).filter(
                    cls.value.notin_(domicile_exclude))
                tickers &= set(j for i in query.distinct().all() for j in i)
            if tickers and currency_include:
                query = sess.query(cls.ticker).filter(cls.field == cls.Columns.CURRENCY.value).filter(
                    cls.value.in_(currency_include))
                tickers &= set(j for i in query.distinct().all() for j in i)
            if tickers and currency_exclude:
                query = sess.query(cls.ticker).filter(cls.field == cls.Columns.CURRENCY.value).filter(
                    cls.value.notin_(currency_exclude))
                tickers &= set(j for i in query.distinct().all() for j in i)
        return tickers


class BondIssueDate(BondIssueBase, BaseModel):
    __tablename__ = 'bond_issue_date'
    _as_type = 'datetime64'
    value = Column(Date)

    class Columns(Enum):
        ANNOUNCE_DATE = 'ANNOUNCE_DT'
        ISSUE_DATE = 'ISSUE_DT'
        MATURITY_DATE = 'MATURITY'

    @classmethod
    def find_tickers(
            cls,
            issue_date_range: Tuple[datetime.date, datetime.date] = None,
            announce_date_range: Tuple[datetime.date, datetime.date] = None,
            maturity_date_range: Tuple[datetime.date, datetime.date] = None,
            session: Session = None,
    ) -> Set[str]:
        with session_context(session=session, mode='r', auto_close=True) as sess:
            tickers: Set[str] = set(j for i in sess.query(cls.ticker).distinct().all() for j in i)
            if tickers and issue_date_range:
                start_date, end_date = issue_date_range
                query = sess.query(cls.ticker).filter(cls.field == cls.Columns.ISSUE_DATE.value)
                if start_date:
                    query = query.filter(cls.value >= start_date)
                if end_date:
                    query = query.filter(cls.value <= end_date)
                tickers &= set(j for i in query.distinct().all() for j in i)
            if tickers and announce_date_range:
                start_date, end_date = announce_date_range
                query = sess.query(cls.ticker).filter(cls.field == cls.Columns.ANNOUNCE_DATE.value)
                if start_date:
                    query = query.filter(cls.value >= start_date)
                if end_date:
                    query = query.filter(cls.value <= end_date)
                tickers &= set(j for i in query.distinct().all() for j in i)
            if tickers and maturity_date_range:
                start_date, end_date = maturity_date_range
                query = sess.query(cls.ticker).filter(cls.field == cls.Columns.MATURITY_DATE.value)
                if start_date:
                    query = query.filter(cls.value >= start_date)
                if end_date:
                    query = query.filter(cls.value <= end_date)
                tickers &= set(j for i in query.distinct().all() for j in i)
        return tickers


class BondIssueFloat(BondIssueBase, BaseModel):
    __tablename__ = 'bond_issue_float'
    _as_type = 'float64'
    value = Column(Float)

    class Columns(Enum):
        AMOUNT_ISSUED = 'AMT_ISSUED'
        COUPON = 'CPN'
        TENOR = 'YRS_TO_MTY_ISSUE'

    @classmethod
    def find_tickers(
            cls,
            tenor_range: Tuple[float, float] = None,
            amount_issued_range: Tuple[float, float] = None,
            session: Session = None,
    ) -> Set[str]:
        with session_context(session=session, mode='r', auto_close=True) as sess:
            tickers: Set[str] = set(j for i in sess.query(cls.ticker).distinct().all() for j in i)
            if tickers and tenor_range:
                _min, _max = tenor_range
                query = sess.query(cls.ticker).filter(cls.field == cls.Columns.TENOR.value)
                if _min is not None:
                    query = query.filter(cls.value >= _min)
                if _max is not None:
                    query = query.filter(cls.value <= _max)
                tickers &= set(j for i in query.distinct().all() for j in i)
            if tickers and amount_issued_range:
                _min, _max = amount_issued_range
                query = sess.query(cls.ticker).filter(cls.field == cls.Columns.AMOUNT_ISSUED.value)
                if _min is not None:
                    query = query.filter(cls.value >= _min)
                if _max is not None:
                    query = query.filter(cls.value <= _max)
                tickers &= set(j for i in query.distinct().all() for j in i)
        return tickers


class BondIssue:
    __tables__ = (BondIssueString, BondIssueDate, BondIssueFloat)

    @classmethod
    def pull(
            cls,
            tickers: Union[str, Set[str]] = None,
            fields: Union[str, Set[str]] = None,
            asof: datetime.datetime = None,
            is_active: bool = True,
            session: Session = None,
    ) -> Dict[Tuple[str, str], Any]:
        def unpack() -> Iterator[Tuple[Tuple[str, str], Any]]:
            with session_context(session=session, mode='r', auto_close=True) as sess:
                for _cls in cls.__tables__:
                    yield from _cls.pull(
                        tickers=tickers,
                        fields=fields,
                        asof=asof,
                        is_active=is_active,
                        session=sess,
                    ).items()

        return dict(unpack())

    @classmethod
    def push_from_bpipe(
            cls,
            tickers: Set[str],
            fields: Set[str] = None,
            reload: bool = False,
            force: bool = False,
            session: Session = None,
    ) -> Sequence[BondIssueBase]:
        def unpack() -> Iterator[BondIssueBase]:
            with session_context(session=session, mode='w', auto_commit=True) as sess:
                for _cls in cls.__tables__:
                    _fields = fields
                    if fields:
                        _fields = set(fields) & {i.value for i in _cls.Columns}
                    yield from _cls.push_from_bpipe(
                        tickers=tickers,
                        fields=_fields,
                        reload=reload,
                        force=force,
                        session=sess,
                    )

        return list(unpack())

    @staticmethod
    def find_tickers(
            domicile_include: Set[str] = None,
            domicile_exclude: Set[str] = None,
            currency_include: Set[str] = None,
            currency_exclude: Set[str] = None,
            issue_date_range: Tuple[datetime.date, datetime.date] = None,
            announce_date_range: Tuple[datetime.date, datetime.date] = None,
            maturity_date_range: Tuple[datetime.date, datetime.date] = None,
            tenor_range: Tuple[float, float] = None,
            amount_issued_range: Tuple[float, float] = None,
            session: Session = None,
    ) -> Set[str]:
        with session_context(session=session, mode='r', auto_close=True) as sess:
            tickers = BondIssueString.find_tickers(
                domicile_include=domicile_include,
                domicile_exclude=domicile_exclude,
                currency_include=currency_include,
                currency_exclude=currency_exclude,
                session=sess,
            )
            if tickers and (issue_date_range or announce_date_range or maturity_date_range):
                tickers &= BondIssueDate.find_tickers(
                    issue_date_range=issue_date_range,
                    announce_date_range=announce_date_range,
                    maturity_date_range=maturity_date_range,
                    session=sess,
                )
            if tickers and (tenor_range or amount_issued_range):
                tickers &= BondIssueFloat.find_tickers(
                    tenor_range=tenor_range,
                    amount_issued_range=amount_issued_range,
                    session=sess,
                )
        return tickers


def _currency_conversion(raw: pandas.DataFrame, currency: str = 'USD') -> pandas.DataFrame:
    _raw = raw[['CURRENCY', 'AMOUNT_ISSUED', 'ANNOUNCE_DATE', 'ISSUE_DATE']]
    fx_tickers: Dict[str, str] = {f'{currency}{i} Curncy': i for i in set(_raw['CURRENCY']) if i != currency}
    start_date = min(_raw['ANNOUNCE_DATE'].dropna().min(), _raw['ISSUE_DATE'].dropna().min())
    end_date = max(_raw['ANNOUNCE_DATE'].dropna().max(), _raw['ISSUE_DATE'].dropna().max())
    logger.debug(f'fetching {len(fx_tickers)} fx tickers ...')
    fx_raw = bpipe.bdh(list(fx_tickers), fields=['LAST_PRICE'], start_date=start_date, end_date=end_date)
    fx_data = fx_raw.droplevel(1, axis=1).rename(fx_tickers, axis=1)

    def unpack():
        for (_, row), (_, announce_fx), (_, issue_fx) in progress_bar(zip(
                _raw.iterrows(),
                fx_data.asof(pandas.DatetimeIndex(_raw['ANNOUNCE_DATE'])).iterrows(),
                fx_data.asof(pandas.DatetimeIndex(_raw['ISSUE_DATE'])).iterrows(),
        ), total=len(_raw)):
            ccy = row['CURRENCY']
            announce_amount = issue_amount = row['AMOUNT_ISSUED']
            if ccy != currency:
                announce_amount /= float('nan') if pandas.isna(announce_fx.name) else announce_fx[ccy]
                issue_amount /= float('nan') if pandas.isna(issue_fx.name) else issue_fx[ccy]
            yield {
                currency + '_AMOUNT_ON_ANNOUNCE_DATE': announce_amount,
                currency + '_AMOUNT_ON_ISSUE_DATE': issue_amount,
            }

    return pandas.DataFrame(unpack(), index=raw.index)


def find_issuance(
        domicile_include: Set[str] = None,
        domicile_exclude: Set[str] = None,
        currency_include: Set[str] = None,
        currency_exclude: Set[str] = None,
        issue_date_range: Tuple[datetime.date, datetime.date] = None,
        announce_date_range: Tuple[datetime.date, datetime.date] = None,
        maturity_date_range: Tuple[datetime.date, datetime.date] = None,
        tenor_range: Tuple[float, float] = None,
        amount_issued_range: Tuple[float, float] = None,
        limit: Optional[int] = 10_000,
        currency_conversion: str = None,
        session: Session = None,
) -> pandas.DataFrame:
    """
    Helper function to search for bond issuance data.

    :param domicile_include: Set[str], a collection of domicile country codes that the search includes
    :param domicile_exclude: Set[str], a collection of domicile country codes that the search excludes
    :param currency_include: Set[str], a collection of currency codes that the search includes
    :param currency_exclude: Set[str], a collection of currency codes that the search excludes
    :param issue_date_range: Tuple[date, date], the min/max issue date range that the search includes
    :param announce_date_range: Tuple[date, date], the min/max announce date range that the search includes
    :param maturity_date_range: Tuple[date, date], the min/max maturity date range that the search includes
    :param tenor_range: Tuple[float, float], the min/max bond tenor range that the search includes
    :param amount_issued_range: Tuple[float, float], the min/max issue amount range that the search includes
    :param limit: int, the maximum number of bonds to return. When is None, no limit is set.
    :param currency_conversion: Optional[str], the currency to which issued amount is converted, e.g. 'USD'
    :param session: sqlalchemy.orm.Session, the session object for database access
    :return: a pandas.DataFrame of the search result.
    """
    columns: Dict[str, str] = {j.value: j.name for i in BondIssue.__tables__ for j in i.Columns}
    raw: Dict[str, Dict[str, Any]] = {}
    with session_context(session=session, mode='r', auto_close=True) as sess:
        tickers = BondIssue.find_tickers(
            domicile_include=domicile_include,
            domicile_exclude=domicile_exclude,
            currency_include=currency_include,
            currency_exclude=currency_exclude,
            issue_date_range=issue_date_range,
            announce_date_range=announce_date_range,
            maturity_date_range=maturity_date_range,
            tenor_range=tenor_range,
            amount_issued_range=amount_issued_range,
            session=sess,
        )
        if tickers:
            if limit:
                assert isinstance(limit, int) and limit > 0
                tickers = set(list(tickers)[:limit])
            for (tkr, fld), val in BondIssue.pull(tickers=tickers, fields=set(columns), session=sess).items():
                raw.setdefault(tkr, {})[fld] = val

    frame = pandas.DataFrame(raw).T
    if len(frame):
        frame.reset_index(inplace=True)
        columns.update({'index': 'TICKER'})
        frame.rename(columns, axis=1, inplace=True)
        if currency_conversion:
            frame = pandas.concat([frame, _currency_conversion(frame, currency=currency_conversion)], axis=1)
    return frame


class CountryAlias:
    EUR = {'AT', 'BE', 'CY', 'DE', 'ES', 'FI', 'FR', 'GR', 'IE', 'IT', 'LT', 'LU', 'LV', 'MT', 'NL', 'PT', 'SK'}
    GBP = {'GB'}
    AUD = {'AU'}
    NZD = {'NZ'}
    CAD = {'CA'}
    SEK = {'SE'}
    JPY = {'JP'}
    HKD = {'HK'}
    SGD = {'SG'}
    USD = {'US'}
    NOK = {'NO'}
    CHF = {'CH'}


DEFAULT_TICKER_FILEPATH = r'.tmp/bond_issue/tickers.csv'


def main():
    print('---------- checking new tickers to push ----------')
    tkr_frame = pandas.read_csv(os.getenv('TICKER_FILEPATH') or DEFAULT_TICKER_FILEPATH, header=[0, 1])
    existing_tickers = BondIssue.find_tickers()
    new_tickers = set()
    for currency in sorted(set(tkr_frame.columns.get_level_values(0))):
        tickers = {j for _, i in tkr_frame[currency].items() for j in i.dropna()} - existing_tickers
        print(currency, len(tickers))
        new_tickers.update(tickers)
    if new_tickers:
        for idx, tkr_col in tkr_frame.items():
            tickers = set(tkr_col.dropna()) & new_tickers
            if tickers:
                print(f'---------- pushing {idx} ----------')
                BondIssue.push_from_bpipe(tickers)
    print('---------- all done ----------')


if __name__ == '__main__':
    pass
    import sylo.config.config

    try:
        sylo.config.config.init_config()
        main()
    except Exception as exc:
        logger.error('', exc_info=exc)
        input('press enter to exit ...')

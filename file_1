File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\firm_data_client.py
----------------------------------------
import os
from typing import Dict, Any

import atom_client.client  # type:ignore
import atom_client.client_secure  # type:ignore

_firm_client_dictionary: Dict[str, Any] = dict()


def get_environ_params() -> Dict[str, str]:
    o = dict()
    val = os.environ.get('firm_DATA_CLIENT_KEY')
    if val is not None:
        o['key'] = val
    val = os.environ.get('firm_DATA_CLIENT_CERTIFICATE')
    if val is not None:
        o['certificate'] = val
    val = os.environ.get('firm_DATA_CLIENT_TRUST')
    if val is not None:
        o['trust'] = val
    val = os.environ.get('firm_DATA_CLIENT_PASSWORD')
    if val is not None:
        o['password'] = val
    return o


def map_environment(env: str) -> str:
    mapping = os.environ.get("firm_DATA_CLIENT_ENV_MAPPING")
    if not mapping:
        return env
    mapping = dict([i.split(":") for i in mapping.split(",")])
    mapped = mapping.get(env)
    if not mapped:
        return env
    return mapped


def firm_connect(firm_client_env: str = 'prd'):
    firm_client_env = map_environment(firm_client_env)

    global _firm_client_dictionary
    key = f"{firm_client_env}"
    params = get_environ_params()

    if key not in _firm_client_dictionary:
        if os.environ.get('firm_DATA_CLIENT_USESECURE') is not None:
            _firm_client_dictionary[key] = atom_client.client_secure.firmDataClient(firm_client_env, **params)
        else:
            _firm_client_dictionary[key] = atom_client.client.firmDataClient(firm_client_env, **params)
    return _firm_client_dictionary[key]


def firm_disconnect_all():
    global _firm_client_dictionary
    for k, v in _firm_client_dictionary.items():
        v.shutdown()
    _firm_client_dictionary.clear()

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\config.py
----------------------------------------
import os
import yaml

try:
    __IPYTHON__  # type: ignore
    import pandas  # type: ignore
except (NameError, ImportError):
    pass
else:
    pandas.options.display.width = 200
    pandas.options.display.max_columns = 10

pkg_dir = os.path.dirname(__file__)

try:
    with open(os.path.join(pkg_dir, 'config.yml'), 'r') as f:
        conf = yaml.safe_load(f)
except FileNotFoundError:
    conf = {}

# jchi@201910
# change working directory when launching via pyxll by Excel
cwd = os.getcwd()
if os.path.basename(cwd).startswith('Office'):
    os.chdir(os.path.abspath(os.path.join(pkg_dir, '..')))

alias = conf.get('projectAlias', os.path.basename(pkg_dir))
root_dir = os.path.abspath(conf.get('systemDirectory', {}).get('root_dir', '.'))
log_dir = os.path.abspath(conf.get('systemDirectory', {}).get('log_dir', './log'))
log_file = conf.get('systemDirectory', {}).get('log_file', '%DYNAMIC%')
tmp_dir = os.path.abspath(conf.get('systemDirectory', {}).get('tmp_dir', './tmp'))

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\config.yml
----------------------------------------
#projectAlias: firm-f3
systemDirectory:
  root_dir: .
  log_dir: ./log
  log_level: 10
  tmp_dir: ./tmp
#f3service:
#  url: http://firmphdr3plxprd01:16161/rpc

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\configuration.prod.yml
----------------------------------------
#########################################################################
# If you are outside of the Platform's security perimeter, you will only
# be able to develop platform clients, and you have to define the
# platform_gateway and platform_authentication_message parameters.
#########################################################################

#platform_gateway: http://127.0.0.1:8090
platform_authentication_message:
    username: "admin"
    password: "pass"
    provider: CUSTOM

#######################################################################################
# For development of Platform extensions you need to be inside its security perimeter.
# In that case comment out the platform_gateway above and specify eureka_service_url.
#######################################################################################
eureka_service_url: http://172.31.22.47:8761
platform_gateway: http://172.31.22.47:8090
# The following needs to be defined only if your Platform does not have the Grid Manager service.
# You can see if that service is present by visiting the above Eureka URL.
# execute_f3ml_url: http://127.0.0.1:8505


#######################################################################################
## Additional optional parameters for developing Platform services/extensions        ##
#######################################################################################
# Use port 0 or comment out if you are ok with randomly selected ports for your services
http_port: 6565
# Needed for registering your services with F3 Platform
token_secret: cuqYrv2V3NkqJD8n
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\configuration.uat.yml
----------------------------------------
#########################################################################
# If you are outside of the Platform's security perimeter, you will only
# be able to develop platform clients, and you have to define the
# platform_gateway and platform_authentication_message parameters.
#########################################################################

#platform_gateway: http://127.0.0.1:8090
platform_authentication_message:
    username: "admin"
    password: "pass"
    provider: CUSTOM

#######################################################################################
# For development of Platform extensions you need to be inside its security perimeter.
# In that case comment out the platform_gateway above and specify eureka_service_url.
#######################################################################################
eureka_service_url: http://firmphdr3plxprd01:8761
platform_gateway: http://firmphdr3plxprd01:8090
# The following needs to be defined only if your Platform does not have the Grid Manager service.
# You can see if that service is present by visiting the above Eureka URL.
# execute_f3ml_url: http://127.0.0.1:8505


#######################################################################################
## Additional optional parameters for developing Platform services/extensions        ##
#######################################################################################
# Use port 0 or comment out if you are ok with randomly selected ports for your services
http_port: 6565
# Needed for registering your services with F3 Platform
token_secret: ZpMb6rZRw9Gm8NeT
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\configuration.yml
----------------------------------------
#########################################################################
# If you are outside of the Platform's security perimeter, you will only
# be able to develop platform clients, and you have to define the
# platform_gateway and platform_authentication_message parameters.
#########################################################################

#platform_gateway: http://127.0.0.1:8090
platform_authentication_message:
    username: "admin"
    password: "pass"
    provider: CUSTOM

#######################################################################################
# For development of Platform extensions you need to be inside its security perimeter.
# In that case comment out the platform_gateway above and specify eureka_service_url.
#######################################################################################
eureka_service_url: http://172.31.22.47:8761
platform_gateway: http://172.31.22.47:8090
# The following needs to be defined only if your Platform does not have the Grid Manager service.
# You can see if that service is present by visiting the above Eureka URL.
# execute_f3ml_url: http://127.0.0.1:8505


#######################################################################################
## Additional optional parameters for developing Platform services/extensions        ##
#######################################################################################
# Use port 0 or comment out if you are ok with randomly selected ports for your services
http_port: 6565
# Needed for registering your services with F3 Platform
token_secret: cuqYrv2V3NkqJD8n
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\crud.py
----------------------------------------
from .core.crud import *
import warnings

msg = """
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                   !!
!! WARNING firm_f3.crud is moved to firm_f3.core.crud                !!
!! please update your import statement accordingly                   !!
!!                                                                   !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"""
print(msg)
warnings.warn(msg, DeprecationWarning)

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\derived_data.py
----------------------------------------
import logging
import asyncio
import datetime
from collections import defaultdict
from typing import Union, Dict, List

import dateutil
import pandas
from f3sdk.f3 import F3Object  # type: ignore
from f3sdk.lib.coroutine import wait  # type: ignore

from firm_f3.core import endpoints
import firm_f3.f3client  # type:ignore
from firm_f3.modelconfig import get_curve_ins_max_tenor, FX_OPTION_CCY
from firm_f3.core.modelutils import get_model_by_ref_async, get_slug_from_model
from firm_f3.util.utils import timer
from firm_domain import Ccy, Tenor, IRS, TenorBasis, XccyBasis, CrossCurrencySwap, OIS, FXForwardOutright, \
    Conventions, InflationSwap
from firm_f3.core.crud import get_one_async, create_async
from firm_f3.mapping import f3instrument_type, f3quote_spec, ccy_to_f3pair
from firm_f3.evaluate import raise_if_error, f3_evaluate_async, req_valuation_date_single
from firm_f3.model_object.calculator import derived_quotes_by_instruments_async, DEFAULT_RISK_TENORS, \
    DEFAULT_FX_RISK_TENORS, DEFAULT_INFLATION_RISK_TENORS

logger = logging.getLogger(__name__)

DEFAULT_RISK_CURRENCIES = [
    Ccy.USD, Ccy.EUR, Ccy.AUD, Ccy.NZD, Ccy.GBP, Ccy.CAD, Ccy.CHF, Ccy.JPY, Ccy.SEK, Ccy.NOK, Ccy.KRW, Ccy.ZAR, Ccy.SAR,
    Ccy.ILS, Ccy.HUF, Ccy.PLN, Ccy.SGD, Ccy.HKD, Ccy.CNY, Ccy.CNH, Ccy.MYR, Ccy.THB, Ccy.RUB, Ccy.INR, Ccy.INO, Ccy.TWD,
    Ccy.NTO, Ccy.PHP, Ccy.IDR, Ccy.TRY, Ccy.MXN,
]
if datetime.date.today() == datetime.date(2020, 7, 21):
    # jchi@2020-07-21
    # F3 error arises on 2020-07-21 for EUR curve, suspect something wrong with the EUR calendar
    # temporarily remove EUR to fix Nimrod so that it can run
    DEFAULT_RISK_CURRENCIES = [i for i in DEFAULT_RISK_CURRENCIES if i not in (Ccy.EUR, Ccy.HUF, Ccy.PLN)]


def risk_model_instruments(ccy: Ccy, tenors=DEFAULT_RISK_TENORS, fx_points_model: bool = False):
    max_tenors = get_curve_ins_max_tenor()
    max_tenor = max_tenors[ccy]

    def unpack():
        if ccy not in (Ccy.PHP, Ccy.IDR, Ccy.MXN):
            for tenor in filter(lambda x: x <= max_tenor, tenors):
                # IRS
                if ccy not in (Ccy.INR, Ccy.INO, Ccy.RUB, Ccy.CNH, Ccy.TRY):
                    if ccy is Ccy.AUD:
                        # enforce 3M the AUD base curve for all tenors
                        irs = IRS(ccy=ccy, tenor=tenor, idx=Tenor.T_3M)
                    else:
                        irs = IRS(ccy=ccy, tenor=tenor)
                    if tenor >= irs.idx:
                        yield irs

                # OIS
                if ccy in (Ccy.INR, Ccy.INO) and tenor >= Tenor.T_6M:
                    yield OIS(ccy=ccy, tenor=tenor)

                # OIS-IRS Basis
                if ccy not in (
                        Ccy.KRW, Ccy.INR, Ccy.INO, Ccy.RUB, Ccy.CNY, Ccy.CNH, Ccy.MYR, Ccy.THB, Ccy.TWD, Ccy.NTO,
                        Ccy.TRY):
                    if ccy is Ccy.AUD:
                        # enforce AUD OIS spread vs. 3M
                        ois = TenorBasis(ccy=ccy, tenor=tenor, idx_1=Tenor.T_1D, idx_2=Tenor.T_3M)
                    else:
                        ois = TenorBasis(ccy=ccy, tenor=tenor, idx_1=Tenor.T_1D)
                    if tenor >= ois.idx_2:
                        yield ois

                # 1s3s Basis
                if tenor >= Tenor.T_3M and ccy in (Ccy.USD, Ccy.HKD, Ccy.AUD):
                    yield TenorBasis(ccy=ccy, tenor=tenor, idx_1=Tenor.T_1M, idx_2=Tenor.T_3M)

                # 3s6s Basis
                if tenor >= Tenor.T_6M and ccy in (
                        Ccy.USD, Ccy.EUR, Ccy.AUD, Ccy.GBP, Ccy.JPY, Ccy.PLN, Ccy.HUF, Ccy.SGD, Ccy.NOK, Ccy.CHF):
                    yield TenorBasis(ccy=ccy, tenor=tenor, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M)

                if not fx_points_model:
                    # Float-Float Cross Currency Basis
                    if ccy not in (
                            Ccy.USD, Ccy.INR, Ccy.INO, Ccy.RUB, Ccy.CNH, Ccy.CNY, Ccy.TWD, Ccy.NTO, Ccy.MYR, Ccy.THB,
                            Ccy.TRY) and tenor >= Tenor.T_3M and (ccy not in (Ccy.KRW, Ccy.SGD) or tenor >= Tenor.T_6M):
                        yield XccyBasis(ccy=ccy, tenor=tenor)

                    # Fix-Float Cross Currency Swap
                    if (ccy in (Ccy.RUB, Ccy.CNH, Ccy.TRY) and tenor >= Tenor.T_3M) or (
                            ccy in (Ccy.INR, Ccy.INO) and tenor >= Tenor.T_6M):
                        yield CrossCurrencySwap(ccy=ccy, tenor=tenor)

        if fx_points_model and ccy is not Ccy.USD:
            # FX forwards
            for tenor in DEFAULT_FX_RISK_TENORS:
                yield FXForwardOutright(ccy=ccy, tenor=tenor)

        # Inflation Swaps
        if ccy is Ccy.USD:  # jchi@202002 limited to USD inflation swaps, will expand the scope in future
            indices = [i for i, c in Conventions.INFLATION_INDEX_TO_CCY_MAPPING.items() if c is ccy]
            for idx in indices:
                for tenor in DEFAULT_INFLATION_RISK_TENORS:
                    yield InflationSwap(idx, tenor)

    return list(unpack())


async def derive_single_curve_async(
        eval_date: datetime,
        f3model: F3Object,
        ccy: Ccy,
        fx_points_model: bool = False,
) -> pandas.DataFrame:
    assert isinstance(ccy, Ccy)
    assert isinstance(f3model, F3Object)
    instruments = risk_model_instruments(ccy, fx_points_model=fx_points_model)

    logger.debug(f'deriving quotes for ccy={ccy}')
    res = await derived_quotes_by_instruments_async(instruments, f3model=f3model)

    rv = defaultdict(dict)
    for inst, rate in zip(instruments, res):
        rv[f3instrument_type(inst)][inst.tenor] = rate

    return pandas.DataFrame(rv).sort_index()


def derive_single_curve(f3model: F3Object, ccy: Ccy, fx_points_model: bool = False) -> pandas.DataFrame:
    return wait(derive_single_curve_async(f3model=f3model, ccy=ccy, fx_points_model=fx_points_model))


async def derive_fx_sabr_async(
        f3model: F3Object,
        ccy_pair: Union[str, Ccy],
) -> pandas.DataFrame:
    f3 = firm_f3.f3client.get_platform_client()
    assert isinstance(f3model, F3Object)
    if isinstance(ccy_pair, Ccy):
        ccy_pair = ccy_to_f3pair(ccy_pair)
    assert isinstance(ccy_pair, str)

    def make_series(raw):
        def unpack():
            if raw:
                raise_if_error(raw[0])
            for idx, v in raw:
                if idx < 0.7 / 12:
                    key = f'{round(idx * 52)}w'
                elif idx < 1:
                    key = f'{round(idx * 12)}m'
                else:
                    key = f'{round(idx)}y'
                yield key, v

        return pandas.Series(dict(unpack()))

    sabr_tags = ['SABRAlpha', 'SABRBeta', 'SABRRho', 'SABRNu']
    req = [f3.ExtractUnderlyingInterpolationPoints(
        Model=f3model,
        CurveTag=[ccy_pair, tag]
    ) for tag in sabr_tags]

    logger.debug(f'deriving SABR coefficients for ccy_pair={ccy_pair}')
    res = await f3_evaluate_async(req, callback=make_series)

    return pandas.DataFrame(res, index=sabr_tags).T


def derive_fx_sabr(f3model: F3Object, ccy_pair: str, ) -> pandas.DataFrame:
    return wait(derive_fx_sabr_async(f3model, ccy_pair))


async def derive_single_curve_f3data_async(
        eval_date: datetime,
        f3model: F3Object,
        ccy: Ccy,
        fx_points_model: bool = False,
) -> Dict[str, F3Object]:
    rv = await derive_single_curve_async(eval_date=eval_date, f3model=f3model, ccy=ccy, fx_points_model=fx_points_model)
    f3 = firm_f3.f3client.get_platform_client()
    derived_data = {}
    for k, v in rv.items():
        v.dropna(inplace=True)
        derived_data[k] = f3.CreateCurveMarketData(
            InstrumentType=k,
            Maturities=list(map(lambda x: f3quote_spec(x, eval_date), v.index)),
            Quotes=list(v)
        )

    return derived_data


async def derive_fx_sabr_f3data_async(
        f3model: F3Object,
        ccy: Ccy,
) -> Dict[str, F3Object]:
    ccy_pair = ccy_to_f3pair(ccy)
    rv = await derive_fx_sabr_async(f3model=f3model, ccy_pair=ccy_pair)
    f3 = firm_f3.f3client.get_platform_client()
    derived_data = {}
    for k, v in rv.items():
        v.dropna(inplace=True)
        derived_data[f'{ccy_pair}-{k}'] = f3.CreateDateValueMarketData(
            DateValueName=f'{k}:{ccy_pair}',
            DateValueType=k,
            Maturities=list(v.index),
            Values=list(v),
            MarketConventions=ccy_pair,
        )

    return derived_data


async def derive_all_f3data_async(eval_date: datetime, f3model: F3Object, fx_points_model: bool = False) -> List[F3Object]:
    def job():
        for ccy in DEFAULT_RISK_CURRENCIES:
            yield derive_single_curve_f3data_async(eval_date=eval_date, f3model=f3model, ccy=ccy, fx_points_model=fx_points_model)
        for ccy in FX_OPTION_CCY:
            yield derive_fx_sabr_f3data_async(f3model=f3model, ccy=ccy)

    cnt = len(DEFAULT_RISK_CURRENCIES) + len(FX_OPTION_CCY)
    with timer(f'::derive_all_f3data_async: request for {cnt} currencies'):
        res = await asyncio.gather(*job())
    return [v for dct in res for v in dct.values()]


async def upload_derived_data_async(
        ref: str = 'prd',
        stream_type: str = 'intraday',
        derived_data: dict = None,
        ordering_time_point: datetime.datetime = None
) -> None:
    f3 = firm_f3.f3client.get_platform_client()
    assert isinstance(derived_data, dict)
    assert isinstance(ordering_time_point, datetime.datetime)
    for k, v in derived_data.items():
        snap_name = f'{k}_Derived_MktData_snap_{ref}_{stream_type}'
        snap_des = f'{snap_name}_description'
        try:
            stream = await get_one_async(endpoints.MarketDataStream,
                                         {'name': f'{k}_Derived_MktData_stream_{ref}_{stream_type}'})
        except RuntimeError:
            stream = await create_async(endpoints.MarketDataStream,
                                        {'name': f'{k}_Derived_MktData_stream_{ref}_{stream_type}'})

        ordering_time_point_str = ordering_time_point.astimezone(datetime.timezone.utc).strftime(
            '%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'

        new_obj = {'name': snap_name,
                   'ordering_timepoint': ordering_time_point_str}

        try:
            res = await get_one_async(endpoints.MarketDataSnapshot, new_obj)
        except RuntimeError:
            pass
        else:
            slug = res['slug']
            await f3.Platform.Object.delete(f"{endpoints.MarketDataSnapshot}/{slug}")

        new_obj.update({'description': snap_des,
                        'format': 'f3ml',
                        'ordering_timepoint': ordering_time_point,
                        'market_data_stream_slug': stream['slug'],
                        'input_f3ml': ''.join(v.form_f3ml())})

        await create_async(endpoint="market_data_snapshot", new_obj=new_obj)
        logger.debug(f'posted to name={snap_name} market_data_stream_slug={stream["slug"]}')


async def update_single_curve_async(
        ref: str = 'prd',
        stream_type: str = 'intraday',
        f3model: F3Object = None,
        ccy: Ccy = None,
        fx_points_model: bool = False,
        ref_timestamp: datetime.datetime = None,
):
    val_date = req_valuation_date_single(f3model)
    derived_data = await derive_single_curve_f3data_async(eval_date=val_date, f3model=f3model, ccy=ccy, fx_points_model=fx_points_model)
    await upload_derived_data_async(ref=ref, stream_type=stream_type, derived_data=derived_data,
                                    ordering_time_point=ref_timestamp)


async def update_single_fx_sabr_async(
        ref: str = 'prd',
        stream_type: str = 'intraday',
        f3model: F3Object = None,
        ccy: Ccy = None,
        ref_timestamp: datetime.datetime = None,
):
    derived_data = await derive_fx_sabr_f3data_async(f3model=f3model, ccy=ccy)
    await upload_derived_data_async(ref=ref, stream_type=stream_type, derived_data=derived_data,
                                    ordering_time_point=ref_timestamp)


async def update_all_curves_async(
        ref: str = 'prd',
        stream_type: str = 'intraday',
        f3model: F3Object = None,
        fx_points_model: bool = False,
) -> None:
    if f3model is None:
        f3model = await get_model_by_ref_async(ref, stream_type)

    logger.debug('fetching model snapshot ref_timestamp')
    try:
        slug = get_slug_from_model(f3model)
    except ValueError:
        ref_timestamp = datetime.datetime.utcnow()
    else:
        res = await get_one_async(f'model_snapshot/{slug}')
        assert res['is_active']
        ref_timestamp = dateutil.parser.parse(res['modified_utc'])

    def job():
        for ccy in DEFAULT_RISK_CURRENCIES:
            yield update_single_curve_async(ref=ref, stream_type=stream_type, f3model=f3model, ccy=ccy,
                                            fx_points_model=fx_points_model, ref_timestamp=ref_timestamp)
        for ccy in FX_OPTION_CCY:
            yield update_single_fx_sabr_async(ref=ref, stream_type=stream_type, f3model=f3model, ccy=ccy,
                                              ref_timestamp=ref_timestamp)

    with timer(f'::derive_all_curves_async: request for {len(DEFAULT_RISK_CURRENCIES)} currencies'):
        await asyncio.gather(*job())


def update_all_curves(ref: str = 'prd', stream_type: str = 'intraday', f3model: F3Object = None,
                      fx_points_model: bool = False):
    return wait(update_all_curves_async(ref, stream_type, f3model=f3model, fx_points_model=fx_points_model))


if __name__ == '__main__':
    pass
    # from FINCAD.evaluate import par_rate
    #
    # f3model = get_model_by_ref()
    #
    # ccy = Ccy.HUF
    # df = par_rate(*risk_model_instruments(ccy), f3model=f3model)

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\endpoints.py
----------------------------------------
from .core.endpoints import *
import warnings

msg = """
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                   !!
!! WARNING firm_f3.endpoints is moved to firm_f3.core.endpoints      !!
!! please update your import statement accordingly                   !!
!!                                                                   !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"""
print(msg)
warnings.warn(msg, DeprecationWarning)

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\f3client.py
----------------------------------------
import os
from functools import wraps
from typing import Any

from f3sdk.f3 import F3Object  # type: ignore
from f3sdk.lib.context_vars import platform_client  # type: ignore
from f3sdk.lib.coroutine import wait  # type: ignore

__f3_connection_object: Any = None # Do not import or use this variable outside this file !!!!!

# if not os.environ.get('F3_SHARED_NO_AUTOCONNECT'):
#     __f3_connection_object = wait(platform_client())


def set_platform_client(client: F3Object) -> None:
    global __f3_connection_object
    __f3_connection_object = client


def get_platform_client() -> Any:
    global __f3_connection_object
    if __f3_connection_object is None:
        raise Exception("F3 connection has not been established yet")
    return __f3_connection_object


async def get_platform_client_autoconnect_async():
    """
    This function should be used only in situations where it is not possible establish connection explicitly
    at the beginning of the program. This is the case of EXCEL functions.

    In all other situations, caller should esstablish and F3 connection explicitly outside
    f3-shared library and then set it using set_platform_client() function.
    """
    global __f3_connection_object
    if __f3_connection_object is None:
        __f3_connection_object = await platform_client()
    return __f3_connection_object


def get_platform_client_autoconnect():
    return wait(get_platform_client_autoconnect_async())


def f3_client_auto_connect(func):
    @wraps(func)
    def f(*args, **kwargs):
        get_platform_client_autoconnect()
        return func(*args, **kwargs)

    return f

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\f3definitions.py
----------------------------------------
from typing import List, Any

from firm_domain.core import Ccy
import firm_f3.f3client  # type:ignore
from f3sdk.f3.context import F3Object  # type: ignore
from f3sdk.lib.coroutine import wait  # type: ignore # Allows to wait for a coroutine to complete.


class PriceOrYield:
    price: float
    yield_convention: str

    def __init__(self, price: float, yield_convention: str):
        self.price = price
        self.yield_convention = yield_convention

    def to_list(self) -> List[Any]:
        return [self.price, self.yield_convention]

    def __str__(self):
        return f"[{self.price}, {self.yield_convention}]"

    def __repr__(self):
        return str(self)


class CurveTag:
    currency: Ccy
    curve: str

    def __init__(self, currency: Ccy, curve: str):
        assert isinstance(currency, Ccy)
        self.currency = currency
        self.curve = curve

    def to_list(self) -> List[str]:
        return [str(self.currency), self.curve]

    def to_discount_curve_tag(self) -> F3Object:
        f3 = firm_f3.f3client.get_platform_client()
        return f3.DiscountCurveTag(str(self.currency), self.curve)

    @staticmethod
    async def from_discount_curve_tag_async(tag: F3Object):
        f3 = firm_f3.f3client.get_platform_client()
        res = await f3.evaluate(tag)
        res = res[0]
        return CurveTag.from_list(res)

    @staticmethod
    def from_list(l: List[str]):
        assert len(l) == 2
        return CurveTag(Ccy[l[0]], l[1])

    @staticmethod
    def from_discount_curve_tag(tag: F3Object):
        return wait(CurveTag.from_discount_curve_tag_async(tag))

    def convert_to_simple_string(self) -> str:
        x = self.curve
        x = x.replace('-', '').replace(':', '').replace(' ', '').replace('/', '')
        return f"{self.currency}{x}"

    def convert_to_string(self) -> str:
        return f"[{self.currency}, {self.curve}]"

    def __str__(self) -> str:
        return self.convert_to_string()

    def __repr__(self):
        return self.convert_to_string()

    def __eq__(self, other):
        return self.convert_to_string() == other.convert_to_string()

    def __lt__(self, other):
        return self.convert_to_string() < other.convert_to_string()

    def __hash__(self):
        return hash(self.convert_to_string())

    @property
    def zspread_convention_name(self) -> str:
        return 'ZSpread-' + '-'.join(self.to_list())

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\fincadutil.py
----------------------------------------
from enum import Enum
from copy import deepcopy
from datetime import datetime, date, time
from typing import Dict, Optional, Tuple, List, Union, Callable, Any, Hashable
import warnings

import pandas as pd  # type: ignore
from f3sdk.f3.f3object import F3Object  # type:ignore
from f3sdk.lib.coroutine import wait  # type: ignore
from firm_domain import (
    Ccy, Tenor, FRA, Trade, CrossCurrencySwap, FXForward, FXForwardTrade,
    CashFlow, Rate, Swap, FXOption, InflationIndex, Swaption
)
import firm_f3.f3client # type:ignore
from firm_f3.evaluate import pv_async, extract_market_data_async, valuation_date_async, value_index_async
from firm_f3.modelconfig import get_curve_ins, SWAPTION_CCY
from firm_f3.mapping import f3instrument_type, f3quote_spec, ccy_to_f3pair, f3products, \
    F3_CONVENTION_BY_IRS_INSTRUMENT_TYPE as INSTRUMENT_TYPE_TO_CONVENTIONS, \
    ccy_to_collateral, f3index, f3seasonality, f3market_data_tag_async

# jchi@201907
# keep naming convention
get_instrument_type = f3instrument_type
get_quote_spec = f3quote_spec


class REQUEST(Enum):
    VALUE = 1
    IMPLIED_CASH_FLOWS = 2
    RISK_REPORT = 3
    PAR_RATE = 4


CCY_TO_VAL_SPEC = {Ccy.PHP: 'DefaultPHP',
                   Ccy.INR: 'DefaultINR',
                   Ccy.CNY: 'DefaultCNY',
                   Ccy.IDR: 'DefaultIDR',
                   Ccy.HKD: 'DefaultHKD',
                   Ccy.THB: 'DefaultTHB',
                   Ccy.SGD: 'DefaultSGD',
                   Ccy.TWD: 'DefaultTWD',
                   Ccy.NTO: 'DefaultNTO',
                   Ccy.CNH: 'DefaultCNH',
                   Ccy.EUR: 'DefaultEUR',
                   Ccy.NZD: 'DefaultNZD',
                   Ccy.SEK: 'DefaultSEK',
                   Ccy.PLN: 'DefaultPLN',
                   Ccy.HUF: 'DefaultHUF',
                   Ccy.ILS: 'DefaultILS',
                   Ccy.CAD: 'DefaultCAD',
                   Ccy.MYR: 'DefaultMYR',
                   Ccy.JPY: 'DefaultJPY',
                   Ccy.GBP: 'DefaultGBP',
                   Ccy.AUD: 'DefaultAUD'}

CCY_TO_CCS_CAL = {Ccy.INR: 'INR_CCS_CAL'}

CCY_TO_VAL_SPEC_BUILDER = {Ccy.PLN: 'vsb_pln_6m',
                           Ccy.ZAR: 'vsb_zar_3m',
                           Ccy.SGD: 'vsb_sgd_6m',
                           Ccy.HKD: 'vsb_hkd_3m',
                           Ccy.ILS: 'vsb_ils_3m',
                           Ccy.HUF: 'vsb_huf_6m'}

FINCAD_FIXING_TO_INDEX = {'AUD:RPI': 'AUCPIQuarterlyLag1q', 'AUD:BRL': 'AUDBRL', 'AUD:CAD': 'AUDCAD',
                          'AUD:CHF': 'AUDCHF', 'AUD:CNH': 'AUDCNH', 'AUD:EUR': 'AUDEUR', 'AUD:GBP': 'AUDGBP',
                          'AUD:HKD': 'AUDHKD', 'AUD:JPY': 'AUDJPY', 'AUD:KRW': 'AUDKRW', 'AUD:MXN': 'AUDMXN',
                          'AUD:NOK': 'AUDNOK', 'AUD:NZD': 'AUDNZD', 'AUD:PLN': 'AUDPLN', 'AUD:RUB': 'AUDRUB',
                          'AUD:SEK': 'AUDSEK', 'AUD:SGD': 'AUDSGD', 'AUD:TRY': 'AUDTRY', 'AUD:USD': 'AUDUSD',
                          'AUD:ZAR': 'AUDZAR', 'AUD O/N:1b': 'OvernightAUD', 'BBSW:12m': 'BBSW12m', 'BBSW:1m': 'BBSW1m',
                          'BBSW:2m': 'BBSW2m', 'BBSW:3m': 'BBSW3m', 'BBSW:4m': 'BBSW4m', 'BBSW:5m': 'BBSW5m',
                          'BBSW:6m': 'BBSW6m', 'BKBM:12m': 'BKBM12m', 'BKBM:1m': 'BKBM1m', 'BKBM:2m': 'BKBM2m',
                          'BKBM:3m': 'BKBM3m', 'BKBM:4m': 'BKBM4m', 'BKBM:5m': 'BKBM5m', 'BKBM:6m': 'BKBM6m',
                          'BRL:AUD': 'BRLAUD', 'BRL:CAD': 'BRLCAD', 'BRL:CHF': 'BRLCHF', 'BRL:CNH': 'BRLCNH',
                          'BRL:EUR': 'BRLEUR', 'BRL:GBP': 'BRLGBP', 'BRL:HKD': 'BRLHKD', 'BRL:JPY': 'BRLJPY',
                          'BRL:KRW': 'BRLKRW', 'BRL:MXN': 'BRLMXN', 'BRL:NOK': 'BRLNOK', 'BRL:NZD': 'BRLNZD',
                          'BRL:PLN': 'BRLPLN', 'BRL:RUB': 'BRLRUB', 'BRL:SEK': 'BRLSEK', 'BRL:SGD': 'BRLSGD',
                          'BRL:TRY': 'BRLTRY', 'BRL:USD': 'BRLUSD', 'BRL:ZAR': 'BRLZAR', 'Bibor:12m': 'Bibor12m',
                          'Bibor:1m': 'Bibor1m', 'Bibor:1w': 'Bibor1w', 'Bibor:2m': 'Bibor2m', 'Bibor:3m': 'Bibor3m',
                          'Bibor:6m': 'Bibor6m', 'BRL O/N:1b': 'OvernightBRL', 'Bubor:12m': 'Bubor12m',
                          'Bubor:1m': 'Bubor1m', 'Bubor:1w': 'Bubor1w', 'Bubor:2m': 'Bubor2m', 'Bubor:2w': 'Bubor2w',
                          'Bubor:3m': 'Bubor3m', 'Bubor:6m': 'Bubor6m', 'Bubor:9m': 'Bubor9m', 'CAD:AUD': 'CADAUD',
                          'CAD:BRL': 'CADBRL', 'CAD:CHF': 'CADCHF', 'CAD:CNH': 'CADCNH', 'CAD:EUR': 'CADEUR',
                          'CAD:GBP': 'CADGBP', 'CAD:HKD': 'CADHKD', 'CAD:JPY': 'CADJPY', 'CAD:KRW': 'CADKRW',
                          'CAD:MXN': 'CADMXN', 'CAD:NOK': 'CADNOK', 'CAD:NZD': 'CADNZD', 'CAD:PLN': 'CADPLN',
                          'CAD:RUB': 'CADRUB', 'CAD:SEK': 'CADSEK', 'CAD:SGD': 'CADSGD', 'CAD:TRY': 'CADTRY',
                          'CAD:USD': 'CADUSD', 'CAD:ZAR': 'CADZAR', 'CDOR:12m': 'CDOR12m', 'CDOR:1m': 'CDOR1m',
                          'CDOR:2m': 'CDOR2m', 'CDOR:3m': 'CDOR3m', 'CDOR:6m': 'CDOR6m', 'CHF:AUD': 'CHFAUD',
                          'CHF:BRL': 'CHFBRL', 'CHF:CAD': 'CHFCAD', 'CHF:CNH': 'CHFCNH', 'CHF:EUR': 'CHFEUR',
                          'CHF:GBP': 'CHFGBP', 'CHF:HKD': 'CHFHKD', 'CHF:JPY': 'CHFJPY', 'CHF:KRW': 'CHFKRW',
                          'CHF:MXN': 'CHFMXN', 'CHF:NOK': 'CHFNOK', 'CHF:NZD': 'CHFNZD', 'CHF:PLN': 'CHFPLN',
                          'CHF:RUB': 'CHFRUB', 'CHF:SEK': 'CHFSEK', 'CHF:SGD': 'CHFSGD', 'CHF:TRY': 'CHFTRY',
                          'CHF:USD': 'CHFUSD', 'CHF:ZAR': 'CHFZAR', 'DKK O/N:1b': 'OvernightDKK', 'CNH:AUD': 'CNHAUD',
                          'CNH:BRL': 'CNHBRL', 'CNH:CAD': 'CNHCAD', 'CNH:CHF': 'CNHCHF', 'CNH:EUR': 'CNHEUR',
                          'CNH:GBP': 'CNHGBP', 'CNH:HKD': 'CNHHKD', 'CNH:JPY': 'CNHJPY', 'CNH:KRW': 'CNHKRW',
                          'CNH:MXN': 'CNHMXN', 'CNH:NOK': 'CNHNOK', 'CNH:NZD': 'CNHNZD', 'CNH:PLN': 'CNHPLN',
                          'CNH:RUB': 'CNHRUB', 'CNH:SEK': 'CNHSEK', 'CNH:SGD': 'CNHSGD', 'CNH:TRY': 'CNHTRY',
                          'CNH:USD': 'CNHUSD', 'CNH:ZAR': 'CNHZAR', 'CNY:USD': 'CNYUSD', 'COP O/N:1b': 'OvernightCOP',
                          'CAD O/N:1b': 'OvernightCAD', 'GBP:USD': 'GBPUSD', 'ChinaRepoRate:7d': 'ChinaRepo7d',
                          'Cibor:12m': 'Cibor12m', 'Cibor:1m': 'Cibor1m', 'Cibor:1w': 'Cibor1w', 'Cibor:2m': 'Cibor2m',
                          'Cibor:2w': 'Cibor2w', 'Cibor:3m': 'Cibor3m', 'Cibor:6m': 'Cibor6m', 'Cibor:9m': 'Cibor9m',
                          'EUR O/N:1b': 'OvernightEUR', 'EUR:RPI': 'ITCPIxTMonthlyLag3m', 'EUR:AUD': 'EURAUD',
                          'EUR:BRL': 'EURBRL', 'EUR:CAD': 'EURCAD', 'EUR:CHF': 'EURCHF', 'EUR:CNH': 'EURCNH',
                          'EUR:GBP': 'EURGBP', 'EUR:HKD': 'EURHKD', 'EUR:HUF': 'EURHUF', 'EUR:JPY': 'EURJPY',
                          'EUR:KRW': 'EURKRW', 'EUR:MXN': 'EURMXN', 'EUR:NOK': 'EURNOK', 'EUR:NZD': 'EURNZD',
                          'EUR:PLN': 'EURPLN', 'EUR:RUB': 'EURRUB', 'EUR:SEK': 'EURSEK', 'EUR:SGD': 'EURSGD',
                          'EUR:TRY': 'EURTRY', 'EUR:USD': 'EURUSD', 'EUR:ZAR': 'EURZAR', 'Euribor:10m': 'Euribor10m',
                          'Euribor:11m': 'Euribor11m', 'Euribor:12m': 'Euribor12m', 'Euribor:1m': 'Euribor1m',
                          'Euribor:2m': 'Euribor2m', 'Euribor:3m': 'Euribor3m', 'Euribor:4m': 'Euribor4m',
                          'Euribor:5m': 'Euribor5m', 'Euribor:6m': 'Euribor6m', 'Euribor:7m': 'Euribor7m',
                          'Euribor:8m': 'Euribor8m', 'Euribor:9m': 'Euribor9m', 'GBP:AUD': 'GBPAUD',
                          'GBP:BRL': 'GBPBRL', 'GBP:CAD': 'GBPCAD', 'GBP:CHF': 'GBPCHF', 'GBP:CNH': 'GBPCNH',
                          'GBP:EUR': 'GBPEUR', 'GBP:HKD': 'GBPHKD', 'GBP:JPY': 'GBPJPY', 'GBP:KRW': 'GBPKRW',
                          'GBP:MXN': 'GBPMXN', 'GBP:NOK': 'GBPNOK', 'GBP:NZD': 'GBPNZD', 'GBP:PLN': 'GBPPLN',
                          'GBP:RUB': 'GBPRUB', 'GBP:SEK': 'GBPSEK', 'GBP:SGD': 'GBPSGD', 'GBP:TRY': 'GBPTRY',
                          'GBP:ZAR': 'GBPZAR', 'HKD:AUD': 'HKDAUD', 'HKD:BRL': 'HKDBRL', 'HKD:CAD': 'HKDCAD',
                          'HKD:CHF': 'HKDCHF', 'HKD:CNH': 'HKDCNH', 'HKD:EUR': 'HKDEUR', 'HKD:GBP': 'HKDGBP',
                          'HKD:JPY': 'HKDJPY', 'HKD:KRW': 'HKDKRW', 'HKD:MXN': 'HKDMXN', 'HKD:NOK': 'HKDNOK',
                          'HKD:NZD': 'HKDNZD', 'HKD:PLN': 'HKDPLN', 'HKD:RUB': 'HKDRUB', 'HKD:SEK': 'HKDSEK',
                          'HKD:SGD': 'HKDSGD', 'HKD:TRY': 'HKDTRY', 'HKD:USD': 'HKDUSD', 'HKD:ZAR': 'HKDZAR',
                          'HUF:EUR': 'HUFEUR', 'HUF O/N:1b': 'OvernightHUF', 'Hibor:12m': 'Hibor12m',
                          'Hibor:1m': 'Hibor1m', 'Hibor:1w': 'Hibor1w', 'Hibor:2m': 'Hibor2m', 'Hibor:2w': 'Hibor2w',
                          'Hibor:3m': 'Hibor3m', 'Hibor:6m': 'Hibor6m', 'HiborCNH:12m': 'HiborCNH12m',
                          'HiborCNH:1m': 'HiborCNH1m', 'HiborCNH:1w': 'HiborCNH1w', 'HiborCNH:2m': 'HiborCNH2m',
                          'HiborCNH:2w': 'HiborCNH2w', 'HiborCNH:3m': 'HiborCNH3m', 'HiborCNH:6m': 'HiborCNH6m',
                          'CNH O/N:1b': 'OvernightCNH', 'HKD O/N:1b': 'OvernightHKD', 'IDR:USD': 'IDRUSD',
                          'IGP-M': 'IGP-M', 'ILS:USD': 'ILSUSD', 'INR:USD': 'INRUSD', 'IPCA': 'IPCA',
                          'JPY:AUD': 'JPYAUD', 'JPY:BRL': 'JPYBRL', 'JPY:CAD': 'JPYCAD', 'JPY:CHF': 'JPYCHF',
                          'JPY:CNH': 'JPYCNH', 'JPY:EUR': 'JPYEUR', 'JPY:GBP': 'JPYGBP', 'JPY:HKD': 'JPYHKD',
                          'JPY:KRW': 'JPYKRW', 'JPY:MXN': 'JPYMXN', 'JPY:NOK': 'JPYNOK', 'JPY:NZD': 'JPYNZD',
                          'JPY:PLN': 'JPYPLN', 'JPY:RUB': 'JPYRUB', 'JPY:SEK': 'JPYSEK', 'JPY:SGD': 'JPYSGD',
                          'JPY:TRY': 'JPYTRY', 'JPY:USD': 'JPYUSD', 'JPY:ZAR': 'JPYZAR', 'Jibar:12m': 'Jibar12m',
                          'Jibar:1m': 'Jibar1m', 'Jibar:3m': 'Jibar3m', 'Jibar:6m': 'Jibar6m', 'Jibar:9m': 'Jibar9m',
                          'KRW:AUD': 'KRWAUD', 'KRW:BRL': 'KRWBRL', 'KRW:CAD': 'KRWCAD', 'KRWCD:3m': 'KRWCD3m',
                          'KRW:CHF': 'KRWCHF', 'KRW:CNH': 'KRWCNH', 'KRW:EUR': 'KRWEUR', 'KRW:GBP': 'KRWGBP',
                          'KRW:HKD': 'KRWHKD', 'KRW:JPY': 'KRWJPY', 'KRW:MXN': 'KRWMXN', 'KRW:NOK': 'KRWNOK',
                          'KRW:NZD': 'KRWNZD', 'KRW:PLN': 'KRWPLN', 'KRW:RUB': 'KRWRUB', 'KRW:SEK': 'KRWSEK',
                          'KRW:SGD': 'KRWSGD', 'KRW:TRY': 'KRWTRY', 'KRW:USD': 'KRWUSD', 'KRW:ZAR': 'KRWZAR',
                          'Klibor:12m': 'Klibor12m', 'Klibor:1m': 'Klibor1m', 'Klibor:2m': 'Klibor2m',
                          'Klibor:3m': 'Klibor3m', 'Klibor:6m': 'Klibor6m', 'Klibor:9m': 'Klibor9m',
                          'AUD LIBOR:10m': 'LiborAUD10m', 'AUD LIBOR:11m': 'LiborAUD11m',
                          'AUD LIBOR:12m': 'LiborAUD12m', 'AUD LIBOR:1m': 'LiborAUD1m', 'AUD LIBOR:2m': 'LiborAUD2m',
                          'AUD LIBOR:3m': 'LiborAUD3m', 'AUD LIBOR:4m': 'LiborAUD4m', 'AUD LIBOR:5m': 'LiborAUD5m',
                          'AUD LIBOR:6m': 'LiborAUD6m', 'AUD LIBOR:7m': 'LiborAUD7m', 'AUD LIBOR:8m': 'LiborAUD8m',
                          'AUD LIBOR:9m': 'LiborAUD9m', 'CAD LIBOR:10m': 'LiborCAD10m', 'CAD LIBOR:11m': 'LiborCAD11m',
                          'CAD LIBOR:12m': 'LiborCAD12m', 'CAD LIBOR:1m': 'LiborCAD1m', 'CAD LIBOR:2m': 'LiborCAD2m',
                          'CAD LIBOR:3m': 'LiborCAD3m', 'CAD LIBOR:4m': 'LiborCAD4m', 'CAD LIBOR:5m': 'LiborCAD5m',
                          'CAD LIBOR:6m': 'LiborCAD6m', 'CAD LIBOR:7m': 'LiborCAD7m', 'CAD LIBOR:8m': 'LiborCAD8m',
                          'CAD LIBOR:9m': 'LiborCAD9m', 'CHF LIBOR:10m': 'LiborCHF10m', 'CHF LIBOR:11m': 'LiborCHF11m',
                          'CHF LIBOR:12m': 'LiborCHF12m', 'CHF LIBOR:1m': 'LiborCHF1m', 'CHF LIBOR:2m': 'LiborCHF2m',
                          'CHF LIBOR:3m': 'LiborCHF3m', 'CHF LIBOR:4m': 'LiborCHF4m', 'CHF LIBOR:5m': 'LiborCHF5m',
                          'CHF LIBOR:6m': 'LiborCHF6m', 'CHF LIBOR:7m': 'LiborCHF7m', 'CHF LIBOR:8m': 'LiborCHF8m',
                          'CHF LIBOR:9m': 'LiborCHF9m', 'DKK LIBOR:10m': 'LiborDKK10m', 'DKK LIBOR:11m': 'LiborDKK11m',
                          'DKK LIBOR:12m': 'LiborDKK12m', 'DKK LIBOR:1m': 'LiborDKK1m', 'DKK LIBOR:2m': 'LiborDKK2m',
                          'DKK LIBOR:3m': 'LiborDKK3m', 'DKK LIBOR:4m': 'LiborDKK4m', 'DKK LIBOR:5m': 'LiborDKK5m',
                          'DKK LIBOR:6m': 'LiborDKK6m', 'DKK LIBOR:7m': 'LiborDKK7m', 'DKK LIBOR:8m': 'LiborDKK8m',
                          'DKK LIBOR:9m': 'LiborDKK9m', 'EUR LIBOR:10m': 'LiborEUR10m', 'EUR LIBOR:11m': 'LiborEUR11m',
                          'EUR LIBOR:12m': 'LiborEUR12m', 'EUR LIBOR:1m': 'LiborEUR1m', 'EUR LIBOR:2m': 'LiborEUR2m',
                          'EUR LIBOR:3m': 'LiborEUR3m', 'EUR LIBOR:4m': 'LiborEUR4m', 'EUR LIBOR:5m': 'LiborEUR5m',
                          'EUR LIBOR:6m': 'LiborEUR6m', 'EUR LIBOR:7m': 'LiborEUR7m', 'EUR LIBOR:8m': 'LiborEUR8m',
                          'EUR LIBOR:9m': 'LiborEUR9m', 'GBP LIBOR:10m': 'LiborGBP10m', 'GBP LIBOR:11m': 'LiborGBP11m',
                          'GBP LIBOR:12m': 'LiborGBP12m', 'GBP LIBOR:1m': 'LiborGBP1m', 'GBP LIBOR:2m': 'LiborGBP2m',
                          'GBP LIBOR:3m': 'LiborGBP3m', 'GBP LIBOR:4m': 'LiborGBP4m', 'GBP LIBOR:5m': 'LiborGBP5m',
                          'GBP LIBOR:6m': 'LiborGBP6m', 'GBP LIBOR:7m': 'LiborGBP7m', 'GBP LIBOR:8m': 'LiborGBP8m',
                          'GBP LIBOR:9m': 'LiborGBP9m', 'JPY LIBOR:10m': 'LiborJPY10m', 'JPY LIBOR:11m': 'LiborJPY11m',
                          'JPY LIBOR:12m': 'LiborJPY12m', 'JPY LIBOR:1m': 'LiborJPY1m', 'JPY LIBOR:2m': 'LiborJPY2m',
                          'JPY LIBOR:3m': 'LiborJPY3m', 'JPY LIBOR:4m': 'LiborJPY4m', 'JPY LIBOR:5m': 'LiborJPY5m',
                          'JPY LIBOR:6m': 'LiborJPY6m', 'JPY LIBOR:7m': 'LiborJPY7m', 'JPY LIBOR:8m': 'LiborJPY8m',
                          'JPY LIBOR:9m': 'LiborJPY9m', 'NZD LIBOR:10m': 'LiborNZD10m', 'NZD LIBOR:11m': 'LiborNZD11m',
                          'NZD LIBOR:12m': 'LiborNZD12m', 'NZD LIBOR:1m': 'LiborNZD1m', 'NZD LIBOR:2m': 'LiborNZD2m',
                          'NZD LIBOR:3m': 'LiborNZD3m', 'NZD LIBOR:4m': 'LiborNZD4m', 'NZD LIBOR:5m': 'LiborNZD5m',
                          'NZD LIBOR:6m': 'LiborNZD6m', 'NZD LIBOR:7m': 'LiborNZD7m', 'NZD LIBOR:8m': 'LiborNZD8m',
                          'NZD LIBOR:9m': 'LiborNZD9m', 'SEK LIBOR:10m': 'LiborSEK10m', 'SEK LIBOR:11m': 'LiborSEK11m',
                          'SEK LIBOR:12m': 'LiborSEK12m', 'SEK LIBOR:1m': 'LiborSEK1m', 'SEK LIBOR:2m': 'LiborSEK2m',
                          'SEK LIBOR:3m': 'LiborSEK3m', 'SEK LIBOR:4m': 'LiborSEK4m', 'SEK LIBOR:5m': 'LiborSEK5m',
                          'SEK LIBOR:6m': 'LiborSEK6m', 'SEK LIBOR:7m': 'LiborSEK7m', 'SEK LIBOR:8m': 'LiborSEK8m',
                          'SEK LIBOR:9m': 'LiborSEK9m', 'USD LIBOR:10m': 'LiborUSD10m', 'USD LIBOR:11m': 'LiborUSD11m',
                          'USD LIBOR:12m': 'LiborUSD12m', 'USD LIBOR:1m': 'LiborUSD1m', 'USD LIBOR:2m': 'LiborUSD2m',
                          'USD LIBOR:3m': 'LiborUSD3m', 'USD LIBOR:4m': 'LiborUSD4m', 'USD LIBOR:5m': 'LiborUSD5m',
                          'USD LIBOR:6m': 'LiborUSD6m', 'USD LIBOR:7m': 'LiborUSD7m', 'USD LIBOR:8m': 'LiborUSD8m',
                          'USD LIBOR:9m': 'LiborUSD9m', 'INR O/N:1b': 'OvernightINR', 'MXN:AUD': 'MXNAUD',
                          'MXN:BRL': 'MXNBRL', 'MXN:CAD': 'MXNCAD', 'MXN:CHF': 'MXNCHF', 'MXN:CNH': 'MXNCNH',
                          'MXN:EUR': 'MXNEUR', 'MXN:GBP': 'MXNGBP', 'MXN:HKD': 'MXNHKD', 'MXN:JPY': 'MXNJPY',
                          'MXN:KRW': 'MXNKRW', 'MXN:NOK': 'MXNNOK', 'MXN:NZD': 'MXNNZD', 'MXN:PLN': 'MXNPLN',
                          'MXN:RUB': 'MXNRUB', 'MXN:SEK': 'MXNSEK', 'MXN:SGD': 'MXNSGD', 'MXN:TRY': 'MXNTRY',
                          'MXN:USD': 'MXNUSD', 'MXN:ZAR': 'MXNZAR', 'MYR O/N:1b': 'OvernightMYR',
                          'Mifor:12m': 'Mifor12m', 'Mifor:1m': 'Mifor1m', 'Mifor:2m': 'Mifor2m', 'Mifor:3m': 'Mifor3m',
                          'Mifor:6m': 'Mifor6m', 'MosPrime:1m': 'MosPrime1m', 'MosPrime:1w': 'MosPrime1w',
                          'MosPrime:2m': 'MosPrime2m', 'MosPrime:2w': 'MosPrime2w', 'MosPrime:3m': 'MosPrime3m',
                          'MosPrime:6m': 'MosPrime6m', 'RUB O/N:1b': 'RUONIA', 'NOK:AUD': 'NOKAUD', 'NOK:BRL': 'NOKBRL',
                          'NOK:CAD': 'NOKCAD', 'NOK:CHF': 'NOKCHF', 'NOK:CNH': 'NOKCNH', 'NOK:EUR': 'NOKEUR',
                          'NOK:GBP': 'NOKGBP', 'NOK:HKD': 'NOKHKD', 'NOK:JPY': 'NOKJPY', 'NOK:KRW': 'NOKKRW',
                          'NOK:MXN': 'NOKMXN', 'NOK:NZD': 'NOKNZD', 'NOK:PLN': 'NOKPLN', 'NOK:RUB': 'NOKRUB',
                          'NOK:SEK': 'NOKSEK', 'NOK:SGD': 'NOKSGD', 'NOK:TRY': 'NOKTRY', 'NOK:USD': 'NOKUSD',
                          'NOK:ZAR': 'NOKZAR', 'NZD:AUD': 'NZDAUD', 'NZD:BRL': 'NZDBRL', 'NZD:CAD': 'NZDCAD',
                          'NZD:CHF': 'NZDCHF', 'NZD:CNH': 'NZDCNH', 'NZD:EUR': 'NZDEUR', 'NZD:GBP': 'NZDGBP',
                          'NZD:HKD': 'NZDHKD', 'NZD:JPY': 'NZDJPY', 'NZD:KRW': 'NZDKRW', 'NZD:MXN': 'NZDMXN',
                          'NZD:NOK': 'NZDNOK', 'NZD:PLN': 'NZDPLN', 'NZD:RUB': 'NZDRUB', 'NZD:SEK': 'NZDSEK',
                          'NZD:SGD': 'NZDSGD', 'NZD:TRY': 'NZDTRY', 'NZD:USD': 'NZDUSD', 'NZD:ZAR': 'NZDZAR',
                          'NZD O/N:1b': 'OvernightNZD', 'Nibor:1m': 'Nibor1m', 'Nibor:1w': 'Nibor1w',
                          'Nibor:2m': 'Nibor2m', 'Nibor:3m': 'Nibor3m', 'Nibor:6m': 'Nibor6m', 'CHF O/N:1b': 'TOIS',
                          'CNY O/N:1b': 'ShiborON', 'GBP O/N:1b': 'SONIA', 'JPY O/N:1b': 'TONAR',
                          'PLN O/N:1b': 'POLONIA', 'SEK O/N:1b': 'SIOR', 'SGD O/N:1b': 'SORON',
                          'TRY O/N:1b': 'TRLiborON', 'USD O/N:1b': 'USFedFunds', 'PHP:USD': 'PHPUSD',
                          'PLN:AUD': 'PLNAUD', 'PLN:BRL': 'PLNBRL', 'PLN:CAD': 'PLNCAD', 'PLN:CHF': 'PLNCHF',
                          'PLN:CNH': 'PLNCNH', 'PLN:EUR': 'PLNEUR', 'PLN:GBP': 'PLNGBP', 'PLN:HKD': 'PLNHKD',
                          'PLN:JPY': 'PLNJPY', 'PLN:KRW': 'PLNKRW', 'PLN:MXN': 'PLNMXN', 'PLN:NOK': 'PLNNOK',
                          'PLN:NZD': 'PLNNZD', 'PLN:RUB': 'PLNRUB', 'PLN:SEK': 'PLNSEK', 'PLN:SGD': 'PLNSGD',
                          'PLN:TRY': 'PLNTRY', 'PLN:USD': 'PLNUSD', 'PLN:ZAR': 'PLNZAR', 'Pribor:12m': 'Pribor12m',
                          'Pribor:1m': 'Pribor1m', 'Pribor:1w': 'Pribor1w', 'Pribor:2m': 'Pribor2m',
                          'Pribor:2w': 'Pribor2w', 'Pribor:3m': 'Pribor3m', 'Pribor:6m': 'Pribor6m',
                          'Pribor:9m': 'Pribor9m', 'RUB:AUD': 'RUBAUD', 'RUB:BRL': 'RUBBRL', 'RUB:CAD': 'RUBCAD',
                          'RUB:CHF': 'RUBCHF', 'RUB:CNH': 'RUBCNH', 'RUB:EUR': 'RUBEUR', 'RUB:GBP': 'RUBGBP',
                          'RUB:HKD': 'RUBHKD', 'RUB:JPY': 'RUBJPY', 'RUB:KRW': 'RUBKRW', 'RUB:MXN': 'RUBMXN',
                          'RUB:NOK': 'RUBNOK', 'RUB:NZD': 'RUBNZD', 'RUB:PLN': 'RUBPLN', 'RUB:SEK': 'RUBSEK',
                          'RUB:SGD': 'RUBSGD', 'RUB:TRY': 'RUBTRY', 'RUB:USD': 'RUBUSD', 'RUB:ZAR': 'RUBZAR',
                          'SAIBOR:12m': 'SAIBOR12m', 'SAIBOR:1m': 'SAIBOR1m', 'SAIBOR:2m': 'SAIBOR2m',
                          'SAIBOR:3m': 'SAIBOR3m', 'SAIBOR:6m': 'SAIBOR6m', 'SAIBOR:9m': 'SAIBOR9m',
                          'SEK:AUD': 'SEKAUD', 'SEK:BRL': 'SEKBRL', 'SEK:CAD': 'SEKCAD', 'SEK:CHF': 'SEKCHF',
                          'SEK:CNH': 'SEKCNH', 'SEK:EUR': 'SEKEUR', 'SEK:GBP': 'SEKGBP', 'SEK:HKD': 'SEKHKD',
                          'SEK:JPY': 'SEKJPY', 'SEK:KRW': 'SEKKRW', 'SEK:MXN': 'SEKMXN', 'SEK:NOK': 'SEKNOK',
                          'SEK:NZD': 'SEKNZD', 'SEK:PLN': 'SEKPLN', 'SEK:RUB': 'SEKRUB', 'SEK:SGD': 'SEKSGD',
                          'SEK:TRY': 'SEKTRY', 'SEK:USD': 'SEKUSD', 'SEK:ZAR': 'SEKZAR', 'SELIC': 'SELIC',
                          'SGD:AUD': 'SGDAUD', 'SGD:BRL': 'SGDBRL', 'SGD:CAD': 'SGDCAD', 'SGD:CHF': 'SGDCHF',
                          'SGD:CNH': 'SGDCNH', 'SGD:EUR': 'SGDEUR', 'SGD:GBP': 'SGDGBP', 'SGD:HKD': 'SGDHKD',
                          'SGD:JPY': 'SGDJPY', 'SGD:KRW': 'SGDKRW', 'SGD:MXN': 'SGDMXN', 'SGD:NOK': 'SGDNOK',
                          'SGD:NZD': 'SGDNZD', 'SGD:PLN': 'SGDPLN', 'SGD:RUB': 'SGDRUB', 'SGD:SEK': 'SGDSEK',
                          'SGD:TRY': 'SGDTRY', 'SGD:USD': 'SGDUSD', 'SGD:ZAR': 'SGDZAR', 'SOFR:1b': 'SOFR',
                          'SOR:1m': 'SOR1m', 'SOR:3m': 'SOR3m', 'SOR:6m': 'SOR6m', 'Shibor:12m': 'Shibor12m',
                          'Shibor:1m': 'Shibor1m', 'Shibor:1w': 'Shibor1w', 'Shibor:2w': 'Shibor2w',
                          'Shibor:3m': 'Shibor3m', 'Shibor:6m': 'Shibor6m', 'Shibor:9m': 'Shibor9m',
                          'Stibor:1m': 'Stibor1m', 'Stibor:1w': 'Stibor1w', 'Stibor:2m': 'Stibor2m',
                          'Stibor:3m': 'Stibor3m', 'Stibor:6m': 'Stibor6m', 'THB:USD': 'THBUSD', 'TIIE:182': 'TIIE182',
                          'TIIE:28': 'TIIE28', 'TIIE:91': 'TIIE91', 'TRLibor:12m': 'TRLibor12m',
                          'TRLibor:1m': 'TRLibor1m', 'TRLibor:1w': 'TRLibor1w', 'TRLibor:2m': 'TRLibor2m',
                          'TRLibor:3m': 'TRLibor3m', 'TRLibor:6m': 'TRLibor6m', 'TRLibor:9m': 'TRLibor9m',
                          'TRY:AUD': 'TRYAUD', 'TRY:BRL': 'TRYBRL', 'TRY:CAD': 'TRYCAD', 'TRY:CHF': 'TRYCHF',
                          'TRY:CNH': 'TRYCNH', 'TRY:EUR': 'TRYEUR', 'TRY:GBP': 'TRYGBP', 'TRY:HKD': 'TRYHKD',
                          'TRY:JPY': 'TRYJPY', 'TRY:KRW': 'TRYKRW', 'TRY:MXN': 'TRYMXN', 'TRY:NOK': 'TRYNOK',
                          'TRY:NZD': 'TRYNZD', 'TRY:PLN': 'TRYPLN', 'TRY:RUB': 'TRYRUB', 'TRY:SEK': 'TRYSEK',
                          'TRY:SGD': 'TRYSGD', 'TRY:USD': 'TRYUSD', 'TRY:ZAR': 'TRYZAR', 'Taibor:12m': 'Taibor12m',
                          'Taibor:1m': 'Taibor1m', 'Taibor:1w': 'Taibor1w', 'Taibor:2m': 'Taibor2m',
                          'Taibor:2w': 'Taibor2w', 'Taibor:3m': 'Taibor3m', 'Taibor:6m': 'Taibor6m',
                          'Taibor:9m': 'Taibor9m', 'Telbor:12m': 'Telbor12m', 'Telbor:1m': 'Telbor1m',
                          'Telbor:3m': 'Telbor3m', 'Telbor:6m': 'Telbor6m', 'Telbor:9m': 'Telbor9m',
                          'TiborEuroyen:12m': 'TiborEuroyen12m', 'TiborEuroyen:1m': 'TiborEuroyen1m',
                          'TiborEuroyen:1w': 'TiborEuroyen1w', 'TiborEuroyen:2m': 'TiborEuroyen2m',
                          'TiborEuroyen:3m': 'TiborEuroyen3m', 'TiborEuroyen:6m': 'TiborEuroyen6m',
                          'TiborJPY:12m': 'TiborJPY12m', 'TiborJPY:1m': 'TiborJPY1m', 'TiborJPY:1w': 'TiborJPY1w',
                          'TiborJPY:2m': 'TiborJPY2m', 'TiborJPY:3m': 'TiborJPY3m', 'TiborJPY:6m': 'TiborJPY6m',
                          'GBP:RPI': 'UKRPIMonthlyLag8m', 'USD:RPI': 'USCPIMonthlyLag3m', 'USD:AUD': 'USDAUD',
                          'USD:BRL': 'USDBRL', 'USD:CAD': 'USDCAD', 'USD:CHF': 'USDCHF', 'USD:CNH': 'USDCNH',
                          'USD:CNY': 'USDCNY', 'USD:EUR': 'USDEUR', 'USD:GBP': 'USDGBP', 'USD:HKD': 'USDHKD',
                          'USD:IDR': 'USDIDR', 'USD:ILS': 'USDILS', 'USD:INR': 'USDINR', 'USD:JPY': 'USDJPY',
                          'USD:KRW': 'USDKRW', 'USD:MXN': 'USDMXN', 'USD:NOK': 'USDNOK', 'USD:NZD': 'USDNZD',
                          'USD:PHP': 'USDPHP', 'USD:PLN': 'USDPLN', 'USD:RUB': 'USDRUB', 'USD:SEK': 'USDSEK',
                          'USD:SGD': 'USDSGD', 'USD:THB': 'USDTHB', 'USD:TRY': 'USDTRY', 'USD:TWD': 'USDTWD',
                          'USD:ZAR': 'USDZAR', 'Wibor:12m': 'Wibor12m', 'Wibor:1m': 'Wibor1m', 'Wibor:1w': 'Wibor1w',
                          'Wibor:2w': 'Wibor2w', 'Wibor:3m': 'Wibor3m', 'Wibor:6m': 'Wibor6m', 'Wibor:9m': 'Wibor9m',
                          'ZAR:AUD': 'ZARAUD', 'ZAR:BRL': 'ZARBRL', 'ZAR:CAD': 'ZARCAD', 'ZAR:CHF': 'ZARCHF',
                          'ZAR:CNH': 'ZARCNH', 'ZAR:EUR': 'ZAREUR', 'ZAR:GBP': 'ZARGBP', 'ZAR:HKD': 'ZARHKD',
                          'ZAR:JPY': 'ZARJPY', 'ZAR:KRW': 'ZARKRW', 'ZAR:MXN': 'ZARMXN', 'ZAR:NOK': 'ZARNOK',
                          'ZAR:NZD': 'ZARNZD', 'ZAR:PLN': 'ZARPLN', 'ZAR:RUB': 'ZARRUB', 'ZAR:SEK': 'ZARSEK',
                          'ZAR:SGD': 'ZARSGD', 'ZAR:TRY': 'ZARTRY', 'ZAR:USD': 'ZARUSD'}


async def calc_trade_async(
        trades: Union[Trade, List[Trade]],
        model: Union[int, F3Object],
        request: REQUEST,
        val_date: Union[pd.Timestamp, date] = None,
        aggregate: bool = True
):
    f3 = firm_f3.f3client.get_platform_client()
    val_spec_usd = f3.CreateNumeraireCurrencyValuationSpecification("Default", "USD")

    if request == REQUEST.VALUE:
        if val_date is None:
            val_date = await valuation_date_async(model)

        if isinstance(val_date, datetime):
            val_date = val_date.date()

        if not isinstance(trades, list):
            trades = [trades]
        fx_data = {(f.ccy, f.fixing_date) for f in trades if
                   isinstance(f, FXForwardTrade) and f.ndf and f.value_date <= val_date}
        if fx_data:
            model_data = await get_model_data_async(model)
        else:
            model_data = None

        fx_fixings = {k: get_model_fixing(k[0], model, k[1], model_data) for k in fx_data}

        val_obj = [trade_to_f3_value_port(t, model, val_date, fx_fixings) for t in trades]

        cash_ccy = {ccy for c in val_obj for ccy in c[1]}
        fx_rates = {ccy: await get_model_fx_rate_async(ccy, model, val_spec_usd, val_date) for ccy in cash_ccy}

        if aggregate:
            f3_trades = [f3t for p in val_obj for f3t in p[0]]
            cash_val = sum([c[1][ccy] / fx_rates[ccy] for c in val_obj for ccy in c[1]])

            if f3_trades:
                fincad_val = sum(await pv_async(f3_trades, f3model=model))
            else:
                fincad_val = 0

            return fincad_val + cash_val
        else:
            f3_val_to_trade_map = {}
            f3_trades = []
            trade_counter = 0
            f3_trade_counter = 0
            for p in val_obj:
                for f3t in p[0]:
                    f3_trades.append(f3t)
                    f3_val_to_trade_map[f3_trade_counter] = trade_counter
                    f3_trade_counter += 1
                trade_counter += 1

            cash_val_list = [sum([c[1][ccy] / fx_rates[ccy] for ccy in c[1]]) for c in val_obj]
            fincad_val_list = [0 for t in trades]
            if f3_trades:
                raw_fincad_vals = await pv_async(f3_trades, f3model=model)
                for i, v in enumerate(raw_fincad_vals):
                    fincad_val_list[f3_val_to_trade_map[i]] += v

            return [cash_val_list[i] + fincad_val_list[i] for i in range(len(trades))]



def calc_trade(trades: Union[Trade, List[Trade]], model, request: REQUEST, val_date: Union[pd.Timestamp, date] = None,
               aggregate: bool = True):
    return wait(calc_trade_async(trades=trades, model=model, request=request, val_date=val_date, aggregate=aggregate))


def trade_to_f3_value_port(trade: Trade, model, val_date: pd.Timestamp = None,
                           fx_fixings: Dict[Tuple[Ccy, pd.Timestamp], float] = None) -> Tuple[List, Dict[Ccy, float]]:
    f3 = firm_f3.f3client.get_platform_client()
    if fx_fixings is None:
        fx_fixings = {}

    if val_date is None:
        val_date = pd.Timestamp(wait(f3.evaluate(f3.ObjectInfo('Model', model, 'ValuationDate')))[0][0]).date()

    if isinstance(val_date, datetime):
        val_date = val_date.date()

    if isinstance(trade, CashFlow):
        cf = trade  # type: CashFlow
        if cf.maturity < val_date:
            return [], {cf.ccy: cf.notional}
        else:
            return [cf], {}

    if isinstance(trade, FXForwardTrade):
        fxf = trade  # type: FXForwardTrade
        if fxf.value_date <= val_date:
            if fxf.ndf:
                fixing = fx_fixings.get((fxf.ccy, fxf.fixing_date), None)
                if fixing is None:
                    fixing = get_model_fixing(fxf.ccy, model, fxf.fixing_date)
                net_cf = fxf.notional - fxf.notional * fxf.rate / fixing
                return [], {fxf.ccy_base: net_cf}
            else:
                return [], {fxf.ccy_base: fxf.notional, fxf.ccy: - fxf.notional * fxf.rate}

        else:
            return [trade], {}

    else:
        return [trade], {}


async def get_market_data_tag_async(mkt_data_obj: F3Object):
    f3 = firm_f3.f3client.get_platform_client()
    assert isinstance(mkt_data_obj, F3Object)
    return await f3.evaluate(f3.ObjectInfo("MarketDataSet", mkt_data_obj, "MarketDataTags"))


async def get_model_fx_rate_async(ccy: Ccy, model, val_spec=None, val_date: pd.Timestamp = None) -> float:
    if ccy == Ccy.USD:
        return 1
    return await value_index_async(ccy, f3model=model, valuation_method=val_spec, ref_spec=val_date)


def get_model_fx_rate(ccy: Ccy, model, val_spec=None, val_date: pd.Timestamp = None) -> float:
    return wait(get_model_fx_rate_async(ccy=ccy, model=model, val_spec=val_spec, val_date=val_date))


def instrument_type_to_conventions(inst_type: str) -> Tuple[str, str, str]:
    return INSTRUMENT_TYPE_TO_CONVENTIONS[inst_type]


def trade_to_instrument_type(t: Trade) -> str:
    warnings.warn('use f3instrument_type instead?', DeprecationWarning)
    return f3instrument_type(t)


def tenor_to_quote_spec(t: Tenor) -> str:
    warnings.warn('use f3quote_spec instead?', DeprecationWarning)
    return f3quote_spec(t)


def ccy_to_f3_fixing(c: Ccy) -> str:
    return f'USD:{c.name}'


def ccy_to_f3ccy(c: Ccy) -> str:
    return str(c)


def ccy_to_ccs_inst_type(c: Ccy, t: Tenor = Tenor.T_1Y) -> str:
    return f3instrument_type(CrossCurrencySwap(c, t))


def ccy_to_fx_inst_type(c: Ccy, c_base: Ccy, t: Tenor = Tenor.T_1M) -> str:
    return f3instrument_type(FXForward(c, t, c_base))


def ccy_to_val_spec(c: Ccy) -> str:
    return CCY_TO_VAL_SPEC[c]


def ccy_to_ccs_cal(c: Ccy) -> str:
    return CCY_TO_CCS_CAL[c]


def trade_to_fincad(trade: Trade) -> object:
    warnings.warn('use f3products instead?', DeprecationWarning)
    return f3products(trade)


def _add_swaption_skew_tags(d: Dict):
    res = {}
    strikes = [0.01, 0.005, 0.0025, 0, -0.0025, -0.005, -0.01]
    swaption_keys = [x for x in d.keys() if x.find('Relative:') > 0]

    aud_swaption_tag_suffix_6m = 'VanillaPhysicallySettledSwaption'
    aud_swaption_tag_prefix_6m = 'SwaptionInstrument:SwapBBSWSemi:BBSW6m:SwapBBSW6m:'
    aud_swaption_tag_suffix_3m = 'VanillaPhysicallySettledSwaption'
    aud_swaption_tag_prefix_3m = 'SwaptionInstrument:SwapBBSWQuarterly:BBSW3m:SwapBBSW3m:'

    for s in strikes:
        for key in swaption_keys:
            f3skewtag = key[0:key.find('Relative:') + len('Relative:')] + str(s) + key[key.find('Relative:') + len(
                'Relative:') + 1:]
            res[f3skewtag] = f'{d[key]}_{s}'
        s1 = 0.0 if s==0 else s
        res[aud_swaption_tag_prefix_6m + str(s1) + aud_swaption_tag_suffix_6m] = f'{Swaption(Ccy.AUD, Tenor.T_5Y, Tenor.T_5Y)}_{s}'
        res[aud_swaption_tag_prefix_3m + str(s1) + aud_swaption_tag_suffix_3m] = f'{Swaption(Ccy.AUD, Tenor.T_1Y, Tenor.T_1Y)}_{s}'

    return {**d, **res}


async def get_model_data_async(model: F3Object, auto_format: bool = False, inst_des: bool = False) -> pd.DataFrame:
    results = await extract_market_data_async(model, callback=None)
    df = pd.DataFrame(data=results, columns=['MarketDataName', 'MarketDataType', 'QuoteSpecification', 'Quote'])
    df = df.ffill()

    if inst_des:
        all_inst = get_curve_ins() + [Swaption(ccy, Tenor.T_5Y, Tenor.T_5Y) for ccy in SWAPTION_CCY if ccy is not Ccy.AUD]
        res = dict(zip([x+y for x,y in await f3market_data_tag_async(*all_inst)], all_inst))
        res = _add_swaption_skew_tags(res)
        df['MarketDataTag'] = df['MarketDataName'] + df['MarketDataType']
        df['MarketDataDes'] = [str(res.get(x, 'KeyError')) for x in df['MarketDataTag']]
        df = df[['MarketDataName', 'MarketDataType', 'MarketDataDes', 'QuoteSpecification', 'Quote']]
        if not auto_format:
            return df
        return pd.pivot_table(df, values='Quote', index=['MarketDataName', 'MarketDataType', 'MarketDataDes', 'QuoteSpecification'])['Quote']

    if not auto_format:
        # original behaviour for backward compatibility
        return df

    # jchi@201907
    # render results into a pandas.MultiIndex Series
    return pd.pivot_table(df, values='Quote', index=['MarketDataName', 'MarketDataType', 'QuoteSpecification'])['Quote']


def get_model_data(model: F3Object, auto_format: bool = False, inst_des: bool = False) -> pd.DataFrame:
    return wait(get_model_data_async(model=model, auto_format=auto_format, inst_des=inst_des))


def get_model_fixing(ccy: Ccy, model, fix_date: Union[datetime, date], model_data: pd.DataFrame = None) -> float:
    if model_data is None:
        model_data = get_model_data(model)

    if isinstance(fix_date, date):
        fix_date = datetime.combine(fix_date, time(0))
    name = ccy_to_f3_fixing(ccy)
    fixings = model_data.loc[
        (model_data['MarketDataName'] == name) & (model_data['MarketDataType'] == 'Fixings')].copy()
    fixings['QuoteSpecification'] = pd.to_datetime(fixings['QuoteSpecification'])
    ret_val = float(fixings[fixings['QuoteSpecification'] == fix_date]['Quote'])
    return ret_val


def get_model_forward(rate: Rate, model, fix_date: datetime, val_spec=None) -> float:
    f3 = firm_f3.f3client.get_platform_client()
    if not val_spec:
        val_spec = 'Default'
    return wait(f3.evaluate(f3.ValueIndex(model, f3index(rate), fix_date, val_spec)))


def get_model_fx(ccy: Ccy, model, value_date: datetime, val_spec=None) -> float:
    f3 = firm_f3.f3client.get_platform_client()
    if not val_spec:
        val_spec = 'Default'
    return wait(f3.evaluate(f3.ValueIndex(model, ccy_to_f3pair(ccy), [value_date, 1], val_spec)))[0][0]


def port_value(portfolios: Union[int, List[int]], model, recursive: bool = True, reload: bool = False) -> float:
    return calc_trade(get_trades_from_portfolio(portfolios, recursive, reload), model, REQUEST.VALUE)


def trades_to_dv01_by_ccy(trades: List[Trade], model) -> Dict[Ccy, float]:
    reports = [calc_trade(t, model, REQUEST.RISK_REPORT) for t in trades]
    exposures = [r.loc[r['QuoteSpecification'] == 'AggregateMaturities', ['Currency', 'Exposure']] for r in reports
                 if not r.empty]
    ccy_to_risk = [r.groupby('Currency')['Exposure'].sum().to_dict() for r in exposures]
    ccys = {c for e in ccy_to_risk for c in e}
    return {Ccy[c]: sum([e.get(c, 0) for e in ccy_to_risk]) for c in ccys}


def trades_to_flat_dv01(trades: List[Trade], model) -> float:
    dv01_by_ccy = trades_to_dv01_by_ccy(trades, model)
    return sum([dv01_by_ccy[c] * get_model_fx_rate(c, model) for c in dv01_by_ccy])


def port_flat_dv01(portfolios: Union[int, List[int]], model, recursive: bool = True,
                   reload: bool = False) -> float:
    return trades_to_flat_dv01(get_trades_from_portfolio(portfolios, recursive, reload), model)


def get_trades_from_portfolio(portfolio: Union[int, List[int]], recursive: bool = True,
                              reload: bool = False) -> List[Trade]:
    from firm_f3.datalayer.sophis import SophisPositionService
    def get_trades_helper(port: int) -> List[Trade]:
        with SophisPositionService() as ps:
            if recursive:
                p = ps.get_portfolio_by_id(port)
                return p.fetch(ps, recursive)
            else:
                return ps.get_trades_by_portfolio_id(port, reload=reload)

    if not isinstance(portfolio, list):
        portfolio = [portfolio]
    trades_lists = [get_trades_helper(p) for p in portfolio]
    return [t for l in trades_lists for t in l]


def rate_to_fincad(rate: Rate) -> str:
    warnings.warn('use f3instrument_type instead?', DeprecationWarning)
    return f3index(rate)


def get_quote_spec_tenor(instrument: Union[Swap, FXOption, FXForward]) -> Tenor:
    if isinstance(instrument, FRA):
        return instrument.start
    if isinstance(instrument, FXOption):
        return instrument.expiry
    else:
        return instrument.tenor


def get_val_spec_builder(ccy: Ccy) -> str:
    return CCY_TO_VAL_SPEC_BUILDER[ccy]


def change_model_date(model: F3Object, new_date: datetime) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.CreateDuplicateModelWithNewValuationDate(model, new_date)


def roll_fixings(model: F3Object, new_date: datetime) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    val_date = pd.Timestamp(wait(f3.evaluate(f3.ObjectInfo('Model', model, 'ValuationDate')))[0][0])

    data = get_model_data(model)
    gb = data.loc[data['MarketDataType'] == 'Fixings', ['MarketDataName', 'QuoteSpecification', 'Quote']].groupby(0)
    latest_fixings = {k: df.loc[df['QuoteSpecification'] == max(df['QuoteSpecification']), 'Quote'].iloc[0] for k, df in
                      gb}

    dr = pd.date_range(val_date, new_date, closed='left')

    for f in latest_fixings:
        index = FINCAD_FIXING_TO_INDEX[f]
        new_fixings = [[d, float(latest_fixings[f])] for d in dr]
        model = f3.AddSimpleFixingsCurveToModel(model, new_fixings, index)
    return model


def get_rolled_model(model: F3Object, new_date: Union[datetime, Tenor], holidays: str = 'HongKongFoll') -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    if isinstance(new_date, Tenor):
        val_date = pd.Timestamp(wait(f3.evaluate(f3.ObjectInfo('Model', model, 'ValuationDate')))[0][0])
        new_date = wait(f3.evaluate(f3.MaturityDate(val_date, f3quote_spec(new_date), holidays)))[0][0]

    new_model = roll_fixings(model, new_date)
    new_model = change_model_date(new_model, new_date)

    return new_model


def fx_delta_to_fincad(delta: float) -> Union[str, float]:
    if not delta:
        return 'DeltaParity'
    else:
        return delta


def maturity_date(trade_date: date, instrument: Union[Swap, FXOption, FXForward]) -> datetime:
    f3 = firm_f3.f3client.get_platform_client()
    if isinstance(instrument, FRA):
        raise ValueError('Not supported for FRAs yet')
    ins_type = get_instrument_type(instrument)
    start = start_date(trade_date, instrument)
    return wait(f3.evaluate(f3.MaturityDate(start, get_quote_spec(instrument, trade_date), ins_type)))[0][0]

async def maturity_date_async(trade_date: date, instrument: Union[Swap, FXOption, FXForward]) -> datetime:
    f3 = firm_f3.f3client.get_platform_client()
    if isinstance(instrument, FRA):
        raise ValueError('Not supported for FRAs yet')
    ins_type = get_instrument_type(instrument)
    start = start_date(trade_date, instrument)
    return await(f3.evaluate(f3.MaturityDate(start, get_quote_spec(instrument, trade_date), ins_type)))[0][0]

def start_date(trade_date: date, instrument: Union[Swap, FXOption, FXForward]) -> date:
    f3 = firm_f3.f3client.get_platform_client()
    if isinstance(instrument, FRA):
        raise ValueError('Not supported for FRAs yet')
    ins_type = get_instrument_type(instrument)
    if isinstance(instrument, (FXOption, FXForward)) or (
            isinstance(instrument, Swap) and instrument.start == Tenor.SPOT):
        return wait(f3.evaluate(f3.TradeDateToStartDate(trade_date, ins_type)))[0][0]
    else:
        new_ins = deepcopy(instrument)
        new_ins.start = Tenor.SPOT
        new_ins.tenor = instrument.start
        return maturity_date(trade_date, deepcopy(instrument))


def get_model_val_date(model) -> date:
    return wait(valuation_date_async(model))


async def apply_to_dict_generic_async(data: Dict[Hashable, List[Any]],
                                      func: Callable[[List[Any]], Any]) -> Dict[Hashable, List[Any]]:
    items_to_key_map = {}
    final_item_list = []
    item_counter = 0
    for k in data:
        for i in data[k]:
            final_item_list.append(i)
            items_to_key_map[item_counter] = k
            item_counter += 1

    ret_values = await func(final_item_list)
    ret_dict = {k: [] for k in data}
    for i, v in enumerate(ret_values):
        ret_dict[items_to_key_map[i]].append(v)

    return ret_dict


async def port_dict_to_value_async(ports: Dict[int, List[Trade]], model,
                                   val_date: Union[pd.Timestamp, date] = None) -> Dict[int, float]:
    async def calc_func(trades: List[Trade]) -> List[float]:
        return await calc_trade_async(trades, model, REQUEST.VALUE, val_date, aggregate=False)

    values = await apply_to_dict_generic_async(ports, calc_func)

    return {p: sum(values[p]) for p in values}


def port_dict_to_value(ports: Dict[int, List[Trade]], model,
                       val_date: Union[pd.Timestamp, date] = None) -> Dict[int, float]:
    return wait(port_dict_to_value_async(ports=ports, model=model, val_date=val_date))


def product_info_dictionary(instrument):
    """Takes in an f3 object that is of type product and returns a dictionary with object info"""
    f3 = firm_f3.f3client.get_platform_client()
    warnings.warn('this function was refactored out of `fincadtools`, which has been removed', DeprecationWarning)
    ll = wait(f3.evaluate(f3.DisplayObject('Product', instrument)))
    d1 = {l[0]: '' for l in ll if len(l) == 1}
    d2 = {l[0]: l[1] for l in ll if len(l) == 2}
    return {**d1, **d2}


def f3index_by_inflation_index(idx: InflationIndex) -> str:
    return f3index(idx)


def f3_seasonality_ins_type_by_inf_index(idx: InflationIndex) -> str:
    return f3seasonality(idx)


def get_discount_factor(model, val_date: date, ccy: Ccy, collat_ccy: Ccy = None,
                        model_val_date: date = None, ) -> float:
    f3 = firm_f3.f3client.get_platform_client()
    if model_val_date is None:
        model_val_date = get_model_val_date(model)
    if collat_ccy is None:
        collat_ccy = ccy

    year_frac = (val_date - model_val_date).days / 365
    curve_tag = f3.DiscountCurveTag(ccy_to_f3ccy(ccy), ccy_to_collateral(collat_ccy))

    return wait(f3.evaluate(f3.ExtractOneDimensionalCurveValue(model, curve_tag, year_frac, False)))[0][0]


def get_root_finder(ccy: Ccy) -> str:
    name_base = 'LevenbergMarquardt_1e-4'
    return f'{name_base}_ {ccy}'


def get_exp_spline_interp_method(tension: float) -> str:
    name_base = 'ExponentialTensionSpline'
    return f'{name_base}_{tension:.2f}'


def fx_neutral_fwd_notional(model, ccy: Ccy, near: Union[Tenor, date], far: Union[Tenor, date], notional: float,
                            val_date: Optional[date] = None) -> float:
    if val_date is None:
        val_date = get_model_val_date(model)

    if isinstance(near, Tenor):
        near = maturity_date(val_date, FXForward(ccy, near))
    if isinstance(far, Tenor):
        far = maturity_date(val_date, FXForward(ccy, far))

    near_rate = get_model_fx(ccy, model, near)
    far_rate = get_model_fx(ccy, model, far)

    near_df = get_discount_factor(model, near, Ccy.USD, Ccy.USD, val_date)
    far_df = get_discount_factor(model, far, Ccy.USD, Ccy.USD, val_date)

    return notional * near_df / far_df * far_rate / near_rate

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\logging.py
----------------------------------------
import os
import logging
import getpass
import platform
from datetime import date
from contextlib import contextmanager
from typing import Optional


DEBUG = False


@contextmanager
def debug(true: bool):
    global DEBUG
    prev_debug = DEBUG
    DEBUG = true
    yield
    DEBUG = prev_debug


logger = logging.getLogger(__name__)


def get_pip_installed_version() -> Optional[str]:
    from pip._vendor import pkg_resources
    for p in pkg_resources.working_set:
        if p.project_name == 'firm-f3':
            return p.version
    return None


FORMAT_SHORT = '%(asctime)s %(levelname)s %(message)s'
FORMAT_LONG = '%(asctime)s %(levelname)s [%(processName)s(%(process)s)/%(threadName)s(%(thread)s)/' \
              '%(name)s::%(funcName)s] %(message)s'


def configure_logging(
        level=logging.INFO,
        log_format: str = FORMAT_SHORT,
        propagate: bool = False,
        name: str = None,
) -> None:
    if name is None:
        name, _, _ = __name__.partition('.')
    log = logging.getLogger(name)
    log.setLevel(level)
    log.propagate = propagate

    if not log.handlers:
        log.addHandler(logging.StreamHandler())
        try:
            log_dir = os.environ['PYTHON_LOG_DIRECTORY']
        except KeyError:
            pass
        else:
            filename = '_'.join(
                [date.today().strftime('%Y%m%d'), platform.node(), getpass.getuser(), log.name]) + '.log'
            filepath = os.path.join(log_dir, filename)
            log.addHandler(logging.FileHandler(filepath, delay=True))

    for handler in log.handlers:
        handler.setFormatter(logging.Formatter(log_format))

    log.info(f'Running code version {getpass.getuser()}@{platform.node()} {get_pip_installed_version()}')


if os.environ.get('F3SHARED_LOGGING_DEBUG'):
    DEBUG = True
    configure_logging(level=logging.DEBUG, log_format=FORMAT_LONG)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\mappings.py
----------------------------------------
"""
Our current object names by category
Naming convention <more specific identifier>_<object name>_<tail/ref/namespace>
e.g. EURUSD-Forward-PointsAtPremium_MktData_snap_prd_intraday
"""

# Models API
from firm_f3.core import endpoints as ep

MODEL_FRAGMENT = {"name": "ModelFragment", "endpoint": ep.ModelFragment}
MODEL_RECIPE = {"name": "ModelRecipe", "endpoint": ep.ModelRecipe}
MODEL_STREAM = {"name": "ModelStream", "endpoint": ep.ModelStream}
MODEL_SNAPSHOT = {"name": "ModelSnapshot", "endpoint": ep.ModelSnapshot}

# Market Data API
INDEX_FIXING = {"name": "Fixing", "endpoint": ep.IndexFixings}
MARKET_DATA_STREAM = {"name": "MktData_stream", "endpoint": ep.MarketDataStream}
MARKET_DATA_SNAPSHOT = {"name": "MktData_snap", "endpoint": ep.MarketDataSnapshot}

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model.py
----------------------------------------
import logging
import asyncio
import getpass
import json
import time
from datetime import datetime
from typing import Dict, Union, Any, Optional, List, Set

import pandas as pd  # type: ignore
from colorama import Fore  # type:ignore
from deprecation import deprecated
from f3sdk.f3 import F3Object  # type: ignore
from f3sdk.lib.coroutine import wait  # type: ignore # Allows to wait for a coroutine to complete.

import firm_f3.core.endpoints as EP
import firm_f3.market_data.marketdata as fmd
import firm_f3.modelconfig as conf
from firm_f3.core.crud import get_one, get_many, MAX_SEMAPHORE_COUNT, delete_many_async, \
    update_or_create_async, get_many_async, get_one_async
# backward compatibility
from firm_f3.core.modelutils import get_slug_from_model, create_tail, create_collapsed_compounding_valspec
from firm_domain.market_date import MarketDate
import firm_f3.f3client  # type:ignore
from firm_f3.market_data.fixings import update_fixings_async
from firm_f3.market_data.marketdata_placeholder import get_mkt_data_placeholder_async
from firm_f3.market_data.mdobject import MDObjectBase
from firm_f3.model_fragments.legacy_strategies import get_instrument_strategies_async
from firm_f3.model_fragments.model_eur import MultiCurveFragmentEur
from firm_f3.model_fragments.model_fragment import update_model_fragment_async, FragmentBase
from firm_f3.model_fragments.model_gbp import MultiCurveFragmentGbp
from firm_f3.model_fragments.model_usd import MultiCurveFragmentUsd
from firm_f3.recipe import update_or_create_recipe_async, run_recipe_from_stream_async
from firm_domain.util.datehelper import format_f3_timestamp, parse_f3_timestamp
from firm_f3.util.utils import chunks_dict, timer

logger = logging.getLogger(__name__)


async def update_model_fragments_async(tail: str, market_data: Dict[str, MDObjectBase]) -> List[Dict[str, Any]]:
    model_fragments: Set[FragmentBase] = set()
    model_fragments.add(MultiCurveFragmentEur())
    model_fragments.add(MultiCurveFragmentUsd())
    model_fragments.add(MultiCurveFragmentGbp())

    # model_fragments.update(bond_config.configuration.additional_bond_fragments)

    model_fragments_saved_coro = []
    for model_fragment in model_fragments:
        logger.info(Fore.BLUE + f"assemble and update fragment {model_fragment.fragment_name}")
        model_fragment_saved = model_fragment.assemble_and_update_async(tail=tail, market_data=market_data)
        model_fragments_saved_coro.append(model_fragment_saved)

    model_fragments_saved = await asyncio.gather(*model_fragments_saved_coro)

    return model_fragments_saved


async def update_remaining_fragment_async(tail: str, model: str = "${-1}", **kwargs) -> Dict[str, Any]:
    f3 = firm_f3.f3client.get_platform_client()
    from firm_f3.model_fragments import (model_sar, model_zar, model_ils, model_hkd, model_sgd, model_huf, model_pln,
                                         model_try, model_ccs_swaption, model_securities)
    import firm_f3.model_fragments.legacy_fragments as lf

    """ return a fragment of the remaining models that have not been extracted yet """
    model = f3.ExtendModelWithValuationSpecification(model, create_collapsed_compounding_valspec())

    model = await lf.extend_with_jpy_multi_curve_async(model, **kwargs)
    model = await lf.extend_with_chf_multi_curve_async(model, **kwargs)
    model = await lf.extend_with_nok_multi_curve_async(model, **kwargs)
    model = await lf.extend_with_sek_multi_curve_async(model, **kwargs)
    model = await lf.extend_with_nzd_multi_curve_async(model, **kwargs)
    model = await lf.extend_with_cad_multi_curve_async(model, **kwargs)
    model = await lf.extend_with_aud_multi_curve_async(model, **kwargs)
    model = lf.extend_with_krw_multi_curve(model, **kwargs)
    model = await lf.extend_with_cnh_multi_curve_async(model, **kwargs)
    model = await lf.extend_with_cny_multi_curve_async(model, **kwargs)
    model = await lf.extend_with_myr_multi_curve_async(model, **kwargs)
    model = await lf.extend_with_twd_multi_curve_async(model, **kwargs)
    model = await lf.extend_with_nto_multi_curve_async(model, **kwargs)
    model = await lf.extend_with_thb_multi_curve_async(model, **kwargs)
    model = await lf.extend_with_inr_multi_curve_async(model, **kwargs)
    model = await lf.extend_with_ino_multi_curve_async(model, **kwargs)
    model = await lf.extend_with_rub_multi_curve_async(model, **kwargs)

    model = await model_ils.assemble_model_fragment_async(model)
    model = await model_zar.assemble_model_fragment_async(model)
    model = await model_sar.assemble_model_fragment_async(model)
    model = await model_pln.assemble_model_fragment_async(model)
    model = await model_huf.assemble_model_fragment_async(model)
    model = await model_hkd.assemble_model_fragment_async(model)
    model = await model_sgd.assemble_model_fragment_async(model)
    model = await model_try.assemble_model_fragment_async(model)

    model = await model_securities.assemble_model_fragment_async(model)

    model = await model_ccs_swaption.assemble_model_fragment_async(model)

    model = await lf.extend_with_fx_fwds_async(model, **kwargs)

    model = lf.extend_with_eur_swaptions(model, **kwargs)
    model = lf.extend_with_pln_swaptions(model, **kwargs)
    model = lf.extend_with_usd_swaptions(model, **kwargs)
    model = lf.extend_with_sar_swaptions(model, **kwargs)
    model = lf.extend_with_aud_swaptions(model, **kwargs)
    model = lf.extend_with_krw_swaptions(model, **kwargs)
    model = lf.extend_with_jpy_swaptions(model, **kwargs)
    model = lf.extend_with_twd_swaptions(model, **kwargs)
    model = lf.extend_with_nto_swaptions(model, **kwargs)
    # model = await lf.extend_with_eur_swaptions_sabr_async(model)
    # model = await lf.extend_with_usd_swaptions_sabr_async(model)
    # model = await lf.extend_with_aud_swaptions_sabr_async(model)
    # model = await lf.extend_with_krw_swaptions_sabr_async(model)
    # model = await lf.extend_with_jpy_swaptions_sabr_async(model)

    for c in conf.FX_OPTION_CCY:
        model = await lf.extend_with_fx_vols_async(model, c, **kwargs)
    for idx in conf.INFLATION_INDICES:
        model = await lf.extend_with_inflation_swap_async(model, idx, **kwargs)

    model_fragment = await update_model_fragment_async(f"remaining_ModelFragment_{tail}", model)
    return model_fragment


##### Recipe & Streams

async def create_recipe_async(tail: str,
                              update_fix_data: bool,
                              fixings_start=None) -> Dict[str, object]:
    logger.info("create_recipe() called")
    start = time.perf_counter()
    fixings = await update_fixings_async(tail=tail, start_date=fixings_start) if update_fix_data else None
    # fixings = get_many(EP.IndexFixings, {"name:like": tail}) Better way of getting fixing slugs, so we don't need to call update_fixings

    ref_date = pd.Timestamp.today()  # needed to get latest bond population and futures expiry list
    placeholder_mkt_data = await get_mkt_data_placeholder_async(ref_date)
    model_fragments = await update_model_fragments_async(tail=tail, market_data=placeholder_mkt_data)
    strategies = await get_instrument_strategies_async(placeholder_mkt_data)
    remaining_fragment = await update_remaining_fragment_async(tail=tail, **strategies)
    logger.info(f"update_model_fragment: {time.perf_counter() - start}")

    mkt_data_streams_posted = {}

    for chunk in chunks_dict(placeholder_mkt_data, MAX_SEMAPHORE_COUNT):
        coros = []
        for s, mkt_data_s in chunk.items():
            coro = fmd.update_or_create_marketdata_stream_async(s, tail)
            coros.append(coro)

        logger.debug(f"waiting for {len(coros)} coroutines (create_recipe)")
        for s, mkt_data_stream in zip(chunk.keys(), await(asyncio.gather(*coros))):
            mkt_data_streams_posted[s] = mkt_data_stream

    await fmd.update_market_data_async(placeholder_mkt_data, tail, MarketDate.CreateIntraday().timestamp)

    logger.info(f"update market data: {time.perf_counter() - start}")

    mkt_data_stream_slugs: List[int] = [v["slug"] for s, v in mkt_data_streams_posted.items()]
    fixings_slugs: List[int] = [fixings[f]["slug"] for f in fixings] if fixings else []

    model_fragment_flugs: List[int] = [f["slug"] for f in model_fragments]
    if remaining_fragment:
        model_fragment_flugs.append(remaining_fragment["slug"])

    recipe = await update_or_create_recipe_async(model_recipe_query={"name": f"ModelRecipe_{tail}"},
                                                 name=f"ModelRecipe_{tail}",
                                                 descr=f"ModelRecipe_{tail}_description",
                                                 fixings_slugs=fixings_slugs,
                                                 market_data_stream_slugs=mkt_data_stream_slugs,
                                                 model_fragment_slugs=model_fragment_flugs,
                                                 max_index_past_days=10_000)

    logger.info(f"update market data: {time.perf_counter() - start}")
    return recipe


def inspect_recipe(model_recipe_query):
    model_recipe = get_one(EP.ModelRecipe, query=model_recipe_query)

    fixings = get_many("index_fixings",
                       {"slug:in": ",".join([f["index_fixings_slug"] for f in model_recipe["fixings_requirements"]])})
    market_data_streams = get_many(EP.MarketDataStream,
                                   {"slug:in": ",".join([m["market_data_stream_slug"] for m in
                                                         model_recipe["market_data_requirements"]])})
    model_fragments = get_many("model_fragment",
                               {"slug:in": ",".join([m for m in model_recipe["model_fragment_slugs"]])})

    result = {
        "description": model_recipe["description"],
        "fixings": [(x["slug"], x["name"]) for x in fixings],
        "market_data_streams": [(x["slug"], x["name"]) for x in market_data_streams],
        "model_fragments": [(x["slug"], x["name"]) for x in model_fragments]
    }

    print(json.dumps(result, indent=4))


async def get_model_stream_async(ref: str = 'prd',
                                 stream_type: str = 'intraday') -> Dict:
    tail = create_tail(ref, stream_type)
    name = f"ModelStream_{tail}"
    model_stream = await get_one_async(EP.ModelStream, query={'name': name})
    return model_stream


async def update_or_create_stream_async(name: str, model_recipe_slug: str):
    """ Update or create model stream """
    # This assert has been added on 2019/09/13. I believe slug is always string in F3 database
    assert isinstance(model_recipe_slug, str)

    new_obj = {"name": name, "model_recipe_slug": model_recipe_slug}
    return await update_or_create_async(EP.ModelStream, name, new_obj=new_obj)


def run_model(ref: Union[int, str] = 'prd',
              stream_type: str = 'intraday',
              eval_date: Optional[MarketDate] = None) -> F3Object:
    return wait(run_model_async(ref=ref, stream_type=stream_type, eval_date=eval_date))


async def run_model_async(ref: Union[int, str] = 'prd',
                          stream_type: str = 'intraday',
                          eval_date: Optional[MarketDate] = None) -> F3Object:
    if eval_date is None:
        eval_date = MarketDate.CreateIntraday()

    # Gets existing model recipe from F3 and combines it with market data snapshot to create model snapshot
    # We call this function when updating market data
    tail = create_tail(ref, stream_type)
    await fmd.update_all_mkt_data_async(tail, eval_date=eval_date)
    model = await run_recipe_from_stream_async({'name': f'ModelStream_{tail}'}, timestamp=eval_date.timestamp,
                                               ref_date=eval_date.timestamp)
    return model


async def get_model_snapshots_async(model_stream_slug: int) -> Dict[datetime, str]:
    res = await get_many_async(EP.ModelSnapshot, {'model_stream_slug': str(model_stream_slug)})
    o = dict()
    ordering_timepoint = lambda d: parse_f3_timestamp(d['ordering_timepoint'])
    for r in sorted(res, key=ordering_timepoint):
        ts = ordering_timepoint(r)
        o[ts] = r['slug']
    return o


def update_model(ref: str = 'prd',
                 stream_type: str = 'intraday',
                 update_fix_data: bool = True,
                 fixings_start: datetime = None) -> int:
    return wait(update_model_async(ref=ref, stream_type=stream_type, update_fix_data=update_fix_data,
                                   fixings_start=fixings_start))


async def update_model_async(ref: str = 'prd',
                             stream_type: str = 'intraday',
                             update_fix_data: bool = True,
                             fixings_start: datetime = None) -> int:
    # Creates a new model recipe and posts it on F3 platform
    # We only run this function if we made change to the model
    with timer('update_model_async', logstart=True):
        tail = create_tail(ref, stream_type)

        model_recipe: dict = await create_recipe_async(tail=tail,
                                                       update_fix_data=update_fix_data,
                                                       fixings_start=fixings_start)
        model_stream = await update_or_create_stream_async(name=f"ModelStream_{tail}",
                                                           model_recipe_slug=model_recipe["slug"])
        return int(model_stream['slug'])


if __name__ == '__main__':
    update_model(getpass.getuser(), 'testing')

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\modelconfig.py
----------------------------------------
import datetime
from collections import defaultdict, namedtuple
from functools import singledispatch
from typing import List, Union, Sequence

from firm_domain import (
    Ccy, Tenor, Month, IRS, XccyBasis, TenorBasis, OIS, FRA, Swap, CrossCurrencySwap, FXForward, FXOption, OptionStrat,
    InflationIndex, InflationSwap, IMMFRA, Rate, Instrument, RatesFuture, FutureExpiry, GenericIMM,
    ECBOIS, ECB, IMMOIS)
from firm_domain.util.datehelper import next_quarter

CURVE_CONFIG = {
    Ccy.USD: [
        (IRS,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_6Y, Tenor.T_7Y, Tenor.T_8Y,
                    Tenor.T_9Y, Tenor.T_10Y, Tenor.T_11Y, Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y,
                    Tenor.T_25Y, Tenor.T_30Y]),
         {}
         ),
        (TenorBasis,
         ('tenor', [Tenor.T_5Y, Tenor.T_6Y, Tenor.T_7Y, Tenor.T_8Y, Tenor.T_9Y, Tenor.T_10Y,
                    Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y, Tenor.T_25Y, Tenor.T_30Y]),
         {'idx_1': Tenor.T_1D, 'idx_2': Tenor.T_3M}),
        (TenorBasis,
         ('tenor', [Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_6Y, Tenor.T_7Y,
                    Tenor.T_8Y, Tenor.T_9Y, Tenor.T_10Y, Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y,
                    Tenor.T_25Y, Tenor.T_30Y]),
         {'idx_1': Tenor.T_3M, 'idx_2': Tenor.T_6M}
         ),
        (TenorBasis,
         ('tenor', [Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y, Tenor.T_18M, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y,
                    Tenor.T_5Y, Tenor.T_6Y, Tenor.T_7Y, Tenor.T_8Y, Tenor.T_9Y, Tenor.T_10Y, Tenor.T_12Y, Tenor.T_15Y,
                    Tenor.T_20Y, Tenor.T_25Y, Tenor.T_30Y]),
         {'idx_1': Tenor.T_1M, 'idx_2': Tenor.T_3M}
         ),
        (FRA,
         ('tenor', [Tenor.T_3M]),
         {'start': Tenor.T_1D}
         ),
        (FRA,
         ('tenor', [Tenor.T_1M]),
         {'start': Tenor.T_1D}
         ),
        (FRA,
         ('tenor', [Tenor.T_6M]),
         {'start': Tenor.T_1D}
         ),
        (OIS,
         ('tenor', [Tenor.T_1W, Tenor.T_2W, Tenor.T_3W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_4M,
                    Tenor.T_5M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y, Tenor.T_18M, Tenor.T_2Y,
                    Tenor.T_3Y,
                    Tenor.T_4Y]),
         {}
         ),
    ],
    Ccy.EUR: [
        (OIS,
         ('tenor', [Tenor.T_1W]),
         {}
         ),
        # TODO: Change to a step curve at the front
        # Need to observe the behaviour when overlaps happend with ECBOIS and IMM
        (ECBOIS,
         ('start', [ECB(1), ECB(2), ECB(3)]),
         {}
         ),
        (IMMOIS,
         ('start', [GenericIMM(i + 2) for i in range(5)]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_1M]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_3M]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_6M]),
         {}
         ),
        (FRA,
         ('start', [Tenor.T_6M, Tenor.T_1Y]),
         {'tenor': Tenor.T_6M}
         ),
        (OIS,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_6Y, Tenor.T_7Y, Tenor.T_8Y, Tenor.T_9Y,
                    Tenor.T_10Y, Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y, Tenor.T_25Y, Tenor.T_30Y, Tenor.T_35Y,
                    Tenor.T_40Y, Tenor.T_50Y]),
         {}
         ),
        (IRS,
         ('tenor', [Tenor.T_2M, Tenor.T_3M, Tenor.T_4M, Tenor.T_5M, Tenor.T_6M, Tenor.T_7M, Tenor.T_8M,
                    Tenor.T_9M, Tenor.T_10M, Tenor.T_11M, Tenor.T_1Y, Tenor.T_15M, Tenor.T_18M, Tenor.T_21M,
                    Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_6Y, Tenor.T_7Y, Tenor.T_8Y, Tenor.T_9Y,
                    Tenor.T_10Y, Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y, Tenor.T_25Y, Tenor.T_30Y]),
         {'idx': Tenor.T_1M}
         ),
        (IRS,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_6Y, Tenor.T_7Y, Tenor.T_8Y,
                    Tenor.T_9Y, Tenor.T_10Y, Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y, Tenor.T_25Y,
                    Tenor.T_30Y, Tenor.T_40Y, Tenor.T_50Y]),
         {}
         ),
        (TenorBasis,
         ('tenor', [Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y,
                    Tenor.T_15Y, Tenor.T_20Y, Tenor.T_30Y]),
         {'idx_1': Tenor.T_3M, 'idx_2': Tenor.T_6M}
         ),
        (XccyBasis,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y, Tenor.T_12Y,
                    Tenor.T_15Y, Tenor.T_20Y, Tenor.T_30Y]),
         {}
         ),
        (FXForward,
         ('tenor',
          [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
    ],
    Ccy.AUD: [
        (OIS,
         ('tenor', [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_4M, Tenor.T_5M,
                    Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y, Tenor.T_18M, Tenor.T_2Y, Tenor.T_3Y]),
         {}
         ),
        (TenorBasis,
         ('tenor', [Tenor.T_4Y, Tenor.T_5Y, Tenor.T_6Y, Tenor.T_7Y, Tenor.T_8Y, Tenor.T_9Y,
                    Tenor.T_10Y, Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y, Tenor.T_25Y, Tenor.T_30Y]),
         {'idx_1': Tenor.T_1D, 'idx_2': Tenor.T_3M}
         ),
        (TenorBasis,
         ('tenor', [Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_6Y, Tenor.T_7Y,
                    Tenor.T_8Y, Tenor.T_9Y, Tenor.T_10Y, Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y]),
         {'idx_1': Tenor.T_3M, 'idx_2': Tenor.T_6M}
         ),
        (TenorBasis,
         ('tenor', [Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y,
                    Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y, Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y, Tenor.T_30Y]),
         {'idx_1': Tenor.T_1M, 'idx_2': Tenor.T_3M}
         ),
        (IRS,
         ('tenor', [Tenor.T_1Y, Tenor.T_18M, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y,
                    Tenor.T_6Y, Tenor.T_7Y, Tenor.T_8Y, Tenor.T_9Y, Tenor.T_10Y, Tenor.T_12Y,
                    Tenor.T_15Y, Tenor.T_20Y, Tenor.T_25Y, Tenor.T_30Y]),
         {}
         ),
        (XccyBasis,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y, Tenor.T_12Y,
                    Tenor.T_15Y, Tenor.T_20Y, Tenor.T_30Y]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_1M]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_3M]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_6M]),
         {}
         ),
        (FRA,
         ('start', [Tenor.T_3M, Tenor.T_6M]),
         {'tenor': Tenor.T_3M}
         ),
        (FXForward,
         ('tenor', [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
    ],
    Ccy.GBP: [
        (IRS,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_6Y, Tenor.T_7Y, Tenor.T_8Y,
                    Tenor.T_9Y, Tenor.T_10Y, Tenor.T_11Y, Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y,
                    Tenor.T_25Y, Tenor.T_30Y, Tenor.T_40Y, Tenor.T_50Y]),
         {}
         ),
        (OIS,
         ('tenor', [Tenor.T_1W, Tenor.T_2W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_4M, Tenor.T_5M,
                    Tenor.T_6M, Tenor.T_7M, Tenor.T_8M, Tenor.T_9M, Tenor.T_1Y, Tenor.T_18M,
                    Tenor.T_2Y,
                    Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_6Y, Tenor.T_7Y, Tenor.T_8Y, Tenor.T_9Y,
                    Tenor.T_10Y, Tenor.T_11Y, Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y, Tenor.T_25Y,
                    Tenor.T_30Y, Tenor.T_40Y, Tenor.T_50Y]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_3M]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_6M]),
         {}
         ),
        (FRA,
         ('start', [Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_4M, Tenor.T_5M, Tenor.T_6M,
                    Tenor.T_9M, Tenor.T_1Y]),
         {'tenor': Tenor.T_6M}
         ),
        (TenorBasis,
         ('tenor', [Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y,
                    Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y, Tenor.T_30Y]),
         {'idx_1': Tenor.T_3M, 'idx_2': Tenor.T_6M}
         ),
        (XccyBasis,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y, Tenor.T_12Y,
                    Tenor.T_15Y, Tenor.T_20Y, Tenor.T_30Y]),
         {}
         ),
        (FXForward,
         ('tenor', [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
    ],
    Ccy.JPY: [
        (IRS,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_6Y, Tenor.T_7Y, Tenor.T_8Y,
                    Tenor.T_9Y, Tenor.T_10Y, Tenor.T_11Y, Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y,
                    Tenor.T_25Y, Tenor.T_30Y, Tenor.T_35Y, Tenor.T_40Y]),
         {}
         ),
        (OIS,
         ('tenor', [Tenor.T_2W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_4M, Tenor.T_5M,
                    Tenor.T_6M, Tenor.T_7M, Tenor.T_8M, Tenor.T_9M, Tenor.T_1Y, Tenor.T_18M,
                    Tenor.T_2Y,
                    Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_6Y, Tenor.T_7Y, Tenor.T_8Y, Tenor.T_9Y,
                    Tenor.T_10Y, Tenor.T_11Y, Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y, Tenor.T_25Y,
                    Tenor.T_30Y, Tenor.T_35Y, Tenor.T_40Y]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_3M]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_6M]),
         {}
         ),
        (FRA,
         ('start', [Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_4M, Tenor.T_5M, Tenor.T_6M,
                    Tenor.T_9M]),
         {'tenor': Tenor.T_6M}
         ),
        (TenorBasis,
         ('tenor', [Tenor.T_1Y, Tenor.T_2Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y,
                    Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y, Tenor.T_30Y]),
         {'idx_1': Tenor.T_3M, 'idx_2': Tenor.T_6M}
         ),
        (XccyBasis,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y, Tenor.T_12Y,
                    Tenor.T_15Y, Tenor.T_20Y, Tenor.T_30Y]),
         {}
         ),
        (FXForward,
         ('tenor', [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
    ],
    Ccy.NZD: [
        (IRS,
         ('tenor', [Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_6Y, Tenor.T_7Y,
                    Tenor.T_8Y, Tenor.T_9Y, Tenor.T_10Y, Tenor.T_12Y, Tenor.T_15Y,
                    Tenor.T_20Y]),
         {}
         ),
        (OIS,
         ('tenor', [Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_4M, Tenor.T_5M,
                    Tenor.T_6M, Tenor.T_7M, Tenor.T_8M, Tenor.T_9M, Tenor.T_1Y, Tenor.T_18M,
                    Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_6Y, Tenor.T_7Y,
                    Tenor.T_8Y, Tenor.T_9Y, Tenor.T_10Y, Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_3M]),
         {}
         ),
        (FRA,
         ('start', [Tenor.T_3M, Tenor.T_6M]),
         {'tenor': Tenor.T_3M}
         ),
        (XccyBasis,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y, Tenor.T_12Y,
                    Tenor.T_15Y, Tenor.T_20Y]),
         {}
         ),
        (FXForward,
         ('tenor',
          [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
    ],
    Ccy.CAD: [
        (IRS,
         ('tenor', [Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_6Y, Tenor.T_7Y,
                    Tenor.T_8Y, Tenor.T_9Y, Tenor.T_10Y, Tenor.T_12Y, Tenor.T_15Y,
                    Tenor.T_20Y]),
         {}
         ),
        (OIS,
         ('tenor', [Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_4M, Tenor.T_5M,
                    Tenor.T_6M, Tenor.T_7M, Tenor.T_8M, Tenor.T_9M, Tenor.T_1Y, Tenor.T_18M,
                    Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_3M]),
         {}
         ),
        (FRA,
         ('start', [Tenor.T_3M, Tenor.T_6M]),
         {'tenor': Tenor.T_3M}
         ),
        (XccyBasis,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y, Tenor.T_12Y,
                    Tenor.T_15Y, Tenor.T_20Y]),
         {}
         ),
        (FXForward,
         ('tenor', [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
    ],
    Ccy.SEK: [
        (IRS,
         ('tenor', [Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_6Y, Tenor.T_7Y,
                    Tenor.T_8Y, Tenor.T_9Y, Tenor.T_10Y, Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y]),
         {}
         ),
        (OIS,
         ('tenor', [Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_4M, Tenor.T_5M,
                    Tenor.T_6M, Tenor.T_7M, Tenor.T_8M, Tenor.T_9M, Tenor.T_1Y, Tenor.T_18M,
                    Tenor.T_2Y,
                    Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_6Y, Tenor.T_7Y, Tenor.T_8Y,
                    Tenor.T_9Y,
                    Tenor.T_10Y, Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y, Tenor.T_25Y, Tenor.T_30Y]),
         {}
         ),
        (XccyBasis,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y,
                    Tenor.T_15Y, Tenor.T_20Y]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_3M]),
         {}
         ),
        (FXForward,
         ('tenor',
          [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
    ],
    Ccy.KRW: [
        (IRS,
         ('tenor', [Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y,
                    Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y, Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y]),
         {}
         ),
        (XccyBasis,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y,
                    Tenor.T_7Y, Tenor.T_10Y, Tenor.T_20Y]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_3M]),
         {}
         ),
        (FXForward,
         ('tenor',
          [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
    ],
    Ccy.ILS: [
        (IRS,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y,
                    Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y]),
         {}
         ),
        (XccyBasis,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y,
                    Tenor.T_7Y, Tenor.T_10Y]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_3M]),
         {}
         ),
        (FRA,
         ('start', [Tenor.T_3M, Tenor.T_6M, Tenor.T_9M]),
         {'tenor': Tenor.T_3M}
         ),
        (FXForward,
         ('tenor',
          [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
    ],
    Ccy.PLN: [
        (IRS,
         ('tenor', [Tenor.T_3Y, Tenor.T_4Y,
                    Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y, Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y]),
         {}
         ),
        (XccyBasis,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y,
                    Tenor.T_7Y, Tenor.T_10Y]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_3M]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_6M]),
         {}
         ),
        (FRA,
         ('start', [Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_4M, Tenor.T_5M, Tenor.T_6M,
                    Tenor.T_7M, Tenor.T_8M, Tenor.T_9M, Tenor.T_12M, Tenor.T_15M, Tenor.T_18M,
                    Tenor.T_21M]),
         {'tenor': Tenor.T_3M}
         ),
        (FRA,
         ('start', [Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_12M,
                    Tenor.T_15M, Tenor.T_18M]),
         {'tenor': Tenor.T_6M}
         ),
        (TenorBasis,
         ('tenor', [Tenor.T_3Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y, Tenor.T_15Y, Tenor.T_20Y]),
         {'idx_1': Tenor.T_3M, 'idx_2': Tenor.T_6M}
         ),
        (FXForward,
         ('tenor',
          [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
    ],
    Ccy.HUF: [
        (IRS,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y,
                    Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y]),
         {}
         ),
        (XccyBasis,
         # ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y,
         ('tenor', [Tenor.T_4Y, Tenor.T_5Y,
                    Tenor.T_7Y, Tenor.T_10Y]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_3M]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_6M]),
         {}
         ),
        (FRA,
         ('start', [Tenor.T_3M, Tenor.T_6M]),
         {'tenor': Tenor.T_6M}
         ),
        (FRA,
         ('start', [Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_4M, Tenor.T_5M,
                    Tenor.T_6M, Tenor.T_9M, Tenor.T_12M, Tenor.T_15M]),
         {'tenor': Tenor.T_3M}
         ),
        (TenorBasis,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y,
                    Tenor.T_15Y, Tenor.T_20Y]),
         {'idx_1': Tenor.T_3M, 'idx_2': Tenor.T_6M}
         ),
        (FXForward,
         ('tenor',
          [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
    ],
    Ccy.HKD: [
        (IRS,
         ('tenor', [Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y,
                    Tenor.T_12Y, Tenor.T_15Y]),
         {}
         ),
        (XccyBasis,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y,
                    Tenor.T_7Y, Tenor.T_10Y]),
         {}),
        (Rate,
         ('tenor', [Tenor.T_3M]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_1M]),
         {}
         ),
        (FRA,
         ('start', [Tenor.T_3M, Tenor.T_6M]),
         {'tenor': Tenor.T_3M}
         ),
        (TenorBasis,
         ('tenor', [Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_7Y,
                    Tenor.T_10Y, Tenor.T_12Y, Tenor.T_15Y]),
         {'idx_1': Tenor.T_1M, 'idx_2': Tenor.T_3M}
         ),
        (FXForward,
         ('tenor',
          [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
    ],
    Ccy.ZAR: [
        (IRS,
         ('tenor', [Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y,
                    Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y, Tenor.T_30Y]),
         {}
         ),
        (XccyBasis,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y,
                    Tenor.T_7Y, Tenor.T_10Y, Tenor.T_15Y]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_3M]),
         {}
         ),
        (FRA,
         ('start', [Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_4M, Tenor.T_5M,
                    Tenor.T_6M, Tenor.T_9M, Tenor.T_12M, Tenor.T_15M, Tenor.T_18M, Tenor.T_21M]),
         {'tenor': Tenor.T_3M}
         ),
        (FXForward,
         ('tenor',
          [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
    ],
    Ccy.SAR: [
        (IRS,
         ('tenor', [Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y]),
         {}
         ),
        (XccyBasis,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_3M]),
         {}
         ),
        (FRA,
         ('start', [Tenor.T_3M, Tenor.T_6M]),
         {'tenor': Tenor.T_3M}
         ),
        (FXForward,
         ('tenor',
          [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
    ],
    Ccy.SGD: [
        (IRS,
         ('tenor', [Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y,
                    Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y, Tenor.T_30Y]),
         {}
         ),
        (IRS,
         ('tenor', [Tenor.T_6M, Tenor.T_9M]),
         {'idx': Tenor.T_3M}
         ),
        (TenorBasis,
         ('tenor', [Tenor.T_1Y, Tenor.T_18M, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_7Y,
                    Tenor.T_10Y, Tenor.T_15Y, Tenor.T_20Y]),
         {'idx_1': Tenor.T_3M, 'idx_2': Tenor.T_6M}
         ),
        (XccyBasis,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y,
                    Tenor.T_7Y, Tenor.T_10Y]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_3M]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_6M]),
         {}
         ),
        (FXForward,
         ('tenor',
          [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
    ],
    Ccy.CNY: [
        (IRS,
         ('tenor', [Tenor.T_3M, Tenor.T_6M, Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_10Y]),
         {}
         ),
        (FXForward,
         ('tenor', [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y,
                    Tenor.T_2Y]),
         {}
         ),
    ],
    Ccy.MYR: [
        (IRS,
         ('tenor', [Tenor.T_6M, Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_10Y]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_3M]),
         {}
         ),
        (FXForward,
         ('tenor', [Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y,
                    Tenor.T_2Y]),
         {}
         ),
    ],
    Ccy.THB: [
        (IRS,
         ('tenor', [Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y, Tenor.T_12Y, Tenor.T_15Y,
                    Tenor.T_20Y]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_6M]),
         {}
         ),
        (FXForward,
         ('tenor', [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
    ],
    Ccy.INR: [
        (OIS,
         ('tenor', [Tenor.T_1Y]),
         {'fixed_freq': Tenor.T_1Y}
         ),
        (OIS,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_10Y]),
         {'fixed_freq': Tenor.T_6M}
         ),
        (CrossCurrencySwap,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y]),
         {}
         ),
        (FXForward,
         ('tenor',
          [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
    ],
    Ccy.INO: [
        (OIS,
         ('tenor', [Tenor.T_1Y]),
         {'fixed_freq': Tenor.T_1Y}
         ),
        (OIS,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_10Y]),
         {'fixed_freq': Tenor.T_6M}
         ),
        (CrossCurrencySwap,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y]),
         {}
         ),
        (FXForward,
         ('tenor', [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
    ],
    Ccy.RUB: [
        (CrossCurrencySwap,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y]),
         {}
         ),
        (FXForward,
         ('tenor', [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
    ],
    Ccy.PHP: [
        (FXForward,
         ('tenor', [Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y, Tenor.T_2Y]),
         {}
         ),
    ],
    Ccy.TRY: [
        (FXForward,
         ('tenor', [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
        (CrossCurrencySwap,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y]),
         {}
         ),
    ],
    Ccy.MXN: [
        (FXForward,
         ('tenor', [Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y, Tenor.T_2Y]),
         {}
         ),
    ],
    Ccy.IDR: [
        (FXForward,
         ('tenor', [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
    ],
    Ccy.CNH: [
        (FXForward,
         ('tenor', [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
        (CrossCurrencySwap,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y]),
         {}
         ),
    ],
    Ccy.TWD: [
        (IRS,
         ('tenor', [Tenor.T_6M, Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_10Y]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_3M]),
         {}
         ),
        (FXForward,
         ('tenor', [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y,
                    Tenor.T_2Y]),
         {}
         ),
    ],
    Ccy.NTO: [
        (IRS,
         ('tenor', [Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_10Y]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_3M]),
         {}
         ),
        (FXForward,
         ('tenor', [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y,
                    Tenor.T_2Y]),
         {}
         ),
    ],
    Ccy.NOK: [
        (FXForward,
         ('tenor', [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
        (XccyBasis,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y,
                    Tenor.T_15Y, Tenor.T_20Y]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_3M]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_6M]),
         {}
         ),
        (IMMFRA,
         ('start', [GenericIMM(i + 1) for i in range(4)]),
         {'tenor': Tenor.T_6M}
         ),
        (IMMFRA,
         ('start', [GenericIMM(i + 1) for i in range(4)]),
         {'tenor': Tenor.T_3M}
         ),
        (TenorBasis,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y, Tenor.T_15Y]),
         {'idx_1': Tenor.T_3M, 'idx_2': Tenor.T_6M}
         ),
        (IRS,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y, Tenor.T_12Y,
                    Tenor.T_15Y, Tenor.T_20Y]),
         {}
         )
    ],
    Ccy.CHF: [
        (IRS,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_6Y, Tenor.T_7Y,
                    Tenor.T_8Y, Tenor.T_9Y, Tenor.T_10Y, Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y, Tenor.T_30Y]),
         {}
         ),
        (OIS,
         ('tenor', [Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y, Tenor.T_18M,
                    Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_6Y, Tenor.T_7Y, Tenor.T_8Y,
                    Tenor.T_9Y, Tenor.T_10Y, Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y, Tenor.T_25Y, Tenor.T_30Y]),
         {}
         ),
        (XccyBasis,
         ('tenor', [Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y,
                    Tenor.T_15Y, Tenor.T_20Y]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_3M]),
         {}
         ),
        (Rate,
         ('tenor', [Tenor.T_6M]),
         {}
         ),
        (FRA,
         ('start', [Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_4M, Tenor.T_5M, Tenor.T_6M, Tenor.T_9M]),
         {'tenor': Tenor.T_6M}
         ),
        (FRA,
         ('start', [Tenor.T_3M]),
         {'tenor': Tenor.T_3M}
         ),
        (TenorBasis,
         ('tenor', [Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_7Y,
                    Tenor.T_10Y, Tenor.T_15Y]),
         {'idx_1': Tenor.T_3M, 'idx_2': Tenor.T_6M}
         ),
        (FXForward,
         ('tenor',
          [Tenor.T_1W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y]),
         {}
         ),
    ]
}

FX_OPTION_CCY = [Ccy.EUR, Ccy.GBP, Ccy.JPY, Ccy.AUD, Ccy.TWD, Ccy.INR, Ccy.HKD, Ccy.IDR, Ccy.KRW, Ccy.PHP, Ccy.SGD,
                 Ccy.CNH, Ccy.CAD, Ccy.CNY, Ccy.MXN, Ccy.RUB, Ccy.TRY, Ccy.ZAR]  # Ccy.SAR
FX_OPTION_TENORS = [Tenor.T_2W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M,
                    Tenor.T_1Y, Tenor.T_2Y]
FX_OPTION_STRIKES = {OptionStrat.STRAD: [0],
                     OptionStrat.RR: [0.1, 0.25],
                     OptionStrat.FLY: [0.1, 0.25]}

INFLATION_INDICES: Sequence = [InflationIndex.CPURNSA]
INFLATION_SWAP_TENORS = [Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y]

CCS_SWAPTION_CCY = [Ccy.CNH, Ccy.TRY]
CCS_SWAPTION_TENORS = [Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_6Y, Tenor.T_7Y, Tenor.T_8Y,
                       Tenor.T_9Y, Tenor.T_10Y]

SWAPTION_CCY = [Ccy.AUD, Ccy.EUR, Ccy.USD, Ccy.SAR, Ccy.KRW, Ccy.JPY, Ccy.GBP, Ccy.TWD, Ccy.NTO, Ccy.PLN]


def get_curve_ins() -> List[Union[Swap, FXForward]]:
    def unpack_swap_ins():
        for ccy, config in CURVE_CONFIG.items():
            for inst_typ, (tenor_typ, tenors), extra in config:
                for t in tenors:
                    if isinstance(t, GenericIMM):
                        t = t.go_specific()
                    yield inst_typ(ccy=ccy, **{tenor_typ: t}, **extra)

    swap_ins = list(unpack_swap_ins())
    inf_ins = [InflationSwap(i, t) for t in INFLATION_SWAP_TENORS for i in INFLATION_INDICES]

    return swap_ins + inf_ins


def get_fx_vol_ins() -> List[FXOption]:
    return [FXOption(c, t, ot, s) for c in FX_OPTION_CCY for t in FX_OPTION_TENORS for ot in FX_OPTION_STRIKES
            for s in FX_OPTION_STRIKES[ot] if not (c is Ccy.HKD and t in (Tenor.T_2W, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M))]


def get_curve_ins_max_tenor():
    all_inst = get_curve_ins()
    rv = defaultdict(dict)
    for inst in all_inst:
        if isinstance(inst, (IRS, XccyBasis, OIS, CrossCurrencySwap, FXForward)) or (
                isinstance(inst, TenorBasis) and inst.idx_1 is Tenor.T_1D):
            key = inst.ccy

            if isinstance(inst, TenorBasis):
                typ = OIS
            else:
                typ = type(inst)

            try:
                prev = rv[key][typ]
            except KeyError:
                rv[key][typ] = inst.tenor
            else:
                rv[key][typ] = max(inst.tenor, prev)

    def unpack():
        for k, v in rv.items():
            if len(v) == 1:
                yield k, max(v.values())
            else:
                for i in (OIS, XccyBasis, CrossCurrencySwap):
                    try:
                        discount_tenor = v.pop(i)
                        break
                    except KeyError:
                        pass
                else:
                    discount_tenor = Tenor.T_60Y
                yield k, min(v.pop(IRS, Tenor.T_60Y), discount_tenor)

    return dict(unpack())


@singledispatch
def curve_config_tenors(inst: Instrument, **kwargs) -> List[Tenor]:
    raise TypeError(f'expect Instrument, got type {type(inst)} instead')


@curve_config_tenors.register
def curve_config_tenors_by_irs(inst: IRS, **kwargs) -> List[Tenor]:
    config = CURVE_CONFIG[inst.ccy]
    for typ, (_, tenors), _ in config:
        if typ is IRS:
            if inst.ccy is Ccy.AUD:
                if inst.idx is Tenor.T_3M:
                    return [i for i in tenors if i <= Tenor.T_3Y]
                elif inst.idx is Tenor.T_6M:
                    return [i for i in tenors if i > Tenor.T_3Y]
            return tenors
    else:
        raise KeyError(f'no curve config for {inst}')


@curve_config_tenors.register
def curve_config_tenors_by_ois(inst: OIS, **kwargs) -> List[Tenor]:
    config = CURVE_CONFIG[inst.ccy]
    for typ, (_, tenors), _ in config:
        if typ is OIS:
            return tenors
    else:
        raise KeyError(f'no curve config for {inst}')


@curve_config_tenors.register
def curve_config_tenors_by_fra(inst: FRA, **kwargs) -> List[Tenor]:
    config = CURVE_CONFIG[inst.ccy]
    for typ, (_, starts), spec in config:
        if typ is FRA and spec['tenor'] is inst.tenor:
            return starts
    else:
        raise KeyError(f'no curve config for {inst}')


@curve_config_tenors.register
def curve_config_tenors_by_rate(inst: Rate, **kwargs) -> List[Tenor]:
    config = CURVE_CONFIG[inst.ccy]
    for typ, (_, tenors), _ in config:
        if typ is Rate and tenors[0] is inst.tenor:
            return tenors
    else:
        raise KeyError(f'no curve config for {inst}')


@curve_config_tenors.register
def curve_config_tenors_by_tenor_basis(inst: TenorBasis, **kwargs) -> List[Tenor]:
    config = CURVE_CONFIG[inst.ccy]
    for typ, (_, tenors), spec in config:
        if typ is TenorBasis and spec['idx_1'] is inst.idx_1 and spec['idx_2'] is inst.idx_2:
            return tenors
    else:
        raise KeyError(f'no curve config for {inst}')


@curve_config_tenors.register
def curve_config_tenors_by_xccy(inst: XccyBasis, **kwargs) -> List[Tenor]:
    config = CURVE_CONFIG[inst.ccy]
    for typ, (_, tenors), _ in config:
        if typ is XccyBasis:
            return tenors
    else:
        raise KeyError(f'no curve config for {inst}')


@curve_config_tenors.register
def curve_config_tenors_by_fx_fwd(inst: FXForward, **kwargs) -> List[Tenor]:
    ccy = inst.ccy
    if ccy is Ccy.USD:
        ccy = inst.ccy_base
    config = CURVE_CONFIG[ccy]
    for typ, (_, tenors), _ in config:
        if typ is FXForward:
            return tenors
    else:
        raise KeyError(f'no curve config for {inst}')


@curve_config_tenors.register
def curve_config_tenors_by_inflation_swap(inst: InflationSwap, **kwargs) -> List[Tenor]:
    return list(INFLATION_SWAP_TENORS)


fut_config = namedtuple('fut_config', 'roll_func,roll_count')
FUTURE_CONFIG = {
    Ccy.USD: {
        Tenor.T_3M: fut_config(next_quarter, 5)
    }
}


@curve_config_tenors.register
def curve_config_tenors_by_rates_future(inst: RatesFuture, ref_date: datetime.date = None) -> List[FutureExpiry]:
    if ref_date is None:
        ref_date = datetime.date.today()
    roll, cnt = FUTURE_CONFIG[inst.ccy][inst.idx]

    def unpack():
        next_date = roll(ref_date)
        for _ in range(cnt):
            yield FutureExpiry(Month(next_date.month - 1), next_date.year)
            next_date = roll(next_date)

    return list(unpack())


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\modelutils.py
----------------------------------------
from .core.modelutils import *
import warnings

msg = """
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                   !!
!! WARNING firm_f3.modelutils is moved to firm_f3.core.modelutils    !!
!! please update your import statement accordingly                   !!
!!                                                                   !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"""
print(msg)
warnings.warn(msg, DeprecationWarning)

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\recipe.py
----------------------------------------
from typing import Dict, Optional, List, Any
from f3sdk.lib.coroutine import wait  # type: ignore
from f3sdk.f3.futures import F3Object  # type: ignore
from datetime import datetime

from firm_f3.core import endpoints
from firm_f3.core.error import F3ObjectNotFoundError
from firm_f3.core.crud import get_one_async, update_or_create_async
import firm_f3.f3client


async def get_latest_model_async(model_recipe_query: Dict[str, object] = None,
                                 model_stream_query: Dict[str, object] = None):
    """ Retrieve the latest model from a given recipe or stream """
    f3 = firm_f3.f3client.get_platform_client()
    assert (model_recipe_query or model_stream_query) and not (model_recipe_query and model_stream_query)
    if model_stream_query:
        model_stream = await get_one_async(endpoints.ModelStream, query={**model_stream_query})
        model_snapshot = await f3.Platform.Object.get(f"model_stream/{model_stream['slug']}/latest")
    else:
        query = {**model_recipe_query, "sort_by": "-created_utc", "limit": 1}  # type: ignore
        model_recipe = await get_one_async(endpoints.ModelRecipe, query=query)
        model_snapshot = await get_one_async(endpoints.ModelSnapshot, query={"model_recipe_slug": model_recipe["slug"],
                                                                             "sort_by": "-created_utc", "limit": 1})
    return await f3.Platform.Object.Get("Model", str(model_snapshot["slug"]))


def get_latest_model(model_recipe_query: Dict[str, object] = None,
                     model_stream_query: Dict[str, object] = None):
    return wait(get_latest_model_async(model_recipe_query=model_recipe_query, model_stream_query=model_stream_query))


async def update_or_create_recipe_async(model_recipe_query: Dict[str, object],
                                        name: str,
                                        descr: str = None,
                                        fixings_slugs: List[int] = None,
                                        fixings_requirements: List[Dict[str, object]] = None,
                                        market_data_stream_slugs: List[int] = None,
                                        market_data_requirements: List[Dict[str, object]] = None,
                                        model_fragment_slugs: List[int] = None,
                                        max_snapshot_age: int = 365,
                                        max_index_past_days: int = 10_000):
    """ Update individual fields in the model recipe or create new recipe with given fields """
    try:
        recipe = await get_one_async(endpoints.ModelRecipe, query={**model_recipe_query, "include_f3ml": "false"})
    except F3ObjectNotFoundError:
        recipe = {"name": name, "description": f"{name}_description"}
    if descr:
        recipe["description"] = descr
    if fixings_slugs is not None:
        recipe["fixings_requirements"] = [{"index_fixings_slug": str(f),
                                           "max_past_days": str(max_index_past_days)} for f in fixings_slugs]
    if fixings_requirements:
        recipe["fixings_requirements"] = fixings_requirements
    if market_data_stream_slugs:
        recipe["market_data_requirements"] = [
            {"market_data_stream_slug": str(m), "max_snapshot_age": str(max_snapshot_age)} for m in
            market_data_stream_slugs]
    if market_data_requirements:
        recipe["market_data_requirements"] = market_data_requirements
    if model_fragment_slugs:
        recipe["model_fragment_slugs"] = [str(m) for m in model_fragment_slugs]
    return await update_or_create_async(endpoints.ModelRecipe, name, new_obj=recipe)


async def run_recipe_async(model_recipe_query: Dict[str, object],
                           model_stream_slug: int = None,
                           timestamp: Optional[datetime] = None,
                           ref_date: Optional[datetime] = None):
    """ Create a new model snapshot from recipe """
    f3 = firm_f3.f3client.get_platform_client()
    model_recipe = await get_one_async(endpoints.ModelRecipe, query={**model_recipe_query, "include_f3ml": "false"})
    ref_date = ref_date or datetime.today()
    timestamp = timestamp or datetime.utcnow()
    new_snapshot = {"format": "model_recipe",
                    "model_recipe_slug": model_recipe["slug"],
                    "model_stream_slug": model_stream_slug,
                    "valuation_date": ref_date.date().isoformat(),
                    "ordering_timepoint": timestamp}
    model_snapshot = await f3.Platform.Object.post(endpoints.ModelSnapshot, new_snapshot)
    model_snapshot_slug = model_snapshot.get("slug")
    if model_snapshot_slug is None:
        errors = '\n'.join(f"{e['message']} ({e['source']})" for e in model_snapshot['errors'])
        raise Exception(errors)
    model = await f3.Platform.Object.Get("Model", str(model_snapshot_slug))
    return model


def run_recipe_from_stream(
        model_stream_query: Dict[str, Any],
        timestamp: Optional[datetime] = None,
        ref_date: Optional[datetime] = None,
) -> F3Object:
    return wait(run_recipe_from_stream_async(
        model_stream_query=model_stream_query,
        timestamp=timestamp,
        ref_date=ref_date))


async def run_recipe_from_stream_async(
        model_stream_query: Dict[str, Any],
        timestamp: Optional[datetime] = None,
        ref_date: Optional[datetime] = None,
) -> F3Object:
    """ Create a new model snapshot from stream """
    model_stream = await get_one_async(endpoints.ModelStream, query={**model_stream_query, "include_f3ml": "false"})
    model = await run_recipe_async(model_recipe_query={"slug": model_stream["model_recipe_slug"]},
                                   model_stream_slug=model_stream["slug"], timestamp=timestamp, ref_date=ref_date)
    return model

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\risk_model.py
----------------------------------------
import asyncio
from datetime import datetime
import logging
from typing import Union

from f3sdk.f3 import F3Object  # type: ignore
from f3sdk.lib.coroutine import wait  # type: ignore

import firm_f3.f3client  # type:ignore
from firm_f3.core.error import F3ObjectNotFoundError
from firm_f3.core.modelutils import get_model_by_ref_async, get_slug_from_model, get_model_by_slug_async
from firm_f3.core.orm import ModelStream, ModelSnapshot
from firm_f3.derived_data import derive_all_f3data_async
from firm_f3.evaluate import valuation_date_async, extract_market_data_async, market_data_fixings_handler
from firm_f3.mapping.platform import PLATFORM_INDEX_CURVE, initiate_platform_objects_async
from firm_f3.model_fragments.risk_model_fragment import assemble_risk_model_fragments_async
from firm_f3.model_object.util import extend_model_with_fixings
from firm_f3.recipe import get_latest_model

logger = logging.getLogger(__name__)


async def run_risk_model_async(
        ref: str = 'prd',
        stream_type: str = 'intraday',
        return_slug: bool = False,
        f3model: F3Object = None,
        save_model: bool = False,
        fx_points_model: bool = False,
) -> Union[F3Object, int]:
    tail = ref
    if stream_type:
        tail += f'_{stream_type}'
    if fx_points_model:
        stream_name = f'FxRisk_ModelStream_{tail}'
    else:
        stream_name = f'Risk_ModelStream_{tail}'

    if f3model is None:
        f3model = await get_model_by_ref_async(ref, stream_type)
    fixing_data_raw, val_date, _ = await asyncio.gather(
        extract_market_data_async(f3model),
        valuation_date_async(f3model),
        initiate_platform_objects_async(),
    )

    f3 = firm_f3.f3client.get_platform_client()
    market_data, model = await asyncio.gather(
        derive_all_f3data_async(eval_date=val_date, f3model=f3model, fx_points_model=fx_points_model),
        assemble_risk_model_fragments_async(f3.CreateEmptyModel(BaseDate=val_date), fx_points_model=fx_points_model),
    )
    model = f3.ExtendModelWithAllMarketDataFromModel(
        BaseModel=model,
        SourceModel=f3model,
    )
    model = f3.ExtendModelWithMarketData(
        BaseModel=model,
        MarketData=f3.CombineMarketDataSets(InputMarketDataSets=market_data),
    )

    fixings = market_data_fixings_handler(fixing_data_raw)
    fixings = fixings.loc[fixings.index.date < val_date]  # exclude fixing on valuation date
    fixings.columns = [PLATFORM_INDEX_CURVE[i] for i in fixings.columns]
    model = extend_model_with_fixings(model, fixings)

    if save_model:
        logger.debug('saving model to F3 platform')
        try:
            stream = await ModelStream.get_one_async(name=stream_name)
        except F3ObjectNotFoundError:
            stream = await ModelStream(name=stream_name).save_async()
        snap = await ModelSnapshot(
            name=stream.name,
            model_stream_slug=stream.slug,
            valuation_date=val_date,
            input_f3ml=model
        ).save_async()
        model = await get_model_by_slug_async(snap.slug)
        logger.debug('saved model to F3 platform')

    if return_slug:
        # jchi@201907
        # return slug of the model snapshot
        return get_slug_from_model(model)
    return model


def run_risk_model(
        ref: str = 'prd',
        stream_type: str = 'intraday',
        return_slug: bool = False,
        f3model: F3Object = None,
        save_model: bool = False,
        fx_points_model: bool = False,
) -> Union[F3Object, int]:
    return wait(run_risk_model_async(ref=ref, stream_type=stream_type, return_slug=return_slug,
                                     f3model=f3model, save_model=save_model, fx_points_model=fx_points_model))


def get_risk_model_by_ref(ref: str = "prd", stream_type: str = 'intraday') -> F3Object:
    name = f'Risk_ModelStream_{ref}'
    if stream_type:
        name += f'_{stream_type}'
    return get_latest_model(model_stream_query={'name': name})


def get_risk_model_by_slug(slug: int) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    return wait(f3.Platform.Object.Get("Model", str(slug)))


def get_risk_model(ref: Union[int, str] = "prd", stream_type: str = 'intraday') -> F3Object:
    if isinstance(ref, int):
        return get_risk_model_by_slug(ref)
    return get_risk_model_by_ref(ref=ref, stream_type=stream_type)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\staticdata.py
----------------------------------------
import logging
import os
import unittest
from datetime import date
from typing import Dict, Any, List

from firm_domain import (
    Ccy, Tenor, Swaption, Rate, FRA, XccyBasis, TenorBasis, FXOption, OptionStrat, IRS, FXForward, OIS,
    IMMFRA, CCSSwaption, Conventions, Security, CrossCurrencySwap
)
from f3sdk.f3 import F3Object  # type:ignore
from f3sdk.lib.coroutine import wait

import firm_f3.f3client  # type:ignore
from firm_f3 import fincadutil as fu
from firm_f3.core import endpoints
from firm_f3.core.crud import update, get_one
from firm_f3.mapping import f3_bond_settlement_convention, f3_bond_type
from firm_f3.mapping import (
    f3instrument_type, ccy_to_collateral, ccy_to_f3pair, F3_CONVENTION_BY_OIS_INSTRUMENT_TYPE,
    f3index, F3_XCCY_BASIS_CONVENTIONS, F3_CCS_CONVENTIONS, f3quote_spec_by_tenor, get_ccs_index_name,
    get_ccs_pvbp_index_name, F3_INSTRUMENT_BY_FX_FWD_OUTRIGHT, F3_CONVENTION_BY_IRS_INSTRUMENT_TYPE,
    f3_security_entity, f3_security_index
)
from firm_f3.mapping.scenario import f3scenario_single
from firm_f3.model_fragments.model_eur import MultiCurveFragmentEur
from firm_f3.model_fragments.model_gbp import MultiCurveFragmentGbp
from firm_f3.model_fragments.model_usd import MultiCurveFragmentUsd
from firm_f3.modelconfig import FX_OPTION_CCY, CCS_SWAPTION_TENORS, CCS_SWAPTION_CCY, get_curve_ins
from firm_f3.util.f3ml import F3mlSpy, to_f3ml

logger = logging.getLogger(__name__)


def assemble_staticdata() -> str:
    staticdata = [
        to_f3ml(create_holiday_conventions()),
        to_f3ml(create_market_conventions()),
        to_f3ml(create_zar_related_static_data()),
        to_f3ml(create_ils_related_static_data()),
        to_f3ml(create_sgd_related_static_data()),
        to_f3ml(create_hkd_related_static_data()),
        to_f3ml(create_huf_related_static_data()),
        to_f3ml(create_pln_related_static_data()),
        to_f3ml(create_nok_related_static_data()),
        to_f3ml(create_sar_related_static_data()),
        to_f3ml(create_twd_related_static_data()),
        to_f3ml(create_nto_related_static_data()),
        to_f3ml(create_ccs_cals()),
        to_f3ml(create_fx_indices()),
        to_f3ml(create_rate_indices()),
        to_f3ml(create_compounded_rate_indices()),
        to_f3ml(create_val_specs()),
        to_f3ml(create_xccy_ins_types()),
        to_f3ml(create_ois_ins_types()),
        to_f3ml(create_tenor_basis_ins_types()),
        to_f3ml(create_fra_ins_types()),
        to_f3ml(create_fx_fwd_ins_types()),
        to_f3ml(create_fx_fwd_outright_ins_types()),
        to_f3ml(create_fx_option_ins_types()),
        to_f3ml(create_swaption_ins_types()),
        to_f3ml(create_ccs_ins_types()),
        to_f3ml(create_val_spec_builders()),
        to_f3ml(create_vield_calculators()),
        to_f3ml(create_settlement_market_convention()),
        to_f3ml(create_bond_types()),
        to_f3ml(create_interpolation_methods()),
        to_f3ml(create_root_finders_by_ccy()),
        to_f3ml(create_calibration_optimizer()),
        to_f3ml(MultiCurveFragmentEur().create_static_data()),
        to_f3ml(MultiCurveFragmentUsd().create_static_data()),
        to_f3ml(MultiCurveFragmentGbp().create_static_data()),
        to_f3ml(create_other_cash_depo_inst_types()),
        to_f3ml(create_scenarios()),
        to_f3ml(create_meeting_dates()),
        to_f3ml(create_future_instrument_types()),
        to_f3ml(create_ccs_swaption_static_data()),
        to_f3ml(create_securities_static_data()),
        to_f3ml(create_bond_types_static_data()),
    ]

    return "".join(staticdata)


class check_staticdata:
    prev_sed: str
    curr_sed: str
    version_number: int
    modified: str
    outdir: str

    def __init__(self, write_to_file: bool = True):
        res = get_one(endpoints.SystemEnvironmentData)
        self.prev_sed = res['definition']
        self.curr_sed = assemble_staticdata()
        self.version_number = int(res['version_number'])
        self.modified = res['modified']
        self.outdir = os.path.abspath('./tmp')
        if write_to_file:
            F3mlSpy(self.prev_sed).write_to_file(os.path.join(self.outdir, 'sed_old.py'))
            F3mlSpy(self.curr_sed).write_to_file(os.path.join(self.outdir, 'sed_new.py'))


def update_staticdata(create_first_version: bool = False):
    f3 = firm_f3.f3client.get_platform_client()
    from colorama import Fore  # type: ignore
    check = None
    if not create_first_version:
        check = check_staticdata()  # generates files which has to be checked

        print("SED currently present on the platform:")
        print("F3 conn  " + Fore.GREEN + os.environ.get("FINCAD_PYTHONSDK_YAML_CONFIG_FILE"))
        print("Version  " + Fore.GREEN + str(check.version_number))
        print("Modified " + Fore.GREEN + check.modified)
        print("Output   " + Fore.GREEN + check.outdir)
        approved = input(
            'Please check the difference between sed_old.py vs sed_new.py in directory. Approve ? (yes/no)')
        if approved != 'yes':
            logger.info('Aborted')
            return

        sed = {"format": 'f3ml', "definition": check.curr_sed}
        update(endpoints.SystemEnvironmentData, new_obj=sed)
    else:
        sed = {"format": 'f3ml', "definition": assemble_staticdata()}
        wait(f3.Platform.Object.post('system_environment_data', json_obj=sed))

    logger.info("system_environment_data updated")


def create_holiday_conventions() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()

    def unpack():
        yield f3.CreateCompositeHolidayConvention(
            HolidayConventions=['Mumbai', date(2019, 10, 21)]
        ).named('MumbaiAdjusted')

        yield f3.CreateBusinessDaysMarketConvention(
            UnderlyingConventions=f3.CreateSettlementMarketConvention(
                PaymentHolidays='MumbaiAdjusted',
                MaturityCalculator='MumbaiFoll',
                SettlementMaturityDescriptor='0b',
                SettlementMaturityCalculator='MumbaiFoll',
            ),
            DayCountConvention='act/365f',
        ).named('MumbaiAdjustedDaily')

    return list(unpack())


def create_fx_fwd_ins_types() -> Dict[str, object]:
    f3 = firm_f3.f3client.get_platform_client()
    fx_fwd_settle_conv = create_settle_conv()
    fx_fwd_inst_types = {
        'KRW': f3.CreateVanillaFXNonDeliverableForwardInstrumentType(
            fx_fwd_settle_conv['KRW'], fu.ccy_to_f3pair(Ccy.KRW), 'ForwardPointsAtPremium').named('KRW_NDF_Inst_Type'),
        'PHP': f3.CreateVanillaFXNonDeliverableForwardInstrumentType(
            fx_fwd_settle_conv['PHP'], fu.ccy_to_f3pair(Ccy.PHP), 'ForwardPointsAtPremium').named('PHP_NDF_Inst_Type'),
        'INR': f3.CreateVanillaFXNonDeliverableForwardInstrumentType(
            fx_fwd_settle_conv['INR'], fu.ccy_to_f3pair(Ccy.INR), 'ForwardPointsAtPremium').named('INR_NDF_Inst_Type'),
        'INO': f3.CreateVanillaFXNonDeliverableForwardInstrumentType(
            fx_fwd_settle_conv['INO'], fu.ccy_to_f3pair(Ccy.INO), 'ForwardPointsAtPremium').named('INO_NDF_Inst_Type'),
        'CNY': f3.CreateVanillaFXNonDeliverableForwardInstrumentType(
            fx_fwd_settle_conv['CNY'], fu.ccy_to_f3pair(Ccy.CNY), 'ForwardPointsAtPremium').named('CNY_NDF_Inst_Type'),
        'MYR': f3.CreateVanillaFXNonDeliverableForwardInstrumentType(
            fx_fwd_settle_conv['MYR'], fu.ccy_to_f3pair(Ccy.MYR), 'ForwardPointsAtPremium').named('MYR_NDF_Inst_Type'),
        'CNH': f3.CreateVanillaFXForwardInstrumentType(
            'USDCNH', fu.ccy_to_f3pair(Ccy.CNH), 'ForwardPointsAtPremium').named('CNH_FX_Inst_Type'),
        'SEK': f3.CreateVanillaFXForwardInstrumentType(
            'USDSEK', fu.ccy_to_f3pair(Ccy.SEK), 'ForwardPointsAtPremium').named('SEK_FX_Inst_Type'),
        'RUB': f3.CreateVanillaFXForwardInstrumentType(
            'USDRUB', fu.ccy_to_f3pair(Ccy.RUB), 'ForwardPointsAtPremium').named('RUB_FX_Inst_Type'),
        # 'ILS': f3.CreateVanillaFXForwardInstrumentType(
        #     fx_fwd_settle_conv['ILS'], fu.ccy_to_f3pair(Ccy.ILS), 'ForwardPointsAtPremium').named('ILS_FX_Inst_Type'),
        'PLN': f3.CreateVanillaFXForwardInstrumentType(
            'EURPLN', fu.ccy_to_f3pair(Ccy.PLN), 'ForwardPointsAtPremium').named('PLN_FX_Inst_Type'),
        'USDPLN': f3.CreateVanillaFXForwardInstrumentType(
            'USDPLN', 'USDPLN', 'ForwardPointsAtPremium').named('USDPLN_FX_Inst_Type'),
        'HUF': f3.CreateVanillaFXForwardInstrumentType(
            fx_fwd_settle_conv['HUF'], fu.ccy_to_f3pair(Ccy.HUF), 'ForwardPointsAtPremium').named('HUF_FX_Inst_Type'),
        'IDR': f3.CreateVanillaFXNonDeliverableForwardInstrumentType(
            fx_fwd_settle_conv['IDR'], fu.ccy_to_f3pair(Ccy.IDR), 'ForwardPointsAtPremium').named('IDR_NDF_Inst_Type'),
        'THB': f3.CreateVanillaFXForwardInstrumentType(
            fx_fwd_settle_conv['THB'], fu.ccy_to_f3pair(Ccy.THB), 'ForwardPointsAtPremium').named('THB_FX_Inst_Type'),
        'MXN': f3.CreateVanillaFXForwardInstrumentType(
            'USDMXN', fu.ccy_to_f3pair(Ccy.MXN), 'ForwardPointsAtPremium').named('MXN_FX_Inst_Type'),
        'TRY': f3.CreateVanillaFXForwardInstrumentType(
            'USDTRY', fu.ccy_to_f3pair(Ccy.TRY), 'ForwardPointsAtPremium').named('TRY_FX_Inst_Type'),
    }

    return fx_fwd_inst_types


def create_fx_fwd_outright_ins_types() -> List[F3Object]:
    def unpack():
        f3 = firm_f3.f3client.get_platform_client()
        for (left, right), inst_type in F3_INSTRUMENT_BY_FX_FWD_OUTRIGHT.items():
            f3idx = f3index(FXForward(ccy_base=left, ccy=right, tenor=Tenor.SPOT))
            if Conventions.trades_as_ndf(left) or Conventions.trades_as_ndf(right):
                yield f3.CreateVanillaFXNonDeliverableForwardInstrumentType(
                    MarketConventions=f3idx,
                    FXRateIndex=f3idx,
                    FXFwdQuoteConvention='FXForwardRate'
                ).named(inst_type)
            else:
                yield f3.CreateVanillaFXForwardInstrumentType(
                    MarketConventions=f3idx,
                    FXRateIndex=f3idx,
                    FXFwdQuoteConvention='FXForwardRate'
                ).named(inst_type)

    return list(unpack())


def create_fx_option_ins_types() -> Dict[str, object]:
    f3 = firm_f3.f3client.get_platform_client()
    option_strat_list = [OptionStrat.STRAD, OptionStrat.RR, OptionStrat.FLY]

    def create_ins(ins: FXOption):
        pair = str(ins.ccy_base) + str(ins.ccy)
        if ins.strat_type == OptionStrat.STRAD:
            return f3.CreateATMStraddleInstrumentType(UnderlyingIndex=pair,
                                                      ATMType='DeltaParity',
                                                      DeltaConvention='ForwardPremiumDelta')
        elif ins.strat_type == OptionStrat.RR:
            return f3.CreateRiskReversalInstrumentType(UnderlyingIndex=pair,
                                                       Delta=0.25,
                                                       DeltaConvention='ForwardPremiumDelta',
                                                       RiskReversalType='Market')
        elif ins.strat_type == OptionStrat.FLY:
            return f3.CreateButterflyInstrumentType(UnderlyingIndex=pair,
                                                    Delta=0.25,
                                                    DeltaConvention='ForwardPremiumDelta',
                                                    StrangleType='Market')
        else:
            raise ValueError('Unknown Option Strategy')

    fx_opt_ins = [FXOption(c, Tenor.T_3M, ot) for c in FX_OPTION_CCY for ot in option_strat_list]

    return {str(i): create_ins(i).named(fu.get_instrument_type(i)) for i in fx_opt_ins}


def create_fra_ins_types() -> Dict[str, object]:
    f3 = firm_f3.f3client.get_platform_client()
    settle_conv = create_settle_conv()
    fra_inst_types = {
        'NZD': f3.CreateFRAInstrumentType(settle_conv['NZD'], f3index(Rate(Ccy.NZD, Tenor.T_3M))),
        'SGD': f3.CreateFRAInstrumentType(settle_conv['SGD'], f3index(Rate(Ccy.SGD, Tenor.T_6M))),
        'HKD': f3.CreateFRAInstrumentType(settle_conv['HKD'], f3index(Rate(Ccy.HKD, Tenor.T_1M))),
        'KRW': f3.CreateFRAInstrumentType(settle_conv['KRW'], f3index(Rate(Ccy.KRW, Tenor.T_3M))),
        'SEK': f3.CreateFRAInstrumentType(settle_conv['SEK'], f3index(Rate(Ccy.SEK, Tenor.T_3M))),
        'MYR': f3.CreateFRAInstrumentType(settle_conv['MYR'], f3index(Rate(Ccy.MYR, Tenor.T_3M))),
        'THB': f3.CreateFRAInstrumentType(settle_conv['THB'], f3index(Rate(Ccy.THB, Tenor.T_6M))),
    }
    collateralized = {
        'NZD': f3.CreateCollateralizedInstrumentType(fra_inst_types['NZD'], ccy_to_collateral(Ccy.NZD)),
        'SEK': f3.CreateCollateralizedInstrumentType(fra_inst_types['SEK'], ccy_to_collateral(Ccy.SEK)),
        'SGD': fra_inst_types['SGD'],
        'HKD': fra_inst_types['HKD'],
        'KRW': fra_inst_types['KRW'],
        'MYR': fra_inst_types['MYR'],
        'THB': fra_inst_types['THB'],
    }
    named = {
        'NZD': collateralized['NZD'].named(fu.get_instrument_type(FRA(Ccy.NZD, Tenor.T_3M, Tenor.T_3M))),
        'SEK': collateralized['SEK'].named(fu.get_instrument_type(FRA(Ccy.SEK, Tenor.T_3M, Tenor.T_3M))),
        # 'SGD': collateralized['SGD'].named(fu.get_instrument_type(FRA(Ccy.SGD, Tenor.T_6M, Tenor.T_6M))),
        # 'HKD': collateralized['HKD'].named(fu.get_instrument_type(FRA(Ccy.HKD, Tenor.T_1M, Tenor.T_1M))),
        'KRW': collateralized['KRW'].named(fu.get_instrument_type(FRA(Ccy.KRW, Tenor.T_3M, Tenor.T_3M))),
        'MYR': collateralized['MYR'].named(fu.get_instrument_type(FRA(Ccy.MYR, Tenor.T_3M, Tenor.T_3M))),
        'THB': collateralized['THB'].named(fu.get_instrument_type(FRA(Ccy.THB, Tenor.T_6M, Tenor.T_6M))),
    }

    return named


def create_tenor_basis_ins_types() -> Dict[str, object]:
    f3 = firm_f3.f3client.get_platform_client()
    custom_instrument_type_tenor_basis = {
        'AUD-ois-6m': f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateRateBasisSwapInstrumentType(
                SettlementMarketConventions='SwapBBSW6mFloating',
                MarginFloatingIndex='OvernightAUDCompounded',
                OpposingFloatingIndex='BBSW6m',
                MarginLegMarketConventions='SwapBBSW6mFloating',
                OpposingLegMarketConventions='SwapBBSW6mFloating'),
            CollateralAgreement=ccy_to_collateral(Ccy.AUD)
        ).named(
            f3instrument_type(TenorBasis(Ccy.AUD, Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=Tenor.T_6M))
        ),
        'AUD-1m-6m': f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateRateBasisSwapInstrumentType(
                SettlementMarketConventions='SwapBBSW6m',
                MarginFloatingIndex='BBSW1m',
                OpposingFloatingIndex='BBSW6m',
                MarginLegMarketConventions='SwapBBSW1m',
                OpposingLegMarketConventions='SwapBBSW6m'),
            CollateralAgreement=ccy_to_collateral(Ccy.AUD)
        ).named(
            f3instrument_type(TenorBasis(Ccy.AUD, Tenor.T_5Y, idx_1=Tenor.T_1M, idx_2=Tenor.T_6M))
        ),
        'JPY-ois-6m': f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateRateBasisSwapInstrumentType(
                SettlementMarketConventions='SwapJPY6m',
                MarginFloatingIndex='OvernightJPYCompounded',
                OpposingFloatingIndex='LiborJPY6m',
                MarginLegMarketConventions='SwapJPY6m',
                OpposingLegMarketConventions='SwapJPY6m'),
            CollateralAgreement=ccy_to_collateral(Ccy.JPY)
        ).named(
            f3instrument_type(TenorBasis(Ccy.JPY, Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=Tenor.T_6M))
        ),
        'NZD-ois-3m': f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateRateBasisSwapInstrumentType(
                SettlementMarketConventions='SwapBKBM3m',
                MarginFloatingIndex='NZOCRCompounded',
                OpposingFloatingIndex='BKBM3m',
                MarginLegMarketConventions='SwapBKBM3m',
                OpposingLegMarketConventions='SwapBKBM3m'),
            CollateralAgreement=ccy_to_collateral(Ccy.NZD)
        ).named(
            f3instrument_type(TenorBasis(Ccy.NZD, Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=Tenor.T_3M))
        ),
        'SEK-ois-3m': f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateRateBasisSwapInstrumentType(
                SettlementMarketConventions='SwapSEK3m',
                MarginFloatingIndex='SIORCompounded',
                OpposingFloatingIndex='Stibor3m',
                MarginLegMarketConventions='SwapSEK3m',
                OpposingLegMarketConventions='SwapSEK3m'),
            CollateralAgreement=ccy_to_collateral(Ccy.SEK)
        ).named(
            f3instrument_type(TenorBasis(Ccy.SEK, Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=Tenor.T_3M))
        ),
        'CHF-ois-6m': f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateRateBasisSwapInstrumentType(
                SettlementMarketConventions='SwapCHF6m',
                MarginFloatingIndex='OvernightCHFCompounded',
                OpposingFloatingIndex='LiborCHF6m',
                MarginLegMarketConventions='SwapCHF6m',
                OpposingLegMarketConventions='SwapCHF6m'),
            CollateralAgreement=ccy_to_collateral(Ccy.CHF)
        ).named(
            f3instrument_type(TenorBasis(Ccy.CHF, Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=Tenor.T_6M))
        ),
    }

    return custom_instrument_type_tenor_basis


def create_ccs_cals() -> Dict[Ccy, object]:
    f3 = firm_f3.f3client.get_platform_client()
    cals = {
        Ccy.INR: f3.CreateCompositeHolidayConvention(['MumbaiAdjusted', 'NewYork', 'London']).named(
            fu.ccy_to_ccs_cal(Ccy.INR))}
    return cals


def create_fx_indices() -> Dict[str, Any]:
    f3 = firm_f3.f3client.get_platform_client()
    fx_fwd_settle_conv = create_settle_conv()
    fx_rate_index = {'USDPHP': f3.CreateFXRateIndex('USD', 'PHP', fx_fwd_settle_conv['PHP']).named('USDPHP'),
                     'PHPUSD': f3.CreateFXRateIndex('PHP', 'USD', fx_fwd_settle_conv['PHP']).named('PHPUSD'),
                     'USDINR': f3.CreateFXRateIndex('USD', 'INR', fx_fwd_settle_conv['INR']).named('USDINR'),
                     'USDINO': f3.CreateFXRateIndex('USD', 'INO', fx_fwd_settle_conv['INO']).named('USDINO'),
                     'INRUSD': f3.CreateFXRateIndex('INR', 'USD', fx_fwd_settle_conv['INR']).named('INRUSD'),
                     'INOUSD': f3.CreateFXRateIndex('INO', 'USD', fx_fwd_settle_conv['INO']).named('INOUSD'),
                     'USDCNY': f3.CreateFXRateIndex('USD', 'CNY', fx_fwd_settle_conv['CNY']).named('USDCNY'),
                     'USDMYR': f3.CreateFXRateIndex('USD', 'MYR', fx_fwd_settle_conv['MYR']).named('USDMYR'),
                     'CNYUSD': f3.CreateFXRateIndex('CNY', 'USD', fx_fwd_settle_conv['CNY']).named('CNYUSD'),
                     'USDIDR': f3.CreateFXRateIndex('USD', 'IDR', fx_fwd_settle_conv['IDR']).named('USDIDR'),
                     'IDRUSD': f3.CreateFXRateIndex('IDR', 'USD', fx_fwd_settle_conv['IDR']).named('IDRUSD'),
                     'EURHUF': f3.CreateFXRateIndex('EUR', 'HUF', fx_fwd_settle_conv['HUF']).named('EURHUF'),
                     'HUFEUR': f3.CreateFXRateIndex('HUF', 'EUR', fx_fwd_settle_conv['HUF']).named('HUFEUR'),
                     # 'USDILS': f3.CreateFXRateIndex('USD', 'ILS', fx_fwd_settle_conv['ILS']).named('USDILS'),
                     # 'ILSUSD': f3.CreateFXRateIndex('ILS', 'USD', fx_fwd_settle_conv['ILS']).named('ILSUSD'),
                     'USDTHB': f3.CreateFXRateIndex('USD', 'THB', fx_fwd_settle_conv['THB']).named('USDTHB'),
                     'THBUSD': f3.CreateFXRateIndex('THB', 'USD', fx_fwd_settle_conv['THB']).named('THBUSD')}
    return fx_rate_index


def create_rate_indices() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()
    rate_index = [f3.CreateOvernightRateIndex(
        Currency=fu.ccy_to_f3ccy(Ccy.INO),
        MarketConventions='MumbaiAdjustedDaily',
        FixingReferencer=['StartOffset', 'MumbaiAdjustedDaily', 'MumbaiAdjusted']
    ).named(f3index(Rate(Ccy.INO, Tenor.T_1D)))]
    return rate_index


def create_compounded_rate_indices() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()

    def unpack():
        yield f3.CreateCompoundingRateIndex(
            UnderlyingRateIndex=f3index(Rate(Ccy.CAD, Tenor.T_3M)),
            FixingReferencer='UnmodifiedStartEndDatePair',
            MarketConventions='SwapCDOR3m'
        ).named(f3index(Rate(Ccy.CAD, Tenor.T_3M), is_compounded=True))

        yield f3.CreateCompoundingRateIndex(
            UnderlyingRateIndex=f3index(Rate(Ccy.CNY, Tenor.T_1W)),
            FixingReferencer='UnmodifiedStartEndDatePair',
            MarketConventions='SwapCNYQuarterly'
        ).named(f3index(Rate(Ccy.CNY, Tenor.T_1W), is_compounded=True))

        yield f3.CreateCompoundingRateIndex(
            UnderlyingRateIndex=f3index(Rate(Ccy.INO, Tenor.T_1D)),
            FixingReferencer='UnmodifiedStartEndDatePair',
            MarketConventions='MumbaiAdjustedDaily'
        ).named(f3index(Rate(Ccy.INO, Tenor.T_1D), is_compounded=True))

        yield f3.CreateCompoundingRateIndex(
            UnderlyingRateIndex=f3index(Rate(Ccy.USD, Tenor.T_1M)),
            FixingReferencer='UnmodifiedStartEndDatePair',
            MarketConventions='SwapUSD1m'
        ).named(f3index(Rate(Ccy.USD, Tenor.T_1M), is_compounded=True))

        yield f3.CreateCompoundingRateIndex(
            UnderlyingRateIndex=f3index(Rate(Ccy.USD, Tenor.T_3M)),
            FixingReferencer='UnmodifiedStartEndDatePair',
            MarketConventions='SwapUSD3m'
        ).named(f3index(Rate(Ccy.USD, Tenor.T_3M), is_compounded=True))

    return list(unpack())


def create_val_specs() -> Dict[str, Any]:
    f3 = firm_f3.f3client.get_platform_client()
    val_specs = {
        'USD': f3.CreateNumeraireCurrencyValuationSpecification('Default', 'USD').named('DefaultUSD2'),
        'PHP': f3.CreateNumeraireCurrencyValuationSpecification('Default', 'PHP').named('DefaultPHP'),
        'INR': f3.CreateNumeraireCurrencyValuationSpecification('Default', 'INR').named('DefaultINR'),
        'INO': f3.CreateNumeraireCurrencyValuationSpecification('Default', 'INO').named('DefaultINO'),
        'CNY': f3.CreateNumeraireCurrencyValuationSpecification('Default', 'CNY').named('DefaultCNY'),
        'THB': f3.CreateNumeraireCurrencyValuationSpecification('Default', 'THB').named('DefaultTHB'),
        'IDR': f3.CreateNumeraireCurrencyValuationSpecification('Default', 'IDR').named('DefaultIDR'),
        'MYR': f3.CreateNumeraireCurrencyValuationSpecification('Default', 'MYR').named('DefaultMYR'),
        'SAR': f3.CreateNumeraireCurrencyValuationSpecification('Default', 'SAR').named('DefaultSAR'),
        'NoFixings': f3.CreateFixingsRequirementValuationSpecification('Default', False, True).named('DefaultIgnoreFix')
    }
    return val_specs


def create_swaption_ins_types() -> Dict[str, object]:
    f3 = firm_f3.f3client.get_platform_client()
    aud_3m_swaption = Swaption(Ccy.AUD, Tenor.T_1Y, Tenor.T_1Y)
    aud_6m_swaption = Swaption(Ccy.AUD, Tenor.T_5Y, Tenor.T_5Y)

    aud_3m_inst_type = fu.get_instrument_type(aud_3m_swaption.get_swap())
    aud_6m_inst_type = fu.get_instrument_type(aud_6m_swaption.get_swap())

    return {'AUD_3M': f3.CreateSwaptionInstrumentType(*fu.instrument_type_to_conventions(aud_3m_inst_type)).named(
        fu.get_instrument_type(aud_3m_swaption)),
        'AUD_6M': f3.CreateSwaptionInstrumentType(*fu.instrument_type_to_conventions(aud_6m_inst_type)).named(
            fu.get_instrument_type(aud_6m_swaption))}


def create_market_conventions() -> Dict[str, object]:
    f3 = firm_f3.f3client.get_platform_client()

    ccy_holidays = {
        Ccy.HKD: ['HongKong'],
        Ccy.RUB: ['Moscow', 'NewYork', 'London'],
        Ccy.TRY: ['Istanbul', 'NewYork', 'London'],
        Ccy.KRW: ['Seoul', 'NewYork', 'London'],
        Ccy.INR: ['Mumbai', 'NewYork', 'London'],
    }

    market_conventions = {
        'SwapHKD1m': create_swap_leg_conventions(ccy_holidays[Ccy.HKD], 'act/365f', 1, smd='0b'),
        'SwapRUBUSDAnn-act/act': create_swap_leg_conventions(ccy_holidays[Ccy.RUB], 'act/actISDA', 12),
        'SwapTRYUSDAnn-act/360': create_swap_leg_conventions(ccy_holidays[Ccy.TRY], 'act/360', 12),
        'SwapKRWUSD6mFloating': create_swap_leg_conventions(ccy_holidays[Ccy.KRW], 'act/360', 6),
        'OISINRSemi': f3.CreateModifiedPaymentScheduleMarketConvention(
            UnderlyingConventions='SwapINRSemi',
            PaymentModifier=f3.CreateMoveDaysDateModifier(
                NumberOfDays=0,
                HolidayConventions='MumbaiAdjusted'
            )
        ),
        'OISINRAnnual': f3.CreateModifiedPaymentScheduleMarketConvention(
            UnderlyingConventions='SwapINRAnnual',
            PaymentModifier=f3.CreateMoveDaysDateModifier(
                NumberOfDays=0,
                HolidayConventions='MumbaiAdjusted'
            )
        ),
        'SwapINRUSD6m-act/365f': create_swap_leg_conventions(ccy_holidays[Ccy.INR], 'act/365f', 6),
    }

    return {k: v.named(k) for k, v in market_conventions.items()}


def create_ccs_ins_types() -> Dict[str, object]:
    f3 = firm_f3.f3client.get_platform_client()
    ccs = {
        'INR': f3.CreateCrossCurrencySwapInstrumentType(
            FXRateIndex=fu.ccy_to_f3pair(Ccy.INR),
            MarginLegRateIndex='ZeroConstant',
            OffsettingLegRateIndex='LiborUSD6m',
            MarketConventions='SwapINRUSD6m-act/365f',
            NotionalAdjustment=['MarginLeg', 'FrontBack'],
            OffsettingLegMarketConventions='SwapUSD6mFloating'
        ).named(fu.ccy_to_ccs_inst_type(Ccy.INR)),
        'INO': f3.CreateCrossCurrencySwapInstrumentType(
            FXRateIndex=fu.ccy_to_f3pair(Ccy.INO),
            MarginLegRateIndex='ZeroConstant',
            OffsettingLegRateIndex='LiborUSD6m',
            MarketConventions='SwapINRUSD6m-act/365f',
            NotionalAdjustment=['MarginLeg', 'FrontBack'],
            OffsettingLegMarketConventions='SwapUSD6mFloating'
        ).named(fu.ccy_to_ccs_inst_type(Ccy.INO)),
        'RUB': f3.CreateCrossCurrencySwapInstrumentType(
            FXRateIndex=fu.ccy_to_f3pair(Ccy.RUB),
            MarginLegRateIndex='ZeroConstant',
            OffsettingLegRateIndex='LiborUSD3m',
            MarketConventions=create_swap_leg_conventions(['NewYork', 'London', 'Moscow'], 'act/actISDA', 12),
            # 'SwapRUBAnnualFixed',
            NotionalAdjustment=['MarginLeg', 'FrontBack'],
            OffsettingLegMarketConventions='SwapRUBUSD3m-act/360'
        ).named(fu.ccy_to_ccs_inst_type(Ccy.RUB)),
        'CNH': f3.CreateCrossCurrencySwapInstrumentType(
            FXRateIndex=fu.ccy_to_f3pair(Ccy.CNH),
            MarginLegRateIndex='ZeroConstant',
            OffsettingLegRateIndex='LiborUSD3m',
            MarketConventions='SwapCNHUSD3m-act/360',
            NotionalAdjustment=['MarginLeg', 'FrontBack'],
            OffsettingLegMarketConventions='SwapCNHUSD3m-act/360'
        ).named(fu.ccy_to_ccs_inst_type(Ccy.CNH)),
        'TRY': f3.CreateCrossCurrencySwapInstrumentType(
            FXRateIndex=fu.ccy_to_f3pair(Ccy.TRY),
            MarginLegRateIndex='ZeroConstant',
            OffsettingLegRateIndex='LiborUSD3m',
            MarketConventions=create_swap_leg_conventions(['NewYork', 'London', 'Istanbul'], 'act/360', 12),
            NotionalAdjustment=['MarginLeg', 'FrontBack'],
            OffsettingLegMarketConventions='SwapTRYUSD3m-act/360'
        ).named(fu.ccy_to_ccs_inst_type(Ccy.TRY)),
    }
    return ccs


def create_xccy_ins_types() -> Dict[Ccy, object]:
    f3 = firm_f3.f3client.get_platform_client()
    custom_instrument_type_xccy = {
        Ccy.SEK: f3.CreateCrossCurrencySwapInstrumentType(
            FXRateIndex=ccy_to_f3pair(Ccy.SEK),
            MarginLegRateIndex=f3index(Rate(Ccy.SEK, Tenor.T_3M)),
            OffsettingLegRateIndex=f3index(Rate(Ccy.USD, Tenor.T_3M)),
            MarketConventions='SwapSEK3mFloating',
            NotionalAdjustment=['OffsettingLeg', 'MarkToMarket'],
            OffsettingLegMarketConventions='SwapUSD3mFloating'
        ),
        Ccy.PLN: f3.CreateCrossCurrencySwapInstrumentType(
            FXRateIndex=ccy_to_f3pair(Ccy.PLN),
            MarginLegRateIndex=f3index(Rate(Ccy.PLN, Tenor.T_3M)),
            OffsettingLegRateIndex=f3index(Rate(Ccy.EUR, Tenor.T_3M)),
            MarketConventions='SwapPLN3mFloating',
            NotionalAdjustment=['OffsettingLeg', 'MarkToMarket'],
            OffsettingLegMarketConventions='SwapEUR3mFloating'
        ),
        Ccy.HUF: f3.CreateCrossCurrencySwapInstrumentType(
            FXRateIndex=ccy_to_f3pair(Ccy.HUF),
            MarginLegRateIndex=f3index(Rate(Ccy.HUF, Tenor.T_3M)),
            OffsettingLegRateIndex=f3index(Rate(Ccy.EUR, Tenor.T_3M)),
            MarketConventions='SwapHUF3mFloating',
            NotionalAdjustment=['OffsettingLeg', 'FrontBack'],
            OffsettingLegMarketConventions='SwapEUR3mFloating'
        ),
    }

    named = {ccy: v.named(fu.get_instrument_type(XccyBasis(ccy, Tenor.T_1Y)))
             for ccy, v in custom_instrument_type_xccy.items()}

    return named


def create_ois_ins_types() -> List[object]:
    f3 = firm_f3.f3client.get_platform_client()
    ccy_list = [(Ccy.INO, Tenor.T_1Y), (Ccy.INO, Tenor.T_6M)]

    ins_type = [fu.get_instrument_type(OIS(ccy, Tenor.T_1Y, fixed_freq=t)) for ccy, t in ccy_list]

    custom_instrument_type_ois = [
        f3.CreateVanillaIRSInstrumentType(
            MarketConventionsForFixedLeg=F3_CONVENTION_BY_OIS_INSTRUMENT_TYPE[it][0],
            FloatingIndex=F3_CONVENTION_BY_OIS_INSTRUMENT_TYPE[it][1],
            FloatingLegMarketConventions=F3_CONVENTION_BY_OIS_INSTRUMENT_TYPE[it][2],
        ).named(it)
        for it in ins_type
    ]

    return custom_instrument_type_ois


def create_vield_calculators() -> Dict[str, object]:
    f3 = firm_f3.f3client.get_platform_client()
    return {
        "zspread_euribor6m": f3.CreateZSpreadConvention(f3.DiscountCurveTag('EUR', 'Euribor6m')).named(
            "zspread_euribor6m")
    }


def create_settlement_market_convention() -> Dict[str, object]:
    f3 = firm_f3.f3client.get_platform_client()
    # DOC: Not complete, just added a few to get started
    return {
        "target_1d": f3.CreateSettlementMarketConvention("TARGET", "TARGETModFoll", "1d", "TARGETModFoll").named(
            "target_1d"),
        "target_7d": f3.CreateSettlementMarketConvention("TARGET", "TARGETModFoll", "1d", "TARGETModFoll").named(
            "target_7d"),
        "target_0b": f3.CreateSettlementMarketConvention("TARGET", "TARGETModFoll", "0b", "TARGETModFoll").named(
            "target_0b"),
        "target_2b": f3.CreateSettlementMarketConvention("TARGET", "TARGETModFoll", "2b", "TARGETModFoll").named(
            "target_2b"),
    }


def create_bond_types() -> Dict[str, object]:
    f3 = firm_f3.f3client.get_platform_client()
    discount_margin_yield_convention = f3.CreateDiscountMarginYieldConvention("Euribor6m",
                                                                              ["UseStubAccrualFraction", True,
                                                                               "UseStubFloatingRate", True,
                                                                               "UseSettlementNotTrade", True,
                                                                               "Index", "Euribor6m"], True)

    # Not really used, will have to review if we end up using these instruments
    ictz_ac = f3.CreateSimpleAccrualConvention("act/360", False, False, True)
    ictz_zciyc = f3.CreateZeroCouponInvestmentYieldConvention(ictz_ac)

    btps_ac = f3.CreateRatioAccrualConvention(DayCountType="NumberOfDays", RequireSettlementDateInPeriod=False,
                                              RequireTradeDateInPeriod=False, EndOnSettlementNotTrade=True)
    simplelast_yc = f3.CreateTrueYieldConvention(AccrualConvention=btps_ac, DateModifier="TARGETFoll", AccrueWholeCoupon=True,
                                           SimpleInLast=1, CompoundingFrequency="Annual")

    semiannual_cpn_msmc = f3.CreateMonthlyScheduleMarketConvention("NoScheduleNoHolidays", 6,
                                                                   "ShortStubAtStart",
                                                                   "NullModifier", "WholeMonths", False, "NullModifier")
    semiannual_cpn_nssmc = f3.CreateNotionalStubScheduleMarketConvention(semiannual_cpn_msmc, "NumberOfDays")

    annual_cpn_msmc = f3.CreateMonthlyScheduleMarketConvention("NoScheduleNoHolidays", 12,
                                                               "LongFirstCouponShortInMonth",
                                                               "NullModifier", "WholeMonths", False, "NullModifier")
    annual_cpn_nssmc = f3.CreateNotionalStubScheduleMarketConvention(annual_cpn_msmc, "NumberOfDays")

    return {
        "CCTS": f3.CreateFloatingRateNoteBondType(
            ["TradeToStartDate", "target_2b"],
            discount_margin_yield_convention,
            "ISMA-99",
            "EUR",
            semiannual_cpn_nssmc,
            "CCTS"
        ).named("CCTS"),
        "ICTZ": f3.CreateZeroCouponBondType(
            ["TradeToStartDate", "target_2b"],
            ictz_zciyc,
            None,
            "EUR",
            "ICTZ"
        ).named("ICTZ"),
        "BTPS": f3.CreateFixedCouponBondType(
            ["TradeToStartDate", "target_2b"],
            simplelast_yc,
            "ISMA-99",
            "EUR",
            semiannual_cpn_nssmc,
            None,
            "BTPS"
        ).named("BTPS"),
        "PGB": f3.CreateFixedCouponBondType(
            ["TradeToStartDate", "target_2b"],
            "ISMA-99",
            "ISMA-99",
            "EUR",
            annual_cpn_nssmc,
            None,
            "PGB"
        ).named("PGB"),
        "DBR": f3.CreateFixedCouponBondType(
            ["TradeToStartDate", "target_2b", "TradeToStartDate", "target_1d"],
            simplelast_yc,
            "ISMA-99",
            "EUR",
            annual_cpn_nssmc,
            None,
            "DBR"
        ).named("DBR"),
        "NETHER": f3.CreateFixedCouponBondType(
            ["TradeToStartDate", "target_2b"],
            "ISMA-99",
            "ISMA-99",
            "EUR",
            annual_cpn_nssmc,
            None,
            "NETHER"
        ).named("NETHER"),
        "BGB": f3.CreateFixedCouponBondType(
            ["TradeToStartDate", "target_2b"],
            "ISMA-99",
            "ISMA-99",
            "EUR",
            annual_cpn_nssmc,
            None,
            "BGB"
        ).named("BGB"),
        "IRISH": f3.CreateFixedCouponBondType(
            ["TradeToStartDate", "target_2b"],
            "ISMA-99",
            "ISMA-99",
            "EUR",
            annual_cpn_nssmc,
            None,
            "IRISH"
        ).named("IRISH"),
        "RAGB": f3.CreateFixedCouponBondType(
            ["TradeToStartDate", "target_2b"],
            "ISMA-99",
            "ISMA-99",
            "EUR",
            annual_cpn_nssmc,
            None,
            "RAGB"
        ).named("RAGB"),
        "RFGB": f3.CreateFixedCouponBondType(
            ["TradeToStartDate", "target_2b"],
            simplelast_yc,
            "ISMA-99",
            "EUR",
            annual_cpn_nssmc,
            None,
            "RFGB"
        ).named("RFGB"),
        "SLOREP": f3.CreateFixedCouponBondType(
            ["TradeToStartDate", "target_2b"],
            "ISMA-99",
            "ISMA-99",
            "EUR",
            annual_cpn_nssmc,
            None,
            "SLOREP"
        ).named("SLOREP"),
    }


def create_settle_conv() -> Dict[str, Any]:
    f3 = firm_f3.f3client.get_platform_client()
    fx_fwd_maturity_calc = {'KRW': f3.CreateSimpleMaturityCalculator(['KoreaExchange'], 'PreserveLastBusinessDay'),
                            'PHP': f3.CreateSimpleMaturityCalculator(['Manila'], 'PreserveLastBusinessDay'),
                            'SEK': f3.CreateSimpleMaturityCalculator(['Stockholm'], 'PreserveLastBusinessDay'),
                            'INR': f3.CreateSimpleMaturityCalculator(['MumbaiAdjusted'], 'PreserveLastBusinessDay'),
                            'INO': f3.CreateSimpleMaturityCalculator(['MumbaiAdjusted'], 'PreserveLastBusinessDay'),
                            'CNH': f3.CreateSimpleMaturityCalculator(['HongKong'], 'PreserveLastBusinessDay'),
                            'CNY': f3.CreateSimpleMaturityCalculator(['Beijing'], 'PreserveLastBusinessDay'),
                            'MYR': f3.CreateSimpleMaturityCalculator(['KualaLumpur'], 'PreserveLastBusinessDay'),
                            'SGD': f3.CreateSimpleMaturityCalculator(['Singapore'], 'PreserveLastBusinessDay'),
                            'IDR': f3.CreateSimpleMaturityCalculator(['Jakarta'], 'PreserveLastBusinessDay'),
                            'HKD': f3.CreateSimpleMaturityCalculator(['HongKong'], 'PreserveLastBusinessDay'),
                            'HUF': f3.CreateSimpleMaturityCalculator(['Budapest'], 'PreserveLastBusinessDay'),
                            'ILS': f3.CreateSimpleMaturityCalculator(['TelAviv'], 'PreserveLastBusinessDay'),
                            'NZD': f3.CreateSimpleMaturityCalculator(['Wellington'], 'PreserveLastBusinessDay'),
                            'THB': f3.CreateSimpleMaturityCalculator(['Bangkok'], 'PreserveLastBusinessDay')}

    fx_fwd_date_mod = {'KRW': f3.CreateFollowingDateModifier('NullModifier', ['KoreaExchange', 'NewYork']),
                       'PHP': f3.CreateFollowingDateModifier('NullModifier', ['Manila', 'NewYork']),
                       'SEK': f3.CreateFollowingDateModifier('NullModifier', ['Stockholm', 'NewYork']),
                       'INR': f3.CreateFollowingDateModifier('NullModifier', ['MumbaiAdjusted', 'NewYork']),
                       'INO': f3.CreateFollowingDateModifier('NullModifier', ['MumbaiAdjusted', 'NewYork']),
                       'CNH': f3.CreateFollowingDateModifier('NullModifier', ['HongKong', 'NewYork']),
                       'CNY': f3.CreateFollowingDateModifier('NullModifier', ['Beijing', 'NewYork']),
                       'MYR': f3.CreateFollowingDateModifier('NullModifier', ['KualaLumpur', 'NewYork']),
                       'SGD': f3.CreateFollowingDateModifier('NullModifier', ['Singapore', 'NewYork']),
                       'IDR': f3.CreateFollowingDateModifier('NullModifier', ['Jakarta', 'NewYork']),
                       'HKD': f3.CreateFollowingDateModifier('NullModifier', ['HongKong', 'NewYork']),
                       'ILS': f3.CreateFollowingDateModifier('NullModifier', ['TelAviv', 'NewYork']),
                       'NZD': f3.CreateFollowingDateModifier('NullModifier', ['Wellington', 'NewYork']),
                       'HUF': f3.CreateFollowingDateModifier('NullModifier', ['Budapest', 'TARGET']),
                       'THB': f3.CreateFollowingDateModifier('NullModifier', ['Bangkok', 'NewYork'])}

    fx_fwd_mod_mat = {'KRW': f3.CreateModifyingMaturityCalculator(fx_fwd_maturity_calc['KRW'], fx_fwd_date_mod['KRW']),
                      'PHP': f3.CreateModifyingMaturityCalculator(fx_fwd_maturity_calc['PHP'], fx_fwd_date_mod['PHP']),
                      'SEK': f3.CreateModifyingMaturityCalculator(fx_fwd_maturity_calc['SEK'], fx_fwd_date_mod['SEK']),
                      'INR': f3.CreateModifyingMaturityCalculator(fx_fwd_maturity_calc['INR'], fx_fwd_date_mod['INR']),
                      'INO': f3.CreateModifyingMaturityCalculator(fx_fwd_maturity_calc['INO'], fx_fwd_date_mod['INO']),
                      'CNH': f3.CreateModifyingMaturityCalculator(fx_fwd_maturity_calc['CNH'], fx_fwd_date_mod['CNH']),
                      'CNY': f3.CreateModifyingMaturityCalculator(fx_fwd_maturity_calc['CNY'], fx_fwd_date_mod['CNY']),
                      'MYR': f3.CreateModifyingMaturityCalculator(fx_fwd_maturity_calc['MYR'], fx_fwd_date_mod['MYR']),
                      'SGD': f3.CreateModifyingMaturityCalculator(fx_fwd_maturity_calc['SGD'], fx_fwd_date_mod['SGD']),
                      'IDR': f3.CreateModifyingMaturityCalculator(fx_fwd_maturity_calc['IDR'], fx_fwd_date_mod['IDR']),
                      'HKD': f3.CreateModifyingMaturityCalculator(fx_fwd_maturity_calc['HKD'], fx_fwd_date_mod['HKD']),
                      'ILS': f3.CreateModifyingMaturityCalculator(fx_fwd_maturity_calc['ILS'], fx_fwd_date_mod['ILS']),
                      'NZD': f3.CreateModifyingMaturityCalculator(fx_fwd_maturity_calc['NZD'], fx_fwd_date_mod['NZD']),
                      'HUF': f3.CreateModifyingMaturityCalculator(fx_fwd_maturity_calc['HUF'], fx_fwd_date_mod['HUF']),
                      'THB': f3.CreateModifyingMaturityCalculator(fx_fwd_maturity_calc['THB'], fx_fwd_date_mod['THB'])}

    fx_fwd_settle_conv = {'KRW': f3.CreateSettlementMarketConvention(['KoreaExchange', 'NewYork'],
                                                                     fx_fwd_mod_mat['KRW'],
                                                                     '2b',
                                                                     fx_fwd_mod_mat['KRW']),
                          'PHP': f3.CreateSettlementMarketConvention(['Manila', 'NewYork'],
                                                                     fx_fwd_mod_mat['PHP'],
                                                                     '2b',
                                                                     fx_fwd_mod_mat['PHP']),
                          'SEK': f3.CreateSettlementMarketConvention(['Stockholm', 'NewYork'],
                                                                     fx_fwd_mod_mat['SEK'],
                                                                     '2b',
                                                                     fx_fwd_mod_mat['SEK']),
                          'INR': f3.CreateSettlementMarketConvention(['MumbaiAdjusted', 'NewYork'],
                                                                     fx_fwd_mod_mat['INR'],
                                                                     '2b',
                                                                     fx_fwd_mod_mat['INR']),
                          'INO': f3.CreateSettlementMarketConvention(['MumbaiAdjusted', 'NewYork'],
                                                                     fx_fwd_mod_mat['INO'],
                                                                     '2b',
                                                                     fx_fwd_mod_mat['INO']),
                          'CNH': f3.CreateSettlementMarketConvention(['HongKong', 'NewYork'],
                                                                     fx_fwd_mod_mat['CNH'],
                                                                     '2b',
                                                                     fx_fwd_mod_mat['CNH']),
                          'CNY': f3.CreateSettlementMarketConvention(['Beijing', 'NewYork'],
                                                                     fx_fwd_mod_mat['CNY'],
                                                                     '2b',
                                                                     fx_fwd_mod_mat['CNY']),
                          'MYR': f3.CreateSettlementMarketConvention(['KualaLumpur', 'NewYork'],
                                                                     fx_fwd_mod_mat['MYR'],
                                                                     '2b',
                                                                     fx_fwd_mod_mat['MYR']),
                          'SGD': f3.CreateSettlementMarketConvention(['Singapore', 'NewYork'],
                                                                     fx_fwd_mod_mat['SGD'],
                                                                     '2b',
                                                                     fx_fwd_mod_mat['SGD']),
                          'IDR': f3.CreateSettlementMarketConvention(['Jakarta', 'NewYork'],
                                                                     fx_fwd_mod_mat['IDR'],
                                                                     '2b',
                                                                     fx_fwd_mod_mat['IDR']),
                          'THB': f3.CreateSettlementMarketConvention(['Bangkok', 'NewYork'],
                                                                     fx_fwd_mod_mat['THB'],
                                                                     '2b',
                                                                     fx_fwd_mod_mat['THB']),
                          'ILS': f3.CreateSettlementMarketConvention(['TelAviv', 'NewYork'],
                                                                     fx_fwd_mod_mat['ILS'],
                                                                     '2b',
                                                                     fx_fwd_mod_mat['ILS']),
                          'NZD': f3.CreateSettlementMarketConvention(['Wellington', 'NewYork'],
                                                                     fx_fwd_mod_mat['NZD'],
                                                                     '2b',
                                                                     fx_fwd_mod_mat['NZD']),
                          'HUF': f3.CreateSettlementMarketConvention(['Budapest', 'TARGET'],
                                                                     fx_fwd_mod_mat['HUF'],
                                                                     '2b',
                                                                     fx_fwd_mod_mat['HUF']),
                          'HKD': f3.CreateSettlementMarketConvention(['HongKong', 'NewYork'],
                                                                     fx_fwd_mod_mat['HKD'],
                                                                     '2b',
                                                                     fx_fwd_mod_mat['HKD'])
                          }

    return fx_fwd_settle_conv


def create_val_spec_builders() -> Dict[str, object]:
    f3 = firm_f3.f3client.get_platform_client()
    cctrvsb = f3.CreateCurveTagReplacementValuationSpecificationBuilder
    dct = f3.DiscountCurveTag
    f3ccy = fu.ccy_to_f3ccy

    valuation_specification_builders = {
        Ccy.PLN: cctrvsb(
            SourceCurveTag=dct(
                Currency=f3ccy(Ccy.PLN)
            ),
            ReplacementCurveTag=dct(
                Currency=f3ccy(Ccy.PLN),
                CollateralAgreement=f3index(Rate(Ccy.PLN, Tenor.T_6M))
            )
        ),
        Ccy.HUF: cctrvsb(
            SourceCurveTag=dct(
                Currency=f3ccy(Ccy.HUF)
            ),
            ReplacementCurveTag=dct(
                Currency=f3ccy(Ccy.HUF),
                CollateralAgreement=f3index(Rate(Ccy.HUF, Tenor.T_6M))
            )
        ),
        Ccy.ZAR: cctrvsb(  # TODO: this is a hack for ZAR, this should go after the fix
            SourceCurveTag=dct(
                Currency=f3ccy(Ccy.ZAR)
            ),
            ReplacementCurveTag=dct(
                Currency=f3ccy(Ccy.ZAR),
                CollateralAgreement=f3index(Rate(Ccy.ZAR, Tenor.T_3M))
            )
        ),
        Ccy.SGD: cctrvsb(  # TODO: this is a hack for SGD, this should go after the fix
            SourceCurveTag=dct(
                Currency=f3ccy(Ccy.SGD)
            ),
            ReplacementCurveTag=dct(
                Currency=f3ccy(Ccy.SGD),
                CollateralAgreement=f3index(Rate(Ccy.SGD, Tenor.T_6M))
            )
        ),
        Ccy.HKD: cctrvsb(
            SourceCurveTag=dct(
                Currency=f3ccy(Ccy.HKD)
            ),
            ReplacementCurveTag=dct(
                Currency=f3ccy(Ccy.HKD),
                CollateralAgreement=f3index(Rate(Ccy.HKD, Tenor.T_3M))
            )
        ),
        Ccy.ILS: cctrvsb(
            SourceCurveTag=dct(
                Currency=f3ccy(Ccy.ILS)
            ),
            ReplacementCurveTag=dct(
                Currency=f3ccy(Ccy.ILS),
                CollateralAgreement=f3index(Rate(Ccy.ILS, Tenor.T_3M))
            )
        )
    }

    return {ccy: vsb.named(fu.get_val_spec_builder(ccy)) for ccy, vsb in valuation_specification_builders.items()}


def create_root_finders_by_ccy() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()
    ccy_factors = {Ccy.EUR: 1,
                   Ccy.GBP: 1,
                   Ccy.JPY: 100,
                   Ccy.AUD: 1,
                   Ccy.TWD: 30,
                   Ccy.NTO: 30,
                   Ccy.INR: 70,
                   Ccy.HKD: 8,
                   Ccy.IDR: 14000,
                   Ccy.KRW: 1100,
                   Ccy.PHP: 50,
                   Ccy.SGD: 1,
                   Ccy.CNH: 7,
                   Ccy.CAD: 1,
                   Ccy.CNY: 7,
                   Ccy.MXN: 19,
                   Ccy.RUB: 60,
                   Ccy.SAR: 4,
                   Ccy.TRY: 6,
                   Ccy.ZAR: 14
                   }

    base_notional = 1000000

    solvers = [f3.CreateLevenbergMarquardtLeastSquaresOptimizer(
        NotionalFactor=base_notional * ccy_factors[c]).named(fu.get_root_finder(c))
               for c in ccy_factors]

    return solvers


def create_interpolation_methods() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()
    tension = [0.1, 0.5]
    splines = [f3.CreateExponentialTensionSplineInterpolationMethod(t).named(fu.get_exp_spline_interp_method(t))
               for t in tension]

    return splines


def create_calibration_optimizer() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()

    def unpack():
        yield f3.CreateNewtonRaphsonRootSearchOptimizer(
            Tolerance=1e-3,  # default: 1e-7
            MaxIterations=25,
            Bisection=True,
            CollectDiagnostics=False,
        ).named('NewtonRaphson_1e-3')

        yield f3.CreateNewtonRaphsonRootSearchOptimizer(
            Tolerance=1e-5,  # default: 1e-7
            MaxIterations=25,
            Bisection=True,
            CollectDiagnostics=False,
        ).named('NewtonRaphson_1e-5')

        yield f3.CreateNewtonRaphsonRootSearchOptimizer(
            Tolerance=1e-7,  # default: 1e-7
            MaxIterations=500,  # default: 25
            Bisection=True,
            CollectDiagnostics=True,
        ).named('NewtonRaphson_diagnostic')

    return list(unpack())


def create_zar_related_static_data() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.ZAR
    fx_pair = ccy_to_f3pair(ccy)  # USDZAR
    overnight_rate = f3index(Rate(ccy, Tenor.T_1D))  # OvernightZAR
    overnight_rate_compounded = f'{overnight_rate}Compounded'  # OvernightZARCompounded
    swap_rate = f3index(Rate(ccy, Tenor.T_3M))  # Jibar3m

    fra_inst = f3instrument_type(FRA(ccy, Tenor.T_3M, Tenor.T_3M))  # ZAR-FRA-Jibar-3m
    irs_inst = f3instrument_type(IRS(ccy, Tenor.T_1Y))  # ZAR-IRS-Quarterly-Jibar-3m

    obs_inst = f3instrument_type(
        TenorBasis(ccy, Tenor.T_2Y, idx_1=Tenor.T_1D, idx_2=Tenor.T_3M))  # ZAR-BasisSwap-OIS-Jibar-3m
    fwd_inst = f3instrument_type(FXForward(ccy, Tenor.T_1Y))  # ZAR_FX_Inst_Type

    def unpack():
        yield f3.FormBasicOvernightRateIndex(
            Currency=ccy.name,
            OvernightRateSettlementDelay='1b',
            OvernightRateDayCountType='act/365f',
            PaymentHolidays='Johannesburg',
            FixingHolidays='Johannesburg',
        ).named(overnight_rate)

        yield f3.CreateCompoundingRateIndex(
            UnderlyingRateIndex=overnight_rate,
            FixingReferencer='UnmodifiedStartEndDatePair',
            MarketConventions='SwapZARQuarterly'
        ).named(overnight_rate_compounded)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying='ZAR-FRA-Jibar-3m-Uncollat',
            CollateralAgreement=overnight_rate
        ).named(fra_inst)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying='ZAR-IRS-Quarterly-Jibar-3m-Uncollat',
            CollateralAgreement=overnight_rate
        ).named(irs_inst)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateRateBasisSwapInstrumentType(
                SettlementMarketConventions='SwapZAR3m',
                MarginFloatingIndex=overnight_rate_compounded,
                OpposingFloatingIndex=swap_rate,
                MarginLegMarketConventions='SwapZAR3m',
                OpposingLegMarketConventions='SwapZAR3m'),
            CollateralAgreement=overnight_rate
        ).named(obs_inst)

        yield f3.CreateVanillaFXForwardInstrumentType(
            MarketConventions=fx_pair,
            FXRateIndex=fx_pair,
            FXFwdQuoteConvention='ForwardPointsAtPremium'
        ).named(fwd_inst)

    return list(unpack())


def create_sar_related_static_data() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.SAR
    mkt_conv = f'Conv{ccy.name}'
    fx_pair = ccy_to_f3pair(ccy)  # USDSAR
    fx_pair_rev = ccy_to_f3pair(ccy, rev=True)  # SARUSD
    overnight_rate = f3index(Rate(ccy, Tenor.T_1D))  # OvernightSAR
    overnight_rate_compounded = f'{overnight_rate}Compounded'  # OvernightSARCompounded
    swap_rate = f3index(Rate(ccy, Tenor.T_3M))  # SAIBOR3m
    xccy_float_sar, xccy_conv_sar, xccy_float_usd, xccy_conv_usd = F3_XCCY_BASIS_CONVENTIONS[ccy, Ccy.USD]
    xccy_holidays = ['NewYork', 'London', 'Riyadh']

    fra_inst = f3instrument_type(FRA(ccy, Tenor.T_3M, Tenor.T_3M))  # SAR-FRA-SAIBOR-3m
    irs_inst = f3instrument_type(IRS(ccy, Tenor.T_1Y))  # SAR-IRS-Quarterly-SAIBOR-3m

    obs_inst = f3instrument_type(
        TenorBasis(ccy, Tenor.T_2Y, idx_1=Tenor.T_1D, idx_2=Tenor.T_3M))  # SAR-BasisSwap-OIS-SAIBOR-3m
    fwd_inst = f3instrument_type(FXForward(ccy, Tenor.T_1Y))  # SAR_FX_Inst_Type
    xccy_inst = f3instrument_type(XccyBasis(ccy, Tenor.T_1Y))
    swaption_inst = f3instrument_type(Swaption(ccy, None, None))
    fixed_conv, idx, floating_conv = F3_CONVENTION_BY_IRS_INSTRUMENT_TYPE[irs_inst]

    usd_coll = ccy_to_collateral(Ccy.USD)

    def unpack():
        yield f3.FormBasicOvernightRateIndex(
            Currency=ccy.name,
            OvernightRateSettlementDelay='1b',
            OvernightRateDayCountType='act/360',
            PaymentHolidays='Riyadh',
            FixingHolidays='Riyadh',
        ).named(overnight_rate)

        yield f3.CreateCompoundingRateIndex(
            UnderlyingRateIndex=overnight_rate,
            FixingReferencer='UnmodifiedStartEndDatePair',
            MarketConventions='SwapSAR3m'
        ).named(overnight_rate_compounded)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying='SAR-FRA-SAIBOR-3m-Uncollat',
            CollateralAgreement=overnight_rate
        ).named(fra_inst)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying='SAR-IRS-Annual-SAIBOR-3m-Uncollat',
            CollateralAgreement=overnight_rate
        ).named(irs_inst)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateRateBasisSwapInstrumentType(
                SettlementMarketConventions='SwapSAR3m',
                MarginFloatingIndex=overnight_rate_compounded,
                OpposingFloatingIndex=swap_rate,
                MarginLegMarketConventions='SwapSAR3m',
                OpposingLegMarketConventions='SwapSAR3m'),
            CollateralAgreement=overnight_rate
        ).named(obs_inst)

        maturity_calculator = f3.CreateModifyingMaturityCalculator(
            UnderlyingMaturityCalculator=f3.CreateSimpleMaturityCalculator(
                HolidayConventions=['Riyadh'],
                PreserveMonthEnd='PreserveLastBusinessDay'
            ),
            DateModifier=f3.CreateFollowingDateModifier(
                UnderlyingDateModifier='NullModifier',
                HolidayConventions=['Riyadh', 'NewYork']
            )
        )

        yield f3.CreateSettlementMarketConvention(
            PaymentHolidays=['Riyadh', 'NewYork'],
            MaturityCalculator=maturity_calculator,
            SettlementMaturityDescriptor='2b',
            SettlementMaturityCalculator=maturity_calculator
        ).named(mkt_conv)

        yield f3.CreateFXRateIndex(
            AssetCurrency='USD',
            NumeraireCurrency='SAR',
            SettlementMarketConventions=mkt_conv,
        ).named(fx_pair)

        yield f3.CreateFXRateIndex(
            AssetCurrency='SAR',
            NumeraireCurrency='USD',
            SettlementMarketConventions=mkt_conv,
        ).named(fx_pair_rev)

        yield f3.CreateVanillaFXForwardInstrumentType(
            MarketConventions=fx_pair,
            FXRateIndex=fx_pair,
            FXFwdQuoteConvention='ForwardPointsAtPremium'
        ).named(fwd_inst)

        yield create_swap_leg_conventions(xccy_holidays, 'act/360', 3).named(xccy_conv_sar)

        yield f3.CreateCrossCurrencySwapInstrumentType(
            FXRateIndex=fx_pair,
            MarginLegRateIndex=xccy_float_sar,
            OffsettingLegRateIndex=xccy_float_usd,
            MarketConventions=xccy_conv_sar,
            NotionalAdjustment=['MarginLeg', 'FrontBack'],
            OffsettingLegMarketConventions=xccy_conv_usd
        ).named(xccy_inst)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateSwaptionInstrumentType(
                FixedLegMarketConventions=fixed_conv,
                FloatingRateIndex=idx,
                FloatingLegMarketConventions=floating_conv,
                SwapCollateralAgreement=overnight_rate,
            ),
            CollateralAgreement=usd_coll
        ).named(swaption_inst)

    return list(unpack())


def create_sgd_related_static_data() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.SGD
    fx_pair = ccy_to_f3pair(ccy)  # USDSGD
    overnight_rate = f3index(Rate(ccy, Tenor.T_1D))  # OvernightSGD
    overnight_rate_compounded = f'{overnight_rate}Compounded'  # OvernightSGDCompounded
    swap_rate = f3index(Rate(ccy, Tenor.T_6M))  # SOR6m
    swap_rate_3m = f3index(Rate(ccy, Tenor.T_3M))

    fra_inst = f3instrument_type(FRA(ccy, Tenor.T_6M, Tenor.T_6M))  # SGD-FRA-SOR-6m
    fra_3m_inst = f3instrument_type(FRA(ccy, Tenor.T_3M, Tenor.T_3M))  # SGD-FRA-SOR-6m
    fra_inst_uncollat = f'{fra_inst}-Uncollat'  # SGD-FRA-SOR-6m-Uncollat
    irs_inst = f3instrument_type(IRS(ccy, Tenor.T_1Y))  # SGD-IRS-Semi-SOR-6m

    obs_inst = f3instrument_type(
        TenorBasis(ccy, Tenor.T_2Y, idx_1=Tenor.T_1D, idx_2=Tenor.T_6M))  # SGD-BasisSwap-OIS-SOR-6m
    tb3s6s_inst = f3instrument_type(TenorBasis(ccy, Tenor.T_2Y, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M))
    fwd_inst = f3instrument_type(FXForward(ccy, Tenor.T_1Y))  # SGD_FX_Inst_Type

    def unpack():
        maturity_calculator = f3.CreateModifyingMaturityCalculator(
            UnderlyingMaturityCalculator=f3.CreateSimpleMaturityCalculator(
                HolidayConventions=['Singapore'],
                PreserveMonthEnd='PreserveLastBusinessDay'
            ),
            DateModifier=f3.CreateFollowingDateModifier(
                UnderlyingDateModifier='NullModifier',
                HolidayConventions=['Singapore', 'NewYork']
            )
        )

        yield f3.CreateFRAInstrumentType(
            MarketConventions=f3.CreateSettlementMarketConvention(
                PaymentHolidays=['Singapore', 'NewYork'],
                MaturityCalculator=maturity_calculator,
                SettlementMaturityDescriptor='2b',
                SettlementMaturityCalculator=maturity_calculator
            ),
            FloatingIndex=swap_rate,
        ).named(fra_inst_uncollat)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying=fra_inst_uncollat,
            CollateralAgreement=overnight_rate
        ).named(fra_inst)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateFRAInstrumentType(
                MarketConventions=f3.CreateSettlementMarketConvention(
                    PaymentHolidays=['Singapore', 'NewYork'],
                    MaturityCalculator=maturity_calculator,
                    SettlementMaturityDescriptor='2b',
                    SettlementMaturityCalculator=maturity_calculator
                ),
                FloatingIndex=swap_rate_3m,
            ),
            CollateralAgreement=overnight_rate
        ).named(fra_3m_inst)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying='SGD-IRS-Semi-SOR-6m-Uncollat',
            CollateralAgreement=overnight_rate
        ).named(irs_inst)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateRateBasisSwapInstrumentType(
                SettlementMarketConventions='SwapSGD6m',
                MarginFloatingIndex=overnight_rate_compounded,
                OpposingFloatingIndex=swap_rate,
                MarginLegMarketConventions='SwapSGD6m',
                OpposingLegMarketConventions='SwapSGD6m'),
            CollateralAgreement=overnight_rate
        ).named(obs_inst)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateRateBasisSwapInstrumentType(
                SettlementMarketConventions='SwapSGD6m',
                MarginFloatingIndex=swap_rate_3m,
                OpposingFloatingIndex=swap_rate,
                MarginLegMarketConventions='SwapSGD3m',
                OpposingLegMarketConventions='SwapSGD6m'),
            CollateralAgreement=overnight_rate
        ).named(tb3s6s_inst)

        yield f3.CreateVanillaFXForwardInstrumentType(
            MarketConventions=fx_pair,
            FXRateIndex=fx_pair,
            FXFwdQuoteConvention='ForwardPointsAtPremium'
        ).named(fwd_inst)

    return list(unpack())


def create_hkd_related_static_data() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.HKD
    fx_pair = ccy_to_f3pair(ccy)  # USDHKD
    overnight_rate = f3index(Rate(ccy, Tenor.T_1D))  # HiborON
    overnight_rate_compounded = f'{overnight_rate}Compounded'  # HiborONCompounded
    swap1m_rate = f3index(Rate(ccy, Tenor.T_1M))  # Hibor1m
    swap3m_rate = f3index(Rate(ccy, Tenor.T_3M))  # Hibor3m

    fra1m_inst = f3instrument_type(FRA(ccy, Tenor.T_1M, Tenor.T_1M))  # HKD-FRA-Hibor-1m
    fra1m_inst_uncollat = f'{fra1m_inst}-Uncollat'  # HKD-FRA-Hibor-1m-Uncollat

    obs_inst = f3instrument_type(
        TenorBasis(ccy, Tenor.T_2Y, idx_1=Tenor.T_1D, idx_2=Tenor.T_3M))  # HKD-BasisSwap-OIS-Hibor-3m
    s1s3_inst = f3instrument_type(
        TenorBasis(ccy, Tenor.T_2Y, idx_1=Tenor.T_1M, idx_2=Tenor.T_3M))  # HKD-BasisSwap-Hibor-1m-3m
    s1s3_inst_uncollat = f'{s1s3_inst}-Uncollat'  # HKD-BasisSwap-Libor-1m-3m-Uncollat
    fwd_inst = f3instrument_type(FXForward(ccy, Tenor.T_1Y))  # HKD_FX_Inst_Type

    def unpack():
        maturity_calculator = f3.CreateModifyingMaturityCalculator(
            UnderlyingMaturityCalculator=f3.CreateSimpleMaturityCalculator(
                HolidayConventions=['HongKong'],
                PreserveMonthEnd='PreserveLastBusinessDay'
            ),
            DateModifier=f3.CreateFollowingDateModifier(
                UnderlyingDateModifier='NullModifier',
                HolidayConventions=['HongKong', 'NewYork']
            )
        )

        yield f3.CreateFRAInstrumentType(
            MarketConventions=f3.CreateSettlementMarketConvention(
                PaymentHolidays=['HongKong', 'NewYork'],
                MaturityCalculator=maturity_calculator,
                SettlementMaturityDescriptor='2b',
                SettlementMaturityCalculator=maturity_calculator
            ),
            FloatingIndex=swap1m_rate,
        ).named(fra1m_inst_uncollat)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying=fra1m_inst_uncollat,
            CollateralAgreement=overnight_rate
        ).named(fra1m_inst)

        yield f3.CreateRateBasisSwapInstrumentType(
            SettlementMarketConventions='SwapHKD3m',
            MarginFloatingIndex='Hibor1m',
            OpposingFloatingIndex='Hibor3m',
            MarginLegMarketConventions='SwapHKD1m',
            OpposingLegMarketConventions='SwapHKD3m'
        ).named(s1s3_inst_uncollat)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying=s1s3_inst_uncollat,
            CollateralAgreement=overnight_rate
        ).named(s1s3_inst)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateRateBasisSwapInstrumentType(
                SettlementMarketConventions='SwapHKD3m',
                MarginFloatingIndex=overnight_rate_compounded,
                OpposingFloatingIndex=swap3m_rate,
                MarginLegMarketConventions='SwapHKD3m',
                OpposingLegMarketConventions='SwapHKD3m'),
            CollateralAgreement=overnight_rate
        ).named(obs_inst)

        yield f3.CreateVanillaFXForwardInstrumentType(
            MarketConventions=fx_pair,
            FXRateIndex=fx_pair,
            FXFwdQuoteConvention='ForwardPointsAtPremium'
        ).named(fwd_inst)

    return list(unpack())


def create_ils_related_static_data() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.ILS
    mkt_conv = f'Conv{ccy.name}'
    fx_pair = ccy_to_f3pair(ccy)  # USDILS
    fx_pair_rev = ccy_to_f3pair(ccy, rev=True)  # ILSUSD
    overnight_rate = f3index(Rate(ccy, Tenor.T_1D))  # OvernightILS
    overnight_rate_compounded = f'{overnight_rate}Compounded'  # OvernightILSCompounded
    swap_rate = f3index(Rate(ccy, Tenor.T_3M))  # Telbor3m

    fra_inst = f3instrument_type(FRA(ccy, Tenor.T_3M, Tenor.T_3M))  # ILS-FRA-Telbor-3m
    irs_inst = f3instrument_type(IRS(ccy, Tenor.T_1Y))  # ILS-IRS-Annual-Telbor-3m

    obs_inst = f3instrument_type(
        TenorBasis(ccy, Tenor.T_2Y, idx_1=Tenor.T_1D, idx_2=Tenor.T_3M))  # ILS-BasisSwap-OIS-Telbor-3m
    fwd_inst = f3instrument_type(FXForward(ccy, Tenor.T_1Y))  # ILS_FX_Inst_Type
    xccy_inst = f3instrument_type(XccyBasis(ccy, Tenor.T_1Y))  # ILSUSD-XccySwap-Telbor3m-LiborUSD3m

    def unpack():
        yield f3.FormBasicOvernightRateIndex(
            Currency=ccy.name,
            OvernightRateSettlementDelay='1b',
            OvernightRateDayCountType='act/365f',
            PaymentHolidays='TelAviv',
            FixingHolidays='TelAviv',
        ).named(overnight_rate)

        yield f3.CreateCompoundingRateIndex(
            UnderlyingRateIndex=overnight_rate,
            FixingReferencer='UnmodifiedStartEndDatePair',
            MarketConventions='SwapILS3m'
        ).named(overnight_rate_compounded)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying='ILS-FRA-Telbor-3m-Uncollat',
            CollateralAgreement=overnight_rate
        ).named(fra_inst)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying='ILS-IRS-Annual-Telbor-3m-Uncollat',
            CollateralAgreement=overnight_rate
        ).named(irs_inst)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateRateBasisSwapInstrumentType(
                SettlementMarketConventions='SwapILS3m',
                MarginFloatingIndex=overnight_rate_compounded,
                OpposingFloatingIndex=swap_rate,
                MarginLegMarketConventions='SwapILS3m',
                OpposingLegMarketConventions='SwapILS3m'),
            CollateralAgreement=overnight_rate
        ).named(obs_inst)

        maturity_calculator = f3.CreateModifyingMaturityCalculator(
            UnderlyingMaturityCalculator=f3.CreateSimpleMaturityCalculator(
                HolidayConventions=['TelAviv'],
                PreserveMonthEnd='PreserveLastBusinessDay'
            ),
            DateModifier=f3.CreateFollowingDateModifier(
                UnderlyingDateModifier='NullModifier',
                HolidayConventions=['TelAviv', 'NewYork']
            )
        )

        yield f3.CreateSettlementMarketConvention(
            PaymentHolidays=['TelAviv', 'NewYork'],
            MaturityCalculator=maturity_calculator,
            SettlementMaturityDescriptor='2b',
            SettlementMaturityCalculator=maturity_calculator
        ).named(mkt_conv)

        yield f3.CreateFXRateIndex(
            AssetCurrency='USD',
            NumeraireCurrency='ILS',
            SettlementMarketConventions=mkt_conv,
        ).named(fx_pair)

        yield f3.CreateFXRateIndex(
            AssetCurrency='ILS',
            NumeraireCurrency='USD',
            SettlementMarketConventions=mkt_conv,
        ).named(fx_pair_rev)

        yield f3.CreateVanillaFXForwardInstrumentType(
            MarketConventions=mkt_conv,
            FXRateIndex=fx_pair,
            FXFwdQuoteConvention='ForwardPointsAtPremium'
        ).named(fwd_inst)

        yield f3.CreateCrossCurrencySwapInstrumentType(
            FXRateIndex=fx_pair,
            MarginLegRateIndex=swap_rate,
            OffsettingLegRateIndex=f3index(Rate(Ccy.USD, Tenor.T_3M)),
            MarketConventions=create_swap_leg_conventions(['NewYork', 'London', 'TelAviv'], 'act/365f', 3),
            NotionalAdjustment=['MarginLeg', 'FrontBack'],
            OffsettingLegMarketConventions=create_swap_leg_conventions(['NewYork', 'London', 'TelAviv'], 'act/360', 3)
        ).named(xccy_inst)

    return list(unpack())


def create_huf_related_static_data() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.HUF
    overnight_rate = f3index(Rate(ccy, Tenor.T_1D))  # OvernightHUF
    overnight_rate_compounded = f'{overnight_rate}Compounded'  # OvernightHUFCompounded
    swap_rate = f3index(Rate(ccy, Tenor.T_6M))  # Bubor6m

    obs_inst = f3instrument_type(
        TenorBasis(ccy, Tenor.T_2Y, idx_1=Tenor.T_1D, idx_2=Tenor.T_6M))  # HUF-BasisSwap-OIS-Bubor-6m

    def unpack():
        yield f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateRateBasisSwapInstrumentType(
                SettlementMarketConventions='SwapHUF6m',
                MarginFloatingIndex=overnight_rate_compounded,
                OpposingFloatingIndex=swap_rate,
                MarginLegMarketConventions='SwapHUF6m',
                OpposingLegMarketConventions='SwapHUF6m'),
            CollateralAgreement=overnight_rate
        ).named(obs_inst)

    return list(unpack())


def create_pln_related_static_data() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.PLN
    overnight_rate = f3index(Rate(ccy, Tenor.T_1D))  # OvernightPLN
    overnight_rate_compounded = f'{overnight_rate}Compounded'  # OvernightPLNCompounded
    overnight_rate_usd = f3index(Rate(Ccy.USD, Tenor.T_1D))
    swap_rate = f3index(Rate(ccy, Tenor.T_6M))  # Wibor6m

    obs_inst = f3instrument_type(
        TenorBasis(ccy, Tenor.T_2Y, idx_1=Tenor.T_1D, idx_2=Tenor.T_6M))  # PLN-BasisSwap-OIS-Wibor-6m

    s3s6_inst = f3instrument_type(
        TenorBasis(ccy, Tenor.T_2Y, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M))  # PLN-BasisSwap-Wibor-3m-6m
    s3s6_inst_uncollat = f'{s3s6_inst}-Uncollat'  # PLN-BasisSwap-Wibor-3m-6m-Uncollat
    swaption_inst = f3instrument_type(Swaption(ccy, Tenor.T_5Y, Tenor.T_5Y))

    def unpack():
        yield f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateRateBasisSwapInstrumentType(
                SettlementMarketConventions='SwapPLN6m',
                MarginFloatingIndex=overnight_rate_compounded,
                OpposingFloatingIndex=swap_rate,
                MarginLegMarketConventions='SwapPLN6m',
                OpposingLegMarketConventions='SwapPLN6m'),
            CollateralAgreement=overnight_rate
        ).named(obs_inst)

        yield f3.CreateRateBasisSwapInstrumentType(
            SettlementMarketConventions='SwapPLN6m',
            MarginFloatingIndex='Wibor3m',
            OpposingFloatingIndex='Wibor6m',
            MarginLegMarketConventions='SwapPLN3m',
            OpposingLegMarketConventions='SwapPLN6m'
        ).named(s3s6_inst_uncollat)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying=s3s6_inst_uncollat,
            CollateralAgreement=overnight_rate
        ).named(s3s6_inst)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying='PLN-Swaption-Annual-Wibor-6m-Uncollat',
            CollateralAgreement=overnight_rate_usd
        ).named(swaption_inst)

    return list(unpack())


def create_twd_related_static_data() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.TWD
    fx_pair = ccy_to_f3pair(ccy)
    mkt_conv = f'Conv{ccy.name}'
    fwd_inst = f3instrument_type(FXForward(ccy, Tenor.T_1Y))
    collateral_rate = f3index(Rate(Ccy.USD, Tenor.T_1D))
    irs_inst = f3instrument_type(IRS(ccy, Tenor.T_1Y))
    val_spec_name = 'Default' + ccy.name
    fixed_conv, idx, floating_conv = F3_CONVENTION_BY_IRS_INSTRUMENT_TYPE[irs_inst]
    swaption_inst = f3instrument_type(Swaption(ccy, Tenor.T_1Y, Tenor.T_5Y))

    float_leg_ind, fix_leg_conv, not_exch_conv, float_leg_conv = F3_CCS_CONVENTIONS[ccy]

    def unpack():
        maturity_calculator = f3.CreateModifyingMaturityCalculator(
            UnderlyingMaturityCalculator=f3.CreateSimpleMaturityCalculator(
                HolidayConventions=['Taipei'],
                PreserveMonthEnd='PreserveLastBusinessDay'
            ),
            DateModifier=f3.CreateFollowingDateModifier(
                UnderlyingDateModifier='NullModifier',
                HolidayConventions=['Taipei', 'NewYork']
            )
        )

        yield f3.CreateSettlementMarketConvention(
            PaymentHolidays=['Taipei', 'NewYork'],
            MaturityCalculator=maturity_calculator,
            SettlementMaturityDescriptor='2b',
            SettlementMaturityCalculator=maturity_calculator
        ).named(mkt_conv)

        yield f3.CreateFXRateIndex(
            AssetCurrency=fx_pair[:3],
            NumeraireCurrency=fx_pair[-3:],
            SettlementMarketConventions=mkt_conv
        ).named(fx_pair)

        yield f3.CreateVanillaFXNonDeliverableForwardInstrumentType(
            MarketConventions=mkt_conv,
            FXRateIndex=fx_pair,
            FXFwdQuoteConvention='ForwardPointsAtPremium'
        ).named(fwd_inst)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying='TWD-IRS-Quarterly-Taibor-3m-Uncollat',
            CollateralAgreement=collateral_rate
        ).named(irs_inst)

        yield f3.CreateNumeraireCurrencyValuationSpecification(
            UnderlyingValuationMethod='Default',
            Currency=ccy.name
        ).named(val_spec_name)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateParYieldCashSettledSwaptionInstrumentType(
                FixedLegMarketConventions=fixed_conv,
                FloatingRateIndex=idx,
                FloatingLegMarketConventions=floating_conv,
                SwapRateCollateralAgreement=collateral_rate),
            CollateralAgreement=collateral_rate
        ).named(swaption_inst)

        yield create_swap_leg_conventions(
            holiday_conventions=['NewYork', 'London', 'Taipei'],
            day_count='act/365f',
            roll_length=6
        ).named(fix_leg_conv)

        yield create_swap_leg_conventions(
            holiday_conventions=['NewYork', 'London', 'Taipei'],
            day_count='act/360',
            roll_length=6
        ).named(float_leg_conv)

        yield f3.CreateCrossCurrencySwapInstrumentType(
            FXRateIndex=fx_pair,
            MarginLegRateIndex='ZeroConstant',
            OffsettingLegRateIndex=float_leg_ind,
            MarketConventions=fix_leg_conv,
            NotionalAdjustment=['MarginLeg', not_exch_conv],
            OffsettingLegMarketConventions=float_leg_conv
        ).named(f3instrument_type(CrossCurrencySwap(ccy, None)))

    return list(unpack())


def create_nto_related_static_data() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.NTO
    fx_pair = ccy_to_f3pair(ccy)
    mkt_conv = f'Conv{ccy.name}'
    fwd_inst = f3instrument_type(FXForward(ccy, Tenor.T_1Y))
    collateral_rate = f3index(Rate(Ccy.USD, Tenor.T_1D))
    libor_rate = f3index(Rate(ccy, Tenor.T_3M))
    libor_conv_name = libor_rate + '_conv'
    irs_inst = f3instrument_type(IRS(ccy, Tenor.T_1Y))
    cash_conv_name = 'Cash' + ccy.name
    val_spec_name = 'Default' + ccy.name
    fixed_conv, idx, floating_conv = F3_CONVENTION_BY_IRS_INSTRUMENT_TYPE[irs_inst]
    swaption_inst = f3instrument_type(Swaption(ccy, Tenor.T_1Y, Tenor.T_5Y))

    def unpack():
        maturity_calculator = f3.CreateModifyingMaturityCalculator(
            UnderlyingMaturityCalculator=f3.CreateSimpleMaturityCalculator(
                HolidayConventions=['Taipei'],
                PreserveMonthEnd='PreserveLastBusinessDay'
            ),
            DateModifier=f3.CreateFollowingDateModifier(
                UnderlyingDateModifier='NullModifier',
                HolidayConventions=['Taipei', 'NewYork']
            )
        )

        yield f3.CreateSettlementMarketConvention(
            PaymentHolidays=['Taipei', 'NewYork'],
            MaturityCalculator=maturity_calculator,
            SettlementMaturityDescriptor='2b',
            SettlementMaturityCalculator=maturity_calculator
        ).named(mkt_conv)

        yield f3.CreateFXRateIndex(
            AssetCurrency=fx_pair[:3],
            NumeraireCurrency=fx_pair[-3:],
            SettlementMarketConventions=mkt_conv
        ).named(fx_pair)

        yield f3.CreateVanillaFXNonDeliverableForwardInstrumentType(
            MarketConventions=mkt_conv,
            FXRateIndex=fx_pair,
            FXFwdQuoteConvention='ForwardPointsAtPremium'
        ).named(fwd_inst)

        yield f3.CreateSwapMarketConvention(
            MaturityCalculator='TaipeiModFoll',
            SettlementMaturityDescriptor='2b',
            RollLength=3,
            DayCountConvention='act/365f',
            RollDayModifier='TaipeiModFoll',
            MonthEndPolicy='PreserveLastBusinessDay'
        ).named(libor_conv_name)

        yield f3.CreateLiborIndex(
            Currency=ccy.name,
            MarketConventions=libor_conv_name,
            FixingReferencer=['StartOffset', libor_conv_name, 'Taipei']
        ).named(libor_rate)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateVanillaIRSInstrumentType(
                MarketConventionsForFixedLeg=fixed_conv,
                FloatingIndex=idx,
                FloatingLegMarketConventions=floating_conv),
            CollateralAgreement=collateral_rate
        ).named(irs_inst)

        yield f3.CreateCashDepoMarketConvention(
            PaymentHolidays='Taipei',
            MaturityCalculator='TaipeiModFoll',
            SettlementMaturityDescriptor='2b',
            SettlementMaturityCalculator='TaipeiFoll',
            DayCountConvention='act/365f'
        ).named(cash_conv_name)

        yield f3.CreateNumeraireCurrencyValuationSpecification(
            UnderlyingValuationMethod='Default',
            Currency=ccy.name
        ).named(val_spec_name)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateParYieldCashSettledSwaptionInstrumentType(
                FixedLegMarketConventions=fixed_conv,
                FloatingRateIndex=idx,
                FloatingLegMarketConventions=floating_conv,
                SwapRateCollateralAgreement=collateral_rate),
            CollateralAgreement=collateral_rate
        ).named(swaption_inst)

    return list(unpack())


def create_nok_related_static_data() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.NOK
    mkt_conv = f'Conv{ccy.name}'
    fx_pair = ccy_to_f3pair(ccy)  # USDNOK
    overnight_rate = f3index(Rate(ccy, Tenor.T_1D))  # OvernightNOK
    overnight_rate_compounded = f'{overnight_rate}Compounded'  # OvernightNOKCompounded
    swap_rate = f3index(Rate(ccy, Tenor.T_6M))  # Nibor6m
    xccy_float_nok, xccy_conv_nok, xccy_float_usd, xccy_conv_usd = F3_XCCY_BASIS_CONVENTIONS[ccy, Ccy.USD]
    xccy_holidays = ['NewYork', 'London', 'Oslo']

    fra_inst_3m = f3instrument_type(FRA(ccy, Tenor.T_3M, Tenor.T_3M))
    immfra_inst_3m = f3instrument_type(IMMFRA(ccy, Tenor.T_3M, None))
    fra_inst_6m = f3instrument_type(FRA(ccy, Tenor.T_6M, Tenor.T_6M))
    immfra_inst_6m = f3instrument_type(IMMFRA(ccy, Tenor.T_6M, None))
    irs_inst = f3instrument_type(IRS(ccy, Tenor.T_1Y))

    obs_inst = f3instrument_type(
        TenorBasis(ccy, Tenor.T_2Y, idx_1=Tenor.T_1D, idx_2=Tenor.T_6M))
    s3s6_inst = f3instrument_type(
        TenorBasis(ccy, Tenor.T_2Y, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M))
    s3s6_inst_uncollat = f'{s3s6_inst}-Uncollat'

    fwd_inst = f3instrument_type(FXForward(ccy, Tenor.T_1Y))
    xccy_inst = f3instrument_type(XccyBasis(ccy, Tenor.T_1Y))

    def unpack():
        yield f3.FormBasicOvernightRateIndex(
            Currency=ccy.name,
            OvernightRateSettlementDelay='1b',
            OvernightRateDayCountType='act/360',
            PaymentHolidays='Oslo',
            FixingHolidays='Oslo',
        ).named(overnight_rate)

        yield f3.CreateCompoundingRateIndex(
            UnderlyingRateIndex=overnight_rate,
            FixingReferencer='UnmodifiedStartEndDatePair',
            MarketConventions='SwapNOK6m'
        ).named(overnight_rate_compounded)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying='NOK-FRA-Nibor-3m-Uncollat',
            CollateralAgreement=overnight_rate
        ).named(immfra_inst_3m)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying='NOK-FRA-Nibor-6m-Uncollat',
            CollateralAgreement=overnight_rate
        ).named(immfra_inst_6m)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying='NOK-IRS-Annual-Nibor-6m-Uncollat',
            CollateralAgreement=overnight_rate
        ).named(irs_inst)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateRateBasisSwapInstrumentType(
                SettlementMarketConventions='SwapNOK6m',
                MarginFloatingIndex=overnight_rate_compounded,
                OpposingFloatingIndex=swap_rate,
                MarginLegMarketConventions='SwapNOK6m',
                OpposingLegMarketConventions='SwapNOK6m'),
            CollateralAgreement=overnight_rate
        ).named(obs_inst)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying=s3s6_inst_uncollat,
            CollateralAgreement=overnight_rate
        ).named(s3s6_inst)

        maturity_calculator = f3.CreateModifyingMaturityCalculator(
            UnderlyingMaturityCalculator=f3.CreateSimpleMaturityCalculator(
                HolidayConventions=['Oslo'],
                PreserveMonthEnd='PreserveLastBusinessDay'
            ),
            DateModifier=f3.CreateFollowingDateModifier(
                UnderlyingDateModifier='NullModifier',
                HolidayConventions=['Oslo', 'NewYork']
            )
        )

        yield f3.CreateSettlementMarketConvention(
            PaymentHolidays=['Oslo', 'NewYork'],
            MaturityCalculator=maturity_calculator,
            SettlementMaturityDescriptor='2b',
            SettlementMaturityCalculator=maturity_calculator
        ).named(mkt_conv)

        yield f3.CreateVanillaFXForwardInstrumentType(
            MarketConventions=mkt_conv,
            FXRateIndex=fx_pair,
            FXFwdQuoteConvention='ForwardPointsAtPremium'
        ).named(fwd_inst)

        yield create_swap_leg_conventions(xccy_holidays, 'act/360', 3).named(xccy_conv_nok)
        yield create_swap_leg_conventions(xccy_holidays, 'act/360', 3).named(xccy_conv_usd)

        yield f3.CreateCrossCurrencySwapInstrumentType(
            FXRateIndex=fx_pair,
            MarginLegRateIndex=xccy_float_nok,
            OffsettingLegRateIndex=xccy_float_usd,
            MarketConventions=xccy_conv_nok,
            NotionalAdjustment=['MarginLeg', 'FrontBack'],
            OffsettingLegMarketConventions=xccy_conv_usd
        ).named(xccy_inst)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateFRAInstrumentType(
                MarketConventions=mkt_conv,
                FloatingIndex=f3index(Rate(ccy, Tenor.T_3M))),
            CollateralAgreement=overnight_rate
        ).named(fra_inst_3m)

        yield f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateFRAInstrumentType(
                MarketConventions=mkt_conv,
                FloatingIndex=f3index(Rate(ccy, Tenor.T_6M))),
            CollateralAgreement=overnight_rate
        ).named(fra_inst_6m)

    return list(unpack())


def create_swap_leg_conventions(holiday_conventions: List[str], day_count: str, roll_length: int, smd='2b') -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    smc = f3.CreateSimpleMaturityCalculator(
        HolidayConventions=holiday_conventions
    )

    fdm = f3.CreateFollowingDateModifier(
        UnderlyingDateModifier='NullModifier',
        HolidayConventions=holiday_conventions,
        AllowMonthChange=False
    )

    mmc = f3.CreateModifyingMaturityCalculator(
        UnderlyingMaturityCalculator=smc,
        DateModifier=fdm
    )

    settlement_mc = f3.CreateSettlementMarketConvention(
        PaymentHolidays=holiday_conventions,
        MaturityCalculator=smc,
        SettlementMaturityDescriptor=smd,
        SettlementMaturityCalculator=mmc
    )

    return f3.CreateMonthlyScheduleMarketConvention(
        UnderlyingConventions=settlement_mc,
        RollLength=roll_length,
        StubType='ShortStubAtStart',
        RollDayModifier=fdm,
        DayCountConvention=day_count,
        ModifyStart=False,
        EndDateModifier=fdm,
        MonthEndPolicy='Preserve'
    )


def create_other_cash_depo_inst_types() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()
    rel_rates = [
        Rate(Ccy.EUR, Tenor.T_1M),
        Rate(Ccy.EUR, Tenor.T_3M),
        Rate(Ccy.EUR, Tenor.T_6M),
        Rate(Ccy.GBP, Tenor.T_3M),
        Rate(Ccy.GBP, Tenor.T_6M),
        Rate(Ccy.AUD, Tenor.T_1M),
        Rate(Ccy.AUD, Tenor.T_3M),
        Rate(Ccy.AUD, Tenor.T_6M),
        Rate(Ccy.NZD, Tenor.T_3M),
        Rate(Ccy.USD, Tenor.T_1M),
        Rate(Ccy.USD, Tenor.T_3M),
        Rate(Ccy.USD, Tenor.T_6M),
        Rate(Ccy.CAD, Tenor.T_3M),
        Rate(Ccy.SEK, Tenor.T_3M),
        Rate(Ccy.JPY, Tenor.T_3M),
        Rate(Ccy.JPY, Tenor.T_6M),
        Rate(Ccy.SGD, Tenor.T_3M),
        Rate(Ccy.SGD, Tenor.T_6M),
        Rate(Ccy.HKD, Tenor.T_1M),
        Rate(Ccy.HKD, Tenor.T_3M),
        Rate(Ccy.KRW, Tenor.T_3M),
        Rate(Ccy.MYR, Tenor.T_3M),
        Rate(Ccy.TWD, Tenor.T_3M),
        Rate(Ccy.NTO, Tenor.T_3M),
        Rate(Ccy.THB, Tenor.T_6M),
        Rate(Ccy.ILS, Tenor.T_3M),
        Rate(Ccy.ZAR, Tenor.T_3M),
        Rate(Ccy.SAR, Tenor.T_3M),
        Rate(Ccy.HUF, Tenor.T_3M),
        Rate(Ccy.HUF, Tenor.T_6M),
        Rate(Ccy.PLN, Tenor.T_3M),
        Rate(Ccy.PLN, Tenor.T_6M),
        Rate(Ccy.CHF, Tenor.T_3M),
        Rate(Ccy.CHF, Tenor.T_6M),
        Rate(Ccy.NOK, Tenor.T_3M),
        Rate(Ccy.NOK, Tenor.T_6M),
    ]

    def _create_cash_depo(rate: Rate) -> F3Object:
        return f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateCashDepoInstrumentType(
                Currency=rate.ccy.name,
                MarketConventions=f'Cash{rate.ccy.name}'
            ),
            CollateralAgreement=f3index(rate)
        ).named(f3instrument_type(rate))

    return [_create_cash_depo(r) for r in rel_rates]


class StaticDataTests(unittest.TestCase):
    def test_assemble_static_data(self):
        s = assemble_staticdata()
        assert isinstance(s, str)
        assert len(s) > 0


def create_scenarios() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()

    def unpack():
        ccys = {t.ccy for t in get_curve_ins() if isinstance(t, (IRS, OIS))}
        bumps = [-0.0001, 0.0001]
        for ccy in sorted(list(ccys)):
            for bump in bumps:
                yield f3.CreateYieldCurveParallelShiftScenario(
                    Currency=ccy.name,
                    ShiftAmount=bump,
                ).named(f3scenario_single(ccy, bump))

    return list(unpack())


def create_meeting_dates() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()

    def unpack():
        yield f3.CreateParameterInstrumentType(
            ParameterName='USDOIS',
            ParameterType='MeetingTimes',
        ).named('USDOIS-MeetingTimes')

        yield f3.CreateParameterInstrumentType(
            ParameterName='ECB',
            ParameterType='MeetingTimes',
        ).named('ECB-MeetingTimes')

    return list(unpack())


def create_future_instrument_types() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()

    def unpack():
        yield f3.CreateCollateralizedInstrumentType(
            Underlying=f3.CreateFuturesInstrumentType(
                FuturesContractType='Standard',
                Underlying='EONIA',
            ),
            CollateralAgreement='FullyCollateralizedInEUR',
        ).named('EUR-Futures-EONIA')

    return list(unpack())


def create_ccs_index(ccy: Ccy, tenor: Tenor) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    float_leg_ind, fix_leg_conv, not_exch_conv, float_leg_conv = F3_CCS_CONVENTIONS[ccy]
    ccy_pair = ccy_to_f3pair(ccy)
    f3_tenor = f3quote_spec_by_tenor(tenor)
    unadj_swap_index = f3.CreateSwapRateIndex(SwapMaturity=f3_tenor,
                                              Currency=str(ccy),
                                              FixedLegConventions=fix_leg_conv,
                                              FloatingRateIndex=f'{float_leg_ind} * {ccy_pair}',
                                              FloatingLegConventions=float_leg_conv,
                                              CollateralAgreement='ZeroCollateral')

    spot_fx_rate_index = f3.CreateIndex(ccy_pair)
    unadj_swap_with_fx_index = f3.CreateRatioIndex(unadj_swap_index, spot_fx_rate_index)

    forward_fx_rate_index = f3.CreateSwapRateIndex(SwapMaturity=f3_tenor,
                                                   Currency=str(ccy),
                                                   FixedLegConventions='NoSchedule',
                                                   FloatingRateIndex=ccy_pair,
                                                   FloatingLegConventions='NoSchedule',
                                                   CollateralAgreement='ZeroCollateral')

    fixed_leg_annuity_index = f3.CreateSwapRateIndex(SwapMaturity=f3_tenor,
                                                     Currency=str(ccy),
                                                     FixedLegConventions=fix_leg_conv,
                                                     FloatingRateIndex=1,
                                                     FloatingLegConventions='NoSchedule',
                                                     CollateralAgreement='ZeroCollateral')

    fx_rate_diff_index = f3.CreateSummationIndex([spot_fx_rate_index, forward_fx_rate_index], [1, -1])
    annuity_index = f3.CreateRatioIndex(fixed_leg_annuity_index, spot_fx_rate_index)
    adjustment_index = f3.CreateProductIndex([fx_rate_diff_index, annuity_index])
    final_index = f3.CreateSummationIndex([unadj_swap_with_fx_index, adjustment_index], [1, -1])
    unit_index = f3.CreateIndex(1)

    for i in range(int(str(tenor)[:-1])):
        final_index = f3.CreateProductIndex([final_index, unit_index])

    return final_index


def create_ccs_pvbp_index(ccy: Ccy, tenor: Tenor) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    float_leg_ind, fix_leg_conv, not_exch_conv, float_leg_conv = F3_CCS_CONVENTIONS[ccy]
    f3_tenor = f3quote_spec_by_tenor(tenor)
    unit_index = f3.CreateIndex(1)

    front_back_conv = f3.CreateInhomogeneousMarketConvention(MainConvention='NoSchedule',
                                                             RollConventions='NoSchedule',
                                                             PeriodLengths='0d')

    front_back_index = f3.CreateSwapRateIndex(SwapMaturity=f3_tenor,
                                              Currency=str(ccy),
                                              FixedLegConventions='NoSchedule',
                                              FloatingRateIndex=1,
                                              FloatingLegConventions=front_back_conv,
                                              CollateralAgreement='ZeroCollateral')

    inv_df_final_index = f3.CreateSummationIndex([front_back_index, unit_index], [1, -1])

    df_final_over_pvbp_index = f3.CreateSwapRateIndex(SwapMaturity=f3_tenor,
                                                      Currency=str(ccy),
                                                      FixedLegConventions=fix_leg_conv,
                                                      FloatingRateIndex=1,
                                                      FloatingLegConventions='NoSchedule',
                                                      CollateralAgreement='ZeroCollateral')

    inv_pvbp_index = f3.CreateProductIndex([inv_df_final_index, df_final_over_pvbp_index])
    return f3.CreateRatioIndex(unit_index, inv_pvbp_index)


def create_ccs_swaption_static_data() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()

    def unpack():
        for ccy in CCS_SWAPTION_CCY:
            for t in CCS_SWAPTION_TENORS:
                index_name = get_ccs_index_name(ccy, t)
                pvbp_index_name = get_ccs_pvbp_index_name(ccy, t)
                ins_type_name = f3instrument_type(CCSSwaption(ccy, Tenor.T_1Y, t))
                yield create_ccs_index(ccy, t).named(index_name)
                yield create_ccs_pvbp_index(ccy, t).named(pvbp_index_name)
                yield f3.CreateVanillaOptionInstrumentType(UnderlyingIndex=index_name).named(ins_type_name)

    return list(unpack())


def create_securities_static_data() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()

    def unpack():
        for s in Security:
            yield f3.CreateEquityEntity(
                Entity=s.name,
                Currency=s.ccy.name
            ).named(f3_security_entity(s))
            yield f3.CreateSimpleEquityAssetIndex(
                Currency=s.ccy.name,
                SettlementConventions='NoSchedule'
            ).named(f3_security_index(s))

    return list(unpack())


def create_bond_types_static_data() -> List[F3Object]:
    f3 = firm_f3.f3client.get_platform_client()

    def unpack():
        ccy = Ccy.KRW
        roll_months = 3
        holidays = ['Seoul']
        settlement_term = '1b'
        krw_smc = f3.CreateSimpleMaturityCalculator(
            HolidayConventions=holidays
        )
        krw_fdm = f3.CreateFollowingDateModifier(
            UnderlyingDateModifier='NullModifier',
            HolidayConventions=holidays,
            AllowMonthChange=True
        )
        krw_mmc = f3.CreateModifyingMaturityCalculator(
            UnderlyingMaturityCalculator=krw_smc,
            DateModifier=krw_fdm
        )
        yield f3.CreateSettlementMarketConvention(
            PaymentHolidays=holidays,
            MaturityCalculator=krw_mmc,
            SettlementMaturityDescriptor=settlement_term,
            SettlementMaturityCalculator=krw_mmc
        ).named(f3_bond_settlement_convention(ccy))
        krw_smc = f3.CreateMonthlyScheduleMarketConvention(
            UnderlyingConventions='NoScheduleNoHolidays',
            RollLength=roll_months,
            StubType='ShortStubAtStart',
            RollDayModifier='NullModifier',
            DayCountConvention='WholeMonths'
        )
        yield f3.CreateFixedCouponBondType(
            SettlementConvention=['TradeToStartDate', f3_bond_settlement_convention(ccy)],
            YieldConvention='ISMA-99',
            AccrualConvention='ISMA-99',
            Currency=ccy.name,
            MarketConventions=krw_smc
        ).named(f3_bond_type(ccy))

    return list(unpack())


if __name__ == '__main__':
    check_staticdata()

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\tenor_schedule.py
----------------------------------------
from typing import List

from math import floor


class TenorSchedule:
    dateptrs: List[int]

    def __init__(self, points: List[int]):
        assert all(isinstance(p, int) for p in points)
        self.dateptrs = points

    def get_f3_years(self) -> List[float]:
        return [i / 365 for i in self.dateptrs]


def create_tenor_schedule(yrs_end: float) -> TenorSchedule:
    daily = {int(i) for i in range(0, 31)}
    weekly = {i * 7 for i in range(0, 28)}
    monthly = {i / 12 for i in range(0, 12 * 100 + 1)}  # monthly up to 200 years
    monthly = {int(p * 365 + 0.5) for p in monthly}
    days = sorted(daily | weekly | monthly)
    days = [d for d in days if d / 365.25 < yrs_end]
    return TenorSchedule(days)


def test_create_tenor_schedule():
    pass


def tenor_to_days(tenor: str) -> int:
    tenor = tenor.upper()
    a, b = int(tenor[:-1]), tenor[-1]
    if b == 'D':
        return a
    elif b == 'W':
        return a * 7
    elif b == 'M':
        mult = 1 / 12
    elif b == 'Y':
        mult = 1
    else:
        raise Exception(f"error parsing {tenor}")
    return int(a * mult * 365 + 0.5)


def get_tenor_representation(numeric: float) -> str:
    def is_divisible_by(val, denominator):
        return (val + 1e-6) % denominator <= 2e-6

    def round(val):
        return floor(val + 0.5)

    if numeric < 1e-6:
        return "0D"

    if is_divisible_by(numeric, 1):
        return "%iY" % round(numeric)

    if is_divisible_by(numeric * 12, 1):
        return "%iM" % round(numeric * 12)

    if is_divisible_by(numeric * 52, 1):
        return "%iW" % round(numeric * 52)

    if is_divisible_by(numeric * 365.25, 1):
        return "%iD" % round(numeric * 365.25)

    raise Exception(f"Unable to find tenor for value {numeric}")


def test_get_tenor_representation():
    assert get_tenor_representation(9.99999999999) == "10Y"
    assert get_tenor_representation(9.99999999999) == "10Y"
    assert get_tenor_representation(1 / 12) == "1M"
    assert get_tenor_representation(15 / 12) == "15M"
    assert get_tenor_representation(1.00000001) == "1Y"
    assert get_tenor_representation(0.9999999) == "1Y"
    assert get_tenor_representation(5 / 52) == "5W"
    assert get_tenor_representation(3 / 365.25) == "3D"
    assert get_tenor_representation(1 / 365.25) == "1D"
    assert get_tenor_representation(0 / 365.25) == "0D"

    # conflicting:
    assert get_tenor_representation(0.25) == "3M"  # also 13W
    assert get_tenor_representation(0.5) == "6M"  # also 126W
    assert get_tenor_representation(1) == "1Y"  # also 12M
    assert get_tenor_representation(1.3333333333333333) == "16M"  # also 487D

    assert get_tenor_representation(tenor_to_days("5D")) == "5D"
    assert get_tenor_representation(tenor_to_days("487D")) == "16M"
    assert get_tenor_representation(tenor_to_days("7D")) == "7D"
    assert get_tenor_representation(tenor_to_days("1W")) == "1W"

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\version.py
----------------------------------------
import os
from typing import Optional


def read_version() -> Optional[str]:
    filename = os.path.join(os.path.dirname(__file__), '__version__')
    try:
        with open(filename, mode='r', encoding='utf-8') as f:
            return f.read()
    except:
        return None


__version__ = read_version()


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\__init__.py
----------------------------------------
from .version import __version__

# monkey patch to make atom2 backward compatible
try:
    from atom_client.client import AtomClient
    import atom_client.client
except ImportError:
    pass
else:
    atom_client.client.firmDataClient = AtomClient

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\.idea\.gitignore
----------------------------------------
# Default ignored files
/shelf/
/workspace.xml
# Editor-based HTTP Client requests
/httpRequests/
# Datasource local storage ignored files
/dataSources/
/dataSources.local.xml
# Zeppelin ignored files
/ZeppelinRemoteNotebooks/

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\.idea\firm_f3.iml
----------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<module type="PYTHON_MODULE" version="4">
  <component name="NewModuleRootManager">
    <content url="file://$MODULE_DIR$" />
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
  <component name="PyDocumentationSettings">
    <option name="format" value="PLAIN" />
    <option name="myDocStringFormat" value="Plain" />
  </component>
</module>
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\.idea\misc.xml
----------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.8 (tensorflow_nn)" project-jdk-type="Python SDK" />
</project>
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\.idea\modules.xml
----------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectModuleManager">
    <modules>
      <module fileurl="file://$PROJECT_DIR$/.idea/firm_f3.iml" filepath="$PROJECT_DIR$/.idea/firm_f3.iml" />
    </modules>
  </component>
</project>
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\.idea\workspace.xml
----------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AutoImportSettings">
    <option name="autoReloadType" value="SELECTIVE" />
  </component>
  <component name="ChangeListManager">
    <list default="true" id="1a224582-b82f-4c6f-b0d3-72034196ff02" name="Changes" comment="" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="ProjectId" id="2U4LZHjtFu7RYbM75VhiIAbqtnd" />
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent"><![CDATA[{
  "keyToString": {
    "RunOnceActivity.ShowReadmeOnStart": "true",
    "WebServerToolWindowFactoryState": "false",
    "last_opened_file_path": "C:/Users/generich/OneDrive/Documents/dev/systematic",
    "node.js.detected.package.eslint": "true",
    "node.js.detected.package.tslint": "true",
    "node.js.selected.package.eslint": "(autodetect)",
    "node.js.selected.package.tslint": "(autodetect)",
    "vue.rearranger.settings.migration": "true"
  }
}]]></component>
  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="1a224582-b82f-4c6f-b0d3-72034196ff02" name="Changes" comment="" />
      <created>1692193959422</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1692193959422</updated>
      <workItem from="1692193960871" duration="3305000" />
    </task>
    <servers />
  </component>
  <component name="TypeScriptGeneratedFilesManager">
    <option name="version" value="3" />
  </component>
</project>
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\.idea\inspectionProfiles\profiles_settings.xml
----------------------------------------
<component name="InspectionProjectProfileManager">
  <settings>
    <option name="USE_PROJECT_PROFILE" value="false" />
    <version value="1.0" />
  </settings>
</component>
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\.idea\inspectionProfiles\Project_Default.xml
----------------------------------------
<component name="InspectionProjectProfileManager">
  <profile version="1.0">
    <option name="myName" value="Project Default" />
    <inspection_tool class="DuplicatedCode" enabled="true" level="WEAK WARNING" enabled_by_default="true">
      <Languages>
        <language minSize="144" name="Python" />
      </Languages>
    </inspection_tool>
    <inspection_tool class="PyCompatibilityInspection" enabled="true" level="WARNING" enabled_by_default="true">
      <option name="ourVersions">
        <value>
          <list size="1">
            <item index="0" class="java.lang.String" itemvalue="3.11" />
          </list>
        </value>
      </option>
    </inspection_tool>
  </profile>
</component>
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\core\crud.py
----------------------------------------
from typing import Dict, Any, List
from f3sdk.lib.coroutine import wait
import firm_f3.f3client
from .error import F3PlatformError, F3ObjectNotFoundError, F3MultipleObjectsFoundError, F3ObjectOperationError


async def get_many_async(endpoint: str, query: Dict[str, Any] = None) -> List[Dict]:
    f3 = firm_f3.f3client.get_platform_client()
    if query and isinstance(query.get('include_f3ml'), bool):
        query['include_f3ml'] = str(query['include_f3ml']).lower()
    try:
        return await f3.Platform.Object.get(endpoint, params=query)
    except Exception as e:
        raise F3PlatformError(f"Failed to get from {endpoint} with query {query}") from e


async def get_one_async(endpoint: str, query: Dict[str, Any] = None) -> Dict:
    res = await get_many_async(endpoint=endpoint, query=query)

    if isinstance(res, list):
        if len(res) == 0:
            raise F3ObjectNotFoundError(f"No object found from {endpoint} with query {query}")
        elif len(res) > 1:
            raise F3MultipleObjectsFoundError(f"{len(res)} objects found from {endpoint} with query {query}")
        res = res[0]
    return res


async def create_async(endpoint: str, new_obj: Dict) -> Dict:
    f3 = firm_f3.f3client.get_platform_client()
    try:
        response = await f3.Platform.Object.post(endpoint, json_obj=new_obj)
    except Exception as e:
        raise F3PlatformError(f"Failed to post to {endpoint} with new_obj {str(new_obj)[:500]}") from e

    if "slug" in response:
        return response
    raise F3ObjectOperationError(f"Failed to post to {endpoint} with new_obj {str(new_obj)[:500]}: {response}")


async def update_async(endpoint: str, new_obj: Dict, query: Dict[str, Any] = None) -> Dict:
    f3 = firm_f3.f3client.get_platform_client()
    try:
        response = await f3.Platform.Object.put(endpoint, json_obj=new_obj, params=query)
    except Exception as e:
        raise F3PlatformError(
            f"Failed to put to {endpoint} with new_obj {str(new_obj)[:500]} with query {query}") from e

    if "slug" in response:
        return response
    raise F3ObjectOperationError(f"Failed to put to {endpoint} with new_obj {str(new_obj)[:500]}: {response}")


async def update_or_create_async(object_type: str, name: str, query=None, new_obj=None, f3ml=None):
    f3 = firm_f3.f3client.get_platform_client()
    existing_obj = await f3.Platform.Object.get(f"{object_type}/",
                                                params={"name": name, **(query or {}), "include_f3ml": "true"})
    if not existing_obj:
        new_obj = {"name": name, "definition": f3ml} if f3ml else new_obj
        return await create_async(endpoint=object_type, new_obj=new_obj)
    elif f3ml and existing_obj[0]["definition"] == f3ml:
        return existing_obj[0]
    else:
        new_obj = {"name": existing_obj[0]["name"], "definition": f3ml} if f3ml else new_obj
        return await update_async(endpoint=f'{object_type}/{existing_obj[0]["slug"]}', new_obj=new_obj)


async def delete_one_async(endpoint: str, query: Dict[str, Any]) -> Dict:
    f3 = firm_f3.f3client.get_platform_client()
    obj = await get_one_async(endpoint=endpoint, query=query)
    slug = obj['slug']
    if not endpoint.endswith(slug):
        endpoint = f'{endpoint}/{slug}'

    try:
        response = await f3.Platform.Object.delete(endpoint)
    except Exception as e:
        raise F3PlatformError(f"Failed to delete from {endpoint} with query {query}") from e

    if "errors" in response:
        raise F3ObjectOperationError(f"Failed to delete from {endpoint} with query {query}: {response}")
    return response


async def delete_many_async(endpoint: str, query: Dict[str, Any]) -> List[Dict]:
    f3 = firm_f3.f3client.get_platform_client()
    objects = await get_many_async(endpoint=endpoint, query=query)
    assert isinstance(objects, list)

    res = []
    for obj in objects:
        url = f"{endpoint}/{obj['slug']}"
        try:
            response = await f3.Platform.Object.delete(url)
        except Exception as e:
            raise F3PlatformError(f"Failed to delete from {url} with query {query}") from e

        if "errors" in response:
            raise F3ObjectOperationError(f"Failed to delete from {url} with query {query}: {response}")
        res.append(response)

    return res


# region synchronous versions

def get_many(endpoint: str, query: Dict[str, Any] = None) -> List[Dict]:
    return wait(get_many_async(endpoint=endpoint, query=query))


def get_one(endpoint: str, query: Dict[str, Any] = None) -> Dict:
    return wait(get_one_async(endpoint=endpoint, query=query))


def create(endpoint: str, new_obj=None) -> Dict:
    return wait(create_async(endpoint=endpoint, new_obj=new_obj))


def update(endpoint: str, new_obj: Dict, query: Dict[str, Any] = None) -> Dict:
    return wait(update_async(endpoint=endpoint, new_obj=new_obj, query=query))


def update_or_create(object_type: str, name: str, query=None, new_obj=None, f3ml=None):
    return wait(update_or_create_async(object_type, name, query, new_obj, f3ml))


def delete_one(endpoint: str, query: Dict[str, Any]) -> Dict:
    return wait(delete_one_async(endpoint=endpoint, query=query))


def delete_many(endpoint: str, query: Dict[str, Any]) -> List[Dict]:
    return wait(delete_many_async(endpoint=endpoint, query=query))


MAX_SEMAPHORE_COUNT = 100

# endregion

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\core\decorators.py
----------------------------------------
from firm_domain.util.decorators import *

__all__ = [k for k, v in globals().items() if getattr(v, '__module__', '').startswith('firm_domain')]

import warnings

WARNING_MESSAGE = """
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                            !!
!! WARNING firm_f3.core.decorators is moved to firm_domain.util.decorators    !!
!! please update your import statement accordingly                            !!
!!                                                                            !!
!! Make sure to run ``pip install firm-domain`` in terminal                   !!
!! Details for migration:                                                     !!
!!     http://firm-bitbucket:7990/projects/firmSSL/repos/firm-domain/browse   !!
!!                                                                            !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"""
print(WARNING_MESSAGE)
warnings.warn(WARNING_MESSAGE, DeprecationWarning)
try:
    __IPYTHON__  # type: ignore
except NameError:
    pass
else:
    input('Press any key to confirm ...')

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\core\endpoints.py
----------------------------------------
# Endpoints by Category

# Authentication and User Management API
Token = 'token'
Identity = 'identity'
User = 'user'
Role = 'role'
Permission = 'permission'
RolePermission = 'role_permission'
UserRole = 'user_role'
License = 'license'
LicenseActivation = 'license_activation'
LicenseInfo = 'license_info'

# Trades API
TradeTemplate = 'trade_template'
Trade = 'trade'
TradeState = 'trade_state'
Book = 'book'
TradeCollection = 'trade_collection'
Position = 'position'

# Models API
ModelFragment = 'model_fragment'
ModelFragmentScript = 'model_fragment_script'
ModelRecipe = 'model_recipe'
ModelStream = 'model_stream'
ModelSnapshot = 'model_snapshot'

# Market Data API
IndexFixings = 'index_fixings'
MarketDataStream = 'market_data_stream'
MarketDataSnapshot = 'market_data_snapshot'
CurveDisplay = 'curve_display'

# Securities API
SecurityTemplate = 'security_template'
SecurityBond = 'security/bond'
SecurityCommodity = 'security/commodity'
SecurityEquity = 'security/equity'
SecurityFutures = 'security/futures'
SecurityGeneric = 'security/generic'
Index = 'index'
SecurityInfo = 'security_info'
SecurityOption = 'security/option'

# Scenarios API
ScenarioTemplate = 'scenario_template'
Scenario = 'scenario'
ScenarioSetStream = 'scenario_set_stream'
ScenarioSnapshot = 'scenario_set_snapshot'

# Reference Data Management API
ReferenceCounterParty = 'reference/counterparty'
ReferenceEntity = 'reference/entity'
SystemEnvironmentData = 'system_environment_data/system_environment_data'

# Integration API
Integration = 'integration'

# Tasks API
Task = 'task'
ValuationStream = 'valuation_stream'

# Utilities API
Utility = 'utility'
ExecuteF3ml = 'executef3ml'
DataManagement = 'data_management'
Grid = 'grid'

# Valuations API
ValuationSpecification = 'valuation_specification'
PortfolioValuationStrategy = 'portfolio_valuation_strategy'
PnlOperation = 'pnl_operation'
LiquidationRule = 'liquidation_rule'

# Business Calendar API

EoxStream = 'eox_stream'
EoxWorkspace = 'eox_workspace'
EoxWorkspaceCommand = 'eox_workspace_command'

# Custom Endpoints API
Route = 'route'
Custom = 'custom'

# Supporting API
Currency = 'currency'
Label = 'label'
ObjectAudit = 'object_audit'
SysInfo = 'sysinfo'
CustomFunction = 'custom_function'
Configuration = 'configuration'

# Risk Summary Report API
RiskSummaryRule = 'risk_summary/rule'
RiskSummaryMapping = 'risk_summary/mapping'
RiskSummaryEnrichedRiskInstrument = 'risk_summary/enriched_risk_instrument'

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\core\error.py
----------------------------------------
class F3PlatformError(RuntimeError):
    pass


class F3ObjectNotFoundError(RuntimeError):
    pass


class F3MultipleObjectsFoundError(RuntimeError):
    pass


class F3ObjectOperationError(RuntimeError):
    pass


class F3ObjectMissingRequiredFieldError(RuntimeError):
    pass


class F3ObjectAlreadyExistsError(RuntimeError):
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\core\extension.py
----------------------------------------
from __future__ import annotations
from typing import List
from f3sdk.f3.f3object import F3Object


class F3ObjectExt(F3Object):
    type: str
    uid: int
    f3ml: List[str]

    def __init__(self, object_type: str, f3ml: List[str], uid: int = None):
        super().__init__(object_type, f3ml, uid)

    def form_f3ml(self) -> List[str]:
        # noinspection PyUnresolvedReferences
        return super().form_f3ml()

    def to_f3_object(self) -> F3Object:
        # noinspection PyArgumentList
        return F3Object(self.type, self.f3ml)

    @classmethod
    def from_f3_object(cls, f3obj: F3Object) -> F3ObjectExt:
        # noinspection PyUnresolvedReferences
        return cls(f3obj.type, f3obj.f3ml)

    def replace_f3ml(self, old: str, new: str) -> F3ObjectExt:
        def new_f3ml():
            for i in self.form_f3ml():
                yield i.replace(old, new)

        return type(self)(self.type, list(new_f3ml()))


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\core\modelutils.py
----------------------------------------
import datetime
from typing import Union
from functools import singledispatch
from f3sdk.lib.coroutine import wait  # type: ignore
from f3sdk.f3 import F3Object  # type:ignore

from firm_f3.core.endpoints import ModelSnapshot
from firm_domain.util.datehelper import datetime2date
from firm_f3.core.crud import get_one_async
import firm_f3.f3client  # type:ignore


async def get_model_snapshot_async(**query) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    if 'slug' in query:
        slug = query['slug']
    else:
        res = await get_one_async(ModelSnapshot, query=query)
        slug = res['slug']
    return await f3.Platform.Object.Get("Model", str(slug))


def get_model_snapshot(**query) -> F3Object:
    return wait(get_model_snapshot_async(**query))


async def get_model_by_slug_async(slug: int) -> F3Object:
    return await get_model_snapshot_async(slug=slug)


def get_model_by_slug(slug: int) -> F3Object:
    return wait(get_model_by_slug_async(slug=slug))


@singledispatch
async def _dispatcher(ref_or_slug: Union[int, str] = "prd", *args, **kwargs) -> F3Object:
    raise TypeError(f'invalid argument type {type(ref_or_slug)}')


@_dispatcher.register
async def _dispatch_by_slug(slug: int, *args, **kwargs) -> F3Object:
    return await get_model_by_slug_async(slug)


@_dispatcher.register
async def _dispatch_by_ref(
        ref: str = "prd",
        stream_type: str = 'intraday',
        as_of: datetime.datetime = None,
        _model_type: str = 'Model'
) -> F3Object:
    name = f'{_model_type}Stream_{ref}'
    if stream_type:
        name += f'_{stream_type}'

    if as_of is None:
        as_of = datetime.datetime.now()
    return await get_model_snapshot_async(name=name, sort_by='-ordering_timepoint', limit=1,
                                          **{'valuation_date:lte': datetime2date(as_of).isoformat()})


async def get_model_by_ref_async(
        ref: str = "prd",
        stream_type: str = 'intraday',
        as_of: datetime.datetime = None,
) -> F3Object:
    return await _dispatch_by_ref(ref, stream_type=stream_type, as_of=as_of, _model_type='Model')


def get_model_by_ref(
        ref: str = "prd",
        stream_type: str = 'intraday',
        as_of: datetime.datetime = None,
) -> F3Object:
    return wait(get_model_by_ref_async(ref=ref, stream_type=stream_type, as_of=as_of))


async def get_risk_model_by_ref_async(
        ref: str = "prd",
        stream_type: str = 'intraday',
        as_of: datetime.datetime = None,
        fx_points_model: bool = False,
) -> F3Object:
    model_type = 'FxRisk_Model' if fx_points_model else 'Risk_Model'
    return await _dispatch_by_ref(ref, stream_type=stream_type, as_of=as_of, _model_type=model_type)


def get_risk_model_by_ref(
        ref: str = "prd",
        stream_type: str = 'intraday',
        as_of: datetime.datetime = None,
        fx_points_model: bool = False,
) -> F3Object:
    return wait(
        get_risk_model_by_ref_async(ref=ref, stream_type=stream_type, as_of=as_of, fx_points_model=fx_points_model))


async def get_model_async(
        ref: Union[int, str] = "prd",
        stream_type: str = 'intraday',
        as_of: Union[datetime.datetime, datetime.date, None] = None,
) -> F3Object:
    return await _dispatcher(ref, stream_type=stream_type, as_of=as_of, _model_type='Model')


def get_model(
        ref: Union[int, str] = "prd",
        stream_type: str = 'intraday',
        as_of: Union[datetime.datetime, datetime.date, None] = None,
) -> F3Object:
    return wait(get_model_async(ref=ref, stream_type=stream_type, as_of=as_of))


async def get_risk_model_async(
        ref: Union[int, str] = "prd",
        stream_type: str = 'intraday',
        as_of: datetime.datetime = None,
) -> F3Object:
    return await _dispatcher(ref, stream_type=stream_type, as_of=as_of, _model_type='Risk_Model')


def get_risk_model(
        ref: Union[int, str] = "prd",
        stream_type: str = 'intraday',
        as_of: datetime.datetime = None,
) -> F3Object:
    return wait(get_risk_model_async(ref=ref, stream_type=stream_type, as_of=as_of))


def get_slug_from_model(model: F3Object) -> int:
    if isinstance(model.uid, str):
        return int(model.uid.rpartition('/')[-1])
    raise ValueError('model given in argument is not a platform model')


def create_tail(ref: str, stream_type: str) -> str:
    tail = ref
    if stream_type:
        tail += f'_{stream_type}'
    return tail


USE_NONSTANDARD_COLLAPSED_COMPOUNDING = False # BI-5410: USD libor model exhibits unexpected behaviour with implied libor discounting curves


def create_collapsed_compounding_valspec() -> Union[F3Object, str]:
    if USE_NONSTANDARD_COLLAPSED_COMPOUNDING:
        f3 = firm_f3.f3client.get_platform_client()
        valspec = f3.CreateUbiquitousCollapsedCompoundingRateValuationSpecification(
            UnderlyingValuationMethod='Default', OvernightRatesOnly=True)
        return valspec
    else:
        return "CollapsedCompounding"


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\core\orm.py
----------------------------------------
from __future__ import annotations
from typing import TypeVar, List, Dict
import datetime
import logging
import asyncio
from dataclasses import dataclass, field
from collections import defaultdict

import dateutil
import pandas
from f3sdk.f3 import F3Object  # type: ignore
from f3sdk.lib.coroutine import wait  # type: ignore

from firm_f3.core import endpoints
from firm_f3.util import f3ml
from firm_domain import Instrument, Tenor, IMM, FutureExpiry, Month
from .crud import get_many_async, get_one_async, create_async, update_async, delete_one_async
from .error import F3ObjectNotFoundError, F3ObjectMissingRequiredFieldError, F3ObjectAlreadyExistsError
from .modelutils import get_model_snapshot_async


class _MissingType:
    def __repr__(self):
        return '<_MISSING_>'

    def __bool__(self):
        return False


MISSING = _MissingType()
F3Obj = TypeVar('F3Obj', bound='F3PlatformObject')


@dataclass
class F3PlatformObject:
    name: str = field(default=MISSING)
    slug: int = field(default=MISSING, compare=False)
    description: str = field(repr=False, default=MISSING)
    is_deleted: bool = field(repr=False, default=MISSING, compare=False)
    created_by: int = field(repr=False, default=MISSING, compare=False)
    modified_by: int = field(repr=False, default=MISSING, compare=False)
    created_utc: datetime.datetime = field(repr=False, default=MISSING, compare=False)
    modified_utc: datetime.datetime = field(repr=False, default=MISSING, compare=False)

    logger = logging.getLogger(__name__)
    _required_fields = ()

    def __post_init__(self):
        if self.slug is not MISSING:
            self.slug = int(self.slug)
        if self.created_utc is not MISSING:
            self.created_utc = dateutil.parser.parse(self.created_utc)
        if self.modified_utc is not MISSING:
            self.modified_utc = dateutil.parser.parse(self.modified_utc)

    def init(self, **kwd):
        try:
            # noinspection PyArgumentList
            self.__init__(**kwd)
        except Exception as e:
            self.logger.error(self, exc_info=e)
            return kwd

    def clean_all(self):
        pass

    @classmethod
    async def get_many_async(cls, **query) -> List[F3Obj]:
        endpoint = getattr(endpoints, cls.__name__)
        res = await get_many_async(endpoint, query=query)
        return [cls(**i) for i in res]

    @classmethod
    def get_many(cls, **query) -> List[F3Obj]:
        return wait(cls.get_many_async(**query))

    @classmethod
    async def get_one_async(cls, **query) -> F3Obj:
        endpoint = getattr(endpoints, cls.__name__)
        res = await get_one_async(endpoint, query=query)
        return cls(**res)

    @classmethod
    def get_one(cls, **query) -> F3Obj:
        return wait(cls.get_one_async(**query))

    async def delete_async(self) -> F3Obj:
        endpoint = getattr(endpoints, type(self).__name__)
        res = await delete_one_async(endpoint, {'slug': self.slug})
        return self.init(**res) or self

    def delete(self) -> F3Obj:
        return wait(self.delete_async())

    def _raw_query(self) -> Dict:
        return {'name': self.name}

    async def save_async(self, force: bool = True) -> F3Obj:
        if not self._required_fields:
            raise NotImplementedError

        self.clean_all()

        def unpack():
            for k in self._required_fields:
                v = getattr(self, k)
                if v:
                    yield k, v

        new_obj = dict(unpack())
        missing_fields = set(self._required_fields) - set(new_obj)
        if missing_fields:
            raise F3ObjectMissingRequiredFieldError(f'missing required field values for {missing_fields}')
        endpoint = getattr(endpoints, type(self).__name__)

        try:
            curr_obj = await get_one_async(endpoint, query=self._raw_query())
        except F3ObjectNotFoundError:
            res = await create_async(endpoint, new_obj=new_obj)
        else:
            if force:
                res = await update_async(f'{endpoint}/{curr_obj["slug"]}', new_obj=new_obj)
            else:
                raise F3ObjectAlreadyExistsError(new_obj)

        return self.init(**res) or self

    def save(self, force: bool = True) -> F3Obj:
        return wait(self.save_async(force=force))

    async def fetch_details_from_platform_async(self, **query) -> F3Obj:
        if self.slug:
            query['slug'] = self.slug
        if self.name:
            query['name'] = self.name
        assert query, 'cannot fetch object with empty query'
        endpoint = getattr(endpoints, type(self).__name__)
        res = await get_one_async(endpoint, query=query)
        return self.init(**res) or self

    def fetch_details_from_platform(self, **query) -> F3Obj:
        return wait(self.fetch_details_from_platform_async(**query))

    async def to_dict_async(self, meta_data: bool = False) -> Dict:
        raise NotImplementedError

    def to_dict(self, meta_data: bool = False) -> Dict:
        return wait(self.to_dict_async(meta_data=meta_data))

    async def to_series_async(self) -> pandas.Series:
        raw = await self.to_dict_async(meta_data=True)
        name = raw.pop('_name')
        return pandas.Series(raw, name=name)

    def to_series(self) -> pandas.Series:
        return wait(self.to_series_async())

    async def to_frame_async(self) -> pandas.DataFrame:
        sr = await self.to_series_async()
        return sr.to_frame()

    def to_frame(self) -> pandas.DataFrame:
        return wait(self.to_frame_async())


@dataclass
class IndexFixings(F3PlatformObject):
    index_name: str = field(repr=False, default=MISSING)
    clean_name: str = field(repr=False, default=MISSING)
    fixings_data: list = field(repr=False, default=MISSING)
    fixings_data_length: int = field(repr=False, default=MISSING)

    is_deleted: bool = field(repr=False, default=MISSING, init=False)

    _required_fields = (
        'name',
        'index_name',
        'fixings_data',
    )

    @classmethod
    async def get_many_by_instruments_async(cls, instruments: List[Instrument],
                                            as_of_date: datetime.date = None) -> IndexFixingsCollection:
        from firm_f3.mapping import f3index
        index2inst_map = {f3index(i): i for i in instruments}
        query = {'name:in': ','.join(f'{i}_Fixing_prd_intraday' for i in index2inst_map)}
        res = await cls.get_many_async(**query)
        fixings = IndexFixingsCollection(res)
        fixings.instrument_map = index2inst_map
        fixings.as_of_date = as_of_date
        return fixings

    async def to_dict_async(self, meta_data: bool = False) -> Dict:
        data = self.fixings_data
        if not data:
            endpoint = getattr(endpoints, type(self).__name__)
            res = await get_one_async(f'{endpoint}/{self.slug}')
            data = self.fixings_data = res['fixings_data']
            for i in data:
                i['fixing_date'] = dateutil.parser.parse(i['fixing_date']).date()

        raw = {i['fixing_date']: i['fixing_value'] for i in data}
        if meta_data:
            raw['_name'] = self.index_name
        return raw


class IndexFixingsCollection(list):
    as_of_date: datetime.date = None
    instrument_map: Dict[str, Instrument] = {}

    async def to_frame_async(self) -> pandas.DataFrame:
        raw = await asyncio.gather(*(i.to_series_async() for i in self))
        df = pandas.DataFrame(raw).T.sort_index()
        df.columns = [self.instrument_map.get(i, i) for i in df.columns]
        df = df.loc[:self.as_of_date].iloc[-200:]
        return df

    def to_frame(self) -> pandas.DataFrame:
        return wait(self.to_frame_async())


@dataclass
class ModelRecipe(F3PlatformObject):
    object_version: int = field(default=MISSING, compare=False)
    is_active: bool = field(repr=False, default=MISSING)
    label_slugs: str = field(repr=False, default=MISSING)
    base_model: str = field(repr=False, default=MISSING)
    fixings_groups: str = field(repr=False, default=MISSING)
    model_components: str = field(repr=False, default=MISSING)
    fixings_requirements: list = field(repr=False, default=MISSING)
    market_data_requirements: list = field(repr=False, default=MISSING)
    model_fragment_slugs: List[int] = field(repr=False, default=MISSING)

    _required_fields = (
        'name',
        'description',
        'fixings_requirements',
        'market_data_requirements',
        'model_fragment_slugs'
    )

    def __post_init__(self):
        super().__post_init__()
        if self.model_fragment_slugs:
            self.model_fragment_slugs = list(map(int, self.model_fragment_slugs))

    @property
    def index_fixing_slugs(self) -> List[int]:
        return [int(i['index_fixings_slug']) for i in self.fixings_requirements]

    @index_fixing_slugs.setter
    def index_fixing_slugs(self, slugs: List[int]):
        self.fixings_requirements = [{"index_fixings_slug": i, "max_past_days": 10_000} for i in slugs]

    async def get_index_fixings_async(self) -> List[IndexFixings]:
        slugs = ','.join(map(str, self.index_fixing_slugs))
        return await IndexFixings.get_many_async(**{'slug:in': slugs})

    def get_index_fixings(self) -> List[IndexFixings]:
        return wait(self.get_index_fixings_async())

    @property
    def market_data_stream_slugs(self) -> List[int]:
        return [int(i['market_data_stream_slug']) for i in self.market_data_requirements]

    @market_data_stream_slugs.setter
    def market_data_stream_slugs(self, slugs: List[int]):
        self.market_data_requirements = [{"market_data_stream_slug": i, "max_snapshot_age": 365} for i in slugs]

    async def get_market_data_streams_async(self) -> List[MarketDataStream]:
        slugs = ','.join(map(str, self.market_data_stream_slugs))
        return await MarketDataStream.get_many_async(**{'slug:in': slugs})

    def get_market_data_streams(self) -> List[MarketDataStream]:
        return wait(self.get_market_data_streams_async())


@dataclass
class _F3MLObject(F3PlatformObject):
    definition: str = field(repr=False, default=MISSING)

    def __post_init__(self):
        super().__post_init__()
        if isinstance(self.definition, F3Object):
            # noinspection PyUnresolvedReferences
            self.definition = ''.join(self.definition.form_f3ml())


@dataclass
class ModelFragment(_F3MLObject):
    object_version: int = field(default=MISSING, compare=False)
    is_active: bool = field(repr=False, default=MISSING)
    label_slugs: str = field(repr=False, default=MISSING)
    external_id: int = field(repr=False, default=MISSING)
    script_input_query: str = field(repr=False, default=MISSING)
    model_fragment_script_slug: int = field(repr=False, default=MISSING)

    description: str = field(repr=False, default=MISSING, init=False)
    _required_fields = (
        'name',
        'definition',
    )


@dataclass
class _F3SnapshotObject(_F3MLObject):
    format: str = field(repr=False, default=MISSING)
    is_active: bool = field(repr=False, default=MISSING)
    label_slugs: str = field(repr=False, default=MISSING)
    external_id: int = field(repr=False, default=MISSING)
    validation_errors: str = field(repr=False, default=MISSING)
    validation_status: str = field(repr=False, default=MISSING)
    ordering_timepoint: datetime.datetime = field(repr=False, default=MISSING, compare=False)

    def __post_init__(self):
        super().__post_init__()
        if isinstance(self.ordering_timepoint, str):
            self.ordering_timepoint = dateutil.parser.parse(self.ordering_timepoint)

    def clean_all(self):
        if not self.ordering_timepoint:
            self.ordering_timepoint = datetime.datetime.utcnow()

    async def get_f3ml_async(self, inplace: bool = False) -> str:
        new = await self.get_one_async(slug=self.slug, include_f3ml=True)
        if inplace:
            self.definition = new.definition
        return new.definition

    def get_f3ml(self, inplace: bool = False) -> str:
        return wait(self.get_f3ml_async(inplace=inplace))


@dataclass
class ModelSnapshot(_F3SnapshotObject):
    input_f3ml: str = field(repr=False, default=MISSING)
    base_model: str = field(repr=False, default=MISSING)
    model_stream_slug: int = field(repr=False, default=MISSING)
    model_recipe_slug: int = field(repr=False, default=MISSING)
    eox_date: datetime.date = field(repr=False, default=MISSING)
    model_recipe_version: int = field(repr=False, default=MISSING)
    valuation_date: datetime.date = field(default=MISSING)
    market_data_snapshots: List[int] = field(repr=False, default=MISSING)

    _required_fields = (
        'name',
        'model_stream_slug',
        'format',
        'input_f3ml',
        'valuation_date',
        'ordering_timepoint',
    )

    def __post_init__(self):
        super().__post_init__()
        if self.model_recipe_slug:
            self.model_recipe_slug = int(self.model_recipe_slug)
        if self.model_stream_slug:
            self.model_stream_slug = int(self.model_stream_slug)
        if self.market_data_snapshots:
            self.market_data_snapshots = list(map(int, self.market_data_snapshots))
        if isinstance(self.valuation_date, str):
            self.valuation_date = dateutil.parser.parse(self.valuation_date).date()

    def clean_all(self):
        if isinstance(self.input_f3ml, F3Object):
            self.input_f3ml = ''.join(self.input_f3ml.form_f3ml())
        if self.model_recipe_slug:
            self.format = 'model_recipe'
        elif self.input_f3ml:
            self.format = 'f3ml'
        super().clean_all()

    def _raw_query(self) -> Dict:
        return {'slug': self.slug or -1}

    async def get_model_async(self) -> F3Object:
        assert self.slug
        return await get_model_snapshot_async(slug=self.slug)

    def get_model(self) -> F3Object:
        return wait(self.get_model_async())


@dataclass
class MarketDataSnapshot(_F3SnapshotObject):
    original_json: str = field(repr=False, default=MISSING)
    market_data_stream_slug: int = field(repr=False, default=MISSING)

    def __post_init__(self):
        super().__post_init__()
        if self.market_data_stream_slug:
            self.market_data_stream_slug = int(self.market_data_stream_slug)

    async def to_dict_async(self, meta_data: bool = False) -> Dict:
        src = self.definition
        if not src:
            src = await self.get_f3ml_async(inplace=True)
        [[name]], *rows = list(f3ml.parse(src, 'v'))

        if 'Swaption' in name:
            [exp], [tnr], [strike], values, *_ = rows
            name += '@' + ':'.join(map(str, strike))
            raw = {(Tenor.parse(e), Tenor.parse(t)): v for e, val in zip(exp, values) for t, v in zip(tnr, val)}
        elif '-ATMStraddle' in name:
            exp, val, _ = rows
            raw = {Tenor.parse(e): v for [e], [v] in zip(exp, val)}
        elif any(i in name for i in ('-RR-', '-BF-')):
            exp, val, strike = rows
            raw = {(s, Tenor.parse(e)): v for [e], [v], (s, _) in zip(exp, val, strike)}
        elif '-IMMFRA-' in name:
            [idx], [val] = rows
            raw = dict(zip(map(IMM.parse, idx), val))
        elif '-Futures-' in name:
            [idx], [val] = rows
            raw = dict(zip(map(FutureExpiry.parse, idx), val))
        elif 'Seasonality' in name:
            [[val]] = rows
            if len(val) == 4:
                idx = (f'Q{i + 1}' for i in range(4))  # quarterly seasonality
            else:
                idx = Month
            raw = dict(zip(idx, val))
        elif name == 'UniqueFXRates':
            [[tag]], [idx], [val] = rows
            name = f'{name}:{tag}'
            raw = dict(zip(idx, val))
        else:
            [idx], [val], *tag = rows
            if tag:
                inst, rest = tag[0][0]
                assert name == inst
                name = f'{inst}:{rest}'
            raw = dict(zip(map(Tenor.parse, idx), val))

        if meta_data:
            raw['_name'] = name
        return raw

    async def to_frame_async(self) -> pandas.DataFrame:
        raw = await self.to_dict_async(meta_data=True)
        name = raw.pop('_name')
        if 'Swaption' in name:
            data = defaultdict(dict)
            for (exp, tnr), val in raw.items():
                data[tnr][exp] = val
            df = pandas.DataFrame(data)
            df.columns.name = name
            return df
        elif any(i in name for i in ('-RR-', '-BF-')):
            data = defaultdict(dict)
            for (stk, exp), val in raw.items():
                data[stk][exp] = val
            df = pandas.DataFrame(data)
            df.columns.name = name
            return df
        return pandas.Series(raw, name=name).to_frame()


class _F3StreamObject(F3PlatformObject):
    _snapshot_cls = None

    async def get_latest_async(self) -> type(_snapshot_cls):
        assert self.slug
        assert self._snapshot_cls
        endpoint = getattr(endpoints, type(self).__name__)
        res = await get_one_async(f'{endpoint}/{self.slug}/latest')
        return self._snapshot_cls(**res)

    def get_latest(self) -> type(_snapshot_cls):
        return wait(self.get_latest_async())


@dataclass
class ModelStream(_F3StreamObject):
    label_slugs: str = field(repr=False, default=MISSING)
    owner_user_id: int = field(repr=False, default=MISSING)
    model_recipe_slug: int = field(repr=False, default=MISSING)
    model_stream_type: str = field(repr=False, default=MISSING)
    expiration_period_days: int = field(repr=False, default=MISSING)

    _snapshot_cls = ModelSnapshot
    _required_fields = (
        'name',
    )

    def __post_init__(self):
        super().__post_init__()
        if self.model_recipe_slug:
            self.model_recipe_slug = int(self.model_recipe_slug)


@dataclass
class MarketDataStream(_F3StreamObject):
    clean_name: str = field(repr=False, default=MISSING)
    expiration_period_days: int = field(repr=False, default=MISSING)

    _snapshot_cls = MarketDataSnapshot

    async def to_dict_async(self, meta_data: bool = False) -> Dict:
        snap = await self.get_latest_async()
        return await snap.to_dict_async(meta_data=meta_data)

    async def to_frame_async(self) -> pandas.DataFrame:
        snap = await self.get_latest_async()
        return await snap.to_frame_async()

    @classmethod
    async def get_many_by_instruments_async(cls, instruments: List[Instrument],
                                            as_of_date: datetime.date = None) -> MarketDataStreamCollection:
        from firm_domain import Swaption
        [inst] = instruments
        assert isinstance(inst, Swaption)
        idx = str(inst.idx).lower() if isinstance(inst.idx, Tenor) else ''
        res = await cls.get_many_async(**{'name:like': f'\%{inst.ccy}Swaption{idx}\%_prd_intraday'})
        streams = MarketDataStreamCollection(res)
        streams.as_of_date = as_of_date
        return streams


class MarketDataStreamCollection(list):
    as_of_date: datetime.date = None

    async def to_frame_async(self) -> pandas.DataFrame:
        async def job(stream: MarketDataStream) -> pandas.DataFrame:
            df = await stream.to_frame_async()
            _, _, strike_str = df.columns.name.partition('@')
            _, _, strike = strike_str.partition(':')
            df.columns = pandas.MultiIndex.from_product([[float(strike)], df.columns])
            return df

        res = await asyncio.gather(*(job(i) for i in self))
        return pandas.concat(list(res), axis=1).T.sort_index().T.sort_index()


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\core\progress_monitor.py
----------------------------------------
import enum
from typing import Optional, Union, Dict


class Status(enum.Enum):
    RUNNING = enum.auto()
    STOPPING = enum.auto()
    CANCELLED = enum.auto()
    FINISHED = enum.auto()


class ProgressMonitor:
    param: Dict[str, str]
    __status: Status

    def __init__(self):
        self.__status = Status.RUNNING
        self.param = dict()

    def set_param(self, key: str, value: str):
        self.param[key] = value

    def mark_complete(self) -> None:
        assert not self.is_complete
        self.__status = Status.FINISHED if self.__status == Status.RUNNING else Status.CANCELLED

    def cancel(self) -> None:
        self.__status = Status.STOPPING

    @property
    def is_stopping(self) -> bool:
        return self.__status == Status.STOPPING

    @property
    def is_complete(self) -> bool:
        return self.__status == Status.CANCELLED or self.__status == Status.FINISHED

    @property
    def status(self) -> Status:
        return self.__status

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\core\__init__.py
----------------------------------------

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\core\__pycache__\decorators.cpython-37.pyc
----------------------------------------
B

    y  d                   @   sf   d dl T dd  e     D  Zd dlZdZee  e  ee  ye	 W n e
k
rX   Y n
X e
d  dS )      ) *c             C   s&   g | ]\}}t |d d  d r| qS ) 
__module__  Z
firm_domain)  getattr 
startswith) .0 k v  r
    HE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/core/decorators.py 
<listcomp>   s    r   Na+  
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                            !!
!! WARNING firm_f3.core.decorators is moved to firm_domain.util.decorators    !!
!! please update your import statement accordingly                            !!
!!                                                                            !!
!! Make sure to run ``pip install firm-domain`` in terminal                   !!
!! Details for migration:                                                     !!
!!     http://firm-bitbucket:7990/projects/firmSSL/repos/firm-domain/browse   !!
!!                                                                            !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
zPress any key to confirm ...)Zfirm_domain.util.decorators  globals items  __all__ warningsZWARNING_MESSAGE print warn DeprecationWarningZ
__IPYTHON__ 	NameError inputr
   r
   r
   r
    <module>   s   

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\core\__pycache__\endpoints.cpython-37.pyc
----------------------------------------
B

    y  d 	                  @   s  d Z dZdZdZdZdZdZd Z dZd	Z	d
Z
d
Z
dZd
Z
dZdZdZdZdZdZdZdZdZdZdZdZdZdZdZdZdZdZd Z d!Z!d"Z"d#Z#d$Z$d%Z%d&Z&d'Z'd(Z(d)Z)d*Z*d+Z+d,Z,d-Z-d.Z.d/Z/d0Z0d1Z1d2Z2d3Z3d4Z4d5Z5d6Z6d7Z7d8Z8d9Z9d:Z:d;Z;d<Z<d=Z=d>Z>d?Z?d@Z@dAZAdBS )C token identity userZroleZ
permissionZrole_permissionZ	user_role  licenseZlicense_activationZlicense_infoZtrade_template tradeZ
trade_state bookZtrade_collection positionZmodel_fragmentZmodel_fragment_scriptZmodel_recipeZmodel_streamZmodel_snapshotZ
index_fixingsZmarket_data_streamZmarket_data_snapshotZ
curve_displayZsecurity_templatez
security/bondzsecurity/commodityzsecurity/equityzsecurity/futureszsecurity/generic indexZ
security_infozsecurity/optionZscenario_templateZscenarioZscenario_set_streamZscenario_set_snapshotzreference/counterpartyzreference/entityz/system_environment_data/system_environment_dataZ
integration taskZvaluation_streamZ utilityZ
executef3mlZdata_management gridZvaluation_specificationZportfolio_valuation_strategyZ
pnl_operationZliquidation_ruleZ
eox_streamZ
eox_workspaceZeox_workspace_commandZrouteZcustom currency labelZobject_auditZ sysinfoZcustom_function 
configurationzrisk_summary/rulezrisk_summary/mappingz%risk_summary/enriched_risk_instrumentN)B TokenZIdentityZUserZRoleZ
PermissionZRolePermissionZUserRole  LicenseZLicenseActivationZ
LicenseInfoZ
TradeTemplateZTradeZ
TradeStateZBookZTradeCollectionZPositionZ
ModelFragmentZModelFragmentScriptZ
ModelRecipeZ
ModelStreamZ
ModelSnapshotZIndexFixingsZMarketDataStreamZMarketDataSnapshotZCurveDisplayZSecurityTemplateZSecurityBondZSecurityCommodityZSecurityEquityZSecurityFuturesZSecurityGeneric IndexZSecurityInfoZSecurityOptionZScenarioTemplateZScenarioZScenarioSetStreamZScenarioSnapshotZReferenceCounterPartyZReferenceEntityZSystemEnvironmentDataZ
Integration TaskZValuationStreamZ UtilityZ
ExecuteF3mlZDataManagementZGridZValuationSpecificationZPortfolioValuationStrategyZPnlOperationZLiquidationRuleZ	EoxStreamZEoxWorkspaceZEoxWorkspaceCommandZRouteZCustomZCurrency LabelZ
ObjectAuditZ SysInfoZCustomFunction 
ConfigurationZRiskSummaryRuleZRiskSummaryMappingZ!RiskSummaryEnrichedRiskInstrument  r   r    GE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/core/endpoints.py <module>   s    
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\core\__pycache__\error.cpython-37.pyc
----------------------------------------
B

    y  dT                  @   sd   G d d  de  ZG dd  de  ZG dd  de  ZG dd   d e  ZG dd	  d	e  ZG d
d
  d
e  ZdS )
c               @   s   e Zd ZdS ) F3PlatformErrorN) __name__ 
__module__ __qualname__  r   r    CE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/core/error.pyr      s   r   c               @   s   e Zd ZdS ) F3ObjectNotFoundErrorN)r   r   r   r   r   r   r   r       s   r    c               @   s   e Zd ZdS ) F3MultipleObjectsFoundErrorN)r   r   r   r   r   r   r   r   	   s   r   c               @   s   e Zd ZdS ) F3ObjectOperationErrorN)r   r   r   r   r   r   r   r	   
   s   r	   c               @   s   e Zd ZdS ) !F3ObjectMissingRequiredFieldErrorN)r   r   r   r   r   r   r   r
      s   r
   c               @   s   e Zd ZdS ) F3ObjectAlreadyExistsErrorN)r   r   r   r   r   r   r   r
      s   r
   N)  RuntimeErrorr   r    r   r	   r
   r
   r   r   r   r    <module>   s
   
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\core\__pycache__\extension.cpython-37.pyc
----------------------------------------
B

    y  d                   @  s@   d dl mZ d dlmZ d dlmZ G dd  de Ze dkr<d S )     ) 
annotations) List) F3Objectc                  s    e Zd ZU ded< ded< ded< ddddd   fd	d
 
Zdd
   fdd
 Zdd
 dd Ze dd d dd  Zddd d dd Z	   Z
S ) 
F3ObjectExt str type int uidz	List[str] f3mlN) 
object_typer
   r	   c               s   t    |||  d S )N) super __init__) selfr
   r
   r	   ) 	__class__   GE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/core/extension.pyr
   
   s    zF3ObjectExt.__init__) returnc               s
   t      S )N)r    	form_f3ml)r   )r   r   r   r      s    zF3ObjectExt.form_f3mlr   c             C  s   t | j| j S )N)r   r    r
   )r   r   r   r    to_f3_object   s    zF3ObjectExt.to_f3_object) f3objr   c             C  s   | |j |j S )N)r    r
   ) clsr   r   r   r    from_f3_object   s    zF3ObjectExt.from_f3_object) old newr   c               s&       fdd }t    j t|    S )Nc              3  s$   x     D ]} |      V  q
W d S )N)r     replace) i)r   r   r   r   r    new_f3ml   s    z*F3ObjectExt.replace_f3ml.<locals>.new_f3ml)r     list)r   r   r   r   r   )r   r   r   r    replace_f3ml   s    zF3ObjectExt.replace_f3ml)N)
 __name__ 
__module__ __qualname__ __annotations__r
   r   r    
classmethodr   r    
__classcell__r   r   )r   r   r      s   
r    __main__N) 
__future__r    typingr   Zf3sdk.f3.f3objectr   r   r   r   r   r   r    <module>   s
   
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\core\__pycache__\__init__.cpython-37.pyc
----------------------------------------
B

    y  d                    @   s   d S )N  r   r   r    FE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/core/__init__.py <module>        
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\datalayer\bbg_mapping.py
----------------------------------------
from firm_domain.datalayer.bbg_mapping import *

__all__ = [k for k, v in globals().items() if getattr(v, '__module__', '').startswith('firm_domain')]

import warnings

WARNING_MESSAGE = """
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                                        !!
!! WARNING firm_f3.datalayer.bbg_mapping is moved to firm_domain.datalayer.bbg_mapping    !!
!! please update your import statement accordingly                                        !!
!!                                                                                        !!
!! Make sure to run ``pip install firm-domain`` in terminal                               !!
!! Details for migration:                                                                 !!
!!     http://firm-bitbucket:7990/projects/firmSSL/repos/firm-domain/browse               !!
!!                                                                                        !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"""
print(WARNING_MESSAGE)
warnings.warn(WARNING_MESSAGE, DeprecationWarning)
try:
    __IPYTHON__  # type: ignore
except NameError:
    pass
else:
    input('Press any key to confirm ...')

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\datalayer\bbg_stream.py
----------------------------------------
from __future__ import annotations
import datetime
from functools import partial
from collections import defaultdict
from dataclasses import dataclass, field
from typing import Dict, List

import pandas
from f3sdk.lib.coroutine import wait  # type: ignore
from atom_client.client import grpc  # type: ignore

from firm_f3.firm_data_client import firm_connect
from firm_domain import Ccy, Tenor, Instrument, Rate, FRA, FXForward, InflationSwap
from firm_domain.datalayer.bbg_mapping import bbg_code, RATES_TO_BBG, bbg_scale_factor, bbg_fx_point_scale_factor
from firm_f3.modelconfig import curve_config_tenors


class SynchronousMixIn:
    async def to_series_async(self) -> pandas.Series:
        raise NotImplementedError

    def to_series(self) -> pandas.Series:
        return wait(self.to_series_async())

    async def to_frame_async(self) -> pandas.DataFrame:
        raise NotImplementedError

    def to_frame(self) -> pandas.DataFrame:
        return wait(self.to_frame_async())


@dataclass
class BBGIndexFixings(SynchronousMixIn):
    instrument: Instrument
    bbg_ticker: str = field(init=False)
    as_of_date: datetime.date = None
    start_date: datetime.date = field(default=None, repr=False)

    def __post_init__(self):
        if self.as_of_date is None:
            self.as_of_date = datetime.date.today()
        if self.start_date is None:
            self.start_date = self.as_of_date - datetime.timedelta(days=200)
        assert self.as_of_date >= self.start_date
        self.bbg_ticker = bbg_code(self.instrument)

    @classmethod
    def get_many(cls, currency: Ccy = None, tenor: Tenor = None, as_of_date: datetime.date = None,
                 start_date: datetime.date = None) -> BBGIndexFixingsCollection:
        def unpack():
            for ccy, v in RATES_TO_BBG.items():
                if currency is None or ccy is currency:
                    for tnr, tkr in v.items():
                        if tenor is None or tnr is tenor:
                            yield BBGIndexFixings(Rate(ccy, tnr), as_of_date=as_of_date, start_date=start_date)

        return BBGIndexFixingsCollection(unpack())

    @classmethod
    async def get_many_by_instruments_async(cls, instruments: List[Instrument], as_of_date: datetime.date = None,
                                            start_date: datetime.date = None) -> BBGIndexFixingsCollection:
        def unpack():
            for inst in instruments:
                yield BBGIndexFixings(inst, as_of_date=as_of_date, start_date=start_date)

        return BBGIndexFixingsCollection(unpack())

    async def to_dict_async(self) -> Dict:
        firm = firm_connect()
        [res] = await firm.market_data.history_async(
            securities=[self.bbg_ticker],
            start_date_time=self.start_date.strftime('%Y%m%d'),
            stop_date_time=self.as_of_date.strftime('%Y%m%d'),
            field_list=['LAST_PRICE'],
        )
        if res.error:
            raise grpc.RpcError(res.error)

        def unpack():
            unit = bbg_scale_factor(self.instrument)
            for v in res.history:
                idx = datetime.datetime.fromtimestamp(v.date / 1000).date()
                [val] = v.data
                yield idx, val / unit

        return dict(unpack())

    async def to_series_async(self) -> pandas.Series:
        raw = await self.to_dict_async()
        return pandas.Series(raw, name=self.instrument).sort_index()


class BBGIndexFixingsCollection(list, SynchronousMixIn):
    def validate(self):
        assert all(isinstance(v, BBGIndexFixings) for v in self)
        assert len(set(v.start_date for v in self)) == 1
        assert len(set(v.as_of_date for v in self)) == 1

    async def to_dict_async(self) -> Dict:
        if not self:
            return {}

        self.validate()
        firm = firm_connect()
        res = await firm.market_data.history_async(
            securities=[v.bbg_ticker for v in self],
            start_date_time=self[0].start_date.strftime('%Y%m%d'),
            stop_date_time=self[0].as_of_date.strftime('%Y%m%d'),
            field_list=['LAST_PRICE'],
        )

        raw = defaultdict(dict)
        for inst, rv in zip((v.instrument for v in self), res):
            if rv.error:
                raise grpc.RpcError(rv.error)
            unit = bbg_scale_factor(inst)
            for v in rv.history:
                idx = datetime.datetime.fromtimestamp(v.date / 1000).date()
                [val] = v.data
                raw[inst][idx] = val / unit

        return raw

    async def to_frame_async(self) -> pandas.DataFrame:
        raw = await self.to_dict_async()
        return pandas.DataFrame(raw).sort_index()


@dataclass
class BBGMarketDataSnapshot(SynchronousMixIn):
    instruments: List[Instrument]
    as_of_date: datetime.date = None
    bbg_tickers: List[str] = field(init=False, repr=False)

    def __post_init__(self):
        self.bbg_tickers = list(map(bbg_code, self.instruments))

    @classmethod
    async def get_many_by_instruments_async(cls, instruments: List[Instrument],
                                            as_of_date: datetime.date = None) -> BBGMarketDataSnapshot:
        return cls(instruments, as_of_date=as_of_date)

    def inverse_ticker_map(self):
        return dict(zip(self.bbg_tickers, self.instruments))

    async def to_dict_async(self) -> Dict[Instrument, float]:
        firm = firm_connect()
        ticker_map = self.inverse_ticker_map()

        if self.as_of_date is None:
            res = await firm.market_data.latest_async(securities=self.bbg_tickers, field_list=['LAST_PRICE'])

            def unpack():
                for v in res:
                    if v.error:
                        raise grpc.RpcError(v.error)
                    unit = bbg_scale_factor(v.security)
                    yield ticker_map[v.security], v.field_values['LAST_PRICE'] / unit

        else:
            res = await firm.market_data.history_async(
                securities=self.bbg_tickers,
                start_date_time=self.as_of_date.strftime('%Y%m%d'),
                stop_date_time=self.as_of_date.strftime('%Y%m%d'),
                field_list=['LAST_PRICE'],
            )

            def unpack():
                for v in res:
                    if v.error:
                        raise grpc.RpcError(v.error)
                    [data] = v.history
                    unit = bbg_scale_factor(v.security)
                    yield ticker_map[v.security], data.data[0] / unit

        return dict(unpack())

    async def to_series_async(self) -> pandas.Series:
        raw = await self.to_dict_async()
        return pandas.Series(raw)


@dataclass
class BBGCurveMarketDataSnapshot(SynchronousMixIn):
    instrument: Instrument
    as_of_date: datetime.date = None
    tenors: List[Tenor] = field(default=None, repr=False)
    bbg_tickers: List[str] = field(init=False, repr=False)

    def __post_init__(self):
        if self.tenors is None:
            self.tenors = curve_config_tenors(self.instrument, ref_date=self.as_of_date)

        var_attr = 'start' if isinstance(self.instrument, FRA) else 'tenor'
        kwd = {k: v for k, v in vars(self.instrument).items() if k != var_attr}
        if isinstance(self.instrument, InflationSwap):
            # jchi@202002
            # ccy is implied for InflationSwap
            del kwd['ccy']
        inst_factory = partial(type(self.instrument), **kwd)
        if len(self.tenors) == 1:
            self.instrument = inst_factory(**{var_attr: self.tenors[0]})
        elif self.instrument.tenor is not None:
            self.instrument = inst_factory(**{var_attr: None})

        self.bbg_tickers = [bbg_code(inst_factory(**{var_attr: t})) for t in self.tenors]

    @classmethod
    async def get_many_by_instruments_async(cls, instruments: List[Instrument],
                                            as_of_date: datetime.date = None) -> BBGCurveMarketDataSnapshotCollection:
        def unpack():
            for inst in instruments:
                yield BBGCurveMarketDataSnapshot(inst, as_of_date=as_of_date)

        return BBGCurveMarketDataSnapshotCollection(unpack())

    def inverse_ticker_map(self):
        return dict(zip(self.bbg_tickers, self.tenors))

    async def to_dict_async(self) -> Dict[Tenor, float]:
        firm = firm_connect()
        ticker_map = self.inverse_ticker_map()
        if isinstance(self.instrument, FXForward):
            unit = bbg_fx_point_scale_factor(self.instrument)
        else:
            unit = bbg_scale_factor(self.instrument)

        if self.as_of_date is None:
            res = await firm.market_data.latest_async(securities=self.bbg_tickers, field_list=['LAST_PRICE'])

            def unpack():
                for v in res:
                    if v.error:
                        raise grpc.RpcError(v.error)
                    yield ticker_map[v.security], v.field_values['LAST_PRICE'] / unit

        else:
            res = await firm.market_data.history_async(
                securities=self.bbg_tickers,
                start_date_time=self.as_of_date.strftime('%Y%m%d'),
                stop_date_time=self.as_of_date.strftime('%Y%m%d'),
                field_list=['LAST_PRICE'],
            )

            def unpack():
                for v in res:
                    if v.error:
                        raise grpc.RpcError(v.error)
                    [data] = v.history
                    yield ticker_map[v.security], data.data[0] / unit

        return dict(unpack())

    async def to_series_async(self) -> pandas.Series:
        raw = await self.to_dict_async()
        return pandas.Series(raw, name=self.instrument).sort_index()


class BBGCurveMarketDataSnapshotCollection(list, SynchronousMixIn):
    def validate(self):
        assert all(isinstance(v, BBGCurveMarketDataSnapshot) for v in self)
        assert len(set(v.as_of_date for v in self)) == 1

    async def to_dict_async(self) -> Dict:
        if not self:
            return {}

        self.validate()
        firm = firm_connect()
        ticker_map = {k: v for i in self for k, v in i.inverse_ticker_map().items()}
        ticker_group = {k: i.instrument for i in self for k in i.bbg_tickers}
        raw = defaultdict(dict)

        if self[0].as_of_date is None:
            res = await firm.market_data.latest_async(
                securities=[v for i in self for v in i.bbg_tickers],
                field_list=['LAST_PRICE']
            )
            for v in res:
                if v.error:
                    raise grpc.RpcError(v.error)
                inst = ticker_group[v.security]
                idx = ticker_map[v.security]
                unit = bbg_fx_point_scale_factor(inst) if isinstance(inst, FXForward) else bbg_scale_factor(inst)
                raw[inst][idx] = v.field_values['LAST_PRICE'] / unit

        else:
            res = await firm.market_data.history_async(
                securities=[v for i in self for v in i.bbg_tickers],
                start_date_time=self[0].as_of_date.strftime('%Y%m%d'),
                stop_date_time=self[0].as_of_date.strftime('%Y%m%d'),
                field_list=['LAST_PRICE'],
            )
            for v in res:
                if v.error:
                    raise grpc.RpcError(v.error)
                inst = ticker_group[v.security]
                idx = ticker_map[v.security]
                [data] = v.history
                unit = bbg_fx_point_scale_factor(inst) if isinstance(inst, FXForward) else bbg_scale_factor(inst)
                raw[inst][idx] = data.data[0] / unit

        return raw

    async def to_frame_async(self) -> pandas.DataFrame:
        raw = await self.to_dict_async()
        return pandas.DataFrame(raw).sort_index()


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\datalayer\datalayer.py
----------------------------------------
import os
import glob
import time
import logging
from datetime import datetime, date, timedelta
from typing import Callable, Optional, List, Union, Dict, Tuple, cast, Sequence

import colorama
import numpy as np
import pandas as pd
from firm_domain.util.decorators import interface
from firm_f3.datalayer.mktdata_provider import MarketDataProvider, MarketDataProviderBpipe
from firm_f3.mapping import calc_quote
from firm_f3.util import timer
from colorama import Fore, Back
from f3sdk.lib.coroutine import wait

from firm_f3.firm_data_client import firm_connect
from firm_domain import Ccy, Tenor, Instrument, IRS, FXForward, XccyBasis, InflationIndex
from firm_domain.market_date import MarketDate
from firm_domain.datalayer.bbg_mapping import tenor_to_bbg, bbg_code, TRADE_AS_OUTRIGHT, bbg_scale_factor, CCY_PTS_SCALE

from .mappings import CHAT_MAPPINGS

colorama.init(autoreset=True)

logger = logging.getLogger(__name__)


def bbgfield(instrument, start=(datetime.now() - timedelta(days=365)).strftime('%Y%m%d'),
             end=datetime.now().strftime('%Y%m%d'), fields=['LAST_PRICE']):
    asset = bbg_code(instrument)
    firm = firm_connect('uat')
    results = firm.market_data.history([asset], start, end, fields)[0]
    # Populate a dataframe whose columns are asset+field
    df = pd.DataFrame(columns=fields)
    for day in results.history:
        date = time.strftime('%Y-%m-%d', time.localtime(day.date / 1e3))
        data = {}
        for idx, val in enumerate(day.data):
            data[fields[idx]] = val
        df.loc[date] = pd.Series(data)
    df.columns = [asset] * len(df.columns)
    df.columns = [m + n for m, n in zip([asset + "^"] * len(fields), fields)]
    return __datetimeindex(df)


@interface
def bbgfields(instruments, start=(datetime.now() - timedelta(days=365)).strftime('%Y%m%d'),
              end=datetime.now().strftime('%Y%m%d'), fields=['LAST_PRICE']):
    """Returns a dataframe that uses the inner join on the dates."""
    assets = [bbg_code(i) for i in instruments]
    df = pd.DataFrame()
    firm = firm_connect('uat')
    results = firm.market_data.history(assets, start, end, fields)
    for i in range(0, len(results)):
        dftemp = pd.DataFrame(columns=['%s' % assets[i]] * len(fields))
        dftemp.columns = [m + n for m, n in zip([assets[i] + "^"] * len(fields), fields)]
        for day in results[i].history:
            date = time.strftime('%Y-%m-%d', time.localtime(day.date / 1e3))
            data = {}
            for idx, val in enumerate(day.data):
                data[fields[idx]] = val
            dftemp.loc[date] = pd.Series(data).values
            # print('date=',date)
            # print(data)
            # print(dftemp)
        # print(dftemp)
        # print(assets[i])
        # print(['%s'%assets[i]]*len(fields))
        df = pd.concat([df, dftemp], axis=1, join='outer', sort="TRUE")
    df = df.dropna()
    return __datetimeindex(df)


def connection_test(instruments=None, start: str = None, end: str = None, fields: List[str] = None, env: str = 'prd',
                    print_errors: bool = True) -> bool:
    if start is None:
        start = (datetime.now() - timedelta(days=10)).strftime('%Y%m%d')
    if end is None:
        end = (datetime.now() - timedelta(days=5)).strftime('%Y%m%d')
    if fields is None:
        fields = ['LAST PRICE']
    if instruments is None:
        assets = ['USSW5 CURNCY']
    else:
        assets = [bbg_code(i) for i in instruments]
    firm = firm_connect(env)
    results = firm.market_data.history(assets, start, end, fields)

    has_error = False
    for i in range(0, len(results)):
        err = getattr(results[i], 'error', None)
        if print_errors:
            print(err)
        if err is not None:
            has_error = True
    return has_error


async def __get_last_available_market_data_snapshot_async(
        instruments: Union[List[str], List[Instrument]],
        eval_date: MarketDate,
        dataprovider: MarketDataProvider,
        field: str) -> Dict[str, float]:
    if len(instruments) == 0:
        return dict()
    kvpairs: List = []
    res = await bdh_async(instruments=instruments,
                          start=eval_date.timestamp - timedelta(days=30),
                          end=eval_date.timestamp,
                          dataprovider=dataprovider,
                          fields=[field])
    res = res.sort_index()
    for ins, sr in res.items():
        if len(sr) == 0:
            logger.warning(f'instrument={ins} unable to retrieve last available historical market data')
        else:
            last_date, last_val = sr.index[-1], sr[-1]
            days = (eval_date.timestamp.date() - last_date.date()).days
            logger.warning(f'instrument={ins} quote_date={last_date} stale for {days} days')
            last_val = float(last_val)  # conversion from numpy.float
            kvpairs.append((ins, last_val))

    out = dict(kvpairs)
    return out


class NoMarketDataException(Exception):
    pass


async def get_market_data_snapshot_async(instruments: Union[List[str], Sequence[Instrument]],
                                         eval_date: MarketDate,
                                         dataprovider: MarketDataProvider,
                                         field: str) -> Union[
    Dict[str, float], Dict[Instrument, float]]:
    try:
        with timer(f"get_market_data_snapshot_async date={eval_date}, instrument count={len(instruments)} ",
                   logstart=True, loglevel=logging.DEBUG):
            if len(instruments) == 0:
                return cast(Union[Dict[str, float], Dict[Instrument, float]], dict())
            if eval_date.is_latest_intraday:
                df = await bdp_async(instruments=instruments, dataprovider=dataprovider, fields=[field])
                dct = df.loc[0].to_dict() if len(df) > 0 else dict()

                missing_instruments = list(set(instruments) - set(dct))
                x = await __get_last_available_market_data_snapshot_async(missing_instruments,
                                                                          eval_date=eval_date,
                                                                          dataprovider=dataprovider,
                                                                          field=field)
                dct.update(x)
                return dct
            else:
                t = eval_date.timestamp
                drop_all_dates = lambda df: df.dropna(axis=1,
                                                      how='any')  # drop all dates for given instrument, if cell is NaN
                df = await bdh_async(instruments=instruments,
                                     start=t,
                                     end=t,
                                     nan_cleanup_function=drop_all_dates,
                                     dataprovider=dataprovider,
                                     fields=[field])
                if len(df) == 0:
                    raise NoMarketDataException(f"No market data found for date {t}")
                assert len(df) == 1
                for ix, row in df.iterrows():
                    ddd = row.to_dict()
                    return ddd
            raise Exception("unreachable")
    except Exception as ex:
        raise Exception("Error in get_market_data_snapshot_async") from ex


def __get_assets_cols_additionalpulls(instruments: Union[List[str], List[Instrument]],
                                      post_process: Optional[bool]) \
        -> Tuple[
            List[str],
            Union[List[str], List[Instrument]],
            List[str],
            bool
        ]:
    if not any(isinstance(i, str) for i in instruments):
        bbg_names = [bbg_code(i) for i in instruments]
        bbg_names = list(set([asset for sublist in bbg_names for asset in sublist]))  # flatten list of list
        if post_process is None:
            post_process = True

    else:
        bbg_names = instruments
        if post_process is None:
            post_process = False

    # wlai@20200707: pretty bad design, a datalayer should not have to know how to handle special cases for specific instruments
    # will not follow this pattern for IMMOIS and create thee logic inside the actual instrument.
    if post_process:
        additional_pulls = __bbg_add_pulls(instruments)
        additional_pulls = list(set([asset for sublist in additional_pulls for asset in sublist]))  # flatten list of list
    else:
        additional_pulls = []

    bbg_names = bbg_names + additional_pulls

    cols = instruments + additional_pulls

    logger.debug("Bloomberg codes to be loaded: " + Fore.MAGENTA + ",".join(str(a) for a in bbg_names))

    return bbg_names, cols, additional_pulls, post_process


def __bbg_add_pulls(ins: List[Instrument]) -> List[str]:
    add_flds = []

    for i in ins:
        if isinstance(i, FXForward):
            spot = FXForward(i.ccy, Tenor.SPOT, i.ccy_base)
            add_flds.append(bbg_code(spot))
        # if isinstance(i, IRS):
        #     if i.ccy is Ccy.JPY:
        # add_flds.append('JYJSLC{t} MTRT CURNCY'.format(t=tenor_to_bbg(i.tenor)))

        if type(i) == XccyBasis:
            xcb = cast(XccyBasis, i)
            if xcb.ccy == Ccy.KRW:
                add_flds.append(('KWSWNI{t} CMPT CURNCY'.format(t=tenor_to_bbg(xcb.tenor)),))
                add_flds.append(('KWSWN{t} CMPT CURNCY'.format(t=tenor_to_bbg(xcb.tenor)),))

    return add_flds


@interface
def bdp(instruments: Union[List[str], List[Instrument]],
        fields: List[str] = None,
        env: str = 'prd',
        dropna: bool = True,
        post_process: Optional[bool] = None,
        allow_missing: bool = False) -> pd.DataFrame:
    return wait(bdp_async(instruments=instruments,
                          fields=fields,
                          dataprovider=MarketDataProviderBpipe(env, allow_missing=allow_missing),
                          dropna=dropna,
                          post_process=post_process))


async def bdp_async(instruments: Union[List[str], List[Instrument]],
                    fields: Optional[List[str]] = None,
                    dataprovider: MarketDataProvider = MarketDataProviderBpipe('prd'),
                    dropna: bool = True,
                    post_process: Optional[bool] = None) -> pd.DataFrame:
    assert isinstance(instruments, list)
    if fields is None:
        fields = ['LAST_PRICE']
    assert len(fields) == 1, "Requesting multiple fields is not supported"

    bbg_names, cols, additional_pulls, post_process = __get_assets_cols_additionalpulls(instruments, post_process)

    quotes = await dataprovider.get_latest_async(set(bbg_names), fields[0])
    df = pd.DataFrame(columns=instruments, index=quotes.index)
    # TODO: Remove additional_pulls and remove the post process and let the calc_quote method handle
    for inst in instruments + additional_pulls:
        df[inst] = calc_quote(inst, quotes)

    if dropna:
        df = df.dropna(axis=1)
    if post_process:
        df = post_process_bbg(df, additional_pulls)
    return df


def parse_bbg_date(d: Optional[Union[datetime, str]]) -> Optional[datetime]:
    if d is None:
        return None
    if isinstance(d, datetime):
        return d
    return datetime.strptime(d, '%Y%m%d')


def __resolve_bdh_args(start: Optional[datetime],
                       end: Optional[datetime],
                       fields: Optional[List[str]]) -> Tuple[datetime, datetime, List[str]]:
    if start is None:
        logger.warning(Back.RED + "This functionality is deprecated: start date should be provided explicitly")
        start = datetime.now() - timedelta(days=365)
    if end is None:
        end = datetime.now()
    if fields is None:
        fields = ['LAST_PRICE']
    return start, end, fields


async def bdh_async(instruments: Union[List[str], Sequence[Instrument]],
                    start: datetime = None,
                    end: datetime = None,
                    fields: List[str] = None,
                    nan_cleanup_function: Callable[[pd.DataFrame], pd.DataFrame] = lambda df: df.dropna(),
                    dataprovider: MarketDataProvider = MarketDataProviderBpipe('prd'),
                    post_process: Optional[bool] = None) -> pd.DataFrame:
    """Returns a dataframe that uses the inner join on the dates."""
    assert isinstance(instruments, list)
    start, end, fields = __resolve_bdh_args(start, end, fields)
    assert len(fields) == 1, "Requesting multiple fields is not supported"

    assets, cols, additional_pulls, post_process = __get_assets_cols_additionalpulls(instruments, post_process)

    quotes = await dataprovider.get_history_async(set(assets), start, end, fields[0])
    df = pd.DataFrame(columns=instruments, index=quotes.index)
    # TODO: Remove additional_pulls and remove the post process and let the calc_quote method handle
    for inst in instruments + additional_pulls:
        df[inst] = calc_quote(inst, quotes)

    df = nan_cleanup_function(df)
    if post_process:
        df = post_process_bbg(df, additional_pulls)
        df = nan_cleanup_function(df)

    return df


@interface
def bdh(instruments: Union[List[str], List[Instrument]],
        start: Union[str, datetime] = None,
        end: Union[str, datetime] = None,
        fields: List[str] = None,
        nan_cleanup_function: Callable[[pd.DataFrame], pd.DataFrame] = lambda df: df.dropna(),
        env: str = 'prd',
        post_process: Optional[bool] = None) -> pd.DataFrame:
    return wait(bdh_async(instruments=instruments,
                          start=parse_bbg_date(start),
                          end=parse_bbg_date(end),
                          fields=fields,
                          nan_cleanup_function=nan_cleanup_function,
                          dataprovider=MarketDataProviderBpipe(env),
                          post_process=post_process))


@interface
def bbgsna(instruments,
           start=(datetime.now() - timedelta(days=365)).strftime('%Y%m%d'),
           end=datetime.now().strftime('%Y%m%d'),
           fields=['LAST_PRICE']):
    """Returns a dataframe that keeps empties."""
    assets = instruments
    df = pd.DataFrame()
    for asset in assets:
        start = parse_bbg_date(start)
        end = parse_bbg_date(end)
        df = pd.concat([df, wait(bdh_async([asset], start, end, fields))], axis=1, join='outer', sort="TRUE")
    return __datetimeindex(df)


def __bbgtick(instrument, start=(datetime.now() - timedelta(seconds=60)).strftime('%Y-%m-%dT%H:%M:%S'),
              end=datetime.now().strftime('%Y-%m-%dT%H:%M:%S'), env='prd'):
    """Takes an asset and a datetime, as well as an endtime, and returns the average price of the asset \
    during the period starting at the time.  Timezone is GMT"""
    asset = bbg_code(instrument)
    firm = firm_connect(env)
    results = firm.market_data.intraday([asset], start, end, ["TRADE"])[0]
    count = 0
    summ = 0
    for tick in results.ticks:
        summ = summ + tick.value
        count = count + 1
    if count != 0:
        return (summ / count)
    else:
        return np.nan


@interface
def bbgtt(instrument, start=(datetime.now() - timedelta(days=180)).strftime('%Y%m%d'),
          end=datetime.now().strftime('%Y%m%d'),
          time="01:30:30", period=30, fields=['LAST_PRICE']):
    """Takes an asset string, start date("20180101") string, end date("20181101")string,\
    a string representing time of day to take snapshot,
    a string period represented as a time period in seconds, and a field.
    Returns the daily average field(price) of the asset over the period, starting at the time."""
    asset = bbg_code(instrument)
    start = parse_bbg_date(start)
    end = parse_bbg_date(end)
    df = wait(bdh_async([asset], start=start, end=end, fields=fields))
    for indi in df.index:
        timestart = '%sT%s' % (indi, time)
        timeend = (datetime.strptime(timestart, "%Y-%m-%dT%H:%M:%S") + timedelta(
            seconds=period)).strftime("%Y-%m-%dT%H:%M:%S")
        df[asset][indi] = __bbgtick(asset, start=timestart, end=timeend)
    return __datetimeindex(df)


@interface
def bbgform(instruments, mults=0,
            start=(datetime.now() - timedelta(days=365)).strftime('%Y%m%d'),
            end=datetime.now().strftime('%Y%m%d'), fields=['LAST_PRICE']):
    """Runs a linear formula on bbg assets and returns that dataframe"""
    assets = instruments
    if (mults == 0):
        mults = [1] * len(assets)
    df = pd.DataFrame()
    start = parse_bbg_date(start)
    end = parse_bbg_date(end)
    for asset in assets:
        df = pd.concat([df, wait(bdh_async([asset], start, end, fields))], axis=1, join='outer', sort="TRUE")
    name = ''
    for i in range(0, len(assets)):
        if (i == 0):
            name = name + str(mults[i]) + '*' + assets[i]
        if (i > 0):
            name = name + " + " + str(mults[i]) + "*" + assets[i]
    df = df.dropna()
    df1 = pd.DataFrame(columns=[name], index=df.index)
    df1[name] = np.zeros(len(df))
    for i in range(0, len(assets)):
        df1[name] = df1[name] + df[assets[i]] * mults[i]
    return __datetimeindex(df1)


async def bbgform_async(instruments, mults=0, start=(datetime.now() - timedelta(days=365)).strftime('%Y%m%d'),
                        end=datetime.now().strftime('%Y%m%d'), fields=['LAST_PRICE']):
    """Runs a linear formula on bbg assets and returns that dataframe"""
    assets = instruments
    if (mults == 0):
        mults = [1] * len(assets)
    df = pd.DataFrame()
    start = parse_bbg_date(start)
    end = parse_bbg_date(end)
    for asset in assets:
        df = pd.concat([df, await(bdh_async([asset], start, end, fields))], axis=1, join='outer', sort="TRUE")
    name = ''
    for i in range(0, len(assets)):
        if (i == 0):
            name = name + str(mults[i]) + '*' + assets[i]
        if (i > 0):
            name = name + " + " + str(mults[i]) + "*" + assets[i]
    df = df.dropna()
    df1 = pd.DataFrame(columns=[name], index=df.index)
    df1[name] = np.zeros(len(df))
    for i in range(0, len(assets)):
        df1[name] = df1[name] + df[assets[i]] * mults[i]
    return __datetimeindex(df1)


@interface
def __datetimeindex(df: pd.DataFrame) -> pd.DataFrame:
    return df.set_index(pd.to_datetime(df.index))


def post_process_bbg(df: pd.DataFrame,
                     columns_to_remove: List[str]) -> pd.DataFrame:
    ret_df = df.copy()
    for c in df.columns:
        try:
            if isinstance(c, FXForward) and c.tenor != Tenor.SPOT and c.ccy not in TRADE_AS_OUTRIGHT:
                direction = 1 if c.tenor > Tenor.SPOT else -1
                code = FXForward(c.ccy, Tenor.SPOT, c.ccy_base)
                assert isinstance(ret_df[code], pd.Series)
                assert isinstance(df[c], pd.Series)
                ret_df[c] = ret_df[code] + df[c] * direction / CCY_PTS_SCALE[c.ccy_base, c.ccy]
            elif isinstance(c, XccyBasis):
                if c.ccy == Ccy.KRW:
                    ndirs = 'KWSWNI{t} CMPT CURNCY'.format(t=tenor_to_bbg(c.tenor))
                    nds = 'KWSWN{t} CMPT CURNCY'.format(t=tenor_to_bbg(c.tenor))
                    ret_df[c] = ret_df[nds] - ret_df[ndirs]
                    ret_df[c] = ret_df[c] / bbg_scale_factor(c) * bbg_scale_factor(IRS(Ccy.KRW, Tenor.T_1Y))
                else:
                    ret_df[c] = ret_df[c] / bbg_scale_factor(c)
            # elif isinstance(c, IRS):
            #     if c.ccy is Ccy.JPY:
            # basis = 'JYJSLC{t} MTRT CURNCY'.format(t=tenor_to_bbg(c.tenor))
            # ret_df[c] = ret_df[c] + ret_df[basis]
            elif isinstance(c, InflationIndex):
                if c == InflationIndex.CPURNSA:
                    only_cpurnsa = ret_df[c].dropna()
                    for i in only_cpurnsa.index:
                        ret_df.loc[pd.Timestamp(year=i.year, month=i.month, day=1), c] = only_cpurnsa[i]
                        ret_df.loc[i, c] = np.nan

            else:
                ret_df[c] = ret_df[c] / bbg_scale_factor(c)
        except Exception as ex:
             raise Exception(F"Unable to post-process BBG ticker {c}") from ex

    if len(columns_to_remove) > 0:
        columns_to_remove = [a for a in columns_to_remove if
                             a in ret_df.columns]  # do not attempt to drop non-existing columns
        ret_df = ret_df.drop(columns_to_remove, axis='columns')

    ret_df = ret_df.dropna(how='all').sort_index()
    return ret_df


@interface
def holiday_cal(file: str = 'firm_f3/datalayer/holidays.csv'):
    cal = pd.read_csv(file, dtype=str).apply(lambda x: pd.to_datetime(x)).to_dict(orient='list')
    ccy_dict = {c.name: c for c in Ccy}
    return {ccy_dict[k]: cal[k] for k in cal if k in ccy_dict}


def index_history(file: str = 'firm_f3/datalayer/Index_History.csv') -> Tuple[pd.DataFrame, pd.DataFrame]:
    idx_his = pd.read_csv(file, index_col=0)
    idx_his = __datetimeindex(idx_his)
    ind_val = idx_his[[c for c in idx_his.columns if '-Release' not in c]]
    ind_release = idx_his[[c for c in idx_his.columns if '-Release' in c]]
    cols = [getattr(InflationIndex, c) for c in ind_val.columns]
    ind_val.columns = cols
    ind_release.columns = cols
    return ind_val, ind_release


@interface
def send_chat(message: Union[pd.DataFrame, str],
              destination: str = 'Rates_Chat',
              env: str = 'prd') -> bool:
    client = firm_connect(env)
    conv_id = CHAT_MAPPINGS[destination]
    if type(message) == pd.DataFrame:
        content = message.to_html(justify='left').replace('border="1"', '')
    else:
        content = message
    return client.symphony.send_chat_message(content, conv_id)


def _sorter(t: str) -> int:
    tail = t.upper()[-1]
    body = t[:-1]
    if tail not in ['Y', 'M']:
        raise ValueError('Tenor supplied t <GO> not of type y or m'.format(t=t))
    if tail == 'Y':
        mult = 12
    else:
        mult = 1
    return int(body) * mult


def _process_surface(df: pd.DataFrame) -> Dict:
    expiry_list = sorted(df['Expiry'].unique(), key=_sorter)
    tenor_list = sorted(df['Tenor'].unique(), key=_sorter)
    gb_strike = df.groupby('Strike')
    by_strike = {x: gb_strike.get_group(x).drop('Strike', axis='columns') for x in gb_strike.groups}
    quotes = {}
    for x in by_strike:
        pivot = pd.pivot_table(by_strike[x], values='Quote', index=['Expiry'], columns='Tenor', aggfunc=np.sum)
        pivot = pivot.loc[expiry_list, tenor_list]
        quotes[x] = pivot.values.tolist()

    return {'tenor': tenor_list,
            'expiry': expiry_list,
            'quote': quotes}


def get_vol_surface() -> Dict:
    dir_path = os.path.dirname(os.path.realpath(__file__))
    list_of_files = glob.glob(dir_path + '/vol_snaps/*.csv')
    if not list_of_files:
        list_of_files = glob.glob('/local/vol_snaps/*.csv')
        if not list_of_files:
            return {}
    latest_file = max(list_of_files, key=os.path.getctime)
    df = pd.read_csv(latest_file)
    df['Quote'] = pd.to_numeric(df['Quote'])

    gb = df.groupby('CCY')
    dfs = {x: gb.get_group(x).drop('CCY', axis='columns') for x in gb.groups}

    results = {}
    for c in dfs:
        results[c] = _process_surface(dfs[c])

    return results

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\datalayer\datalayer_parsers.py
----------------------------------------
from typing import List, Union, Dict

import atom_client.data_frame
from atom_client.historic_market_data import HistoricMarketData
from atom_client.market_data import MarketData
from atom_client.time_query_response import TimeQueryResponse
from firm_domain import Instrument
from firm_domain.util import str2date, str2dateC, date2str

from firm_f3.logging import logger
from firm_f3.util import get_index_by_name, logging, ensure_dir_exists
from pandas import DataFrame, Series
import pandas
import time
from datetime import datetime


def parse_bdh_bpipe(results: HistoricMarketData,
                    assets: List[str]) -> DataFrame:
    subdfs = []

    for i, (result, asset) in enumerate(zip(results, assets)):
        if getattr(result, 'error', None) is not None:
            logging.error(asset)
            logging.error(result.error)
        dftemp_index = []
        dftemp_rows = []
        for day in result.history:
            date = time.strftime('%Y-%m-%d', time.localtime(day.date / 1e3))
            dftemp_index.append(date)
            if len(day.data) > 1:
                raise Exception("Parsing multiple fields is not supported")
            dftemp_rows.append(day.data)
        dftemp = DataFrame(dftemp_rows, index=dftemp_index, columns=[assets[i]])
        subdfs.append(dftemp)

    df = pandas.concat(subdfs, axis=1, join='outer', sort="TRUE") if len(subdfs) > 0 else DataFrame()
    df = df.set_index(pandas.to_datetime(df.index))
    return df


def parse_bdp_bpipe(results: List[MarketData],
                    field: str,
                    assets: List[str],
                    allow_missing: bool) -> DataFrame:
    data = {}
    err_res = []
    for res in results:
        try:
            data[res.security] = res.field_values[field]
        except (TypeError, KeyError):
            err_res.append(res)
    if err_res:
        if allow_missing:
            for res in err_res:
                if res.error:
                    logger.error(f'ticker="{res.security}" field="{field}" error={res.error}')
                elif not res.field_values:
                    logger.warning(f'ticker="{res.security}" field="{field}" returns None')
                else:
                    raise TypeError('should not reach this line, please check the code')
        else:
            err_msg = [f'Unable to process result for security {i.security}. Error is {i.error}' for i in err_res]
            raise ValueError(err_msg)
    df = Series({asset: data.get(asset) for asset in assets}).to_frame().T
    return df


def parse_bdp_onetick(results: Dict[str, TimeQueryResponse], allow_missing: bool) -> DataFrame:
    dictionary: Dict[str, float] = dict()
    for k, v in results.items():
        if v.error is not None:
            if allow_missing:
                logger.warning(v.error)
            else:
                raise ValueError(v.error)
        row = v.result.rows[0]
        price = row[get_index_by_name(v.result.columns, 'PRICE')]
        tick_time = row[get_index_by_name(v.result.columns, 'TICK_TIME')]
        logger.debug(f"bdp_onetick {k} {price} {tick_time}")
        dictionary[k] = price
    df = DataFrame([dictionary])
    return df


def parse_bdh_halftick(response: Dict[str, TimeQueryResponse],
                       assets: List[str]) -> DataFrame:
    try:
        columns2 = ['Date', 'Symbol', 'Payload']
        rows2 = []

        if len(response) > 0:
            for asset in assets:
                if asset not in response:
                    logger.warning(f"{asset} not found in response")
                    continue
                res = response[asset]
                if res.error is not None:
                    logger.error(res.error)
                result: atom_client.data_frame.DataFrame = res.result
                assert result.columns == columns2
                for row in result.rows:
                    date, asset, payload = tuple(row)
                    date = date2str(str2dateC(date))
                    payload = float(payload)
                    rows2.append([date, asset, payload])
            df0 = DataFrame(rows2, columns=columns2)
            df = pandas.pivot_table(df0, index='Date', columns='Symbol', values='Payload')
        else:
            df = DataFrame([], columns=assets)
        df.index.name = None
        df = df.set_index(pandas.to_datetime(df.index))
        return df
    except Exception as ex:
        raise Exception("Error in parse_bdh_halftick") from ex


def iso_date_time(t: Union[str, datetime]) -> str:
    """
    Returns date in format %Y-%m-%dT%H:%M:%S
    """
    if isinstance(t, datetime):
        o = datetime.strftime(t, '%Y-%m-%dT%H:%M:%S')
        return o
    if isinstance(t, str):
        ts = datetime.strptime(t, '%Y%m%d')
        o = datetime.strftime(ts, '%Y-%m-%dT%H:%M:%S')
        return o


def save_dataframe(df: DataFrame) -> None:
    ensure_dir_exists(r'c:\om\temp\prices')
    with open(r"c:\om\temp\prices\prices.txt", 'a') as writer:
        for date, row in df.iterrows():
            for key, value in row.items():
                print(date, key, value, sep='\t', file=writer)

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\datalayer\economics.py
----------------------------------------
import os
import datetime
import logging
from collections import defaultdict
import dateutil
import pandas
from firm_domain.util.datehelper import bump_workday
from typing import Tuple

SURVEY_DATES_HEADER_MAP = {
    'Consensus Forecasts Survey Dates': 'cf',
    'Asia Pacific Consensus Forecasts': 'ap',
    'Eastern Europe Consensus Forecasts': 'ee',
    'Latin American Consensus Forecasts': 'la'
}


def type_percent(x: str):
    try:
        x = float(x)
    except ValueError:
        return pandas.np.nan
    return x / 100


def type_billion(x: str):
    try:
        x = float(x)
    except ValueError:
        return pandas.np.nan
    return x * 1_000_000_000


def type_trillion(x: str):
    try:
        x = float(x)
    except ValueError:
        return pandas.np.nan
    return x * 1_000_000_000_000


def type_datetime(x: str):
    try:
        x = dateutil.parser.parse(x)
    except ValueError:
        return pandas.NaT
    return pandas.Timestamp(x)


def type_month(x: str):
    # jchi@201907
    # error should be raised if failure to parse month
    x = dateutil.parser.parse(x)
    return x.strftime('%Y-%m')


def read_csv_native(filepath: str, survey_dates: dict) -> Tuple[pandas.DataFrame, dict]:
    with open(filepath, 'r') as f:
        lines = f.read().split('\n')
    assert len(lines) > 6

    def clean_header(raw: str):
        for v in raw.split(',"'):
            if v:
                v = v[:-1]
            yield v

    des = list(clean_header(lines[0]))
    source = list(clean_header(lines[5]))
    tickers = lines[1].split(',')
    unit = lines[4].split(',')

    def meta_data():
        for t, d, u, s in zip(tickers, des, unit, source):
            if t:
                yield t, {'FDS_ECON_DESCRIPTION': d, 'FDS_ECON_UNIT': u, 'FDS_ECON_SOURCE': s}

    def clean_type():
        for i, (d, v) in enumerate(zip(des, unit)):
            v = v.strip()
            if v == 'Percent':
                yield type_percent
            elif v.endswith(' bn'):
                yield type_billion
            elif v.endswith(' tn'):
                yield type_trillion
            elif v == 'None' and 'Date' in d:
                yield type_datetime
            elif i == 0:
                yield type_month
            else:
                yield lambda x: x

    types = list(clean_type())

    def unpack():
        for line in lines[6:]:
            if line:
                row = [typ(v) for typ, v in zip(types, line.split(','))]
                survey_date = survey_dates[row[0]]
                assert isinstance(survey_date, datetime.datetime)
                # jchi@201907
                # assume release date is the 3rd weekday after survey date
                release_date = bump_workday(survey_date, 3)
                yield release_date, row[1:]

    index, arr = list(zip(*unpack()))
    frame = pandas.DataFrame(list(arr), index, columns=tickers[1:])
    return frame, dict(meta_data())


def read_csv(filepath: str, survey_dates: dict) -> Tuple[pandas.DataFrame, dict]:
    raw = pandas.read_csv(filepath, header=list(range(6)), index_col=0)

    def clean_index():
        for i in raw.index:
            month = dateutil.parser.parse(str(i)).strftime('%Y-%m')
            survey_date = survey_dates[month]
            release_date = bump_workday(survey_date, 3)
            yield pandas.Timestamp(release_date)

    raw.index = list(clean_index())
    meta_data = {}

    def clean_column():
        for (des, tkr, _, _, unit, src), sr in raw.items():
            unit = unit.strip().lower()
            if unit == 'percent':
                sr /= 100
            elif unit.endswith(' bn'):
                sr *= 1_000_000_000
            elif unit.endswith(' tn'):
                sr *= 1_000_000_000_000
            elif unit == 'none' and 'Date' in des:
                sr = pandas.to_datetime(sr)
            meta_data[tkr] = {'FDS_ECON_DESCRIPTION': des, 'FDS_ECON_UNIT': unit, 'FDS_ECON_SOURCE': src}
            yield tkr, sr

    return pandas.DataFrame(dict(clean_column())), meta_data


class DataLoader:
    logger = logging.getLogger(__name__)
    debug = False
    DATA_DIR = r'G:\GOG_IT\jchi\ConsensusEconomics'
    SURVEY_DATES_FILE = 'Survey Dates.csv'

    def __init__(self):
        self.survey_dates = defaultdict(dict)

    def load_survey_dates(self):
        filepath = os.path.join(self.DATA_DIR, self.SURVEY_DATES_FILE)
        if self.debug:
            self.logger.debug(f'loading survey dates from "{filepath}"')
        with open(filepath, 'r') as f:
            lines = f.read().split('\n')
        assert len(lines) > 1

        def clean_header():
            for i, h in enumerate(lines[0].split(',')):
                if h:
                    yield SURVEY_DATES_HEADER_MAP.get(h, h)
                elif i == 0:
                    yield 'year-month'

        header = list(clean_header())
        for row in lines[1:]:
            month = None
            for k, v in zip(header, row.split(',')):
                if v:
                    try:
                        v = v.strip().replace(' Survey', '')
                        v = dateutil.parser.parse(v)
                    except ValueError:
                        self.logger.error(f'fails to parse k="{k}"" v="{v}"')
                        raise
                    if k == 'year-month':
                        month = v.strftime('%Y-%m')
                    else:
                        self.survey_dates[k][month] = v

    def lazy_load_survey_dates(self):
        if not self.survey_dates:
            self.load_survey_dates()

    def load_by_country(self, country: str) -> Tuple[pandas.DataFrame, dict]:
        assert country
        self.lazy_load_survey_dates()
        for filename in os.listdir(self.DATA_DIR):
            if filename.endswith('.csv'):
                region, _, country_csv = filename.replace('.csv', '').partition('_')
                if country_csv == country:
                    survey_dates = self.survey_dates[region]
                    assert survey_dates
                    filepath = os.path.join(self.DATA_DIR, filename)
                    if self.debug:
                        self.logger.debug(f'loading data from "{filepath}"')
                    break
        else:
            raise FileNotFoundError(f'No data file for country "{country}"')

        return read_csv(filepath, survey_dates)


if __name__ == '__main__':
    # Example to load Consensus Economics data
    # initiate DataLoader object
    data = self = DataLoader()
    # run .load_by_country to load data for specific country
    # the function returns a tuple of a pandas.DataFrame and a dict of meta data
    country = 'new_zealand'
    df, meta = data.load_by_country(country)

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\datalayer\halftick.py
----------------------------------------
from typing import List, Tuple, Optional, Dict, Union
from datetime import date, datetime
from itertools import chain
from enum import Enum, auto

import pandas as pd
from atom_client.client import firmDataClient
import atom_client.data_frame
from atom_client.status_response import StatusResponse
from firm_domain.util import date2strC
from firm_f3.firm_data_client import firm_connect
from firm_domain import Instrument, Rate, FRA, IMMFRA, FXForward, FXOption, OIS, IRS, Swaption, XccyBasis, \
    CrossCurrencySwap, CCSSwaption, TenorBasis, InflationSwap

DATASET = 'AR_HISTORICAL_DATA'
TICK_TYPE = 'CLOSE'
ENV = 'uat'

class DataSet(Enum):
    EXAMPLE = auto()
    AR_HISTORICAL_DATA = auto()
    STIR = auto()
    EURO_RATES = auto()
    RATES_VOL = auto()



def half_tick_date_format(d: Union[date, str]) -> str:
    if isinstance(d, str):
        return d
    return date2strC(d)


def unpack_dataframe(data: pd.DataFrame) -> List[Tuple[str, str, float]]:
    def unpack():
        for c in data.columns:
            yield pd.DataFrame({0: list(map(half_tick_date_format, data.index)), 1: c, 2: data[c]}).values.tolist()
    return list(chain(*unpack()))


def repack_dataframe(data: atom_client.data_frame.DataFrame) -> pd.DataFrame:
    temp_df = pd.DataFrame(data=data.rows, columns=data.columns)
    return pd.DataFrame(index=pd.to_datetime(temp_df['Date']), data=temp_df['Payload'].values,
                        columns=[temp_df['Symbol'][0]])


async def insert_dataframe_async(data: pd.DataFrame, dataset: DataSet = DataSet.EXAMPLE) -> bool:
    data.columns = [ins_to_symbol(c) for c in data.columns]
    unpacked_data = unpack_dataframe(data)
    # await delete_data_from_database(unpacked_data)
    client: firmDataClient = firm_connect(ENV)
    response: StatusResponse = await client.half_tick.insert_batch_async(
        dataset=dataset.name,
        tick_type=TICK_TYPE,
        data=atom_client.data_frame.DataFrame(
            columns=["Date", "Symbol", "Payload"],
            rows=unpacked_data))
    return response.success


async def delete_single_point_from_database(symbol: Union[str, Instrument], timestamp: Union[datetime, str],
                                            dataset: DataSet = DataSet.EXAMPLE) -> bool:
    client: firmDataClient = firm_connect(ENV)
    symbol = ins_to_symbol(symbol)
    ts = half_tick_date_format(timestamp)
    response = await client.half_tick.delete_batch_async(
        dataset=dataset.name,
        tick_type=TICK_TYPE,
        symbols=[symbol],
        start_iso_date_time=ts,
        end_iso_date_time=ts)
    return response.success


async def get_dataframe_async(symbols: List[Union[str, Instrument]], start: Union[datetime, str],
                              end: Optional[date] = None,  dataset: DataSet = DataSet.EXAMPLE) -> pd.DataFrame:
    str_symbols = [ins_to_symbol(s) for s in symbols]
    client: firmDataClient = firm_connect(ENV)
    response: Dict = await client.half_tick.history_async(
        dataset=dataset.name,
        tick_type=TICK_TYPE,
        symbols=str_symbols,
        start_iso_date_time=half_tick_date_format(start),
        end_iso_date_time=None if end is None else half_tick_date_format(end))

    def unpack():
        for s in str_symbols:
            res = response[s].result
            yield repack_dataframe(res)

    return pd.concat(unpack(), axis=1).rename(dict(zip(str_symbols, symbols)), axis='columns').sort_index()


def ins_to_symbol(ins: Union[Instrument, str]) -> str:
    return str(ins)


INSTRUMENT_STR_MAPPING = {
    'Rate': Rate,
    'FRA': FRA,
    'IMMFRA': IMMFRA,
    'FXForward': FXForward,
    'FXOption': FXOption,
    'OIS': OIS,
    'IRS': IRS,
    'Swaption': Swaption,
    'XccyBasis': XccyBasis,
    'CrossCurrencySwap': CrossCurrencySwap,
    'CCSSwaption': CCSSwaption,
    'TenorBasis': TenorBasis,
    'InflationSwap': InflationSwap,
}


def symbol_to_ins(symbol: str) -> Instrument:
    ins_type, *data = symbol.split('_')
    return INSTRUMENT_STR_MAPPING[ins_type].from_data(data)


........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\datalayer\mappings.py
----------------------------------------
CHAT_MAPPINGS = {
    'Rates_Chat': '/wPZnADwxbAymoyFeZpJlH///pWmmo62dA==',
    'AsiaRatesDev': 'M6XvHbQPO08dsi4DOTT38X///pSqDBv7dA==',
    'JimTest': 'Dr0fi70JiZRSn5UqDOXuMX///pSVnBu+dA==',
    'Apollo': 'otD053cj+kBuqXlvCiCMIH///pGR2DvtdA==',
    'MarketScreens': 'wC6+HbLYC4ajGvjESgtLE3///pG76hD4dA=='
}

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\datalayer\mktdata_provider.py
----------------------------------------
import itertools
import logging
from datetime import datetime, time, timedelta, date
from enum import auto
from typing import List, Union, Set, Dict, Tuple, Optional

import math
from atom_client.market_data import MarketData
from firm_domain import PrintableEnum
from firm_domain.market_date import MarketDate
from firm_domain.util.fileutils import read_excel_sheet
from dateutil.relativedelta import relativedelta
from pandas import DataFrame

from firm_f3.firm_data_client import firm_connect
from firm_f3.datalayer.datalayer_parsers import parse_bdh_bpipe, parse_bdp_bpipe

logger = logging.getLogger(__name__)

riskval_override_file_token = 'riskval_override_file'


class MarketDataProvider:
    def __init__(self):
        pass

    async def get_history_async(self,
                                assets: Set[str],
                                start: datetime,
                                end: datetime,
                                field: str) -> DataFrame:
        raise NotImplementedError()

    async def get_latest_async(self,
                               assets: Set[str],
                               field: str) -> DataFrame:
        raise NotImplementedError()


class MarketDataProviderBpipe(MarketDataProvider):
    def __init__(self, env: str, allow_missing: bool = True):
        super().__init__()
        self.__env = env
        self.__firm = firm_connect(self.__env)
        self.__allow_missing = allow_missing

    async def get_history_async(self,
                                assets: Set[str],
                                start: datetime,
                                end: datetime,
                                field: str) -> DataFrame:
        assets_list = sorted(set(assets))
        results1 = await self.__firm.market_data.history_async(assets_list,
                                                               fmt_bbg_date(start), fmt_bbg_date(end),
                                                               [field])
        df = parse_bdh_bpipe(results1, assets_list)
        return df

    async def get_latest_async(self,
                               assets: Set[str],
                               field: str) -> DataFrame:
        assets_list = sorted(set(assets))
        results1: List[MarketData] = await self.__firm.market_data.latest_async(assets_list, [field])
        df = parse_bdp_bpipe(results=results1, field=field, assets=assets_list, allow_missing=self.__allow_missing)
        return df


class MktDbKeys:
    field = 'fld'
    date = 'date'
    symbol = 'sym'
    value = 'val'


DateSymbolKey = Tuple[datetime, str]


class IntradayCache(PrintableEnum):
    Disabled = auto()
    ReadOnly = auto()
    WriteOnly = auto()


class MarketDataProviderFileOverride(MarketDataProvider):
    def __init__(self, inner: MarketDataProvider, file: str):
        super().__init__()
        self.inner = inner
        df = read_excel_sheet(file)
        self.overrides: Dict[Tuple[str, datetime, str], float] = dict()
        for ix, row in df.iterrows():
            self.overrides[(row.sym, row.date, row.fld)] = row.val

    async def get_history_async(self,
                                assets: Set[str],
                                start: datetime,
                                end: datetime,
                                field: str) -> DataFrame:
        hist = await self.inner.get_history_async(assets=assets, start=start, end=end, field=field)
        for dt, row in hist.iterrows():
            for sym, val in row.items():
                override = self.overrides.get((sym, dt, field))
                if override:
                    logging.debug(f"Overriding sym={sym}, date={dt}, val={val}, override={override}")
                    assert isinstance(override, float)
                    row[sym] = override

        return hist

    async def get_latest_async(self, assets: Set[str], field: str) -> DataFrame:
        return await self.inner.get_latest_async(assets, field)


class MarketDataProviderCached(MarketDataProvider):

    def __init__(self,
                 inner: MarketDataProvider,
                 mongo_client: 'motor.motor_asyncio.AsyncIOMotorClient',
                 mongodb: str,
                 mongocol: str,
                 mongocol_intraday: str):
        super().__init__()
        self.__inner = inner
        self.__col = mongo_client.get_database(mongodb).get_collection(mongocol)
        self.__col_intraday = mongo_client.get_database(mongodb).get_collection(mongocol_intraday)
        self.__initialised = False
        self.__cumulative_reads_db = 0
        self.__cumulative_reads_inner = 0
        self.__cumulative_writes = 0
        self.__intraday_timestamp_read: Optional[MarketDate] = None
        self.__intraday_timestamp_write: Optional[MarketDate] = None
        self.intraday_cache = IntradayCache.Disabled

    def get_stats(self) -> Dict[str, int]:
        return {'reads_db': self.__cumulative_reads_db,
                'reads_inner': self.__cumulative_reads_inner,
                'writes_db': self.__cumulative_writes}

    async def __create_indices(self):
        if self.__initialised:
            return
        self.__initialised = True
        try:
            from pymongo import IndexModel, ASCENDING
        except ImportError:
            raise ImportError(f'please pip install pymongo for this optional feature')
        indexmodels = [
            IndexModel([
                (MktDbKeys.field, ASCENDING),
                (MktDbKeys.date, ASCENDING),
                (MktDbKeys.symbol, ASCENDING),
            ], name="field_date_symbol"),
            IndexModel([
                (MktDbKeys.field, ASCENDING),
                (MktDbKeys.symbol, ASCENDING),
                (MktDbKeys.date, ASCENDING),
            ], name="field_symbol_date")
        ]
        for col in [self.__col, self.__col_intraday]:
            await col.create_indexes(indexmodels)

    async def __load_from_db_async(self, assets: Set[str], dates: Set[datetime], field: str):
        records: Dict[DateSymbolKey, float] = dict()
        async for doc in self.__col.find({MktDbKeys.field: field,
                                          MktDbKeys.date: {'$in': list(dates)},
                                          MktDbKeys.symbol: {'$in': list(assets)}},
                                         {MktDbKeys.date: 1,
                                          MktDbKeys.symbol: 1,
                                          MktDbKeys.value: 1}):
            date, sym, val = tuple(
                doc[x] for x in [MktDbKeys.date, MktDbKeys.symbol, MktDbKeys.value])
            records[(date, sym)] = val
            # logging.debug('reading from db', date, sym, val)
        return records

    async def __load_from_bpipe_async(self, assets: Set[str], dates: Set[datetime], field: str) \
            -> Dict[DateSymbolKey, float]:
        def df_to_dict(df: DataFrame) -> Dict[DateSymbolKey, float]:
            out = dict()
            for date, row in df.iterrows():
                date = date
                for symbol, value in row.iteritems():
                    out[(date, symbol)] = value
            return out

        if len(assets) > 0 and len(dates) > 0:
            records_bpipe = df_to_dict(await self.__inner.get_history_async(assets=assets,
                                                                            start=min(dates),
                                                                            end=max(dates),
                                                                            field=field))
            for (d, s), v in sorted(records_bpipe.items()):
                pass
                # logging.debug('reading from bpipe', d, s, v)
            for date in dates:
                for asset in assets:
                    if (date, asset) not in records_bpipe:
                        records_bpipe[(date, asset)] = math.nan
        else:
            records_bpipe = dict()
        return records_bpipe

    def __generate_date_set(self, assets, start, end) -> Set[datetime]:
        t0, t1 = start.date(), end.date()
        out = set()
        t = t0
        while t <= t1:
            out.add(datetime.combine(t, time()))
            t += relativedelta(days=1)
        return out

    async def get_history_async(self,
                                assets: Set[str],
                                start: datetime,
                                end: datetime,
                                field: str) -> DataFrame:
        try:
            from pymongo import ReplaceOne
            from pymongo.errors import BulkWriteError
        except ImportError:
            raise ImportError(f'please pip install pymongo for this optional feature')

        await self.__create_indices()
        dates = self.__generate_date_set(assets, start, end)

        # read data from database
        records_db = await self.__load_from_db_async(assets, dates, field)
        self.__cumulative_reads_db += len(records_db)
        logging.info(f"MarketDataProviderCached: records loaded from database {len(records_db)}")

        # figure out what to query (possibly more than we need)
        dates_query: Set[datetime] = set()
        symbols_query: Set[str] = set()
        for d, s in itertools.product(dates, assets):
            if (d, s) not in records_db:
                dates_query.add(d)
                symbols_query.add(s)

        records_bpipe = await self.__load_from_bpipe_async(symbols_query, dates_query, field)
        self.__cumulative_reads_inner += len(records_bpipe)
        logging.info(f"MarketDataProviderCached: records loaded from bpipe {len(records_bpipe)} (including gaps)")

        # What to return:
        records_ret: Dict[DateSymbolKey, float] = dict()
        records_ret.update(records_db)
        records_ret.update(records_bpipe)
        logging.info(f"MarketDataProviderCached: records to return {len(records_ret)}")

        # what to update back to database:
        do_write = lambda d: datetime.utcnow() - d >= timedelta(days=2)
        ## do not store to database prices of last 2 days, to avoid risk of storing intraday prices
        records_write = {k: v for k, v in records_bpipe.items() if do_write(k[0])}
        self.__cumulative_writes += len(records_write)
        logging.info(f"MarketDataProviderCached: records to write back {len(records_write)}")
        update_requests = []
        for (date, asset), value in sorted(records_write.items()):
            if not math.isnan(value):
                update_requests.append(ReplaceOne(filter={MktDbKeys.field: field,
                                                          MktDbKeys.date: date,
                                                          MktDbKeys.symbol: asset},
                                                  replacement={MktDbKeys.field: field,
                                                               MktDbKeys.date: date,
                                                               MktDbKeys.symbol: asset,
                                                               MktDbKeys.value: value},
                                                  upsert=True))
        if len(update_requests) > 0:
            try:
                logging.info(f"updating {len(update_requests)} fixings in db asynchronously")
                self.__col.bulk_write(requests=update_requests, ordered=False)
            except BulkWriteError as bwe:
                print(bwe.details)
        df = DataFrame([(*k, v) for k, v in records_ret.items()])
        df = df.pivot(index=0, columns=1, values=2)
        df.columns.name = None
        df.index.name = None
        return df

    def set_intraday_timestamp_read(self, market_date: Optional[datetime]) -> None:
        self.__intraday_timestamp_read = market_date

    def set_intraday_timestamp_write(self, market_date: Optional[datetime]) -> None:
        self.__intraday_timestamp_write = market_date

    async def get_latest_async(self,
                               assets: Set[str],
                               field: str) -> DataFrame:
        if self.intraday_cache == IntradayCache.Disabled:
            return await self.__inner.get_latest_async(assets, field)

        if self.intraday_cache == IntradayCache.WriteOnly:
            latest = await self.__inner.get_latest_async(assets, field)
            for asset, data in latest.items():
                for key, value in data.items():
                    await self.__col_intraday.replace_one(
                        filter={
                            MktDbKeys.field: field,
                            MktDbKeys.date: self.__intraday_timestamp_write,
                            MktDbKeys.symbol: asset},
                        replacement={MktDbKeys.field: field,
                                     MktDbKeys.date: self.__intraday_timestamp_write,
                                     MktDbKeys.symbol: asset,
                                     MktDbKeys.value: value},
                        upsert=True)
            return latest

        if self.intraday_cache == IntradayCache.ReadOnly:
            records_ret: Dict[Tuple[int, str], float] = dict()
            async for record in self.__col_intraday.find(filter={MktDbKeys.field: field,
                                                                 MktDbKeys.date: self.__intraday_timestamp_read,
                                                                 MktDbKeys.symbol: {'$in': list(assets)}}):
                records_ret[(0, record[MktDbKeys.symbol])] = record[MktDbKeys.value]
            if len(records_ret) < len(assets):
                missed_symbols = assets - {k[1] for k in records_ret.keys()}
                logging.debug(
                    f"INTRADAY: Symbols {missed_symbols} not retrieved for date {self.__intraday_timestamp_read}")
                return await self.__inner.get_latest_async(assets, field)

            df = DataFrame([(*k, v) for k, v in records_ret.items()])
            df = df.pivot(index=0, columns=1, values=2)
            df.columns.name = None
            df.index.name = None
            return df

        raise Exception("unreachable")


class MarketDataProviderOnetick(MarketDataProvider):
    def __init__(self, env: str):
        super().__init__()
        self.__env = env

    async def get_history_async(self,
                                assets: Set[str],
                                start: datetime,
                                end: datetime,
                                field: str) -> DataFrame:
        raise NotImplementedError()

    async def get_latest_async(self,
                               assets: Set[str],
                               field: str) -> DataFrame:
        raise NotImplementedError()


class MarketDataNotAvailableProvider(MarketDataProvider):
    def __init__(self):
        super().__init__()
        pass

    async def get_history_async(self,
                                assets: Set[str],
                                start: datetime,
                                end: datetime,
                                field: str) -> DataFrame:
        raise Exception("MarketDataNotAvailableProvider: Market data is not available")

    async def get_latest_async(self,
                               assets: Set[str],
                               field: str) -> DataFrame:
        raise Exception("MarketDataNotAvailableProvider: Market data is not available")


def fmt_bbg_date(d: Union[date, str]) -> str:
    if isinstance(d, str):
        return d
    return d.strftime("%Y%m%d")

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\datalayer\sophis.py
----------------------------------------
from __future__ import annotations
import logging
import os
import re
import copy
import datetime
import dateutil
from typing import Iterable, Tuple, Dict, Union, List
from functools import partial, wraps
from collections import defaultdict

from atom_client.fee_type import FeeType  # type: ignore
from atom_client.trade import Trade  # type: ignore
from atom_client.client import firmDataClient, grpc  # type: ignore
from atom_client.sophis_portfolio_view import SophisPortfolioView  # type: ignore
import firm_domain as domain
from firm_f3.util.utils import timer
from firm_f3.firm_data_client import map_environment

from firm_f3.util.attribute import Attribute
from firm_f3.util.caching import Cacher
from firm_f3.util.xml import xml2dict

import warnings

WARNING_MESSAGE = """
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                            !!
!! WARNING firm_f3.datalayer.sophis is going to be deprecated                 !!
!! functionality is migrated to Cerebro Position Service                      !!
!!                                                                            !!
!! Details of the new repo                                                    !!
!!     http://firm-bitbucket:7990/projects/BI/repos/firm-cerebro/browse       !!
!!                                                                            !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"""
print(WARNING_MESSAGE)
warnings.warn(WARNING_MESSAGE, DeprecationWarning)

logger = logging.getLogger(__name__)


class SophisInstrumentLoadingError(Exception):
    pass


class SophisTradeValidationError(Exception):
    pass


SOPHIS_XML_NAMESPACE = {'{http://www.sophis.net/Instrument}': '',
                        '{http://sophis.net/sophis/common}': ''}


def type_ccy(x: str) -> domain.Ccy:
    if isinstance(x, domain.Ccy):
        return x
    return domain.Ccy[x]


def type_fee_type(x: str) -> FeeType:
    if isinstance(x, FeeType):
        return x
    return FeeType[x]


class SophisFee:
    logger = logging.getLogger(__name__)
    type = Attribute(type_fee_type)
    currency = Attribute(type_ccy)
    amount = Attribute(float)

    def __init__(self, fee: dict):
        self._raw = fee
        for k, v in fee.items():
            try:
                setattr(self, k, v)
            except Exception as e:
                self.logger.error(f'{k}: {v}', exc_info=e)

    def __repr__(self):
        return f'<{type(self).__name__}.{self.type.name} {self.currency}{self.amount}>'


def type_datetime_from_timestamp(x: float) -> datetime.datetime:
    if isinstance(x, datetime.datetime):
        return x
    return datetime.datetime.fromtimestamp(x / 1000)


def type_date_from_timestamp(x: float) -> datetime.date:
    if isinstance(x, datetime.date):
        return x
    return datetime.datetime.fromtimestamp(x / 1000).date()


def type_datetime_from_str(x: str) -> datetime.datetime:
    if isinstance(x, datetime.datetime):
        return x
    return dateutil.parser.parse(x)


def type_date_from_str(x: str) -> datetime.date:
    if isinstance(x, datetime.date):
        return x
    return dateutil.parser.parse(x).date()


def type_dict(x: dict) -> dict:
    # jchi@201911
    # Use Case 1: Trade.other is either a dict or an empty list
    # Use Case 2: Instrument.strike is either a dict or a float
    return x or {}


def type_fees(x: list) -> list:
    return [SophisFee(i) for i in x]


class SophisTrade:
    logger = logging.getLogger(__name__)
    trade_id = Attribute(int)
    instrument_id = Attribute(int)
    instrument_reference = Attribute(str)
    price = Attribute(float)
    quantity = Attribute(float)
    net_amount = Attribute(float)  # cash flows/fees in Sophis
    portfolio = Attribute(int)
    trade_date = Attribute(type_datetime_from_timestamp)
    modification_date = Attribute(type_datetime_from_timestamp)
    settlement_date = Attribute(type_date_from_timestamp)
    accounting_date = Attribute(type_date_from_timestamp)  # fixing date in Sophis
    fixing_date = Attribute(type_date_from_str)
    business_event = Attribute(str)
    depositary_id = Attribute(int)
    depositary_name = Attribute(str)
    depositary_reference = Attribute(str)
    counterparty_id = Attribute(int)
    counterparty_name = Attribute(str)
    counterparty_reference = Attribute(str)
    broker_reference = Attribute(str)
    fees = Attribute(type_fees)
    pay_currency = Attribute(type_ccy)
    comments = Attribute(list)
    other = Attribute(type_dict)
    status = Attribute(str)

    def __init__(self, trade: Trade):
        self._raw = trade
        for k, v in trade.to_flat_dict().items():
            if v is not None:
                try:
                    setattr(self, k, v)
                except Exception as e:
                    self.logger.error(f'{k}: {v} -> {type(e).__name__} {e}')

        # jchi@201906
        # special parsing for fixing date from comment field
        try:
            self.fixing_date = self.other['FixingDate']
        except KeyError:
            pass

    def to_dict(self):
        return {k: v for k, v in self.__dict__.items() if not k.startswith('_')}

    def __repr__(self):
        return f'<{type(self).__name__} tid={self.trade_id} iid={self.instrument_id} pid={self.portfolio}>'


class SophisInstrument:
    logger = logging.getLogger(__name__)
    ccy_base = Attribute(type_ccy)
    ccy = Attribute(type_ccy)

    productType = Attribute(str)
    Reference = Attribute(str)
    sicovam = Attribute(int)
    currency = Attribute(type_ccy)
    underlyer = Attribute(dict)
    receivingLeg = Attribute(dict)
    payingLeg = Attribute(dict)
    strike = Attribute(type_dict)
    pointValue = Attribute(dict)
    optionType = Attribute(str)
    FXOptionType = Attribute(str)
    exercise = Attribute(dict)
    swapInSwaption = Attribute(dict)
    settlementType = Attribute(str)

    # IR-Futures-All fields
    expirationDate = Attribute(type_date_from_str)
    notional = Attribute(dict)

    # IR-Futures-Options fields
    contractSize = Attribute(float)

    # FI-Bonds-All fields
    interestType = Attribute(dict)
    cashFlowGeneration = Attribute(dict)

    # IR-Caps & Floors fields
    capfloorType = Attribute(str)
    floatingComponent = Attribute(type_dict)

    # Spread Option fields
    name = Attribute(str)

    def __init__(self, inst: dict):
        self._raw = inst
        for k, v in inst.items():
            if v is not None:
                try:
                    setattr(self, k, v)
                except Exception as e:
                    self.logger.error(f'{k}: {v} -> {type(e).__name__} {e}')
                    raise SophisInstrumentLoadingError(e) from e

        try:
            self.sicovam = inst['identifier']['sophis']
        except KeyError:
            # jchi@201906
            # assert only NDF is allowed not to have a sicovam
            if not self.productType.startswith('FX-Non Deliverable Forwards'):
                err = f'missing identifier in {inst}'
                self.logger.error(err)
                raise ValueError(err)

        if self.productType.startswith('FX-Non Deliverable Forwards'):
            # special parsing for NDFs
            self.ccy, _, self.ccy_base = self.Reference.partition(' ')[0].partition('/')
        elif self.productType.startswith('FX-Options') or self.productType.startswith('FX Option-Digital'):
            self.ccy_base, _, self.ccy = self.underlyer['reference'].partition('/')
        else:
            try:
                pair = inst['quotedCurrencyPair']
                self.ccy_base, self.ccy = pair['currency1'], pair['currency2']
            except KeyError:
                pass

    def to_dict(self):
        return {k: v for k, v in self.__dict__.items() if not k.startswith('_')}

    def __repr__(self):
        return f'<{type(self).__name__} sicovam={self.sicovam}>'


class SophisValidator:
    logger = logging.getLogger(__name__)

    def __init__(self, verbose: bool = True, raise_error: bool = False):
        self.verbose = verbose
        self.raise_error = raise_error
        self.errors = []

    def print_errors(self):
        for err in self.errors:
            print(err)

    def __enter__(self):
        return self

    def __exit__(self, *exc):
        self.print_errors()

    def validate_one(self, trade: SophisTrade, inst: SophisInstrument):
        try:
            validate_type(trade, inst)
            product = inst.productType
            if product.startswith('FX-Non Deliverable Forwards'):
                validate_ndf(trade, inst)
        except AssertionError as e:
            err = SophisTradeValidationError(e)
            if self.verbose:
                self.logger.error(err)
            if self.raise_error:
                raise err from e
            self.errors.append(err)

    def validate_all(self, it: Iterable[Tuple[SophisTrade, SophisInstrument]]):
        for trade, inst in it:
            self.validate_one(trade, inst)


def validate_type(trade: SophisTrade, inst: SophisInstrument):
    product = inst.productType
    if product.startswith('FX-Spot FX'):
        assert not domain.Conventions.trades_as_ndf(inst.ccy), f'{trade} ccy={inst.ccy} booked as an FX-Spot trade'
        assert not domain.Conventions.trades_as_ndf(
            inst.ccy_base), f'{trade} ccy_base={inst.ccy_base} booked as an FX-Spot trade'


def validate_ndf(trade: SophisTrade, inst: SophisInstrument):
    fixing_date = trade.fixing_date
    assert fixing_date is not None, f'{trade} Fixing Date is not defined for NDF trade'
    assert isinstance(fixing_date, datetime.date), f'{trade} Fixing Date is not a datetime.date object'


class SophisPortfolio:
    logger = logging.getLogger(__name__)
    debug = False

    def __init__(self, name: str, pid: int):
        self.name = name
        self.pid = pid
        self.parent = None
        self.children = {}
        self.trades = []

    @property
    def long_name(self) -> str:
        def unpack(folio: SophisPortfolio):
            yield folio.name
            if folio.parent:
                for name in unpack(folio.parent):
                    yield name

        return '|'.join(reversed(list(unpack(self))))

    def iter(self, exclude: List[int] = ()) -> Iterable[Tuple[int, SophisPortfolio]]:
        def unpack(folio: SophisPortfolio, lv: int = 0):
            if folio.pid not in exclude:
                yield lv, folio
                for child in folio.children.values():
                    if isinstance(child, SophisPortfolio):
                        for i in unpack(child, lv + 1):
                            yield i

        return unpack(self)

    @property
    def nested_trades(self) -> List[Trade]:
        trades = []
        for _, folio in self.iter():
            trades.extend(folio.trades)

        return trades

    def __repr__(self) -> str:
        def unpack():
            if self.parent:
                yield f'\t..: <{self.parent.name} ({self.parent.pid})>\n'
            for k, v in self.children.items():
                if isinstance(v, type(self)):
                    v = f'<{v.name}>'
                yield f'\t{k}: {v}\n'

        return f'<{self.name} ({self.pid})>\n' + ''.join(unpack())

    def __getitem__(self, item) -> SophisPortfolio:
        if item == '..':
            if self.parent:
                return self.parent
            raise KeyError('..')
        return self.children[item]

    def add_children(self, children: dict):
        for k, v in children.items():
            if isinstance(v, SophisPortfolio):
                v.parent = self
            self.children[k] = v

    def find(self, item: int) -> SophisPortfolio:
        if item == self.pid:
            return self
        elif item != '..':
            try:
                return self.children[item]
            except KeyError:
                pass

            for child in self.children.values():
                if isinstance(child, SophisPortfolio):
                    try:
                        return child.find(item)
                    except KeyError:
                        pass
        raise KeyError(item)

    def __eq__(self, other: SophisPortfolio) -> bool:
        assert isinstance(other, type(self))
        return other.pid == self.pid and set(other.children) == set(self.children)

    def fetch_sophis_trades(self, ps: SophisPositionService, recursive=False) -> List[SophisTrade]:
        trades = list(ps.get_sophis_trades(self.pid).values())
        if recursive:
            for k, v in self.children.items():
                if isinstance(v, SophisPortfolio):
                    trades.extend(v.fetch_sophis_trades(ps, recursive=True))
        return trades

    def fetch(
            self,
            ps: SophisPositionService,
            recursive: bool = False,
            reload: bool = False,
            exclude: Tuple[int] = (),
            validator: SophisValidator = None,
            use_cache: bool = True
    ) -> List[Trade]:
        trades = []
        if self.pid not in exclude:
            try:
                trades.extend(
                    ps.get_trades_by_portfolio_id(self.pid, reload=reload, validator=validator, use_cache=use_cache))
            except Exception as e:
                self.logger.error(f'<{self.name} ({self.pid})>', exc_info=e)
                if not self.debug:
                    raise
            else:
                self.trades.clear()
                self.trades.extend(trades)
        if recursive:
            for k, v in self.children.items():
                if isinstance(v, SophisPortfolio):
                    trades.extend(v.fetch(ps, recursive=True, reload=reload, exclude=exclude, validator=validator,
                                          use_cache=use_cache))
        return trades

    def collapse_by_portfolio(self, ref_date: datetime.date, exclude: List[int] = (),
                              inplace: bool = True) -> SophisPortfolio:
        folio = self if inplace else copy.deepcopy(self)
        for _, p in folio.iter(exclude=exclude):
            p.trades = domain.collapse_trades(trades=p.trades, ref_date=ref_date)
        return folio


class SophisPositionService:
    logger = logging.getLogger(__name__)
    verbose: bool = True
    diagnosis: bool = False
    diagnostic_errors: dict = defaultdict(list)

    def __init__(self, env_or_host='prd', **kwargs):
        env_or_host = map_environment(env_or_host)
        self.__connect = partial(firmDataClient, env_or_host, **kwargs)
        self._conn = None

    def __enter__(self):
        if not self._conn:
            self._conn = self.__connect()
        return self

    def __exit__(self, *exc):
        if isinstance(self._conn, firmDataClient):
            self._conn.shutdown()
            self.logger.debug(f'{self._conn} shutdown')
            self._conn = False

    def __del__(self):
        self.__exit__()

    start = __enter__
    exit = __exit__

    @property
    def conn(self):
        if self._conn is None:
            raise ValueError('connection not initialised yet')
        elif self._conn is False:
            raise ValueError('connection already closed')
        assert isinstance(self._conn, firmDataClient)
        return self._conn

    def get_portfolio_by_id(self, pid: int):
        conn = self.conn
        t = datetime.datetime.now()
        try:
            raw_table = conn.portfolio_directory.get_portfolio_tree(root_portfolio_id=pid)
        except grpc.RpcError:
            # jchi@202002
            # backward compatibility - fallback method between atom releases
            raw_table = conn.portfolio_directory.children_of(parent_portfolio_id=pid)
        if self.verbose:
            self.logger.debug(f'fetch {len(raw_table)} table rows, time elapsed {datetime.datetime.now() - t}')

        def clean_table():
            for item in raw_table:
                v = item.to_flat_dict()
                v['id'] = int(v['id'])
                v['parent'] = int(v['parent'])
                yield v['id'], v

        table = dict(clean_table())

        def table2tree(root):
            def unpack():
                for row in table.values():
                    child, parent = row['id'], row['parent']
                    if parent == root:
                        yield child, table2tree(child)

            try:
                name = table[root]['name']
            except KeyError:
                # jchi@202002
                # backward compatibility - fallback method between atom releases
                name = '__ROOT__'
            rv = SophisPortfolio(name=name, pid=root)
            rv.add_children(dict(unpack()))
            return rv

        return table2tree(pid)

    def get_portfolio_by_id__deprecated(self, pid: int):
        """
            jchi@202002
            This is using the old way to get portfolio structure via the Sophis Data Service (SDS)
            SDS is very slow. It should be avoided for as much as possible.
        """
        conn = self.conn
        t = datetime.datetime.now()
        raw_table = conn.sophis_portfolio.dump(portfolio_id=pid, columns=[], view=SophisPortfolioView.Hierarchical)
        if self.verbose:
            self.logger.debug(f'fetch {len(raw_table)} table rows, time elapsed {datetime.datetime.now() - t}')

        def clean_table():
            keys = raw_table[0]
            for row in raw_table[1:]:
                v = dict(zip(keys, row))
                v['ID'] = int(v['ID'])
                v['PARENTID'] = int(v['PARENTID'])
                v['CHILDRENCOUNT'] = int(v['CHILDRENCOUNT'])
                yield v['ID'], v

        table = dict(clean_table())

        def table2tree(root):
            def unpack():
                for row in table.values():
                    child, parent = row['ID'], row['PARENTID']
                    if parent == root:
                        if row['_type'] == 'folio':
                            yield child, table2tree(child)
                        else:
                            yield child, row['_name']

            rv = SophisPortfolio(name=table[root]['_name'], pid=root)
            rv.add_children(dict(unpack()))
            return rv

        return table2tree(pid)

    def get_sophis_trades(self, pid: int) -> dict:
        t = datetime.datetime.now()
        raw_trades = self.conn.trade.find(portfolio=int(pid))

        def clean_trades():
            for i in raw_trades:
                if 'cancelled' not in str(i.status).lower():
                    trade = SophisTrade(i)
                    yield trade.trade_id, trade

        rv = dict(clean_trades())
        sicovams = {trade.instrument_id for trade in rv.values()}
        if self.verbose:
            self.logger.debug(f'portfolio={pid} returns {len(raw_trades)} trades with {len(sicovams)} unique '
                              f'sicovams, {len(raw_trades) - len(rv)} cancelled trades, '
                              f'time elapsed {datetime.datetime.now() - t}')
        return rv

    def fetch_sophis_instruments_from_integration_service(self, sicovams: Iterable, reload: bool = False) -> dict:
        unique_sicovams = set(sicovams)
        if not unique_sicovams:
            return {}

        t = datetime.datetime.now()
        res = self.conn.sophis_integration.instruments(sicovams=list(unique_sicovams), reload=reload)
        try:
            # jchi@201907
            # from firm-data-1.0.215 onwards IS returns a SophisIntegrationResponse object instead
            if res.error:
                raise grpc.RpcError(res.error)
            raw_xml = res.results
        except AttributeError:
            # backward compatibility, before firm-data-1.0.215 IS returns a dict
            raw_xml = res
        if self.verbose:
            self.logger.debug(f'sophis_integration fetches {len(raw_xml)} XML instrument definitions, '
                              f'time elapsed {datetime.datetime.now() - t}')

        missing_sicovams = unique_sicovams - set(raw_xml)
        if missing_sicovams:
            raise ValueError('sophis returns less XML instrument definitions than it is asked for, '
                             f'missing {len(missing_sicovams)} definitions - {missing_sicovams}')

        def clean_instruments():
            for i, src in enumerate(raw_xml.values()):
                try:
                    v = xml2dict(src, ns_mapper=SOPHIS_XML_NAMESPACE)
                    if 'identifier' in v:
                        inst = SophisInstrument(v)
                        yield inst.sicovam, inst
                except Exception as e:
                    self.logger.error(f'error at raw_xml[{i}]', exc_info=e)

        return dict(clean_instruments())

    def fetch_sophis_instruments_for_ndf(self, sicovams: Iterable) -> dict:
        unique_sicovams = set(sicovams)
        if not unique_sicovams:
            return {}

        def unpack():
            with timer(f'sophis_reference fetches {len(unique_sicovams)} NDF instruments', logstart=self.verbose):
                for key in unique_sicovams:
                    if self.verbose:
                        self.logger.debug(f'fetching Reference for instrument_id={key} (NDF?)')

                    if os.environ.get('EXPERIMENT_FEATURE'):
                        try:
                            # jchi@202003
                            # experiment feature: get reference from trade object in order to bypass SDS
                            t, *_ = self.conn.trade.find(instrument_id=key)
                            ref = t.instrument_reference
                            inst = SophisInstrument({'productType': 'FX-Non Deliverable Forwards', 'Reference': ref})
                        except Exception as e:
                            self.logger.warning(f'fallback to SDS on iid={key} err={e}')
                            ref = self.conn.sophis_instrument.reference_by_id(sicovam=key, ref_type="Reference")
                            inst = SophisInstrument({'productType': 'FX-Non Deliverable Forwards', 'Reference': ref})
                    else:
                        ref = self.conn.sophis_instrument.reference_by_id(sicovam=key, ref_type="Reference")
                        inst = SophisInstrument({'productType': 'FX-Non Deliverable Forwards', 'Reference': ref})

                    if self.verbose:
                        self.logger.debug(f'got instrument_id={key} ref={ref} (NDF?)')
                    yield key, inst

        return dict(unpack())

    def get_sophis_instruments(self, sicovams: Iterable, reload: bool = False) -> dict:
        unique_sicovams = set(sicovams)
        if not unique_sicovams:
            return {}

        fetched_instruments = self.fetch_sophis_instruments_from_integration_service(unique_sicovams, reload=reload)
        remaining_sicovams = unique_sicovams - set(fetched_instruments)
        fetched_ndf_instruments = self.fetch_sophis_instruments_for_ndf(remaining_sicovams)
        fetched_instruments.update(fetched_ndf_instruments)
        return fetched_instruments

    def _get_trades_helper(self, trades: Dict, instruments: Dict, reload: bool = False,
                           validator: SophisValidator = None):
        sicovams = {t.instrument_id for t in trades.values()}
        if reload:
            unknown_sicovams = sicovams
        else:
            unknown_sicovams = [i for i in sicovams if i not in instruments]

        fetched_instruments = self.get_sophis_instruments(unknown_sicovams, reload=reload)
        instruments.update(fetched_instruments)
        if self.verbose:
            self.logger.debug(f'updated {len(fetched_instruments)} clean instruments to cache')

        if isinstance(validator, SophisValidator):
            validator.validate_all((t, instruments[t.instrument_id]) for t in trades.values())

        res = self._dispatch((t, instruments[t.instrument_id]) for t in trades.values())
        return res

    def _diagnose_sophis_instruments(self, trades: Dict, validator: SophisValidator = None):
        from tqdm import tqdm

        try:
            return self._get_trades_helper(trades, {}, reload=True,
                                           validator=SophisValidator(verbose=False, raise_error=True))
        except Exception as err:
            self.logger.info(f'Entering Diagnosis Mode on {err}')

        def unpack():
            self.verbose = False
            for tid, t in tqdm(trades.items()):
                v = SophisValidator(verbose=False, raise_error=False)
                try:
                    trade, *_ = self._get_trades_helper({tid: t}, {}, reload=True, validator=v)
                except Exception as e:
                    self.logger.error(e)
                    self.diagnostic_errors[(t.portfolio, t.trade_id, t.instrument_id)].append(e)
                else:
                    if v.errors:
                        self.diagnostic_errors[(t.portfolio, t.trade_id, t.instrument_id)].extend(v.errors)
                        if isinstance(validator, SophisValidator):
                            validator.errors.extend(v.errors)
                    yield trade
            self.verbose = True

        return list(unpack())

    def get_trades_by_portfolio_id(self, pid: int, reload: bool = False, validator: SophisValidator = None,
                                   use_cache: bool = True):
        trades = self.get_sophis_trades(pid)
        if self.diagnosis:
            return self._diagnose_sophis_instruments(trades, validator=validator)

        if use_cache:
            with Cacher('instruments.cache') as instruments:
                return self._get_trades_helper(trades, instruments, reload, validator)
        return self._get_trades_helper(trades, {}, reload, validator)

    def _dispatch(self, it: Iterable[Tuple[SophisTrade, SophisInstrument]]):
        def unpack():
            for t, inst in it:
                product = inst.productType
                if t.quantity and t.business_event != 'Coupon':
                    try:
                        if product == 'EQU-Stock Derivatives|IR-Products-All|IR-Spread Options|IR-Swaptions':
                            yield sophis2spread_option(t, inst)
                        elif product.startswith('FX-Spot FX'):
                            yield sophis2fwd(t, inst)
                        elif product.startswith('FX-Non Deliverable Forwards'):
                            yield sophis2ndf(t, inst)
                        elif product.startswith('FX-Options') or product.startswith('FX Option-Digital'):
                            yield sophis2opt(t, inst)
                        elif product.startswith('INF-Swaps-All'):
                            yield sophis2inf(t, inst)
                        elif product.startswith('IR-Futures-All|IR-Futures-Bond|IR-Futures-Notional'):
                            yield sophis2bondfuture(t, inst)
                        elif product.startswith('IR-Futures-All|IR-Futures-Monetary|IR-Products-All'):
                            yield sophis2ratesfuture(t, inst)
                        elif product.startswith('IR-Derivatives|IR-Futures-Options'):
                            yield sophis2rates_option(t, inst)
                        elif product.startswith('IR-Futures-Options'):
                            yield sophis2rates_option2(t, inst)
                        elif product.startswith('IR-Caps & Floors'):
                            yield sophis2cap_floor(t, inst)
                        elif product.startswith('FI-Bonds-All|FI-Bonds-Fixed'):
                            yield sophis2bond(t, inst)
                        elif product.endswith('IR-Swaps-IRS'):
                            pay = inst.payingLeg['swapStream']
                            reset_freq = pay['resetDates']['resetFrequency']
                            tenor = reset_freq['periodMultiplier'] + reset_freq['periodEnum'][:1]
                            if domain.Tenor[f'T_{tenor}'] is domain.Tenor.T_1D:
                                yield sophis2ois(t, inst)
                            else:
                                yield sophis2irs(t, inst)
                        elif product.endswith('IR-Swaps-Domestic Basis Swap'):
                            yield sophis2tenorbasis(t, inst)
                        elif product.endswith('IR-Swaptions'):
                            yield sophis2swaption(t, inst)
                        elif product.endswith('IR-Swaps-CIRS Fixed-Floating'):
                            yield sophis2ccs(t, inst)
                        elif product.endswith('IR-Swaps-X CCY Basis Swap'):
                            yield sophis2xccybasis(t, inst)
                        elif product.endswith('EQU-Swaps-Equity Swap Fixed Index'):
                            yield sophis2trs(t, inst)
                        else:
                            self.logger.warning(f'ignore product: {product} pid={t.portfolio} tid={t.trade_id}')
                    except Exception as e:
                        logger.error(f'pid={t.portfolio} tid={t.trade_id} iid={t.instrument_id} {product}', exc_info=e)
                        raise

                if (product.startswith('FX-Options') or not product.startswith('FX-')) and t.net_amount:
                    yield sophis2cashflow(t, inst)

        return list(unpack())


def with_sophis_ids(func):
    @wraps(func)
    def f(t: SophisTrade, inst: SophisInstrument):
        trade = func(t, inst)
        trade.pid = t.portfolio
        trade.tid = t.trade_id
        trade.iid = t.instrument_id
        if t.counterparty_id:
            trade.cp_id = t.counterparty_id
            trade.cp_name = t.counterparty_name
            trade.cp_ref = t.counterparty_reference
            trade.broker_ref = t.broker_reference
        return trade

    return f


@with_sophis_ids
def sophis2ndf(trade: SophisTrade, inst: SophisInstrument) -> domain.FXForwardTrade:
    def unpack():
        yield 'ccy_base', inst.ccy_base
        yield 'ccy', inst.ccy
        yield 'trade_date', trade.trade_date
        yield 'value_date', trade.settlement_date
        yield 'fixing_date', trade.fixing_date or trade.accounting_date

        # jchi@201906
        # hard coded fix for some wrongly booked trade price in Sophis
        price = trade.price
        if price < 1:
            if any(i.startswith('Expiry') for i in trade.comments):
                price = 1 / price
            else:
                err = f'bad trade="{inst.Reference}" price={price} comments={trade.comments}'
                logger.error(err)
                raise ValueError(err)
        yield 'rate', price
        yield 'notional', -trade.quantity / price

    return domain.FXForwardTrade(**dict(unpack()))


@with_sophis_ids
def sophis2fwd(trade: SophisTrade, inst: SophisInstrument) -> domain.FXForwardTrade:
    def unpack():
        yield 'ccy_base', inst.ccy_base
        yield 'ccy', inst.ccy
        yield 'trade_date', trade.trade_date
        yield 'value_date', trade.settlement_date

        notional = trade.quantity
        notional2 = -trade.net_amount
        yield 'rate', -notional2 / notional
        yield 'notional', notional

    return domain.FXForwardTrade(**dict(unpack()))


SOPHIS_FX_OPTION_TO_OPTION_TYPE = {
    ('CALL', 'VANILLA'): domain.OptionType.CALL,
    ('PUT', 'VANILLA'): domain.OptionType.PUT,
    ('CALL', 'DIGITAL'): domain.OptionType.DIGITAL_CALL,
    ('PUT', 'DIGITAL'): domain.OptionType.DIGITAL_PUT,
}


@with_sophis_ids
def sophis2opt(trade: SophisTrade, inst: SophisInstrument) -> domain.FXOptionTrade:
    def unpack():
        yield 'ccy', inst.ccy
        yield 'ccy_base', inst.ccy_base
        yield 'option_type', SOPHIS_FX_OPTION_TO_OPTION_TYPE[inst.optionType.upper(), inst.FXOptionType.upper()]

        strike = inst.strike['strikeValue']['strikePrice']['amount']
        multiplier = inst.pointValue.get('inAmount', 1)
        yield 'strike', float(strike) * float(multiplier)

        raw_exp = inst.exercise['europeanExercise']['expirationDate']['adjustableDate']['unadjustedDate']
        exp = datetime.datetime.strptime(raw_exp, '%Y-%m-%d').date()
        yield 'expiry', exp

        raw_vd = inst.exercise['settlementDate']['adjustableDate']['unadjustedDate']
        vd = datetime.datetime.strptime(raw_vd, '%Y-%m-%d').date()
        yield 'value_date', vd

        yield 'notional', trade.quantity
        yield 'trade_date', trade.trade_date

    return domain.FXOptionTrade(**dict(unpack()))


@with_sophis_ids
def sophis2inf(trade: SophisTrade, inst: SophisInstrument) -> domain.InflationSwapTrade:
    def unpack():
        rec = inst.receivingLeg['inflationYoYLeg']
        dates = rec['calculationPeriodDates']
        start = dates['effectiveDate']['adjustableDate']['unadjustedDate']
        yield 'start', datetime.datetime.strptime(start, '%Y-%m-%d').date()

        maturity = dates['terminationDate']['adjustableDate']['unadjustedDate']
        yield 'maturity', datetime.datetime.strptime(maturity, '%Y-%m-%d').date()

        index = rec['inflationIndexIdentifier']['reference']
        yield 'index', domain.InflationIndex[index.replace(' INDEX', '')]

        pay = inst.payingLeg['swapStream']
        cal = pay['calculationPeriodAmount']['calculation']
        rate = cal['fixedRateSchedule']['initialValue']
        yield 'rate', float(rate)

        yield 'trade_date', trade.trade_date
        yield 'notional', trade.quantity

    return domain.InflationSwapTrade(**dict(unpack()))


@with_sophis_ids
def sophis2irs(trade: SophisTrade, inst: SophisInstrument) -> domain.IRSTrade:
    def unpack():
        yield 'ccy', inst.currency

        rec = inst.receivingLeg['swapStream']
        dates = rec['calculationPeriodDates']
        start = dates['effectiveDate']['adjustableDate']['unadjustedDate']
        yield 'start', datetime.datetime.strptime(start, '%Y-%m-%d').date()

        maturity = dates['terminationDate']['adjustableDate']['unadjustedDate']
        yield 'maturity', datetime.datetime.strptime(maturity, '%Y-%m-%d').date()

        cal = rec['calculationPeriodAmount']['calculation']
        rate = cal['fixedRateSchedule']['initialValue']
        yield 'rate', float(rate)

        pay = inst.payingLeg['swapStream']
        reset_freq = pay['resetDates']['resetFrequency']
        tenor = reset_freq['periodMultiplier'] + reset_freq['periodEnum'][:1]
        yield 'idx', domain.Tenor[f'T_{tenor}']

        yield 'trade_date', trade.trade_date
        yield 'notional', trade.quantity

    return domain.IRSTrade(**dict(unpack()))


@with_sophis_ids
def sophis2cap_floor(trade: SophisTrade, inst: SophisInstrument) -> domain.CapFloorTrade:
    def unpack():
        yield 'trade_date', trade.trade_date
        yield 'notional', trade.quantity

        yield 'ccy', inst.currency
        yield 'strike', float(inst.strike)
        yield 'option_type', domain.CapFloorType[inst.capfloorType.upper()]

        reset_freq = inst.floatingComponent['resetDates']['resetFrequency']
        tenor = reset_freq['periodMultiplier'] + reset_freq['periodEnum'][:1]
        yield 'idx', domain.Tenor[f'T_{tenor}']

        dates = inst.floatingComponent['calculationPeriodDates']
        start = dates['effectiveDate']['adjustableDate']['unadjustedDate']
        yield 'start', datetime.datetime.strptime(start, '%Y-%m-%d').date()
        maturity = dates['terminationDate']['adjustableDate']['unadjustedDate']
        yield 'maturity', datetime.datetime.strptime(maturity, '%Y-%m-%d').date()

    return domain.CapFloorTrade(**dict(unpack()))


@with_sophis_ids
def sophis2ois(trade: SophisTrade, inst: SophisInstrument) -> domain.OISTrade:
    def unpack():
        yield 'ccy', inst.currency

        rec = inst.receivingLeg['swapStream']
        dates = rec['calculationPeriodDates']
        start = dates['effectiveDate']['adjustableDate']['unadjustedDate']
        yield 'start', datetime.datetime.strptime(start, '%Y-%m-%d').date()

        maturity = dates['terminationDate']['adjustableDate']['unadjustedDate']
        yield 'maturity', datetime.datetime.strptime(maturity, '%Y-%m-%d').date()

        cal = rec['calculationPeriodAmount']['calculation']
        rate = cal['fixedRateSchedule']['initialValue']
        yield 'rate', float(rate)

        payment_freq = rec['paymentDates']['paymentFrequency']
        tenor = payment_freq['periodMultiplier'] + payment_freq['periodEnum'][:1]
        yield 'fixed_freq', domain.Tenor[f'T_{tenor}']

        yield 'trade_date', trade.trade_date
        yield 'notional', trade.quantity

    return domain.OISTrade(**dict(unpack()))


@with_sophis_ids
def sophis2tenorbasis(trade: SophisTrade, inst: SophisInstrument) -> domain.TenorBasisTrade:
    def unpack():
        yield 'ccy', inst.currency

        rec = inst.receivingLeg['swapStream']
        pay = inst.payingLeg['swapStream']

        rec_dates = rec['calculationPeriodDates']
        start = rec_dates['effectiveDate']['adjustableDate']['unadjustedDate']
        yield 'start', datetime.datetime.strptime(start, '%Y-%m-%d').date()
        maturity = rec_dates['terminationDate']['adjustableDate']['unadjustedDate']
        yield 'maturity', datetime.datetime.strptime(maturity, '%Y-%m-%d').date()

        rec_reset_freq = rec['resetDates']['resetFrequency']
        rec_tenor = rec_reset_freq['periodMultiplier'] + rec_reset_freq['periodEnum'][:1]
        idx_1 = domain.Tenor[f'T_{rec_tenor}']
        yield 'idx_1', idx_1

        pay_reset_freq = pay['resetDates']['resetFrequency']
        pay_tenor = pay_reset_freq['periodMultiplier'] + pay_reset_freq['periodEnum'][:1]
        idx_2 = domain.Tenor[f'T_{pay_tenor}']
        yield 'idx_2', idx_2

        try:
            cal = rec['calculationPeriodAmount']['calculation']
            rate = cal['floatingRateCalculation']['spread']
            yield 'spread_tenor', idx_1
            yield 'notional', trade.quantity
        except KeyError:
            try:
                cal = pay['calculationPeriodAmount']['calculation']
                rate = cal['floatingRateCalculation']['spread']
                yield 'spread_tenor', idx_2
                yield 'notional', trade.quantity * -1
            except KeyError:
                yield 'spread_tenor', idx_1
                yield 'notional', trade.quantity
                rate = 0
        yield 'rate', float(rate)
        yield 'trade_date', trade.trade_date

    return domain.TenorBasisTrade(**dict(unpack()))


@with_sophis_ids
def sophis2ccs(trade: SophisTrade, inst: SophisInstrument) -> domain.CrossCurrencySwapTrade:
    def unpack():
        rec = inst.receivingLeg['swapStream']
        pay = inst.payingLeg['swapStream']

        dates = rec['calculationPeriodDates']
        start = dates['effectiveDate']['adjustableDate']['unadjustedDate']
        yield 'start', datetime.datetime.strptime(start, '%Y-%m-%d').date()
        maturity = dates['terminationDate']['adjustableDate']['unadjustedDate']
        yield 'maturity', datetime.datetime.strptime(maturity, '%Y-%m-%d').date()

        rec_cal = rec['calculationPeriodAmount']['calculation']
        ccy = rec_cal['notionalSchedule']['notionalStepSchedule']['currency']
        yield 'ccy', type_ccy(ccy)
        rate = rec_cal['fixedRateSchedule']['initialValue']
        yield 'rate', float(rate)

        pay_cal = pay['calculationPeriodAmount']['calculation']
        ccy_base = pay_cal['notionalSchedule']['notionalStepSchedule']['currency']
        yield 'ccy_base', type_ccy(ccy_base)
        reset_freq = pay['resetDates']['resetFrequency']
        tenor = reset_freq['periodMultiplier'] + reset_freq['periodEnum'][:1]
        yield 'idx', domain.Tenor[f'T_{tenor}']

        try:
            forex_base = rec['forexInformation']['initialForexSpot']
        except KeyError:
            forex_base = 1
        try:
            forex = pay['forexInformation']['initialForexSpot']
        except KeyError:
            forex = 1
        yield 'fx_rate', float(forex) / float(forex_base)

        yield 'trade_date', trade.trade_date
        yield 'notional', trade.quantity

    return domain.CrossCurrencySwapTrade(**dict(unpack()))


@with_sophis_ids
def sophis2xccybasis(trade: SophisTrade, inst: SophisInstrument) -> domain.XccyBasisTrade:
    def unpack():
        rec = inst.receivingLeg['swapStream']
        pay = inst.payingLeg['swapStream']

        dates = rec['calculationPeriodDates']
        start = dates['effectiveDate']['adjustableDate']['unadjustedDate']
        yield 'start', datetime.datetime.strptime(start, '%Y-%m-%d').date()
        maturity = dates['terminationDate']['adjustableDate']['unadjustedDate']
        yield 'maturity', datetime.datetime.strptime(maturity, '%Y-%m-%d').date()

        rec_cal = rec['calculationPeriodAmount']['calculation']
        ccy = rec_cal['notionalSchedule']['notionalStepSchedule']['currency']
        yield 'ccy', type_ccy(ccy)
        rate = rec_cal['floatingRateCalculation']['spread']
        yield 'rate', float(rate)

        pay_cal = pay['calculationPeriodAmount']['calculation']
        ccy_base = pay_cal['notionalSchedule']['notionalStepSchedule']['currency']
        yield 'ccy_base', type_ccy(ccy_base)
        forex = pay['forexInformation']['initialForexSpot']
        yield 'fx_rate', float(forex)

        yield 'trade_date', trade.trade_date
        yield 'notional', trade.quantity

    return domain.XccyBasisTrade(**dict(unpack()))


@with_sophis_ids
def sophis2trs(trade: SophisTrade, inst: SophisInstrument) -> domain.TRSTrade:
    # sfarrell@202001
    # placeholder for a more complete description of the trade
    def unpack():
        rec = inst.receivingLeg['equityLeg']
        pay = inst.payingLeg['swapStream']

        dates = pay['calculationPeriodDates']
        start = dates['effectiveDate']['adjustableDate']['unadjustedDate']
        yield 'start', datetime.datetime.strptime(start, '%Y-%m-%d').date()
        maturity = dates['terminationDate']['adjustableDate']['unadjustedDate']
        yield 'maturity', datetime.datetime.strptime(maturity, '%Y-%m-%d').date()
        pay_cal = pay['calculationPeriodAmount']['calculation']
        yield 'margin', float(pay_cal['floatingRateCalculation']['spread'])
        ccy_funding = pay_cal['notionalSchedule']['notionalStepSchedule']['currency']
        yield 'ccy_funding', type_ccy(ccy_funding)
        forex = pay['forexInformation']['initialForexSpot']
        yield 'fx_rate', float(forex)
        reset_freq = pay['resetDates']['resetFrequency']
        tenor = reset_freq['periodMultiplier'] + reset_freq['periodEnum'][:1]
        yield 'idx', domain.Tenor[f'T_{tenor}']

        yield 'underlying', domain.Security[rec['equityUnderlyer']['singleUnderlyer']['underlyingAsset']['reference']]
        yield 'price', float(rec['rateOfReturn']['initialPrice']['netPrice']['amount'])

        yield 'trade_date', trade.trade_date

        yield 'notional', trade.quantity * 100
        yield 'ccy', inst.currency

        # trade_date: datetime
        # underlying: Security
        # ccy: Ccy
        # start: date
        # maturity: date
        # margin: float
        # notional: float
        # price: float
        # ccy_funding: Ccy = Ccy.USD
        # idx: Optional[Tenor] = None
        # fx_rate: float = 1

    return domain.TRSTrade(**dict(unpack()))


@with_sophis_ids
def sophis2swaption(
        trade: SophisTrade,
        inst: SophisInstrument
) -> Union[domain.SwaptionTrade, domain.CrossCurrencySwaptionTrade]:
    from firm_f3.modelconfig import CCS_SWAPTION_CCY
    is_ccs_swaption = inst.currency in CCS_SWAPTION_CCY

    def unpack():
        yield 'ccy', inst.currency
        strike = inst.strike['strikeValue']['strikePrice']['amount']
        multiplier = inst.pointValue.get('inPercent', 1)
        yield 'strike', float(strike) * float(multiplier)

        typ = inst.optionType
        if typ == 'Call':
            # jchi@201906
            # sophis convention: Call==PAYER, Put==RECEIVER (market convention is the opposite)
            yield 'swaption_type', domain.SwaptionType.PAYER
        elif typ == 'Put':
            yield 'swaption_type', domain.SwaptionType.RECEIVER
        else:
            err = f'bad optionType in {inst}'
            logger.error(err)
            raise ValueError(err)

        raw_exp = inst.exercise['europeanExercise']['expirationDate']['adjustableDate']['unadjustedDate']
        exp = datetime.datetime.strptime(raw_exp, '%Y-%m-%d').date()
        yield 'expiry', exp

        swap = inst.swapInSwaption
        if swap is None:
            raise SophisInstrumentLoadingError(f'swapInSwaption is None in instrument={trade.instrument_id}')
        raw_start = swap['startDate2']['adjustableDate']['unadjustedDate']
        start = datetime.datetime.strptime(raw_start, '%Y-%m-%d').date()
        yield 'start', start
        raw_end = swap['endDate2']['adjustableDate']['unadjustedDate']
        end = datetime.datetime.strptime(raw_end, '%Y-%m-%d').date()
        yield 'maturity', end

        idx_tenor = swap['floatingIndexTenor']
        tenor = idx_tenor['periodMultiplier'] + idx_tenor['periodEnum'][:1]
        yield 'idx', domain.Tenor[f'T_{tenor}']

        if not is_ccs_swaption:
            yield 'cash_settle', inst.settlementType == 'Cash'

        yield 'notional', trade.quantity
        yield 'trade_date', trade.trade_date


    if is_ccs_swaption:
        return domain.CrossCurrencySwaptionTrade(**dict(unpack()))
    return domain.SwaptionTrade(**dict(unpack()))


@with_sophis_ids
def sophis2cashflow(trade: SophisTrade, inst: SophisInstrument = None) -> domain.CashFlow:
    def unpack():
        yield 'trade_date', trade.trade_date
        yield 'ccy', trade.pay_currency
        yield 'maturity', trade.settlement_date
        yield 'notional', -trade.net_amount

    return domain.CashFlow(**dict(unpack()))


@with_sophis_ids
def sophis2bondfuture(trade: SophisTrade, inst: SophisInstrument) -> domain.BondFutureTrade:
    def unpack():
        yield 'trade_date', trade.trade_date
        yield 'ticker', trade.instrument_reference
        yield 'quantity', trade.quantity
        yield 'price', trade.price

        yield 'ccy', inst.currency
        yield 'expiry', inst.expirationDate
        yield 'contract_size', float(inst.notional['amount'])

    return domain.BondFutureTrade(**dict(unpack()))


@with_sophis_ids
def sophis2ratesfuture(trade: SophisTrade, inst: SophisInstrument) -> domain.RatesFutureTrade:
    def unpack():
        yield 'trade_date', trade.trade_date
        yield 'ticker', trade.instrument_reference
        yield 'quantity', trade.quantity
        yield 'price', trade.price

        yield 'ccy', inst.currency
        yield 'expiry', inst.expirationDate
        yield 'contract_size', float(inst.notional['amount'])

    return domain.RatesFutureTrade(**dict(unpack()))


@with_sophis_ids
def sophis2rates_option(trade: SophisTrade, inst: SophisInstrument) -> domain.RatesFutureOptionTrade:
    def unpack():
        yield 'trade_date', trade.trade_date
        yield 'quantity', trade.quantity
        yield 'price', trade.price

        yield 'ccy', inst.notional['currency']
        yield 'ticker', inst.underlyer['reference']
        yield 'strike', float(inst.strike['strikeValue']['strikePrice']['amount'])
        yield 'option_type', inst.optionType.upper()
        expiry_str = inst.exercise['europeanExercise']['expirationDate']['adjustableDate']['unadjustedDate']
        yield 'expiry', type_date_from_str(expiry_str)
        yield 'contract_size', float(inst.notional['amount'])

    return domain.RatesFutureOptionTrade(**dict(unpack()))


@with_sophis_ids
def sophis2rates_option2(trade: SophisTrade, inst: SophisInstrument) -> domain.RatesFutureOptionTrade:
    def unpack():
        yield 'trade_date', trade.trade_date
        yield 'ticker', trade.instrument_reference
        yield 'quantity', trade.quantity
        yield 'price', trade.price

        yield 'ccy', inst.currency
        yield 'strike', float(inst.strike['strikeValue']['strikePrice']['amount'])
        yield 'option_type', inst.optionType.upper()
        expiry_str = inst.exercise['americanExercise']['expirationDate']['adjustableDate']['unadjustedDate']
        yield 'expiry', type_date_from_str(expiry_str)
        yield 'contract_size', inst.contractSize

    return domain.RatesFutureOptionTrade(**dict(unpack()))


@with_sophis_ids
def sophis2bond(trade: SophisTrade, inst: SophisInstrument) -> domain.BondTrade:
    def unpack():
        yield 'trade_date', trade.trade_date
        yield 'ccy', trade.pay_currency
        yield 'price', trade.price
        yield 'isin', trade.instrument_reference

        yield 'coupon', float(inst.interestType['fixed']['nominalRate'])
        yield 'maturity', type_date_from_str(inst.cashFlowGeneration['redemptionDate'])
        yield 'issue_date', type_date_from_str(inst.cashFlowGeneration['issueDate'])

        yield 'notional', trade.quantity * float(inst.notional['amount'])

    return domain.BondTrade(**dict(unpack()))


@with_sophis_ids
def sophis2spread_option(trade: SophisTrade, inst: SophisInstrument) -> domain.SpreadOptionTrade:
    def unpack():
        yield 'trade_date', trade.trade_date
        yield 'notional', trade.quantity

        yield 'ccy', inst.currency
        yield 'strike', float(inst.strike['strikeValue']['strikePrice']['amount'])

        raw_exp = inst.exercise['europeanExercise']['expirationDate']['adjustableDate']['unadjustedDate']
        exp = datetime.datetime.strptime(raw_exp, '%Y-%m-%d').date()
        yield 'expiry', exp

        try:
            idx_1, idx_2 = re.findall('(\d+[YMWDymwd])', inst.name)
        except ValueError:
            raise ValueError(f'cannot parse indices from name {inst.name}')
        yield 'idx_1', domain.Tenor[f'T_{idx_1.upper()}']
        yield 'idx_2', domain.Tenor[f'T_{idx_2.upper()}']

    return domain.SpreadOptionTrade(**dict(unpack()))


if __name__ == '__main__':
    pass
    # ps = self = SophisPositionService().__enter__()
    # instruments = Cacher('instruments.cache').__enter__()
    #
    # # pid = 35876  # ndf IDR
    # # pid = 33535  # ndf INR
    # # pid = 33215  # fx/fwd/spot
    # # pid = 32712  # vanilla swap
    # # pid = 33676  # swap/fx mix
    # # pid = 33536  # swaption
    # # pid = 34473  # nested portfolio
    # # pid = 33675  # nested portfolio 2 layers
    # # pid = 34399  # Xccy swap
    # # pid = 35177  # Xccy basis swap
    # # pid = 32055  # tenor basis EUR
    # # pid = 31897  # tenor basis AUD
    # # pid = 30895  # root
    # # pid = 32841  # fx options
    # # pid = 31815  # SGD portfolio with suspicious fixing date
    # # pid = 35213  # IRS with coupon payment
    # # pid = 32456  # inflation swap
    # # pid = 33318  # AUD swaption
    # pid = 37580  # Kris 10Y portfolio
    # # pid = 37578  # Kris WHITE BOX
    # # pid = 19515  # jchilton root
    # # pid = 38575  # rates vol root
    #
    # ps.get_trades_by_portfolio_id(pid)
    # # root = ps.get_portfolio_by_id(pid)
    # # trades = root.fetch(ps, reload=True, recursive=True)
    #
    # # clean up
    # instruments.__exit__()
    # ps.__exit__()

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\datalayer\sophis_diagnostic.py
----------------------------------------
from typing import Tuple, List
from functools import singledispatch
import pandas
from atom_client.client import grpc

from firm_f3.util.email import EmailMessage
from firm_f3.datalayer.sophis import SophisPositionService, SophisInstrumentLoadingError, SophisTradeValidationError

PORTFOLIOS_FOR_DIAGNOSIS = (
    30895,  # asia rates
    38575,  # rates vol
    # 34473, 32400, 39555, 39556
)
EMAIL_SENDER = 'jchi@firm-partners.com'
EMAIL_RECIPIENTS = (
    'jchi@firm-partners.com',
)
OUTPUT_FILE_PATH = './bad_instrument_id.txt'


def diagnose_sophis_trades(
        portfolio_ids: List[int] = PORTFOLIOS_FOR_DIAGNOSIS,
        report_recipients: List[str] = EMAIL_RECIPIENTS,
):
    with SophisPositionService() as ps:
        ps.diagnosis = True
        for pid in portfolio_ids:
            root = ps.get_portfolio_by_id(pid)
            root.fetch(ps, recursive=True)

    errors = [(pid, tid, iid, e) for (pid, tid, iid), v in ps.diagnostic_errors.items() for e in v]
    if errors:
        df = handle_diagnostic_errors(errors)

        msg = EmailMessage() \
            .set_sender(EMAIL_SENDER) \
            .set_recipients(report_recipients) \
            .set_subject('[Sophis Trade Diagnosis] Actions Required') \
            .set_html_content(df.to_html())

        msg.send()

        with open(OUTPUT_FILE_PATH, 'w') as f:
            f.write('\n'.join(map(str, set(df['InstrumentID']))))

    print(f'Sophis diagnosis done with {len(errors)} errors')


def handle_diagnostic_errors(errors: List[Tuple[int, int, int, Exception]]):
    def unpack():
        for pid, tid, iid, err in errors:
            e = str(err)
            if '>' in e:
                _, _, e = e.partition('>')
            yield pid, tid, iid, e.strip(), error_action(err)

    return pandas.DataFrame(unpack(), columns=['PortfolioID', 'TradeID', 'InstrumentID', 'Error', 'Recommended Action'])


DEFAULT_ACTION = 'Contact Jim (jchi@firm-partners.com)'


@singledispatch
def error_action(err: Exception) -> str:
    return DEFAULT_ACTION


@error_action.register
def error_action_for_grpc_error(err: grpc.RpcError) -> str:
    e = str(err)
    if 'errors are: Unknown: Invalid Data Value  : XML_Root= :Not underlying type defined' in e:
        return 'Go to Sophis GUI, check the "swap" box'
    return DEFAULT_ACTION


@error_action.register
def error_action_for_sophis_position_loading_error(err: SophisInstrumentLoadingError) -> str:
    e = str(err)
    if 'swapInSwaption is None' in e:
        return 'Go to Sophis GUI, check the "swap" box'
    return DEFAULT_ACTION


@error_action.register
def error_action_for_sophis_trade_validation_error(err: SophisTradeValidationError) -> str:
    e = str(err)
    if 'booked as an FX-Spot trade' in e:
        return 'Ask trader to revise the booking'
    return DEFAULT_ACTION


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser(description='Diagnose Sophis API.')
    parser.add_argument('-P', '--portfolio-ids', type=lambda x: list(map(int, x.split(','))),
                        default=PORTFOLIOS_FOR_DIAGNOSIS)
    parser.add_argument('-R', '--report_recipients', type=lambda x: x.split(','), default=EMAIL_RECIPIENTS)

    namespace = parser.parse_args()
    diagnose_sophis_trades(**vars(namespace))

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\datalayer\sophis_test.py
----------------------------------------
import logging
import pytest  # type:ignore
from time import sleep
from firm_f3.util.utils import timer
from .sophis import SophisPositionService

logger = logging.getLogger(__name__)


@pytest.fixture(scope='module', params=['prd'])
def ps(request):
    logger.debug('fixture setup ...')
    with SophisPositionService(env_or_host=request.param) as ps:
        yield ps
    logger.debug('fixture teardown ...')


CASES = [
    (31899, 'cancelled trades'),
    # (35876, 'ndf IDR'),
    # (33535, 'ndf INR'),
    # (33215, 'fx/fwd/spot'),
    # (32712, 'vanilla swap'),
    # (33676, 'swap/fx mix'),
    # (32055, 'tenor basis'),
    # (33536, 'swaption'),
    # (34473, 'nested portfolio'),
    # (33675, 'nested portfolio 2 layers'),
    # (34399, 'Xccy swap'),
    # (35177, 'Xccy basis swap'),
    # (32055, 'tenor basis EUR'),
    # (31897, 'tenor basis AUD'),
    # (32841, 'fx options'),
    # (31815, 'SGD portfolio with suspicious fixing date'),
    # (35213, 'IRS with coupon payment'),
    # (32456, 'inflation swap'),
]


@pytest.fixture(scope='function', params=[i for i, _ in CASES], ids=[j for _, j in CASES])
def pid(request):
    logger.info('-' * 20 + f' test pid={request.param} ({request.param_index + 1}/{len(CASES)}) ' + '-' * 20)
    yield request.param
    if request.param_index + 1 != len(CASES):
        sleep(5)  # cooldown between tests
    else:
        logger.debug('-' * 20 + ' all done ' + '-' * 20)


def test_client(ps, pid):
    with timer():
        ps.get_trades_by_portfolio_id(pid)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\datalayer\swaption_csv.py
----------------------------------------
from __future__ import annotations
import os
import datetime
from dataclasses import dataclass, field
from collections import defaultdict
from typing import List, Callable

import dateutil
import pandas
from firm_domain import Tenor, Swaption

try:
    SWAPTION_DATA_DIR = os.environ['F3SHARED_DATA_DIR']
except KeyError:
    SWAPTION_DATA_DIR = os.path.abspath('./data')


@dataclass
class FlatFileMarketDataSnapshot:
    file_path: str
    valuation_date: datetime.date
    ordering_timepoint: datetime.datetime = field(repr=False, init=False)

    def __post_init__(self):
        self.ordering_timepoint = datetime.datetime.fromtimestamp(os.path.getmtime(self.file_path))

    def __gt__(self, other: FlatFileMarketDataSnapshot) -> bool:
        assert isinstance(other, type(self))
        return (self.valuation_date, self.ordering_timepoint) > (other.valuation_date, other.ordering_timepoint)

    async def to_frame_async(self) -> pandas.DataFrame:
        df = pandas.read_csv(self.file_path)
        raw = defaultdict(dict)
        for _, row in df.iterrows():
            expiry_str, tenor_str, strike_raw, vol_raw = row['OptionMat'], row['Tenor'], row['Strike'], row['Nvol']
            try:
                expiry = Tenor.parse(expiry_str)
                tenor = Tenor.parse(tenor_str)
                strike = float(strike_raw) / 10000
                vol = float(vol_raw) / 10000
            except (KeyError, ValueError):
                continue
            raw[(strike, tenor)][expiry] = vol

        return pandas.DataFrame(raw).T.sort_index().T.sort_index()


@dataclass
class FlatFileMarketDataStream:
    file_dir: str

    @classmethod
    def get_many(cls, data_dir: str = None, dir_filter: Callable = None) -> List[FlatFileMarketDataStream]:
        if data_dir is None:
            data_dir = SWAPTION_DATA_DIR

        def unpack():
            for file_dir, _, file_names in os.walk(data_dir):
                if file_names and (not callable(dir_filter) or dir_filter(file_dir)):
                    yield cls(file_dir)

        return list(unpack())

    @classmethod
    def get_one(cls, data_dir: str = None, dir_filter: Callable = None) -> FlatFileMarketDataStream:
        [res] = cls.get_many(data_dir=data_dir, dir_filter=dir_filter)
        return res

    @classmethod
    async def get_many_by_instruments_async(cls, instruments: List[Swaption],
                                            as_of_date: datetime.date = None) -> FlatFileMarketDataSnapshot:
        [[inst_type, ccy]] = {(type(i).__name__, i.ccy) for i in instruments}
        tail = f'\\{inst_type.lower()}\\{ccy}'
        stream = cls.get_one(dir_filter=lambda x: tail in x)
        return stream.get_latest(as_of_date=as_of_date)

    def get_snapshots(self, as_of_date: datetime.date = None) -> List[FlatFileMarketDataSnapshot]:
        if as_of_date is None:
            as_of_date = datetime.date.today()

        def unpack():
            for filename in os.listdir(self.file_dir):
                if filename.endswith('.csv'):
                    _, _, date_str = filename.replace('.csv', '').rpartition('_')
                    try:
                        date = dateutil.parser.parse(date_str).date()
                    except ValueError:
                        continue
                    if date <= as_of_date:
                        yield FlatFileMarketDataSnapshot(os.path.join(self.file_dir, filename), valuation_date=date)

        return list(unpack())

    def get_latest(self, as_of_date: datetime.date = None) -> FlatFileMarketDataSnapshot:
        return max(self.get_snapshots(as_of_date=as_of_date))


if __name__ == '__main__':
    pass
    # streams = FlatFileMarketDataStream.get_many()
    # stream = streams[0]
    # snap = stream.get_latest()
    # df = snap.to_frame()

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\datalayer\symphony.py
----------------------------------------
import logging
import threading
from atom_client.client import grpc  # type:ignore
from atom_client.chat_message import ChatMessage  # type:ignore
from atom_client.symphony_client import SymphonyClient  # type:ignore
from firm_f3.datalayer.mappings import CHAT_MAPPINGS
from firm_f3.datalayer.sophis import SophisPositionService, SophisPortfolio
from firm_f3.fincadutil import calc_trade, REQUEST
from firm_f3.core.modelutils import get_model_by_ref
from firm_f3.util.caching import Cacher

logger = logging.getLogger(__name__)
MESSAGE_HISTORY = []


def escape_message_ml(text) -> str:
    if text is None:
        return ''
    return str(text) \
        .replace("&", "&amp;") \
        .replace("'", "&apos;") \
        .replace('"', "&quot;") \
        .replace("<", "&lt;") \
        .replace(">", "&gt;")


def code_block(text) -> str:
    return f'<code>{escape_message_ml(text)}</code>'


class ChatBot:
    logger = logging.getLogger(__name__)
    root: SophisPortfolio
    folio: SophisPortfolio
    ps: SophisPositionService
    trades: list = []
    model: None
    prev_msg_dict = {}

    def __init__(self, name: str, conn: SymphonyClient):
        self.name = name
        self.conversation_id = CHAT_MAPPINGS[name]
        self.conn = conn
        self._closed = False
        self._t = None

    def __repr__(self):
        return f'<{type(self).__name__} {self.name}>'

    def __send(self, content: str):
        self.logger.debug(content)
        self.conn.send_chat_message(content, conversation_id=self.conversation_id)

    send_message = __send

    def run(self):
        self.logger.info(f'subscribing to chat {self.name} cid={self.conversation_id}')
        i = 0
        while True:
            try:
                self.conn.subscribe_to_chat_messages(self._dispatch, self.conversation_id)
            except grpc.RpcError as e:
                if e.code() is grpc.StatusCode.UNKNOWN and e.details() == 'Stream removed':
                    i += 1
                    self.logger.debug(f'stream removed, reconnect {i} ...')
                    continue
                elif e.code() is not grpc.StatusCode.CANCELLED:
                    self.logger.error('', exc_info=e)
                break
        self.logger.debug('chat closed ...')

    def _dispatch(self, res: dict):
        MESSAGE_HISTORY.append(res)
        msg = res['value']
        if msg.conversation_id == self.conversation_id:
            if res.get('_operation') == 'INSERT':
                try:
                    self.on_insert(msg)
                except Exception as e:
                    self.logger.error(res, exc_info=e)
                    self.send_message(f'INTERNAL ERROR {e}')

    def kill(self):
        self.send_message('jarvis leaving the chat, bye!')
        self.conn.channel.close()

    def __enter__(self):
        self._t = threading.Thread(target=self.run, name=self.name)
        self._t.start()
        return self

    def __exit__(self, *exc):
        self.logger.debug(f'chat {self.name} exiting ...')

    start = __enter__
    exit = __exit__

    def on_insert(self, msg: ChatMessage):
        msg_dict = msg.to_flat_dict()
        if msg_dict == self.prev_msg_dict:
            # ignore duplicate messages
            return
        self.prev_msg_dict = msg_dict
        head, _, tail = msg.content.partition(' ')
        if head == 'jarvis':
            self.logger.debug(f'responding to "{msg.content}"')
            cmd = tail.split()
            if not cmd:
                self.send_message("hi, i'm listening")
            elif cmd[0] == 'kill':
                self.kill()
            elif cmd[0] == 'root':
                self.folio = self.root
                self.send_message(code_block(self.folio))
            elif cmd[0] == 'cd':
                if len(cmd) > 1:
                    try:
                        pid = int(cmd[1])
                        self.folio = self.root.find(pid)
                    except ValueError:
                        # non int operand
                        self.folio = self.folio[cmd[1]]
                    except KeyError:
                        self.send_message(f'bad portfolio id {cmd[1]}')
                self.send_message(code_block(self.folio))
            elif cmd[0] == 'pv':
                self.trades.clear()
                self.trades.extend(self.folio.fetch(self.ps))
                self.send_message(f'fetched {len(self.trades)} trades, calculating pv ...')
                pv = calc_trade(self.trades, self.model, REQUEST.VALUE)
                self.send_message(f'{self.folio.name}: ${pv:,.2f}')


def main(daemon=False):
    with Cacher('symphony.cache') as cacher:
        with SophisPositionService() as ps:
            chat = ChatBot('AsiaRatesDev', conn=ps.conn.symphony)
            pid = 30895  # AsiaRates root
            chat.root = chat.folio = ps.get_portfolio_by_id(pid)
            chat.ps = ps
            chat.model = get_model_by_ref()
            if daemon:
                logger.debug('running in daemon mode ...')
                chat.run()
            else:
                from IPython import embed  # type:ignore
                with chat:
                    embed()
        cacher['MESSAGE_HISTORY'] = MESSAGE_HISTORY


if __name__ == '__main__':
    main(daemon=True)

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\datalayer\symphony_test.py
----------------------------------------
import logging
import pytest  # type:ignore
import random
from firm_f3.util.caching import Cacher
from .symphony import ChatBot, SophisPositionService, get_model_by_ref, ChatMessage

logger = logging.getLogger(__name__)


@pytest.fixture(scope='module', params=['prd'])
def ps(request):
    logger.debug('fixture setup ...')
    with SophisPositionService(env_or_host=request.param) as ps:
        yield ps
    logger.debug('fixture teardown ...')


@pytest.fixture(scope='module', params=['JimTest'])
def chat(request, ps):
    logger.debug('fixture setup ...')
    ChatBot.send_message = logger.info
    chat = ChatBot(request.param, conn=ps.conn.symphony)

    with Cacher('symphony_test.cache') as cacher:
        try:
            root = cacher['root']
        except KeyError:
            pid = 30895  # AsiaRates root
            logger.debug(f'loading portfolio {pid} ...')
            cacher['root'] = root = ps.get_portfolio_by_id(pid)

        chat.root = chat.folio = root
        chat.ps = ps
        chat.model = get_model_by_ref()
        yield chat

    logger.debug('fixture teardown ...')


CASES = [
    'jarvis',
    'jarvis root',
    'jarvis cd',
    'jarvis cd ?',
    'jarvis cd ?',
    'jarvis cd ..',
    'jarvis cd 35876',
    'jarvis pv',
    'jarvis kill'
]


@pytest.fixture(scope='function', params=CASES)
def msg(chat, request):
    cmd, _, param = request.param.rpartition(' ')
    if cmd == 'jarvis cd' and param == '?':
        i = random.choice(list(chat.folio))
        request.param = f'{cmd} {i}'
    return ChatMessage(content=request.param)


def test_on_insert(chat, msg: ChatMessage):
    logger.debug(f'receiving message: "{msg.content}"')
    chat.on_insert(msg)


if __name__ == '__main__':
    ps = SophisPositionService(env_or_host='prd').__enter__()

    ps.__exit__()

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\datalayer\__init__.py
----------------------------------------
from .economics import *
from .datalayer import *
from .halftick import *

__all__ = [k for k, v in globals().items() if getattr(v, '__module__', '').startswith(__name__)]

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\datalayer\__pycache__\bbg_mapping.cpython-37.pyc
----------------------------------------
B

    y  d                  @   sf   d dl T dd  e     D  Zd dlZdZee  e  ee  ye	 W n e
k
rX   Y n
X e
d  dS )      ) *c             C   s&   g | ]\}}t |d d  d r| qS ) 
__module__  Z
firm_domain)  getattr 
startswith) .0 k v  r
    NE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/datalayer/bbg_mapping.py 
<listcomp>   s    r   Na   
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                                        !!
!! WARNING firm_f3.datalayer.bbg_mapping is moved to firm_domain.datalayer.bbg_mapping    !!
!! please update your import statement accordingly                                        !!
!!                                                                                        !!
!! Make sure to run ``pip install firm-domain`` in terminal                               !!
!! Details for migration:                                                                 !!
!!     http://firm-bitbucket:7990/projects/firmSSL/repos/firm-domain/browse               !!
!!                                                                                        !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
zPress any key to confirm ...)Z!firm_domain.datalayer.bbg_mapping  globals items  __all__ warningsZWARNING_MESSAGE print warn DeprecationWarningZ
__IPYTHON__ 	NameError inputr
   r
   r
   r
    <module>   s   

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\datalayer\__pycache__\mappings.cpython-37.pyc
----------------------------------------
B

    y  d3                  @   s   d ddddd Z dS ) z$/wPZnADwxbAymoyFeZpJlH///pWmmo62dA==z$M6XvHbQPO08dsi4DOTT38X///pSqDBv7dA==z$Dr0fi70JiZRSn5UqDOXuMX///pSVnBu+dA==z$otD053cj+kBuqXlvCiCMIH///pGR2DvtdA==z$wC6+HbLYC4ajGvjESgtLE3///pG76hD4dA==)Z
Rates_ChatZAsiaRatesDevZ JimTestZApolloZ
MarketScreensN)Z
CHAT_MAPPINGS  r   r    KE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/datalayer/mappings.py <module>   s   
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\datalayer\__pycache__\__init__.cpython-37.pyc
----------------------------------------
B

    y  d                    @   s0   d dl T d dlT d dlT dd  e     D  ZdS )    ) *c             C   s&   g | ]\}}t |d d  t r| qS ) 
__module__  )  getattr 
startswith __name__) .0 k v  r
    KE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/datalayer/__init__.py 
<listcomp>   s    r
   N)Z	economicsZ	datalayerZhalftick  globals items  __all__r
   r
   r
   r    <module>   s   
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\domain\core.py
----------------------------------------
import firm_domain.core as domain

# jchi@201912
# backward compatibility for unpickling files stored in Pepper Asia
# objects were stored as firm_f3.domain.core.CCY in Pepper Asia pickle files
CCY = Ccy = domain.Ccy
TENOR = Tenor = domain.Tenor

Month = domain.Month
IMM = domain.IMM
FutureExpiry = domain.FutureExpiry
SwaptionType = domain.SwaptionType
OptionStrat = domain.OptionStrat
OptionType = domain.OptionType
InflationIndex = domain.InflationIndex
SabrCoefficient = domain.SabrCoefficient
Country = domain.Country

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\domain\instrument.py
----------------------------------------
from firm_domain import instrument as domain

# jchi@201912
# backward compatibility for unpickling files stored in Pepper Asia
Instrument = domain.Instrument
Rate = domain.Rate
FRA = domain.FRA
IMMFRA = domain.IMMFRA
FXForward = domain.FXForward
FXOption = domain.FXOption
Swap = domain.Swap
OIS = domain.OIS
IRS = domain.IRS
Swaption = domain.Swaption
XccyBasis = domain.XccyBasis
CrossCurrencySwap = domain.CrossCurrencySwap
CCSSwaption = domain.CCSSwaption
TenorBasis = domain.TenorBasis
InflationSwap = domain.InflationSwap
RatesFuture = domain.RatesFuture

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\domain\trade.py
----------------------------------------
from firm_domain import trade as domain

# jchi@201912
# backward compatibility for unpickling files stored in Pepper Asia
Trade=domain.Trade
BondTrade=domain.BondTrade
BondFutureTrade=domain.BondFutureTrade
RatesFutureTrade=domain.RatesFutureTrade
FXForwardTrade=domain.FXForwardTrade
IRSTrade=domain.IRSTrade
OISTrade=domain.OISTrade
TenorBasisTrade=domain.TenorBasisTrade
InflationSwapTrade=domain.InflationSwapTrade
CrossCurrencySwapTrade=domain.CrossCurrencySwapTrade
CrossCurrencySwaptionTrade=domain.CrossCurrencySwaptionTrade
SwaptionTrade=domain.SwaptionTrade
CashFlow=domain.CashFlow
XccyBasisTrade=domain.XccyBasisTrade
FXOptionTrade=domain.FXOptionTrade

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\domain\__init__.py
----------------------------------------
from firm_domain.core import *
from firm_domain.convention import *
from firm_domain.instrument import *
from firm_domain.instrument_spot import *
from firm_domain.instrument_type import *
from firm_domain.trade import *
from firm_domain.position import *
from firm_domain.market_date import *
from firm_domain.trade_collapse import *
from firm_domain.market_data import *

__all__ = [k for k, v in globals().items() if getattr(v, '__module__', '').startswith('firm_domain')]

import warnings

WARNING_MESSAGE = """
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                            !!
!! WARNING firm_f3.domain is moved to be firm_domain                          !!
!! please update your import statement accordingly                            !!
!!                                                                            !!
!! Make sure to run ``pip install firm-domain`` in terminal                   !!
!! Details for migration:                                                     !!
!!     http://firm-bitbucket:7990/projects/firmSSL/repos/firm-domain/browse   !!
!!                                                                            !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"""
print(WARNING_MESSAGE)
warnings.warn(WARNING_MESSAGE, DeprecationWarning)
try:
    __IPYTHON__  # type: ignore
except NameError:
    pass
else:
    input('Press any key to confirm ...')

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\domain\__pycache__\core.cpython-37.pyc
----------------------------------------
B

    y  d                  @   sZ   d dl mZ ej ZZej ZZej Z ejZej	Z	ej
Z
ej
Z
ejZej
Z
ejZejZdS )     N)Zfirm_domain.core core domainZCcyZCCYZTenorZTENORZMonthZIMMZFutureExpiryZSwaptionTypeZ
OptionStratZ
OptionTypeZInflationIndexZSabrCoefficientZ Country  r   r    DE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/domain/core.py <module>   s   


........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\domain\__pycache__\instrument.cpython-37.pyc
----------------------------------------
B

    y  d2                  @   sp   d dl mZ ejZejZejZejZej Z ejZej	Z	ej
Z
ej
Z
ejZej
Z
ejZejZejZejZejZdS )     ) 
instrumentN)Z
firm_domainr    domainZ
InstrumentZRateZFRAZIMMFRAZ	FXForwardZFXOptionZSwapZOISZIRSZSwaptionZ	XccyBasisZCrossCurrencySwapZ
CCSSwaptionZ
TenorBasisZ
InflationSwapZ
RatesFuture  r   r    JE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/domain/instrument.py <module>   s    
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\domain\__pycache__\trade.cpython-37.pyc
----------------------------------------
B

    y  d                   @   sj   d dl mZ ejZejZejZejZej Z ejZej	Z	ej
Z
ej
Z
ejZej
Z
ejZejZejZejZdS )     ) tradeN)Z
firm_domainr    domainZTradeZ	BondTradeZBondFutureTradeZRatesFutureTradeZFXForwardTradeZIRSTradeZOISTradeZTenorBasisTradeZInflationSwapTradeZCrossCurrencySwapTradeZCrossCurrencySwaptionTradeZ
SwaptionTradeZCashFlowZXccyBasisTradeZ
FXOptionTrade  r   r    EE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/domain/trade.py <module>   s   
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\domain\__pycache__\__init__.cpython-37.pyc
----------------------------------------
B

    y  d                   @   s    d dl T d dlT d dlT d dlT d dlT d dlT d dlT d dl T d dlT d dl	T dd  e
   
  D  Zd dl
Z
dZee  e
 ee  ye W n ek
r    Y n
X ed  dS )      ) *c             C   s&   g | ]\}}t |d d  d r| qS ) 
__module__  Z
firm_domain)  getattr 
startswith) .0 k v  r
    HE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/domain/__init__.py 
<listcomp>   s    r   Na+  
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                            !!
!! WARNING firm_f3.domain is moved to be firm_domain                          !!
!! please update your import statement accordingly                            !!
!!                                                                            !!
!! Make sure to run ``pip install firm-domain`` in terminal                   !!
!! Details for migration:                                                     !!
!!     http://firm-bitbucket:7990/projects/firmSSL/repos/firm-domain/browse   !!
!!                                                                            !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
zPress any key to confirm ...)Zfirm_domain.coreZfirm_domain.conventionZfirm_domain.instrumentZfirm_domain.instrument_spotZfirm_domain.instrument_typeZfirm_domain.tradeZfirm_domain.positionZfirm_domain.market_dateZfirm_domain.trade_collapseZfirm_domain.market_data  globals items  __all__ warningsZWARNING_MESSAGE print warn DeprecationWarningZ
__IPYTHON__ 	NameError inputr
   r
   r
   r
    <module>   s&   

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\evaluate\asset_curve_tag.py
----------------------------------------
from functools import singledispatch
from typing import List, Union

from f3sdk.f3 import F3Object  # type: ignore
from f3sdk.lib.coroutine import wait  # type: ignore
from firm_domain import Security
import firm_f3.f3client  # type:ignore
from firm_f3.mapping import f3_security_entity

from .handlers import scalar_handler
from .core import f3_evaluate_async


async def f3_asset_curve_tag_async(sec: Security, *secs) -> Union[List[str], List[List[str]]]:
    if secs :
        req = [req_asset_curve_tag_single(i) for i in (sec, *secs)]
    else:
        req = req_asset_curve_tag_single(sec)
    return await f3_evaluate_async(req, callback=scalar_handler)


def f3_asset_curve_tag(sec: Security, *secs) -> List[List[str]]:
    return wait(f3_asset_curve_tag_async(sec, *secs))


@singledispatch
def req_asset_curve_tag_single(sec: Security) -> F3Object:
    raise TypeError(f'expect Security, got type {type(sec)} instead')


@req_asset_curve_tag_single.register
def req_asset_curve_tag_single_by_f3obj(f3obj: F3Object) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.AssetPriceCurveTag(
        AssetCurveIdentifier=f3obj
    )


@req_asset_curve_tag_single.register
def req_asset_curve_tag_single_by_security(sec: Security) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.AssetPriceCurveTag(
        AssetCurveIdentifier=f3_security_entity(sec)
    )


@req_asset_curve_tag_single.register
def req_asset_curve_tag_single_by_str(sec: str) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.AssetPriceCurveTag(
        AssetCurveIdentifier=sec
    )


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\evaluate\core.py
----------------------------------------
import asyncio
import itertools
import logging
from typing import Callable, Iterable, List, Optional, Any, Union

from firm_domain.util.exceptionutils import create_exception_bypasser, get_inner_exception
from firm_domain.util.fileutils import rotate_filename
from deprecation import deprecated
from f3sdk.f3.f3object import F3Object
from f3sdk.lib.coroutine import wait  # type: ignore
from f3sdk.f3 import Future  # type: ignore

import firm_f3.f3client  # type:ignore
from firm_f3.util.f3ml import F3mlSpy
from firm_f3.util.utils import timer, chunks_list

logger = logging.getLogger(__name__)


async def f3_evaluate_sequence_async(req: Iterable, callback: Callable = None):
    f3 = firm_f3.f3client.get_platform_client()
    req_sequence = list(req)

    req_index = 0
    req_mapping = {}
    for i, r in enumerate(req_sequence):
        if r is None:
            req_mapping[i] = None
        else:
            req_mapping[i] = req_index
            req_index += 1

    actual_reqs = [req_sequence[i] for i, v in req_mapping.items() if v is not None]

    for i, r in enumerate(actual_reqs):
        assert isinstance(r, Future), f'{r} @i={i} is not a {Future}'

    # with timer(f'await f3.evaluate_sequence for {len(req_sequence)} requests'):
    temp_res = await f3.evaluate_sequence(actual_reqs)

    res = [None if v is None else temp_res[v] for v in req_mapping.values()]

    if callback is None:
        return res
    elif asyncio.iscoroutinefunction(callback):
        return [await callback(i) for i in res]
    return [callback(i) for i in res]


async def f3_evaluate_single_async(req, callback: Callable = None):
    f3 = firm_f3.f3client.get_platform_client()
    if isinstance(req, Iterable):
        return await f3_evaluate_sequence_async(req, callback=callback)
    elif not asyncio.iscoroutine(req):
        req = f3.evaluate(req)

    # with timer(f'await f3.evaluate for {req}'):
    res = await req

    if callback is None:
        return res
    elif asyncio.iscoroutinefunction(callback):
        return await callback(res)
    return callback(res)


async def f3_evaluate_many_async(req, *reqs,
                                 callback: Callable = None):
    requests = list(f3_evaluate_single_async(r, callback=callback) for r in (req, *reqs))

    # with timer(f'parallel for {len(requests)} requests'):
    return await asyncio.gather(*requests)


async def f3_evaluate_async(req, *reqs, callback: Callable = None):
    if reqs:
        return await f3_evaluate_many_async(req, *reqs, callback=callback)
    return await f3_evaluate_single_async(req, callback=callback)


@deprecated
class EvalStrategy:
    max_length: int
    mode: str

    def __init__(self, max_length: int, mode: str):
        if mode != 'parallel' and mode != 'sequence':
            raise Exception(f"Unknown evaluation strategy '{mode}'")
        self.max_length = max_length
        self.mode = mode

    def __repr__(self):
        return f"{self.max_length} ({self.mode})"


@deprecated
async def f3_evaluate_with_split_async(req: List[F3Object],
                                       strategy: EvalStrategy,
                                       callback: Optional[Callable] = None) -> List[Any]:
    """
    List of requests will be split into the chunks, where each chunk has max_length requests.
    Each chunk of requests is sent to the F3 platform as f3.evaluate_sequence()
    There are two modes of how these chunks can be dispatched:
    parallel:   all chunks are sent at the same time
    sequence:   chunks are sent sequentially, e.g. 2nd chunk is sent only after 1st chunk is finished
    """
    reqs = list(chunks_list(req, strategy.max_length))
    if strategy.mode == 'parallel':
        results = await f3_evaluate_many_async(*reqs, callback=callback)
    elif strategy.mode == 'sequence':
        results = []
        n = len(reqs)
        for i, r in enumerate(reqs):
            with timer(f'Evaluating list of {len(r)} requests sequentially [{i + 1}/{n}]', logstart=True):
                r_out = await f3_evaluate_many_async(r, callback=callback)
                for rr in r_out:
                    results.append(rr)
    else:
        raise Exception("Unreachable")
    return list(itertools.chain.from_iterable(results))


def is_f3_internal_server_error(ex: BaseException) -> bool:
    f3err = get_inner_exception(ex, lambda e: 'internal server error' in str(e).lower())
    return f3err is not None


async def evaluate_excp_bypass(req: Union[F3Object, Exception],
                               message: str = "") -> Union[Any, Exception]:
    res = await  evaluate_sequence_excp_bypass([req], message)
    return res[0]


async def evaluate_sequence_excp_bypass(req: List[Union[F3Object, Exception]],
                                        message: str = "") -> List[Union[Any, Exception]]:
    f3 = firm_f3.f3client.get_platform_client()
    bypasser = create_exception_bypasser(req)
    f3requests = bypasser.passed
    try:
        # for r in req:
        #    F3mlSpy(r).write_f3ml_to_file(rotate_filename(f'c:/om/temp/f3mlspy/{message}/request.xml'))
        timermsg = f'evaluate_sequence_excp_bypass({message}) for {len(f3requests)} requests'
        with timer(timermsg, logstart=True, loglevel=logging.INFO):
            f3results = await f3.evaluate_sequence(f3requests) if len(f3requests) > 0 else []
    except Exception as ex:
        f3results = []
        if is_f3_internal_server_error(ex):
            raise ex
        if len(f3requests) == 1:
            f3results.append(ex)
        else:
            logger.debug(f'Exception happened during evaluate_sequence. Evaluate {len(f3requests)} requests one-by-one')
            for f3request in f3requests:
                try:
                    f3results.append(await f3.evaluate(f3request))
                except Exception as ex2:
                    if is_f3_internal_server_error(ex2):
                        raise ex2
                    f3results.append(ex2)
    assert len(f3requests) == len(f3results)
    return bypasser.recombine_passed(f3results)


def f3_evaluate(req, *reqs, callback: Callable = None):
    return wait(f3_evaluate_async(req, *reqs, callback=callback))


af3v = af3_eval = f3_evaluate_async
f3v = f3_eval = f3_evaluate

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\evaluate\error.py
----------------------------------------
from typing import Any, Optional
from f3sdk.f3 import F3Error  # type: ignore


def extract_f3_error(res: Any) -> Optional[F3Error]:
    def starts_with_error(msg: str) -> bool:
        msg = msg.lower()
        return msg.startswith('#error:') or msg.startswith("#unexpected error:")

    if isinstance(res, list) and res:
        if len(res) == 0:
            return None
        msg = res[0]
        if isinstance(msg, str) and starts_with_error(msg):
            return F3Error(*res)
        for elem in res:
            elem_err = extract_f3_error(elem)
            if elem_err is not None:
                return elem_err
    return None


def raise_if_error(res: Any) -> None:
    err = extract_f3_error(res)
    if err is not None:
        raise err
    return None


def test_extract_f3_error():
    err = ['#error: MyError', 'origin', 'classification', 'description']
    expected = "#error: MyError - in 'origin' function"
    assert str(extract_f3_error(err)) == expected
    assert str(extract_f3_error([err])) == expected
    assert str(extract_f3_error([[err]])) == expected
    assert str(extract_f3_error([1, 2, 3, err])) == expected
    assert str(extract_f3_error([1, 2, 3, [err]])) == expected
    assert extract_f3_error([1, 2, 3]) is None

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\evaluate\extract_market_data.py
----------------------------------------
import logging
from typing import Union, Callable, Any, List
from f3sdk.f3 import F3Object  # type:ignore
from f3sdk.lib.coroutine import wait  # type: ignore
import firm_f3.f3client  # type:ignore
from firm_domain import Instrument, market_data
from firm_f3.mapping import f3market_data_tag_async
from .types import MARKET_DATA_TAG_TYPE
from .core import f3_evaluate_async

logger = logging.getLogger(__name__)


async def req_market_data_async(
        f3model: F3Object,
        market_data_tag: Union[Instrument, MARKET_DATA_TAG_TYPE] = None,
        table_format: str = 'Condensed',
) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    if isinstance(market_data_tag, Instrument):
        market_data_tag = await f3market_data_tag_async(market_data_tag)

    if market_data_tag:
        return f3.ExtractElementMarketDataQuotes(
            MarketDataSet=f3model,
            MarketDataTag=market_data_tag,
            TableFormat=table_format,
        )
    return f3.ExtractAllMarketDataQuotes(
        MarketDataSet=f3model,
        TableFormat=table_format,
    )


def _dispatcher(tag1, tag2):
    if tag2 == 'Fixings':
        return market_data.IndexMarketData(name=tag1)
    elif tag2 == 'FXSpotQuotes':
        return market_data.FxSpotMarketData(name=(tag1, tag2))
    elif any(tag1.startswith(key) for key in ('IRS', 'BasisSwap', 'FXForward', 'FXNDFwd', 'CrossCurrencySwap')):
        return market_data.CurveMarketData(name=(tag1, tag2))
    elif tag1.startswith('ATMStraddle:FXRate'):
        return market_data.FxStraddleMarketData(name=tag1)
    elif tag1.startswith('VegaWeightedButterfly:FXRate'):
        return market_data.FxButterflyMarketData(name=tag1)
    elif 'Swaption' in tag1:
        return market_data.SwaptionMarketData(name=tag1)
    return market_data.MarketData(name=(tag1, tag2))


def condensed_market_data_handler(res: List) -> market_data.MarketDataCollection:
    def unpack():
        data = None
        for tag1, tag2, key, value in res:
            if isinstance(tag1, str) and isinstance(tag2, str):
                if isinstance(data, market_data.MarketData):
                    yield data
                data = _dispatcher(tag1, tag2)
            try:
                data.add_market_data(key, value)
            except Exception as e:
                logger.error(f'data={data} row={[key, value]}', exc_info=e)
                raise

    return market_data.MarketDataCollection(unpack())


def element_market_data_handler(res: List):
    assert len(res) >= 2
    tag1, tag2 = res[0]
    data = _dispatcher(tag1, tag2)
    for key, value in res[1:]:
        try:
            data.add_market_data(key, value)
        except Exception as e:
            logger.error(f'data={data} row={[key, value]}', exc_info=e)
            raise

    return data


async def extract_market_data_async(
        f3model: F3Object,
        *f3models: F3Object,
        market_data_tag: Union[Instrument, MARKET_DATA_TAG_TYPE] = None,
        table_format: str = 'Condensed',
        callback: Callable = None,
) -> Any:
    if isinstance(market_data_tag, Instrument):
        market_data_tag = await f3market_data_tag_async(market_data_tag)

    if f3models:
        return await f3_evaluate_async(
            [await req_market_data_async(i, market_data_tag=market_data_tag, table_format=table_format) for i in
             (f3model, *f3models)], callback=callback)
    return await f3_evaluate_async(
        await req_market_data_async(f3model, market_data_tag=market_data_tag, table_format=table_format),
        callback=callback)


def extract_market_data(
        f3model: F3Object,
        *f3models: F3Object,
        market_data_tag: Union[Instrument, MARKET_DATA_TAG_TYPE] = None,
        table_format: str = 'Condensed',
        callback: Callable = None,
) -> Any:
    return wait(
        extract_market_data_async(f3model, *f3models, market_data_tag=market_data_tag, table_format=table_format,
                                  callback=callback))


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\evaluate\handlers.py
----------------------------------------
import datetime
from typing import List, Dict, Tuple, Callable
from collections import defaultdict
import pandas  # type:ignore
import dateutil.parser

from firm_domain import Ccy, Tenor
from .types import RISK_REPORT_TYPE, MARKET_DATA_TYPE
from .error import raise_if_error


def scalar_handler(res: List) -> object:
    while isinstance(res, list) and len(res) == 1:
        res = res[0]
    return res


def scalar_handler_strict(res: List) -> object:
    res = scalar_handler(res)
    raise_if_error(res)
    return res


def local_ccy_to_dict_handler(res: List) -> object:
    def unpack():
        for p in res:
            if isinstance(p, list) and len(p) == 2:
                yield Ccy[p[0]], p[1]

    return dict(unpack())


def dataframe_handler(res: list) -> pandas.DataFrame:
    return pandas.DataFrame(res).ffill()


def make_counter():
    return defaultdict(lambda: 0.)


def risk_report_fx_spot_handler(res: RISK_REPORT_TYPE) -> pandas.Series:
    rv: Dict[str, float] = make_counter()

    if res:
        heading = res[0]
        for i in res[1:]:
            raise_if_error(i)
            row = dict(zip(heading, i))
            try:
                if row['MarketDataType'] == 'FXSpotQuotes':
                    idx = str(row['QuoteSpecification'])
                    exposure, quote = float(row['Exposure']), float(row['Quote'])
                    val = exposure * quote  # convert to notional (vs delta per 1 pt change in quote)
                    if val:
                        left, _, right = idx.partition(':')
                        if left == 'USD':
                            idx = right
                            val *= -1
                        elif right == 'USD':
                            idx = left
                        elif left == 'EUR':
                            idx = f'{right}/{left}'
                            val *= -1
                        rv[idx] += val
            except KeyError:
                pass

    return pandas.Series(rv, name='FXSpotRawValueExposure')


def risk_report_fx_fwd_outright_handler(res: RISK_REPORT_TYPE) -> pandas.DataFrame:
    rv: Dict[str, Dict[Tenor, float]] = defaultdict(make_counter)

    if res:
        heading = res[0]
        for i in res[1:]:
            raise_if_error(i)
            row = dict(zip(heading, i))
            try:
                if row['MarketDataType'] in ('FXForward', 'FXNDFwd') and row['ExposureType'] == '<RawValueExposure>':
                    _, _, col = str(row['MarketDataName']).partition(':')
                    exposure, quote = float(row['Exposure']), float(row['Quote'])
                    val = exposure * quote  # convert to notional (vs delta per 1 pt change in quote)
                    if val:
                        idx = Tenor.parse(str(row['QuoteSpecification']))
                        left, _, right = col.partition(':')
                        if left == 'USD':
                            col = right
                            val *= -1
                        elif right == 'USD':
                            col = left
                        elif left == 'EUR':
                            col = f'{right}/{left}'
                            val *= -1
                        rv[col][idx] += val
            except KeyError:
                pass

    return pandas.DataFrame(rv).sort_index()


def cashflow_projection_handler(res: RISK_REPORT_TYPE) -> pandas.DataFrame:
    headers = res[0]
    if len(res) == 1 or res[1]==['<Product does not support implied cash flows>']:
        return pandas.DataFrame(columns=headers)
    return pandas.DataFrame(res[1:], columns=headers)


def risk_report_pvbp_handler(res: RISK_REPORT_TYPE) -> pandas.DataFrame:
    rv: Dict[str, Dict[Tenor, float]] = defaultdict(make_counter)

    if res:
        heading = res[0]
        for i in res[1:]:
            raise_if_error(i)
            row = dict(zip(heading, i))
            col = str(row['MarketDataName'])
            try:
                if row['ExposureType'] == 'PVBP Delta':
                    idx = Tenor[f'T_{str(row["QuoteSpecification"]).upper()}']
                    rv[col][idx] += float(row['Exposure'])
            except KeyError:
                pass

    return pandas.DataFrame(rv).sort_index()


IR_VEGA_PRODUCT_MAP = {
    'VanillaSwaption:IRS:6m:USD LIBOR:3m:Relative': 'USD',
    'VanillaSwaption:IRS:12m:Wibor:6m:Relative': 'PLN',
    'ParYieldCashSettledSwaption:IRS:12m:Euribor:6m:Relative': 'EUR',
    'ParYieldCashSettledSwaption:IRS:6m:GBP LIBOR:6m:Relative': 'GBP',
    'SwaptionInstrument:SwapBBSWSemi:BBSW6m:SwapBBSW6m': 'AUD',
    'SwaptionInstrument:SwapBBSWQuarterly:BBSW3m:SwapBBSW3m': 'AUD',
    'ParYieldCashSettledSwaption:IRS:3m:NTO LIBOR:3m:Relative': 'NTO',
    'VanillaSwaption:IRS:3m:KRWCD:3m:Relative': 'KRW',
    'VanillaSwaption:IRS:12m:SAIBOR:3m:FullCashSingleCurrencyCollateralInSAR:Relative': 'SAR',
}


def risk_report_ir_vega_handler(res: RISK_REPORT_TYPE) -> pandas.DataFrame:
    rv: Dict[Tuple[Ccy, Tenor], Dict[Tenor, float]] = defaultdict(make_counter)

    if res:
        heading = res[0]
        for i in res[1:]:
            raise_if_error(i)
            row = dict(zip(heading, i))
            name = str(row['MarketDataName'])
            try:
                if i[-1] == 'Straddle':
                    for u, ccy in IR_VEGA_PRODUCT_MAP.items():
                        if u in name:
                            break
                    else:
                        continue
                    col = ccy, Tenor[f'T_{str(i[-4]).upper()}']
                    idx = Tenor[f'T_{str(row["FurtherQuoteInfo"]).upper()}']
                    rv[col][idx] += float(row['Exposure']) / 10_000  # per basis point in vol term
            except KeyError:
                pass

    return pandas.DataFrame(rv).sort_index()


CCS_VOL_TAGS = defaultdict(dict)


async def ccs_vol_tags_async(ccy):
    if not CCS_VOL_TAGS[ccy]:
        from firm_f3.modelconfig import CCS_SWAPTION_TENORS
        from firm_f3.mapping import get_ccs_index_name
        from firm_f3.evaluate.core import f3_evaluate_async
        import firm_f3.f3client

        f3 = firm_f3.f3client.get_platform_client()
        tags = await f3_evaluate_async(
            [f3.VolatilityCurveTag(get_ccs_index_name(ccy, t)) for t in CCS_SWAPTION_TENORS],
            callback=lambda x: x[0][0])

        CCS_VOL_TAGS[ccy].update(zip(CCS_SWAPTION_TENORS, tags))

    return CCS_VOL_TAGS[ccy]


def ccs_vol_tags(ccy):
    if not CCS_VOL_TAGS[ccy]:
        from f3sdk.lib.coroutine import wait  # type: ignore
        return wait(ccs_vol_tags_async(ccy))
    return CCS_VOL_TAGS[ccy]


def risk_report_ccs_vega_handler(res: RISK_REPORT_TYPE) -> pandas.DataFrame:
    rv: Dict[Tuple[Ccy, Tenor], Dict[Tenor, float]] = defaultdict(make_counter)
    from firm_f3.modelconfig import CCS_SWAPTION_CCY
    for ccy in CCS_SWAPTION_CCY:
        if res:
            vol_tags = ccs_vol_tags(ccy)
            heading = res[0]
            for i in res[1:]:
                row = dict(zip(heading, i))
                name = str(row['MarketDataName'])
                if name.startswith('VanillaOption:'):
                    name = name.replace('VanillaOption:', '')
                    for t, tag in vol_tags.items():
                        if name.startswith(tag):
                            break
                    else:
                        continue

                    col = f'{ccy} ccs', t
                    try:
                        idx = Tenor[f'T_{str(row["FurtherQuoteInfo"]).upper()}']
                        rv[col][idx] += float(row['Exposure']) / 10_000  # per basis point in vol term
                    except KeyError:
                        pass

    return pandas.DataFrame(rv).sort_index()


def risk_report_fx_vega_handler(res: RISK_REPORT_TYPE) -> pandas.DataFrame:
    rv: Dict[str, Dict[Tenor, float]] = defaultdict(make_counter)

    if res:
        heading = res[0]
        for i in res[1:]:
            raise_if_error(i)
            row = dict(zip(heading, i))
            col = str(row['MarketDataName'])
            try:
                if row['MarketDataType'] == 'ATMStraddle':
                    idx = Tenor[f'T_{str(row["FurtherQuoteInfo"]).upper()}']
                    rv[col][idx] += float(row['Exposure']) / 100  # per percent point in vol term
            except KeyError:
                pass

    return pandas.DataFrame(rv).sort_index()


def flip_fx_risk(ccy_pair: str, risk_val: float, numeraire: Ccy = Ccy.USD):
    left, right = ccy_pair[:3], ccy_pair[3:]
    try:
        left_ccy, right_ccy = Ccy[left], Ccy[right]
    except KeyError:
        raise ValueError(f'invalid ccy_pair={ccy_pair}')
    if left_ccy is numeraire:
        return right_ccy.name + left_ccy.name, risk_val * -1
    return ccy_pair, risk_val


def risk_report_fx_sabr_handler(res: RISK_REPORT_TYPE) -> pandas.DataFrame:
    rv: Dict[Tuple[str, str], Dict[Tenor, float]] = defaultdict(make_counter)

    if res:
        heading = res[0]
        for i in res[1:]:
            raise_if_error(i)
            row = dict(zip(heading, i))
            name = str(row['MarketDataName'])
            try:
                typ = row['MarketDataType']
                if typ.startswith('SABR'):
                    _, _, name = name.partition(':')
                    val = float(row['Exposure'])
                    if typ.endswith('Rho'):
                        name, val = flip_fx_risk(name, val)
                    col = typ, name.replace('USD', '')
                    idx = Tenor[f'T_{str(row["QuoteSpecification"]).upper()}']
                    rv[col][idx] += val / 100  # per percent point in vol term
            except KeyError:
                pass

    return pandas.DataFrame(rv).T.sort_index().T.sort_index()


def market_data_simple_tenor_handler(res: MARKET_DATA_TYPE, _key: Callable = None) -> pandas.DataFrame:
    rv: Dict[str, Dict[Tenor, float]] = defaultdict(dict)

    if res:
        curr_tag = None
        for tag1, tag2, key, value in res:
            if isinstance(tag1, str):
                curr_tag = tag1
            if _key is None or _key(curr_tag):
                try:
                    idx = Tenor[f'T_{key.upper()}']
                except KeyError:
                    continue
                if idx in rv[curr_tag]:
                    raise KeyError(f'{curr_tag}:{idx} is already assigned')
                rv[curr_tag][idx] = float(value)

    return pandas.DataFrame(rv).sort_index()


def market_data_irs_handler(res: MARKET_DATA_TYPE) -> pandas.DataFrame:
    return market_data_simple_tenor_handler(res, _key=lambda x: x.startswith('IRS'))


def market_data_basis_handler(res: MARKET_DATA_TYPE) -> pandas.DataFrame:
    return market_data_simple_tenor_handler(res, _key=lambda x: any(
        x.startswith(key) for key in ('BasisSwap', 'CrossCurrencySwap')))


def market_data_ccs_handler(res: MARKET_DATA_TYPE) -> pandas.DataFrame:
    return market_data_simple_tenor_handler(res, _key=lambda x: x.startswith('CrossCurrencySwap'))


def market_data_fx_fwd_handler(res: MARKET_DATA_TYPE) -> pandas.DataFrame:
    return market_data_simple_tenor_handler(res, _key=lambda x: any(
        x.startswith(key) for key in ('FXForward', 'FXNDFwd')))


def market_data_fx_sabr_handler(res: MARKET_DATA_TYPE) -> pandas.DataFrame:
    raw = market_data_simple_tenor_handler(res, _key=lambda x: x.startswith('SABR'))

    def unpack():
        for tag, v in raw.items():
            typ, _, ccy_pair = tag.partition(':')
            if typ == 'SABRRho' and ccy_pair.startswith('USD'):
                v = v.mul(-1)
            ccy_pair = ccy_pair.replace('USD', '')
            yield (typ, ccy_pair), v

    return pandas.DataFrame(dict(unpack())).T.sort_index().T.sort_index()


def market_data_fx_spot_handler(res: MARKET_DATA_TYPE, return_fx_pairs: bool = False) -> pandas.Series:
    rv: Dict[str, float] = {}

    fx_tag = 'UniqueFXRates'
    if res:
        curr_tag = None
        for tag1, tag2, key, value, *_ in res:
            if isinstance(tag1, str):
                curr_tag = tag1
            if curr_tag == fx_tag:
                idx, val = key, float(value)

                if not return_fx_pairs:
                    left, _, right = key.partition(':')
                    if left == 'USD':
                        idx = right
                        val **= -1
                    elif right == 'USD':
                        idx = left
                    elif left == 'EUR':
                        idx = f'{right}/{left}'
                        val **= -1

                if idx in rv:
                    raise KeyError(f'{idx} is already assigned')
                rv[idx] = val

    return pandas.Series(rv, name=fx_tag)


def market_data_fixings_handler(res: MARKET_DATA_TYPE) -> pandas.DataFrame:
    rv: Dict[str, Dict[datetime.datetime, float]] = defaultdict(dict)

    if res:
        curr_tag = None
        for tag1, tag2, key, value in res:
            if tag2 == 'Fixings':
                curr_tag = tag1
            elif tag2 is not None:
                curr_tag = None
            if curr_tag is not None:
                idx = dateutil.parser.parse(key)
                val = float(value)
                rv[curr_tag][idx] = val

    return pandas.DataFrame(rv).sort_index()


def market_data_swaption_handler(res: MARKET_DATA_TYPE) -> pandas.DataFrame:
    rv: Dict[Tuple[str, float, Tenor], Dict[Tenor, float]] = defaultdict(make_counter)

    if res:
        curr_tag = None
        for tag1, tag2, key, value in res:
            try:
                expiry, tenor, strike_type, strike, swaption_type = key.split(':')
                expiry = Tenor[f'T_{expiry.upper()}']
                tenor = Tenor[f'T_{tenor.upper()}']
                strike = float(strike)
            except (ValueError, KeyError):
                continue
            if tag1 is not None:
                *tags, tail_1, tail_2 = tag1.split(':')
                assert float(tail_2) == strike
                if tail_1 != strike_type:
                    tags.append(tail_1)
                curr_tag = ':'.join(tags)
            rv[(curr_tag, strike, tenor)][expiry] = float(value)

    return pandas.DataFrame(rv).sort_index()


def market_data_fx_straddle_handler(res: MARKET_DATA_TYPE) -> pandas.DataFrame:
    rv: Dict[str, Dict[Tenor, float]] = defaultdict(make_counter)

    if res:
        curr_tag = None
        for tag1, tag2, key, value in res:
            try:
                expiry, tenor, strike_type, strike, swaption_type = key.split(':')
                expiry = Tenor[f'T_{expiry.upper()}']
                tenor = Tenor[f'T_{tenor.upper()}']
                strike = float(strike)
            except (ValueError, KeyError):
                continue
            if tag1 is not None:
                *tags, tail_1, tail_2 = tag1.split(':')
                assert float(tail_2) == strike
                if tail_1 != strike_type:
                    tags.append(tail_1)
                curr_tag = ':'.join(tags)
            rv[(curr_tag, strike, tenor)][expiry] = float(value)

    return pandas.DataFrame(rv).sort_index()


def market_data_dispatch(res: MARKET_DATA_TYPE) -> Tuple:
    fixings, fx_spot, fx_fwd, fx_sabr, fx_straddle, fx_strat, ir, ir_vol, rest = [], [], [], [], [], [], [], [], []

    curr_tag1, curr_tag2 = None, None
    for tag1, tag2, key, value in res:
        if tag1 is not None:
            curr_tag1, curr_tag2 = tag1, tag2

        if curr_tag2 == 'Fixings':
            fixings.append([tag1, tag2, key, value])
        elif curr_tag2 == 'ATMStraddle':
            fx_straddle.append([tag1, tag2, key, value])
        elif curr_tag2 in ('RiskReversal', 'VegaWeightedButterfly'):
            fx_strat.append([tag1, tag2, key, value])
        elif curr_tag2 in ('FXForward', 'FXNDFwd'):
            fx_fwd.append([tag1, tag2, key, value])
        elif curr_tag1 == 'UniqueFXRates':
            fx_spot.append([tag1, tag2, key, value])
        elif curr_tag1.startswith('SABR'):
            fx_sabr.append([tag1, tag2, key, value])
        elif any(curr_tag1.startswith(i) for i in ('IRS', 'BasisSwap', 'CrossCurrencySwap')):
            ir.append([tag1, tag2, key, value])
        else:
            quote_specs = key.split(':')
            if len(quote_specs) == 5:
                ir_vol.append([tag1, tag2, key, value])
            else:
                rest.append([tag1, tag2, key, value])

    return fixings, fx_spot, fx_fwd, fx_sabr, fx_straddle, fx_strat, ir, ir_vol, rest


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\evaluate\impliedvol.py
----------------------------------------
from functools import singledispatch
from typing import Iterable, Union, Callable, List, Optional
from f3sdk.f3 import F3Object  # type:ignore
from f3sdk.lib.coroutine import wait  # type: ignore

from firm_domain import (
    FXOptionTrade, SwaptionTrade, CrossCurrencySwaptionTrade,
)

from .types import PRODUCT_TYPE, SINGLE_PRODUCT_TYPE
from .core import f3_evaluate_async
from .handlers import scalar_handler
from .value_product import req_value_product



async def req_imp_vol(
        f3model: F3Object,
        trade: PRODUCT_TYPE,
) -> Union[F3Object, Iterable[F3Object]]:
    if isinstance(trade, Iterable):
        return [await req_imp_vol_single(
            i,
            f3model=f3model
        ) for i in trade]
    return await req_imp_vol_single(
        trade,
        f3model=f3model
    )


@singledispatch
async def req_imp_vol_single(trade: PRODUCT_TYPE, f3model: F3Object) -> Optional[F3Object]:
    return None


@req_imp_vol_single.register
async def req_imp_vol_single_by_fx_option_trade(trade: FXOptionTrade, f3model: F3Object) -> F3Object:
    return req_imp_vol_lognormal(trade, f3model)


@req_imp_vol_single.register
async def req_imp_vol_single_by_ccs_swaption_trade(trade: CrossCurrencySwaptionTrade, f3model: F3Object) -> F3Object:
    return req_imp_vol_normal(trade, f3model)


@req_imp_vol_single.register
async def req_imp_vol_single_by_swaption_trade(trade: SwaptionTrade, f3model: F3Object) -> F3Object:
    return req_imp_vol_normal(trade, f3model)


def req_imp_vol_normal(trade: SINGLE_PRODUCT_TYPE, f3model: F3Object) -> F3Object:
    return req_value_product(f3model, trade, 'DefaultUSD', 'OptionImpliedNormalVolatility')


def req_imp_vol_lognormal(trade: SINGLE_PRODUCT_TYPE, f3model: F3Object) -> F3Object:
    return req_value_product(f3model, trade, 'DefaultUSD', 'OptionImpliedBlackVolatility')



async def imp_vol_async(
        trade: PRODUCT_TYPE,
        *trades: PRODUCT_TYPE,
        f3model: F3Object,
        callback: Callable = scalar_handler,
) -> Union[float, List[float]]:
    if trades:
        requests = await f3_evaluate_async(*(req_imp_vol(f3model, i) for i in (trade, *trades)))
        return await f3_evaluate_async(*requests, callback=callback)
    return await f3_evaluate_async(await req_imp_vol(f3model, trade), callback=callback)


def imp_vol(
        trade: PRODUCT_TYPE,
        *trades: PRODUCT_TYPE,
        f3model: F3Object,
        callback: Callable = scalar_handler,
) -> Union[float, List[float]]:
    return wait(imp_vol_async(trade, *trades, f3model=f3model, callback=callback))


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\evaluate\instrument2parrate.py
----------------------------------------
from typing import Union, List

from f3sdk.lib.coroutine import wait

from firm_f3.util import flatten
from firm_domain import Instrument
from .valuation_date import valuation_date_async
from .instrument2trade import trades_from_instruments_async


def par_rate_from_instrument(instruments: Union[Instrument, List[Instrument]], f3model) -> Union[float, List[float]]:
    return wait(par_rate_from_instrument_async(instruments, f3model))


async def par_rate_from_instrument_async(instruments: Union[Instrument, List[Instrument]],
                                         f3model) -> Union[float, List[float]]:
    val_date = await valuation_date_async(f3model)
    instruments = [*flatten([instruments])]
    trades = await trades_from_instruments_async(*instruments, valuation_date=val_date, f3model=f3model)
    rv = [t.get_rate() for t in trades]
    if len(instruments) == 1:
        return rv[0]
    return rv
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\evaluate\instrument2trade.py
----------------------------------------
import asyncio
import datetime
from typing import Optional
from functools import singledispatch

from f3sdk.f3 import F3Object  # type:ignore
from firm_domain import (
    Trade, FXForward, FXOption, XccyBasis, OIS, IRS, Swaption, InflationSwap, CrossCurrencySwap, TenorBasis,
    IRSTrade, OISTrade, FXForwardTrade, FXOptionTrade, XccyBasisTrade, CrossCurrencySwapTrade, InflationSwapTrade,
    TenorBasisTrade, SwaptionTrade, Conventions, OptionType, SwaptionType, CCSSwaption, CrossCurrencySwaptionTrade,
    Tenor)
from firm_f3.evaluate import valuation_date_async, par_rate_async
from .maturity_date import maturity_date_async, start_date_async, trade_date_from_val_date_async

BLANK_RATE = 0.0
NOTIONAL = 1
FX_RATE = 1.0


async def trades_from_instruments_async(inst, *instruments, valuation_date: Optional[datetime.date] = None,
                                        f3model: Optional[F3Object] = None):
    assert valuation_date is not None or f3model is not None, 'Must provide either model or valuation date'
    if valuation_date is None:
        valuation_date = await valuation_date_async(f3model)

    def job():
        if instruments:
            ins_list = (inst, *instruments)
        else:
            ins_list = [inst]
        for ins in ins_list:
            yield trades_from_instruments_single_async(ins, valuation_date=valuation_date, f3model=f3model)

    rv = await asyncio.gather(*job())
    return rv


@singledispatch
async def trades_from_instruments_single_async(inst, valuation_date: datetime.date, f3model: F3Object) -> Trade:
    if isinstance(inst, Trade):
        return inst
    raise TypeError(f'expect inst object, got type {type(inst)} instead')


@trades_from_instruments_single_async.register
async def trades_from_instruments_irs(irs: IRS, valuation_date: datetime.date, f3model: F3Object) -> IRSTrade:
    start_date = await start_date_async(valuation_date, irs)
    mat_date = await maturity_date_async(valuation_date, irs)
    temp_trade = IRSTrade(
        trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
        ccy=irs.ccy,
        start=start_date,
        maturity=mat_date,
        rate=BLANK_RATE,
        notional=NOTIONAL,
        idx=irs.idx
    )
    if f3model:
        rate = await par_rate_async(temp_trade, f3model=f3model)
        return IRSTrade(
            trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
            ccy=irs.ccy,
            start=start_date,
            maturity=mat_date,
            rate=rate,
            notional=NOTIONAL,
            idx=irs.idx
        )
    return temp_trade


@trades_from_instruments_single_async.register
async def trades_from_instruments_fx_forward(fxf: FXForward, valuation_date: datetime.date,
                                             f3model: F3Object) -> FXForwardTrade:
    mat_date = await maturity_date_async(valuation_date, fxf)
    fixing_date = await trade_date_from_val_date_async(mat_date, fxf) if Conventions.trades_as_ndf(
        fxf.ccy) else None
    temp_trade = FXForwardTrade(
        trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
        ccy=fxf.ccy,
        value_date=mat_date,
        rate=FX_RATE,
        notional=NOTIONAL,
        ccy_base=fxf.ccy_base,
        fixing_date=fixing_date
    )
    if f3model:
        rate = await par_rate_async(temp_trade, f3model=f3model)
        return FXForwardTrade(
            trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
            ccy=fxf.ccy,
            value_date=mat_date,
            rate=rate,
            notional=NOTIONAL,
            ccy_base=fxf.ccy_base,
            fixing_date=fixing_date
        )
    return temp_trade


@trades_from_instruments_single_async.register
async def trades_from_instruments_ois(ois: OIS, valuation_date: datetime.date, f3model: F3Object) -> OISTrade:
    start_date = await start_date_async(valuation_date, ois)
    mat_date = await maturity_date_async(valuation_date, ois)
    temp_trade = OISTrade(
        trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
        ccy=ois.ccy,
        start=start_date,
        maturity=mat_date,
        rate=BLANK_RATE,
        notional=NOTIONAL
    )
    if f3model:
        rate = await par_rate_async(temp_trade, f3model=f3model)
        return OISTrade(
            trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
            ccy=ois.ccy,
            start=start_date,
            maturity=mat_date,
            rate=rate,
            notional=NOTIONAL
        )
    return temp_trade


@trades_from_instruments_single_async.register
async def trades_from_instruments_tenorbasis(tb: TenorBasis, valuation_date: datetime.date,
                                             f3model: F3Object) -> TenorBasisTrade:
    start_date = await start_date_async(valuation_date, tb)
    mat_date = await maturity_date_async(valuation_date, tb)
    temp_trade = TenorBasisTrade(
        trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
        ccy=tb.ccy,
        start=start_date,
        maturity=mat_date,
        notional=NOTIONAL,
        rate=BLANK_RATE,
        idx_1=tb.idx_1,
        idx_2=tb.idx_2
    )
    if f3model:
        rate = await par_rate_async(temp_trade, f3model=f3model)
        return TenorBasisTrade(
            trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
            ccy=tb.ccy,
            start=start_date,
            maturity=mat_date,
            notional=NOTIONAL,
            rate=rate,
            idx_1=tb.idx_1,
            idx_2=tb.idx_2
        )
    return temp_trade


@trades_from_instruments_single_async.register
async def trades_from_instruments_inflationswap(inf_swap: InflationSwap,
                                                valuation_date: datetime.date, f3model: F3Object) -> InflationSwapTrade:
    start_date = await start_date_async(valuation_date, inf_swap)
    mat_date = await maturity_date_async(valuation_date, inf_swap)
    temp_trade = InflationSwapTrade(
        trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
        index=inf_swap.index,
        start=start_date,
        maturity=mat_date,
        rate=BLANK_RATE,
        notional=NOTIONAL
    )
    if f3model:
        rate = await par_rate_async(temp_trade, f3model=f3model)
        return InflationSwapTrade(
            trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
            index=inf_swap.index,
            start=start_date,
            maturity=mat_date,
            rate=rate,
            notional=NOTIONAL
        )
    return temp_trade


@trades_from_instruments_single_async.register
async def trades_from_instruments_ccs(ccs: CrossCurrencySwap, valuation_date: datetime.date,
                                      f3model: F3Object) -> CrossCurrencySwapTrade:
    start_date = await start_date_async(valuation_date, ccs)
    mat_date = await maturity_date_async(valuation_date, ccs)
    temp_trade = CrossCurrencySwapTrade(
        trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
        ccy=ccs.ccy,
        start=start_date,
        maturity=mat_date,
        rate=BLANK_RATE,
        notional=NOTIONAL,
        fx_rate=FX_RATE
    )
    if f3model:
        if Conventions.ccs_fx_spot_ref(ccs.ccy):
            fx_date = (await maturity_date_async(valuation_date, FXForward(ccs.ccy, Tenor.SPOT)))
        else:
            fx_date = start_date
        temp_fx = FXForwardTrade(trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
                                 ccy=ccs.ccy,
                                 value_date=fx_date,
                                 rate=BLANK_RATE,
                                 notional=NOTIONAL
                                 )
        fx_rate = await par_rate_async(temp_fx, f3model=f3model)
        temp_trade_updated = CrossCurrencySwapTrade(
            trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
            ccy=ccs.ccy,
            start=start_date,
            maturity=mat_date,
            rate=BLANK_RATE,
            notional=NOTIONAL,
            fx_rate=fx_rate
        )
        rate = await par_rate_async(temp_trade_updated, f3model=f3model)
        return CrossCurrencySwapTrade(
            trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
            ccy=ccs.ccy,
            start=start_date,
            maturity=mat_date,
            rate=rate,
            notional=NOTIONAL,
            fx_rate=fx_rate
        )
    return temp_trade


@trades_from_instruments_single_async.register
async def trades_from_instruments_swaption(swaption: Swaption, valuation_date: datetime.date,
                                           f3model: F3Object) -> SwaptionTrade:
    underlying_irs = IRS(ccy=swaption.ccy, tenor=swaption.tenor, start=swaption.expiry)
    start_date = await start_date_async(valuation_date, underlying_irs)
    mat_date = await maturity_date_async(valuation_date, underlying_irs)
    expiry_date = await trade_date_from_val_date_async(start_date, underlying_irs)
    temp_trade = SwaptionTrade(
        trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
        ccy=swaption.ccy,
        expiry=expiry_date,
        start=start_date,
        maturity=mat_date,
        strike=BLANK_RATE,
        swaption_type=SwaptionType.RECEIVER,
        notional=NOTIONAL
    )
    if f3model:
        rate = await par_rate_async(temp_trade, f3model=f3model)
        return SwaptionTrade(
            trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
            ccy=swaption.ccy,
            expiry=expiry_date,
            start=start_date,
            maturity=mat_date,
            strike=rate,
            swaption_type=SwaptionType.RECEIVER,
            notional=NOTIONAL
        )
    return temp_trade


@trades_from_instruments_single_async.register
async def trades_from_instruments_ccs_swaption(swaption: CCSSwaption, valuation_date: datetime.date,
                                               f3model: F3Object) -> CrossCurrencySwaptionTrade:
    underlying_ccs = CrossCurrencySwap(ccy=swaption.ccy, tenor=swaption.tenor, start=swaption.expiry)
    start_date = await start_date_async(valuation_date, underlying_ccs)
    mat_date = await maturity_date_async(valuation_date, underlying_ccs)
    expiry_date = await trade_date_from_val_date_async(start_date, underlying_ccs)
    temp_trade = CrossCurrencySwaptionTrade(
        trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
        ccy=swaption.ccy,
        expiry=expiry_date,
        start=start_date,
        maturity=mat_date,
        strike=BLANK_RATE,
        swaption_type=SwaptionType.RECEIVER,
        notional=NOTIONAL
    )
    if f3model:
        rate = await par_rate_async(temp_trade, f3model=f3model)
        return CrossCurrencySwaptionTrade(
            trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
            ccy=swaption.ccy,
            expiry=expiry_date,
            start=start_date,
            maturity=mat_date,
            strike=rate,
            swaption_type=SwaptionType.RECEIVER,
            notional=NOTIONAL
        )
    return temp_trade


@trades_from_instruments_single_async.register
async def trades_from_instruments_xccybasis(xccy: XccyBasis, valuation_date: datetime.date,
                                            f3model: F3Object) -> XccyBasisTrade:
    start_date = await start_date_async(valuation_date, xccy)
    mat_date = await maturity_date_async(valuation_date, xccy)
    temp_trade = XccyBasisTrade(
        trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
        ccy=xccy.ccy,
        start=start_date,
        maturity=mat_date,
        rate=BLANK_RATE,
        notional=NOTIONAL,
        fx_rate=FX_RATE
    )
    if f3model:
        fx_rate = FX_RATE
        if not temp_trade.is_mtm:
            temp_fx = FXForwardTrade(trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
                                     ccy=xccy.ccy,
                                     value_date=start_date,
                                     rate=BLANK_RATE,
                                     notional=NOTIONAL
                                     )
            fx_rate = await par_rate_async(temp_fx, f3model=f3model)
        temp_trade_updated = XccyBasisTrade(
            trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
            ccy=xccy.ccy,
            start=start_date,
            maturity=mat_date,
            rate=BLANK_RATE,
            notional=NOTIONAL,
            fx_rate=fx_rate
        )
        rate = await par_rate_async(temp_trade_updated, f3model=f3model)
        return XccyBasisTrade(
            trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
            ccy=xccy.ccy,
            start=start_date,
            maturity=mat_date,
            rate=rate,
            notional=NOTIONAL,
            fx_rate=fx_rate
        )
    return temp_trade


@trades_from_instruments_single_async.register
async def trades_from_instruments_fxoption(fxo: FXOption, valuation_date: datetime.date,
                                           f3model: F3Object) -> FXOptionTrade:
    dlv_date = await maturity_date_async(valuation_date, fxo)
    expiry_date = await trade_date_from_val_date_async(dlv_date, fxo)
    temp_trade = FXOptionTrade(
        trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
        ccy=fxo.ccy,
        expiry=expiry_date,
        strike=FX_RATE,
        option_type=OptionType.CALL,
        notional=NOTIONAL,
        value_date=dlv_date,
        ccy_base=fxo.ccy_base
    )
    if f3model:
        rate = await par_rate_async(temp_trade, f3model=f3model)
        return FXOptionTrade(
            trade_date=datetime.datetime.combine(valuation_date, datetime.time.min),
            ccy=fxo.ccy,
            expiry=expiry_date,
            strike=rate,
            option_type=OptionType.CALL,
            notional=NOTIONAL,
            value_date=dlv_date,
            ccy_base=fxo.ccy_base
        )
    return temp_trade

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\evaluate\maturity_date.py
----------------------------------------
import datetime
from typing import Union
from f3sdk.f3 import F3Object  # type:ignore

import firm_f3.f3client
from firm_domain import Tenor, Instrument, Swap, FXForward, FXOption, FRA, instrument_to_spot
from firm_f3.mapping import f3instrument_type, f3quote_spec

from .core import f3_evaluate_async
from .handlers import scalar_handler


async def maturity_date_async(trade_date: datetime, instrument: Union[Swap, FXOption, FXForward]) -> datetime.date:
    if isinstance(instrument, FRA):
        raise ValueError('Not supported for FRAs yet')
    ins_type = f3instrument_type(instrument)
    start = await start_date_async(trade_date, instrument)
    return await f3_evaluate_async(req_maturity_date(start, f3quote_spec(instrument, eval_date=trade_date), ins_type),
                                   callback=scalar_handler)


async def start_date_async(trade_date: datetime, instrument: Union[Swap, FXOption, FXForward]) -> datetime.date:
    # todo: I do not think this is the precisely accurate way to do this, but it will be very close
    if isinstance(instrument, FRA):
        raise ValueError('Not supported for FRAs yet')
    ins_type = f3instrument_type(instrument)
    if isinstance(instrument, (FXOption, FXForward)) or (
            isinstance(instrument, Swap) and instrument.start == Tenor.SPOT):
        unadj_start = await f3_evaluate_async(req_start_date(trade_date, ins_type), callback=scalar_handler)
    else:
        new_ins = instrument_to_spot(instrument)
        unadj_start = await maturity_date_async(trade_date, new_ins)
    return await f3_evaluate_async(req_bump_date(unadj_start, ins_type), callback=scalar_handler)


async def trade_date_from_val_date_async(val_date: datetime.date, inst: Instrument) -> datetime.date:
    rv = await f3_evaluate_async(req_trade_date_fixing(val_date, inst), callback=scalar_handler)
    return rv + datetime.timedelta(days=-1)


def req_maturity_date(start: datetime, quote_spec: str, inst_type: str) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.MaturityDate(
        StartDate=start,
        Maturity=quote_spec,
        MaturityConvention=inst_type
    )


def req_start_date(trade_date: datetime, inst_type: str) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.TradeDateToStartDate(
        TradeDate=trade_date,
        MarketConvention=inst_type
    )


def req_bump_date(val_date: datetime.date, inst_type: str) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.AdjustDate(
        StartDate=val_date,
        DateModifier=['FirstGoodPaymentDate', inst_type]
    )


def req_trade_date_fixing(val_date: datetime.date, inst: Instrument) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.AdjustDate(
        StartDate=val_date,
        DateModifier=['LatestTradeDate', f3instrument_type(inst)]
    )


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\evaluate\par_rate.py
----------------------------------------
import asyncio
import datetime
from functools import singledispatch
from typing import Iterable, Union, Callable, List
from f3sdk.f3 import F3Object  # type:ignore
from f3sdk.lib.coroutine import wait  # type: ignore

from firm_domain import (
    IRSTrade, OISTrade, FXOptionTrade, XccyBasisTrade, CrossCurrencySwapTrade, TenorBasisTrade, FXForwardTrade,
    InflationSwapTrade, Ccy, SwaptionTrade, CashFlow, CrossCurrencySwaptionTrade, FXForward, Instrument, Trade
)
from nimrod.core.model_set import ModelSet
from firm_f3.mapping import f3products_from_instruments, f3products

from .types import PRODUCT_TYPE, SINGLE_PRODUCT_TYPE
from .core import f3_evaluate_async
from .handlers import scalar_handler

from .value_index import req_value_index
from .value_product import req_value_product
from .valuation_date import valuation_date_fast
from .maturity_date import maturity_date_async


async def req_par_rate(
        f3model: F3Object,
        trade: PRODUCT_TYPE,
) -> Union[F3Object, Iterable[F3Object]]:
    if isinstance(trade, Iterable):
        return [await req_par_rate_single(
            i,
            f3model=f3model
        ) for i in trade]
    return await req_par_rate_single(
        trade,
        f3model=f3model
    )


@singledispatch
async def req_par_rate_single(trade: PRODUCT_TYPE, f3model: F3Object) -> F3Object:
    if isinstance(trade, Trade):
        trade = f3products(trade)
    if isinstance(trade, F3Object):
        return req_par_rate_default(trade, f3model)
    raise TypeError(f'expect Trade, got type {type(trade)} instead')


@req_par_rate_single.register
async def req_par_rate_single_by_irs_trade(trade: IRSTrade, f3model: F3Object) -> F3Object:
    return req_par_rate_default(trade, f3model)


@req_par_rate_single.register
async def req_par_rate_single_by_cash_flow(trade: CashFlow, f3model: F3Object) -> F3Object:
    return req_par_rate_default(trade, f3model)


@req_par_rate_single.register
async def req_par_rate_single_by_ois_trade(trade: OISTrade, f3model: F3Object) -> F3Object:
    return req_par_rate_default(trade, f3model)


@req_par_rate_single.register
async def req_par_rate_single_by_fx_option_trade(trade: FXOptionTrade, f3model: F3Object) -> F3Object:
    return req_par_rate_fx_option(trade, f3model)


@req_par_rate_single.register
async def req_par_rate_single_by_xccy_basis_trade(trade: XccyBasisTrade, f3model: F3Object) -> F3Object:
    return req_par_rate_default(trade, f3model)


@req_par_rate_single.register
async def req_par_rate_single_by_ccs_trade(trade: CrossCurrencySwapTrade, f3model: F3Object) -> F3Object:
    return req_par_rate_default(trade, f3model)


@req_par_rate_single.register
async def req_par_rate_single_by_ccs_swaption_trade(trade: CrossCurrencySwaptionTrade, f3model: F3Object) -> F3Object:
    temp_fx = FXForwardTrade(trade_date=datetime.datetime.now(),
                             ccy=trade.ccy,
                             value_date=trade.start,
                             rate=1,
                             notional=trade.notional
                             )
    fx_rate = await par_rate_async(temp_fx, f3model=f3model)
    return req_par_rate_default(trade.get_swap(fx_rate), f3model)


@req_par_rate_single.register
async def req_par_rate_single_by_swaption_trade(trade: SwaptionTrade, f3model: F3Object) -> F3Object:
    return req_par_rate_default(trade.get_swap(), f3model)


@req_par_rate_single.register
async def req_par_rate_single_by_tenor_basis_trade(trade: TenorBasisTrade, f3model: F3Object) -> F3Object:
    return req_par_rate_default(trade, f3model)


@req_par_rate_single.register
async def req_par_rate_single_by_inflation_swap_trade(trade: InflationSwapTrade, f3model: F3Object) -> F3Object:
    return req_par_rate_default(trade, f3model)


@req_par_rate_single.register
async def req_par_rate_single_by_fx_forward_trade(trade: FXForwardTrade, f3model: F3Object) -> F3Object:
    return req_par_rate_fx(trade.ccy, trade.ccy_base, trade.value_date, f3model)


@req_par_rate_single.register
async def req_par_rate_single_by_fx_forward(inst: FXForward, f3model: F3Object) -> F3Object:
    val_date = valuation_date_fast(f3model)
    mat_date = await maturity_date_async(val_date, inst)
    return req_par_rate_fx(inst.ccy, inst.ccy_base, mat_date, f3model)


@req_par_rate_single.register
async def req_par_rate_single_by_instrument(inst: Instrument, f3model: F3Object) -> F3Object:
    val_date = valuation_date_fast(f3model)
    product = f3products_from_instruments(inst, valuation_date=val_date)
    return req_par_rate_default(product, f3model)


def req_par_rate_default(trade: SINGLE_PRODUCT_TYPE, f3model: F3Object) -> F3Object:
    return req_value_product(f3model, trade, 'DefaultUSD', 'ParRate')


def req_par_rate_fx(ccy: Ccy, ccy_base: Ccy, val_date: datetime.date, f3model: F3Object) -> F3Object:
    return req_value_index(f3model, str(ccy_base) + str(ccy), (val_date, 1), 'DefaultIgnoreFix')


def req_par_rate_fx_option(trade: SINGLE_PRODUCT_TYPE, f3model: F3Object) -> F3Object:
    return req_value_product(f3model, trade, 'DefaultUSD', 'OptionForward')


async def par_rate_with_f3_model_async(
        trade: PRODUCT_TYPE,
        *trades: PRODUCT_TYPE,
        f3model: F3Object,
        callback: Callable = scalar_handler,
) -> Union[float, List[float]]:
    if trades:
        requests = await f3_evaluate_async(*(req_par_rate(f3model, i) for i in (trade, *trades)))
        return await f3_evaluate_async(*requests, callback=callback)
    return await f3_evaluate_async(await req_par_rate(f3model, trade), callback=callback)


async def _par_rate_with_model_set(
        trade: PRODUCT_TYPE,
        f3model: ModelSet,
        callback: Callable = scalar_handler,
) -> Union[float, List[float]]:
    if not isinstance(trade, Iterable):
        trade = [trade]
    fut = f3model.eval_with(trade)
    model_trade_pairs = await fut.gather_models()
    res = await asyncio.gather(
        *(par_rate_with_f3_model_async(t, f3model=m, callback=callback) for m, t in model_trade_pairs))
    fut.set_results(res)
    if len(trade) == 1:
        return fut.results[0]
    return fut.results


async def par_rate_with_model_set_async(
        trade: PRODUCT_TYPE,
        *trades: PRODUCT_TYPE,
        f3model: ModelSet,
        callback: Callable = scalar_handler,
) -> Union[float, List[float]]:
    if trades:
        return await asyncio.gather(*(_par_rate_with_model_set(i, f3model, callback) for i in (trade, *trades)))
    return await _par_rate_with_model_set(trade, f3model, callback)


async def par_rate_async(
        trade: PRODUCT_TYPE,
        *trades: PRODUCT_TYPE,
        f3model: Union[F3Object, ModelSet],
        callback: Callable = scalar_handler,
) -> Union[float, List[float]]:
    if isinstance(f3model, ModelSet):
        return await par_rate_with_model_set_async(trade, *trades, f3model=f3model, callback=callback)
    elif isinstance(f3model, F3Object):
        return await par_rate_with_f3_model_async(trade, *trades, f3model=f3model, callback=callback)
    raise TypeError(f'got wrong type {type(f3model)} for f3model')


def par_rate(
        trade: PRODUCT_TYPE,
        *trades: PRODUCT_TYPE,
        f3model: F3Object,
        callback: Callable = scalar_handler,
) -> Union[float, List[float]]:
    return wait(par_rate_async(trade, *trades, f3model=f3model, callback=callback))


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\evaluate\scenarios.py
----------------------------------------
from typing import Union, Iterable, Dict, Tuple
from itertools import product
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client # type:ignore
from firm_domain import Ccy
from firm_f3.mapping.scenario import f3scenario_single


def apply_scenario_many(f3model: F3Object, ccy: Iterable[Ccy], bumps: Iterable[float]) -> Dict[Tuple, F3Object]:
    f3 = firm_f3.f3client.get_platform_client()
    assert isinstance(ccy, Iterable)
    assert isinstance(bumps, Iterable)

    return {(c, b): f3.ApplyScenarioToModel(
        BaseModel=f3model,
        Scenario=f3scenario_single(ccy=c, bump=b),
    ) for c, b in product(ccy, bumps)}


def create_composite_bump_scenario(ccy: Union[str, Ccy], *ccys: Iterable[Union[str, Ccy]], bump: float) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    if ccys:
        return f3.CreateCompositeScenario(
            ScenarioCollection=[f3scenario_single(i, bump=bump) for i in (ccy, *ccys)]
        )
    return f3.CreateCompositeScenario(ScenarioCollection=[f3scenario_single(ccy=ccy, bump=bump)])


def apply_composite_bump_scenario(
        ccy: Union[str, Ccy],
        *ccys: Iterable[Union[str, Ccy]],
        bump: float,
        f3model: F3Object,
) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    if bump == 0:
        return f3model
    return f3.ApplyScenarioToModel(
        BaseModel=f3model,
        Scenario=create_composite_bump_scenario(ccy, *ccys, bump=bump),
    )


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\evaluate\scenarios2.py
----------------------------------------
from typing import Callable

import pandas
from f3sdk.f3 import F3Object  # type:ignore

from firm_domain import Ccy, Tenor, FXForward
from firm_f3.model_object.util import extend_model_with_fx_market_data
from firm_f3.util.f3utils import make_wait

from .types import MARKET_DATA_TYPE
from .handlers import market_data_fx_spot_handler
from .extract_market_data import extract_market_data_async


async def apply_fx_spot_scenario_to_model_async(
        f3model: F3Object,
        scenario: Callable,
        market_data: MARKET_DATA_TYPE = None,
) -> F3Object:
    if market_data is None:
        market_data = await extract_market_data_async(f3model, callback=None)

    old_data = market_data_fx_spot_handler(market_data)
    new_data = scenario(old_data)

    def unpack():
        for k, v in new_data.items():
            if ':' in k:
                left, _, right = k.partition(':')
            elif '/' in k:
                left, _, right = k.partition('/')
            else:
                left, right = k, 'USD'

            ccy_base, ccy = Ccy[left], Ccy[right]
            if ccy_base > ccy:
                ccy, ccy_base = ccy_base, ccy
                v **= -1
            yield FXForward(ccy_base=ccy_base, ccy=ccy, tenor=Tenor.SPOT), v

    clean_data = pandas.Series(dict(unpack()))
    return extend_model_with_fx_market_data(f3model, clean_data)


apply_fx_spot_scenario_to_model = apply_fx_spot_scenario_to_model_async
# noinspection PyRedeclaration
apply_fx_spot_scenario_to_model = make_wait(apply_fx_spot_scenario_to_model_async)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\evaluate\types.py
----------------------------------------
import datetime
from typing import Union, List, Iterable, Tuple
from f3sdk.f3 import F3Object  # type:ignore
from firm_domain import Instrument, Trade, Ccy

EXCEL_F3OBJECT_TYPE = Union[F3Object, List[F3Object]]
EXCEL_DATE_TYPE = Union[datetime.date, List[datetime.date]]
SINGLE_ROLL_TYPE = Tuple[datetime.date, float]
ROLL_TYPE = Union[SINGLE_ROLL_TYPE, List[SINGLE_ROLL_TYPE]]
MARKET_DATA_TAG_TYPE = List[str]

SINGLE_INDEX_TYPE = Union[F3Object, Instrument, Ccy, str]
SINGLE_PRODUCT_TYPE = Union[F3Object, Trade, Instrument]
SINGLE_REQUEST_TYPE = str
SINGLE_SCENARIO_TYPE = Union[str, F3Object]

INDEX_TYPE = Union[SINGLE_INDEX_TYPE, Iterable[SINGLE_INDEX_TYPE]]
PRODUCT_TYPE = Union[SINGLE_PRODUCT_TYPE, Iterable[SINGLE_PRODUCT_TYPE]]
REQUEST_TYPE = Union[SINGLE_REQUEST_TYPE, List[SINGLE_REQUEST_TYPE]]

REFERENCE_SPECIFICATION_TYPE = Union[EXCEL_DATE_TYPE, ROLL_TYPE]
VALUATION_SPECIFICATION_TYPE = Union[str, F3Object, datetime.date]
EVALUATION_POINT_TYPE = List[Union[str, datetime.date]]
IMPLIED_VOLATILITY_CALCULATOR_TYPE = str

RISK_REPORT_TYPE = List[List[Union[str, float]]]
MARKET_DATA_TYPE = List[List[Union[str, float]]]

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\evaluate\valuation_date.py
----------------------------------------
import datetime
from typing import Callable, Tuple

from f3sdk.f3 import F3Object  # type:ignore
from f3sdk.lib.coroutine import wait  # type: ignore
import firm_f3.f3client  # type:ignore
from .core import f3_evaluate_async
from .types import EXCEL_DATE_TYPE, EXCEL_F3OBJECT_TYPE
from .handlers import scalar_handler


def req_valuation_date_single(f3model: F3Object) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ObjectInfo('Model', f3model, 'ValuationDate')


def req_valuation_date(f3model: F3Object, *f3models: Tuple[F3Object]) -> EXCEL_F3OBJECT_TYPE:
    if f3models:
        return [req_valuation_date_single(i) for i in (f3model, *f3models)]
    return req_valuation_date_single(f3model)


async def valuation_date_single_async(f3model: F3Object, callback: Callable = scalar_handler) -> datetime.date:
    return await f3_evaluate_async(req_valuation_date_single(f3model), callback=callback)


async def valuation_date_async(
        f3model: F3Object,
        *f3models: Tuple[F3Object],
        callback: Callable = scalar_handler,
) -> EXCEL_DATE_TYPE:
    if f3models:
        req = req_valuation_date(f3model, *f3models)
        return await f3_evaluate_async(*req, callback=callback)
    return await valuation_date_single_async(f3model, callback=callback)


def valuation_date(
        f3model: F3Object,
        *f3models: Tuple[F3Object],
        callback: Callable = scalar_handler,
) -> EXCEL_DATE_TYPE:
    return wait(valuation_date_async(f3model, *f3models, callback=callback))


def valuation_date_fast(f3model: F3Object) -> datetime.date:
    src, *_ = f3model.form_f3ml()
    idx = src.index('<D>')
    date_str = src[idx + 3:idx + 13]
    return datetime.datetime.strptime(date_str, '%Y-%m-%d').date()


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\evaluate\value_index.py
----------------------------------------
from typing import Iterable, Union, Tuple, Callable, List
from f3sdk.f3 import F3Object  # type:ignore
from f3sdk.lib.coroutine import wait  # type: ignore
import firm_f3.f3client # type:ignore
from firm_f3.mapping import f3index
from .core import f3_evaluate_async
from .handlers import scalar_handler
from .valuation_date import valuation_date_async
from .types import INDEX_TYPE, VALUATION_SPECIFICATION_TYPE, REFERENCE_SPECIFICATION_TYPE, EVALUATION_POINT_TYPE


def req_value_index(
        f3model: F3Object,
        index: INDEX_TYPE,
        ref_spec: REFERENCE_SPECIFICATION_TYPE,
        valuation_method: VALUATION_SPECIFICATION_TYPE,
        return_risk: bool = False,
        sort_lexically: bool = True,
        evaluation_point: EVALUATION_POINT_TYPE = None,
) -> Union[F3Object, Iterable[F3Object]]:
    f3 = firm_f3.f3client.get_platform_client()
    if isinstance(index, Iterable) and not isinstance(index, str):
        indices = f3index(*index)
        return [f3.ValueIndex(
            Model=f3model,
            Index=i,
            RefSpec=ref_spec,
            ValuationMethod=valuation_method,
            ReturnRisk=return_risk,
            SortLexically=sort_lexically,
            EvaluationPoint=evaluation_point,
        ) for i in indices]
    return f3.ValueIndex(
        Model=f3model,
        Index=f3index(index),
        RefSpec=ref_spec,
        ValuationMethod=valuation_method,
        ReturnRisk=return_risk,
        SortLexically=sort_lexically,
        EvaluationPoint=evaluation_point,
    )


async def value_index_async(
        index: INDEX_TYPE,
        *indices: Tuple[INDEX_TYPE],
        f3model: F3Object,
        ref_spec: REFERENCE_SPECIFICATION_TYPE = None,
        valuation_method: VALUATION_SPECIFICATION_TYPE = 'Default',
        return_risk: bool = False,
        sort_lexically: bool = True,
        evaluation_point: EVALUATION_POINT_TYPE = None,
        callback: Callable = scalar_handler,
) -> Union[float, List[float]]:
    if ref_spec is None:
        ref_spec = await valuation_date_async(f3model)
    if valuation_method is None:
        valuation_method = 'Default'

    if indices:
        return await f3_evaluate_async(
            *(req_value_index(f3model, i, ref_spec, valuation_method, return_risk, sort_lexically, evaluation_point) for
              i in (index, *indices)), callback=callback)
    return await f3_evaluate_async(
        req_value_index(f3model, index, ref_spec, valuation_method, return_risk, sort_lexically, evaluation_point),
        callback=callback)


def value_index(
        index: INDEX_TYPE,
        *indices: Tuple[INDEX_TYPE],
        f3model: F3Object,
        ref_spec: REFERENCE_SPECIFICATION_TYPE = None,
        valuation_method: VALUATION_SPECIFICATION_TYPE = 'Default',
        return_risk: bool = False,
        sort_lexically: bool = True,
        evaluation_point: EVALUATION_POINT_TYPE = None,
        callback: Callable = scalar_handler,
) -> Union[float, List[float]]:
    return wait(
        value_index_async(index, *indices, f3model=f3model, ref_spec=ref_spec, valuation_method=valuation_method,
                          return_risk=return_risk, sort_lexically=sort_lexically, evaluation_point=evaluation_point,
                          callback=callback))


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\evaluate\value_product.py
----------------------------------------
import asyncio
import datetime
from typing import Iterable, Union, Callable, List, Any
import pandas

from f3sdk.f3 import F3Object  # type:ignore
from f3sdk.lib.coroutine import wait  # type: ignore
from nimrod.core.model_set import ModelSet
import firm_f3.f3client  # type:ignore
from firm_f3.mapping import f3products

from .types import PRODUCT_TYPE, VALUATION_SPECIFICATION_TYPE, REQUEST_TYPE, RISK_REPORT_TYPE
from .core import f3_evaluate_async
from .handlers import scalar_handler, local_ccy_to_dict_handler, cashflow_projection_handler

DEFAULT_VAL_SPEC = 'DefaultUSD'


def req_value_product(
        f3model: F3Object,
        trade: PRODUCT_TYPE,
        valuation_method: VALUATION_SPECIFICATION_TYPE,
        requests: REQUEST_TYPE,
) -> Union[F3Object, Iterable[F3Object]]:
    f3 = firm_f3.f3client.get_platform_client()

    if isinstance(valuation_method, datetime.date):
        # jchi@201912
        # if provided a date, convert it for forward valuation
        valuation_method = f3.CreateForwardValuationSpecification(
            UnderlyingValuationMethod=DEFAULT_VAL_SPEC,
            Horizon=valuation_method,
            FutureHistory='Flat',
        )

    if isinstance(trade, Iterable) and not isinstance(trade, str):
        return [f3.ValueProduct(
            Model=f3model,
            Product=f3products(i),
            ValuationMethod=valuation_method,
            Requests=requests
        ) for i in trade]
    return f3.ValueProduct(
        Model=f3model,
        Product=f3products(trade),
        ValuationMethod=valuation_method,
        Requests=requests
    )


async def value_product_with_f3_model_async(
        trade: PRODUCT_TYPE,
        *trades: PRODUCT_TYPE,
        f3model: F3Object,
        valuation_method: VALUATION_SPECIFICATION_TYPE,
        requests: REQUEST_TYPE,
        callback: Callable = None,
) -> Any:
    if trades:
        return await f3_evaluate_async(
            *(req_value_product(f3model, i, valuation_method, requests) for i in (trade, *trades)), callback=callback)
    return await f3_evaluate_async(req_value_product(f3model, trade, valuation_method, requests), callback=callback)


async def _value_product_with_model_set(
        trade: PRODUCT_TYPE,
        f3model: ModelSet,
        valuation_method: VALUATION_SPECIFICATION_TYPE,
        requests: REQUEST_TYPE,
        callback: Callable = None,
) -> Any:
    if not isinstance(trade, Iterable):
        trade = [trade]
    fut = f3model.eval_with(trade)
    model_trade_pairs = await fut.gather_models()
    res = await asyncio.gather(*(
        value_product_with_f3_model_async(t, f3model=m, valuation_method=valuation_method, requests=requests,
                                          callback=callback) for m, t in model_trade_pairs))
    fut.set_results(res)
    if len(trade) == 1:
        return fut.results[0]
    return fut.results


async def value_product_with_model_set_async(
        trade: PRODUCT_TYPE,
        *trades: PRODUCT_TYPE,
        f3model: ModelSet,
        valuation_method: VALUATION_SPECIFICATION_TYPE,
        requests: REQUEST_TYPE,
        callback: Callable = None,
) -> Any:
    if trades:
        return await asyncio.gather(
            *(_value_product_with_model_set(i, f3model, valuation_method, requests, callback) for i in
              (trade, *trades)))
    return await _value_product_with_model_set(trade, f3model, valuation_method, requests, callback)


async def value_product_async(
        trade: PRODUCT_TYPE,
        *trades: PRODUCT_TYPE,
        f3model: Union[F3Object, ModelSet],
        valuation_method: VALUATION_SPECIFICATION_TYPE,
        requests: REQUEST_TYPE,
        callback: Callable = None,
) -> Any:
    if isinstance(f3model, ModelSet):
        return await value_product_with_model_set_async(
            trade, *trades, f3model=f3model, valuation_method=valuation_method, requests=requests, callback=callback)
    elif isinstance(f3model, F3Object):
        return await value_product_with_f3_model_async(
            trade, *trades, f3model=f3model, valuation_method=valuation_method, requests=requests, callback=callback)
    raise TypeError(f'got wrong type {type(f3model)} for f3model')


def value_product(
        trade: PRODUCT_TYPE,
        *trades: PRODUCT_TYPE,
        f3model: F3Object,
        valuation_method: VALUATION_SPECIFICATION_TYPE,
        requests: REQUEST_TYPE,
        callback: Callable = None,
):
    return wait(
        value_product_async(trade, *trades, f3model=f3model, valuation_method=valuation_method, requests=requests,
                            callback=callback))


async def pv_async(
        trade: PRODUCT_TYPE,
        *trades: PRODUCT_TYPE,
        f3model: F3Object,
        valuation_method: VALUATION_SPECIFICATION_TYPE = DEFAULT_VAL_SPEC,
        callback: Callable = scalar_handler,
) -> Union[float, List[float]]:
    return await value_product_async(
        trade,
        *trades,
        f3model=f3model,
        valuation_method=valuation_method,
        requests='NumeraireValue',
        callback=callback,
    )


def pv(
        trade: PRODUCT_TYPE,
        *trades: PRODUCT_TYPE,
        f3model: F3Object,
        valuation_method: VALUATION_SPECIFICATION_TYPE = DEFAULT_VAL_SPEC,
        callback: Callable = scalar_handler,
) -> Union[float, List[float]]:
    return wait(pv_async(trade, *trades, f3model=f3model, valuation_method=valuation_method, callback=callback))


async def cashflow_async(
        trade: PRODUCT_TYPE,
        *trades: PRODUCT_TYPE,
        f3model: F3Object,
        valuation_method: VALUATION_SPECIFICATION_TYPE = DEFAULT_VAL_SPEC,
        callback: Callable = cashflow_projection_handler,
) -> pandas.DataFrame:
    return await value_product_async(
        trade,
        *trades,
        f3model=f3model,
        valuation_method=valuation_method,
        requests=['ImpliedCashflowsLabels', 'ImpliedCashflows'],
        callback=callback,
    )


def cashflow(
        trade: PRODUCT_TYPE,
        *trades: PRODUCT_TYPE,
        f3model: F3Object,
        valuation_method: VALUATION_SPECIFICATION_TYPE = DEFAULT_VAL_SPEC,
        callback: Callable = cashflow_projection_handler,
) -> pandas.DataFrame:
    return wait(cashflow_async(trade, *trades, f3model=f3model, valuation_method=valuation_method, callback=callback))



async def pv_local_async(
        trade: PRODUCT_TYPE,
        *trades: PRODUCT_TYPE,
        f3model: F3Object,
        valuation_method: VALUATION_SPECIFICATION_TYPE = DEFAULT_VAL_SPEC,
        callback: Callable = local_ccy_to_dict_handler,
) -> Union[float, List[float]]:
    return await value_product_async(
        trade,
        *trades,
        f3model=f3model,
        valuation_method=valuation_method,
        requests='Value',
        callback=callback,
    )


def pv_local(
        trade: PRODUCT_TYPE,
        *trades: PRODUCT_TYPE,
        f3model: F3Object,
        valuation_method: VALUATION_SPECIFICATION_TYPE = DEFAULT_VAL_SPEC,
        callback: Callable = local_ccy_to_dict_handler,
) -> Union[float, List[float]]:
    return wait(pv_local_async(trade, *trades, f3model=f3model, valuation_method=valuation_method, callback=callback))


async def delta_async(
        trade: PRODUCT_TYPE,
        *trades: PRODUCT_TYPE,
        f3model: F3Object,
        valuation_method: VALUATION_SPECIFICATION_TYPE = DEFAULT_VAL_SPEC,
        callback: Callable = scalar_handler,
) -> Union[float, List[float]]:
    return await value_product_async(
        trade,
        *trades,
        f3model=f3model,
        valuation_method=valuation_method,
        requests='Delta',
        callback=callback,
    )


def delta(
        trade: PRODUCT_TYPE,
        *trades: PRODUCT_TYPE,
        f3model: F3Object,
        valuation_method: VALUATION_SPECIFICATION_TYPE = DEFAULT_VAL_SPEC,
        callback: Callable = scalar_handler,
) -> Union[float, List[float]]:
    return wait(delta_async(trade, *trades, f3model=f3model, valuation_method=valuation_method, callback=callback))


async def gamma_async(
        trade: PRODUCT_TYPE,
        *trades: PRODUCT_TYPE,
        f3model: F3Object,
        valuation_method: VALUATION_SPECIFICATION_TYPE = DEFAULT_VAL_SPEC,
        callback: Callable = scalar_handler,
) -> Union[float, List[float]]:
    return await value_product_async(
        trade,
        *trades,
        f3model=f3model,
        valuation_method=valuation_method,
        requests='Gamma',
        callback=callback,
    )


def gamma(
        trade: PRODUCT_TYPE,
        *trades: PRODUCT_TYPE,
        f3model: F3Object,
        valuation_method: VALUATION_SPECIFICATION_TYPE = DEFAULT_VAL_SPEC,
        callback: Callable = scalar_handler,
) -> Union[float, List[float]]:
    return wait(gamma_async(trade, *trades, f3model=f3model, valuation_method=valuation_method, callback=callback))


async def risk_report_async(
        trade: PRODUCT_TYPE,
        *trades: PRODUCT_TYPE,
        f3model: F3Object,
        valuation_method: VALUATION_SPECIFICATION_TYPE = DEFAULT_VAL_SPEC,
        callback: Callable = None,
) -> RISK_REPORT_TYPE:
    # krw_cache: Dict[str, float] = {}
    #
    # async def callback_with_krw_hotfix(res):
    #     raise_if_error(res[0])
    #     heading = res[0]
    #     idx = heading.index('Exposure')
    #     for v in res[1:]:
    #         row = dict(zip(heading, v))
    #         if row.get('MarketDataName') == 'IRS:3m:KRWCD:3m' and row.get('ExposureType') == 'PVBP Delta':
    #             try:
    #                 krw_fx_spot = krw_cache['krw_fx_spot']
    #             except KeyError:
    #                 krw_fx_spot = krw_cache['krw_fx_spot'] = await value_index_async('USDKRW', f3model=f3model)
    #             v[idx] /= krw_fx_spot
    #
    #     if callback is None:
    #         return res
    #     elif asyncio.iscoroutinefunction(callback):
    #         return await callback(res)
    #     return callback(res)

    return await value_product_async(
        trade,
        *trades,
        f3model=f3model,
        valuation_method=valuation_method,
        requests=['NumeraireRiskLabels', 'NumeraireRisk'],
        callback=callback
    )


def risk_report(
        trade: PRODUCT_TYPE,
        *trades: PRODUCT_TYPE,
        f3model: F3Object,
        valuation_method: VALUATION_SPECIFICATION_TYPE = DEFAULT_VAL_SPEC,
        callback: Callable = None,
) -> RISK_REPORT_TYPE:
    return wait(
        risk_report_async(trade, *trades, f3model=f3model, valuation_method=valuation_method, callback=callback))


if __name__ == '__main__':
    pass
    # import datetime
    # from firm_f3.core.modelutils import *
    # from firm_domain import *
    # from firm_f3.evaluate import *
    #
    # f3model = get_model()
    #
    # irs1 = IRSTrade(datetime.datetime(2019, 8, 10), Ccy.USD, datetime.datetime(2019, 8, 12),
    #                 datetime.datetime(2021, 8, 12), 0.02, 1000)
    # irs2 = IRSTrade(datetime.datetime(2019, 8, 10), Ccy.EUR, datetime.datetime(2019, 8, 12),
    #                 datetime.datetime(2021, 8, 12), 0.005, 1000)
    # swaption1 = SwaptionTrade(datetime.datetime(2019, 8, 10), Ccy.EUR, datetime.datetime(2019, 11, 10),
    #                          datetime.datetime(2019, 11, 11), datetime.datetime(2021, 11, 10), -0.005,
    #                          SwaptionType.PAYER, 1000000)
    # swaption2 = SwaptionTrade(datetime.datetime(2019, 8, 10), Ccy.KRW, datetime.datetime(2019, 11, 10),
    #                          datetime.datetime(2019, 11, 11), datetime.datetime(2021, 11, 10), -0.005,
    #                          SwaptionType.PAYER, 1000000)
    #
    # pv([irs1, irs2], swaption1, swaption2, f3model=f3model)
    # pv([irs1, irs2, swaption1, swaption2], f3model=f3model)
    #
    # tmp = risk_report([irs1, irs2], swaption1, swaption2, f3model=f3model)
    # tmp = risk_report([irs1, irs2], [swaption1, swaption2], f3model=f3model)
    # tmp = risk_report([irs1, irs2, swaption1, swaption2], f3model=f3model)

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\evaluate\__init__.py
----------------------------------------
from .core import *
from .handlers import *
from .error import *
from .extract_market_data import *
from .scenarios import *
from .scenarios2 import *
from .impliedvol import *
from .valuation_date import *
from .maturity_date import *
from .value_index import *
from .value_product import *
from .par_rate import *
from .instrument2trade import *
from .instrument2parrate import *
from .asset_curve_tag import f3_asset_curve_tag_async

__all__ = [k for k, v in globals().items() if getattr(v, '__module__', '').startswith(__name__)]

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\evaluate\__pycache__\error.cpython-37.pyc
----------------------------------------
B

    y  d                   @   sL   d dl mZmZ d dlmZ eee d dd Zedd d d Zd	d
  Z dS )
     ) Any Optional)  F3Error) res returnc             C   sv   t td dd }t| t rr| rrt|  dkr.d S | d }t|t  rP|| rPt|   S x | D ]}t| }|d k	rV|S qVW d S )N) msgr   c             S   s   |     } |  d p|  d S )Nz #error:z#unexpected error:) lower 
startswith)r      r
    GE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/evaluate/error.py starts_with_error   s    z+extract_f3_error.<locals>.starts_with_errorr   )  str bool 
isinstance list lenr    extract_f3_error)r   r   r     elemZelem_errr
   r
   r
   r      s    
r   Nc             C   s   t |  }|d k	r| d S )N)r   )r    errr
   r
   r
    raise_if_error   s    r   c              C   s    ddddg} d}t t|   |ks$t t t| g  |ks:t t t| gg  |ksRt t tdd d| g  |ksnt t tdd d| gg  |ks t tdd dg d ks t d S )	Nz#error: MyError originZclassification 
descriptionz&#error: MyError - in 'origin' function            )r
   r    AssertionError)r    expectedr
   r
   r
    test_extract_f3_error   s    r   ) typingr   r   Zf3sdk.f3r   r   r   r   r
   r
   r
   r
    <module>   s    
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\evaluate\__pycache__\instrument2parrate.cpython-37.pyc
----------------------------------------
B

    y  d                   @   s    d dl mZmZ d dlmZ d dlmZ d dl mZ ddl	m
Z
 dd l
mZ eeee f ee
ee
 f d d	d
 Zeeee f ee
ee
 f d d
d Zd
S )     ) Union List) wait)  flatten) 
Instrument    ) valuation_date_async) trades_from_instruments_async) 
instruments returnc             C   s   t t| |  S )N)r    par_rate_from_instrument_async)r
     f3model  r    TE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/evaluate/instrument2parrate.py par_rate_from_instrument
   s    r   c                 sV   t | I d H }t| g  } t| ||d  I d H }dd  |D  }t|  dkrR|d S |S )N) valuation_dater
   c             S   s   g | ]}|     qS r   )Zget_rate) .0 tr   r   r    
<listcomp>   s    z2par_rate_from_instrument_async.<locals>.<listcomp>r    r   )r   r   r	    len)r
   r
   Zval_dateZtrades rvr   r   r   r      s    r   N) typingr   r   Zf3sdk.lib.coroutiner   Zfirm_f3.utilr   Z
firm_domainr   r   r   Zinstrument2trader	    floatr   r   r   r   r   r    <module>   s   (
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\evaluate\__pycache__\__init__.cpython-37.pyc
----------------------------------------
B

    y  d                  @   s    d dl T d dlT d dlT d dlT d dlT d dlT d dlT d dl T d dlT d dl	T d dl
T d dl
T d dlT d dl
T d dlmZ dd  e     D  ZdS )    ) *) f3_asset_curve_tag_asyncc             C   s&   g | ]\}}t |d d  t r| qS ) 
__module__  )  getattr 
startswith __name__) .0 k v  r    JE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/evaluate/__init__.py 
<listcomp>   s    r   N) core handlers errorZextract_market_dataZ	scenariosZ
scenarios2Z
impliedvolZvaluation_dateZ
maturity_dateZ
value_indexZ
value_productZpar_rateZinstrument2tradeZinstrument2parrateZasset_curve_tagr     globals items  __all__r   r   r   r
    <module>   s   
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\exceltools\datalayer.py
----------------------------------------
from typing import Union
import datetime
import pandas  # type: ignore
from pyxll import xl_func, xl_arg, xl_return  # type: ignore
from atom_client.historic_data import HistoricData  # type: ignore
from atom_client.historic_market_data import HistoricMarketData  # type: ignore
from atom_client.reference_data import ReferenceData  # type: ignore

from firm_f3.firm_data_client import firm_connect


def ensure_float(x: str) -> Union[float, str]:
    try:
        return float(x)
    except ValueError:
        return x


class firmDataError(Exception):
    pass


class BlpResult(dict):
    def add_historic_market_data(self, item: HistoricMarketData):
        if isinstance(item, HistoricMarketData):
            if item.error:
                raise firmDataError(item.error)
            assert item.security, 'HistoricMarketData.security is an empty string'
            assert item.fields, 'HistoricMarketData.fields is an empty list'

            def unpack(idx: int):
                for v in item.history:
                    if isinstance(v, HistoricData):
                        k = datetime.datetime.fromtimestamp(v.date / 1000)
                        yield k, v.data[idx]

            for i, field in enumerate(item.fields):
                key = item.security, field
                val = dict(unpack(i))
                self[key] = val

    def add_reference_data(self, item: ReferenceData):
        if isinstance(item, ReferenceData):
            if item.error:
                raise firmDataError(item.error)
            assert item.security, 'ReferenceData.security is an empty string'

            for k, v in item.field_values.items():
                key = item.security, k
                val = ensure_float(v)
                self[key] = val


@xl_func
@xl_arg('tickers', 'str[]')
@xl_arg('fields', 'str[]')
def blp_bdh(
        tickers,
        fields,
        start_date: datetime.date,
        end_date: datetime.date,
) -> object:
    tkrs = [i.upper() for i in set(tickers)]
    flds = [i.upper() for i in set(fields)]
    start = start_date.strftime('%Y%m%d')
    end = end_date.strftime('%Y%m%d')

    firm = firm_connect('prd')
    res = firm.market_data.history(tkrs, start, end, flds)

    rv = BlpResult()
    for i in res:
        rv.add_historic_market_data(i)
    return rv


@xl_func
@xl_return('dataframe', index=True, columns=True)
def blp_bdh_enlist(
        blp_result: object,
        sort_ascending: bool = True,
        fill: bool = False
):
    assert isinstance(blp_result, BlpResult)
    rv = pandas.DataFrame(blp_result)
    rv.sort_index(ascending=sort_ascending, inplace=True)
    if fill:
        rv.ffill(inplace=True)
    return rv


@xl_func
def blp_bdp_single(ticker: str, field: str):
    firm = firm_connect('prd')
    res = firm.market_data.reference([ticker.upper()], [field.upper()])
    rv = next(iter(res.values()))

    assert isinstance(rv, ReferenceData)
    v = next(iter(rv.field_values.values()))
    return ensure_float(v)


@xl_func
@xl_arg('tickers', 'str[]')
@xl_arg('fields', 'str[]')
def blp_bdp_multiple(
        tickers,
        fields,
) -> object:
    tkrs = [i.upper() for i in set(tickers)]
    flds = [i.upper() for i in set(fields)]

    firm = firm_connect('prd')
    res = firm.market_data.reference(tkrs, flds)

    rv = BlpResult()
    for i in res.values():
        rv.add_reference_data(i)
    return rv


@xl_func
@xl_return('series', index=True)
def blp_bdp_enlist(blp_result: object):
    assert isinstance(blp_result, BlpResult)
    return pandas.Series(blp_result)


@xl_func
@xl_arg('tickers', 'str[]')
@xl_arg('fields', 'str[]')
def blp_bdp(tickers, fields):
    if len(tickers) == len(fields) == 1:
        return blp_bdp_single(tickers[0], fields[0])
    return blp_bdp_multiple(tickers, fields)


__all__ = [i for i in globals() if i.startswith('blp_')]

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\exceltools\f3api.py
----------------------------------------
import datetime
from typing import List, Union, Any
from pyxll import xl_func  # type: ignore
from f3sdk.f3 import F3Object  # type: ignore
import firm_f3.f3client # type:ignore
from firm_f3.f3client import f3_client_auto_connect
from firm_f3.evaluate import f3_evaluate, scalar_handler
from firm_f3.util.funcutils import inspect_arguments


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_TradeDateToStartDate(
        TradeDate: List[datetime.date],
        MarketConvention: Any,
) -> List[datetime.date]:
    f3 = firm_f3.f3client.get_platform_client()
    return f3_evaluate([f3.TradeDateToStartDate(i, MarketConvention) for i in TradeDate], callback=scalar_handler)


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_AdjustDate(
        StartDate: datetime.date,
        DateModifier: List[str],
) -> list:
    """
    F3 AdjustDate function, see F3 documentation:
        https://help.fincad.com/f381/f3_documentation/html/references/functions/AdjustDate.html

    :param StartDate: datetime.date
    :param DateModifier: [str]
    :return: datetime.date
    """
    f3 = firm_f3.f3client.get_platform_client()
    return f3_evaluate(f3.AdjustDate(StartDate, DateModifier))


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_MoveBusinessDays(
        StartDate: datetime.date,
        HolidayConventions: List[str],
        NumberOfDays: int
) -> list:
    f3 = firm_f3.f3client.get_platform_client()
    return f3_evaluate(f3.MoveBusinessDays(StartDate, HolidayConventions, NumberOfDays))


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_IsGoodBusinessDay(
        Date: datetime.date,
        HolidayConventions: List[str],
) -> list:
    f3 = firm_f3.f3client.get_platform_client()
    return f3_evaluate(f3.IsGoodBusinessDay(Date, HolidayConventions))


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_DayCountFraction(
        FirstDate: datetime.date,
        SecondDate: datetime.date,
        DayCountType: str,
) -> list:
    f3 = firm_f3.f3client.get_platform_client()
    return f3_evaluate(f3.DayCountFraction(FirstDate, SecondDate, DayCountType))


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_SortArray(
        Vector: list,
        Reverse: bool,
) -> list:
    f3 = firm_f3.f3client.get_platform_client()
    return f3_evaluate(f3.SortArray(Vector, Reverse))


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_SubArray(
        InputRange: list,
        StartRow: int = 1,
        StartColumn: int = 1,
        NumberOfRows: int = 0,
        NumberOfColumns: int = 0,
) -> list:
    f3 = firm_f3.f3client.get_platform_client()
    return f3_evaluate(f3.SubArray(InputRange, StartRow, StartColumn, NumberOfRows, NumberOfColumns))


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_ArrayFilter(
        InputArray: list,
        FilterColumn: int,
        FilterValue: str,
) -> list:
    f3 = firm_f3.f3client.get_platform_client()
    return f3_evaluate(f3.ArrayFilter(InputArray, FilterColumn, FilterValue))


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_ArrayStack(
        Argument1: list = None,
        Argument2: list = None,
        Argument3: list = None,
        Argument4: list = None,
        Argument5: list = None,
        Argument6: list = None,
        Argument7: list = None,
        Argument8: list = None,
        Argument9: list = None,
) -> list:
    f3 = firm_f3.f3client.get_platform_client()
    return f3_evaluate(
        f3.ArrayStack(Argument1, Argument2, Argument3, Argument4, Argument5, Argument6, Argument7, Argument8,
                      Argument9))


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_ExtractAllMarketDataQuotes(
        MarketDataSet: object,
        TableFormat: List[str],
) -> list:
    f3 = firm_f3.f3client.get_platform_client()
    return f3_evaluate(f3.ExtractAllMarketDataQuotes(MarketDataSet, TableFormat))


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_FuturesExpiryList(
        ReferenceDate: datetime.date,
        ContractType: str = 'EuroDollar',
        RollBufferInDays: int = 3,
        NumberOfMonthlyFutures: int = 6,
        NumberOfQuarterlyFutures: int = 10,
) -> list:
    f3 = firm_f3.f3client.get_platform_client()
    return f3_evaluate(f3.FuturesExpiryList(ReferenceDate, ContractType, RollBufferInDays, NumberOfMonthlyFutures,
                                            NumberOfQuarterlyFutures))


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_EigenDecomposition(
        InputMatrix: List[List[float]],
        DoRisk: bool = False
) -> list:
    f3 = firm_f3.f3client.get_platform_client()
    return f3_evaluate(f3.EigenDecomposition(InputMatrix, DoRisk))


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_SwapRate(
        Model: object,
        StartDate: List[datetime.date],
        Maturity: List[datetime.date],
        FixedLegConventions: List[List[Union[str, float]]],
        FloatingRateIndex: List[List[Union[str, float]]],
        FloatingLegConventions: List[List[Union[str, float]]],
        DoRisk: bool = False,
        ValuationMethod: Union[List[str], str] = 'Default',
        CollateralAgreement: str = 'ZeroCollateral',
) -> List[float]:
    f3 = firm_f3.f3client.get_platform_client()
    assert isinstance(Model, F3Object)

    def req():
        for start, maturity in zip(StartDate, Maturity):
            yield f3.SwapRate(Model, start, maturity, FixedLegConventions, FloatingRateIndex, FloatingLegConventions,
                              DoRisk, ValuationMethod, CollateralAgreement)

    return f3_evaluate(list(req()), callback=scalar_handler)


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_SwaptionImpliedVolatility(
        Model: object,
        SwapMaturity: datetime.date,
        FixedLegConventions: List[List[Union[str, float]]],
        FloatingRateIndex: List[List[Union[str, float]]],
        FloatingLegConventions: List[List[Union[str, float]]],
        Strike: List[Union[str, float]],
        Expiry: datetime.date,
        ValuationMethod: Union[List[str], str] = 'Default',
        ImpliedVolatilityCalculator: str = 'Black',
        CollateralAgreement: str = 'ZeroCollateral',
) -> list:
    f3 = firm_f3.f3client.get_platform_client()
    return f3_evaluate(f3.SwaptionImpliedVolatility(Model, SwapMaturity, FixedLegConventions, FloatingRateIndex,
                                                    FloatingLegConventions, Strike, Expiry, ValuationMethod,
                                                    ImpliedVolatilityCalculator, CollateralAgreement))


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_ValueProduct(
        Model: object,
        Product: object,
        ValuationMethod: List[str],
        Requests: List[str],
) -> list:
    f3 = firm_f3.f3client.get_platform_client()
    return f3_evaluate(f3.ValueProduct(Model, Product, ValuationMethod, Requests))


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_ValueProducts(
        Model: object,
        Product: List[object],
        ValuationMethod: List[str],
        Requests: List[str],
        InternalAggregation: bool = True,
) -> list:
    f3 = firm_f3.f3client.get_platform_client()
    return f3_evaluate(f3.ValueProducts(Model, Product, ValuationMethod, Requests, InternalAggregation))


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_CreateCollateralizedProduct(
        ProductName: str,
        UnderlyingProduct: object,
        CollateralAgreement: str,
) -> object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.CreateCollateralizedProduct(UnderlyingProduct, CollateralAgreement).named(ProductName)


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_CreateInterestRateSwap(
        ProductName: str,
        StartDate: datetime.date,
        Maturity: datetime.date,
        Notional: float,
        Currency: str,
        FixedCoupon: float,
        MarketConvention: str,
        FloatingRateIndex: str,
        Margin: float,
        PayRec: str,
        FloatingLegMarketConventions: str,
) -> object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.CreateInterestRateSwap(StartDate, Maturity, Notional, Currency, FixedCoupon, MarketConvention,
                                     FloatingRateIndex, Margin, PayRec, FloatingLegMarketConventions).named(ProductName)


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_CreateVanillaInterestRateSwaption(
        ProductName: str,
        Expiry: datetime.date,
        Maturity: datetime.date,
        Notional: float,
        Currency: str,
        Strike: float,
        Payoff: str,
        FixedLegMarketConvention: str,
        FloatingRateIndex: str,
        BuySell: str,
        FloatingLegMarketConvention: str,
) -> object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.CreateVanillaInterestRateSwaption(Expiry, Maturity, Notional, Currency, Strike, Payoff,
                                                FixedLegMarketConvention, FloatingRateIndex, BuySell,
                                                FloatingLegMarketConvention).named(ProductName)


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_CreateYieldCurveParallelShiftScenario(
        Currency: str,
        ShiftAmount: float = 0.0001,
) -> object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.CreateYieldCurveParallelShiftScenario(Currency, ShiftAmount)


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_ApplyScenarioToModel(
        BaseModel: object,
        Scenario: Union[str, object],
) -> object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ApplyScenarioToModel(BaseModel, Scenario)


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_CreateCompositeScenario(
        ScenarioCollection: List[Union[str, object]],
) -> object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.CreateCompositeScenario(ScenarioCollection)


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_CreateProductValueGenerator(
        BaseModel: object,
        Product: object,
        ValuationMethod: List[str],
        ScenarioGenerator: List[str],
) -> object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.CreateProductValueGenerator(BaseModel, Product, ValuationMethod, ScenarioGenerator)


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_CreateInstrumentPropertiesScenario(
        Categories: str,
        TypeNames: str,
        Currencies: List[str],
        PayoffDescriptions: str,
        ModificationAmount: float,
        RelativeOrAbsolute: List[Union[str, float]],
) -> object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.CreateInstrumentPropertiesScenario(Categories, TypeNames, Currencies, PayoffDescriptions,
                                                 ModificationAmount, RelativeOrAbsolute)


@xl_func
@inspect_arguments
@f3_client_auto_connect
def f3_CreateIdentifierListScenario(
        ScenarioName: str,
        InstrumentIdentifiers: List[List[str]],
        Amounts: List[float],
        ScenarioStyles: List[str],
) -> object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.CreateIdentifierListScenario(InstrumentIdentifiers, Amounts, ScenarioStyles).named(ScenarioName)


__all__ = [i for i in globals() if i.startswith('f3_')]

if __name__ == '__main__':
    pass
    # import datetime
    # from firm_f3 import *
    # from firm_f3.exceltools import *
    # from firm_f3.util.utils import timer
    #
    # import logging
    #
    # logging.root.setLevel(logging.NOTSET)
    # if not logging.root.handlers:
    #     logging.root.addHandler(logging.StreamHandler())
    #
    # Model = get_model()
    #
    # scen = f3_CreateIdentifierListScenario(
    #     'testABC',
    #     [['1y', 'USD-OIS'], ['2y', 'USD-OIS']],
    #     [0.01, 0.02],
    #     ['Relative'],
    # )
    #
    # f3model = f3_ApplyScenarioToModel(Model, scen)

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\exceltools\models.py
----------------------------------------
import datetime
from typing import Any

from pyxll import xl_func  # type: ignore
from f3sdk.f3 import F3Object  # type:ignore
from nimrod import NimrodClient
from firm_domain.util.datehelper import utc2local, bump_workday

from firm_f3.f3client import f3_client_auto_connect
from firm_f3.util.funcutils import inspect_arguments
from firm_f3.core.orm import ModelSnapshot
from firm_f3.core.modelutils import get_model_by_ref, get_risk_model_by_ref, get_model_by_slug, get_slug_from_model
from firm_f3.evaluate import extract_market_data, valuation_date_fast as valuation_date
from firm_f3.reporting import model_apply_bump_scenario

from firm_f3.model import run_model
from firm_f3.risk_model import run_risk_model

nimrod_client = NimrodClient('uat')


@xl_func
@inspect_arguments
def nimrod_market_model(as_of: datetime.date = None, force_weekday: bool = False) -> int:
    if not isinstance(as_of, datetime.date):
        as_of = datetime.datetime.now()
    elif not isinstance(as_of, datetime.datetime):
        as_of = datetime.datetime.combine(as_of, datetime.time(18, 0))
    if force_weekday and as_of.weekday() > 4:
        as_of = bump_workday(as_of, -1)
    res = nimrod_client.get_market_model_set(as_of=as_of.date(), triggered_by=as_of)
    return res.get('default').model_slug


@xl_func
@inspect_arguments
def nimrod_rates_model(as_of: datetime.date = None, force_weekday: bool = False) -> int:
    if not isinstance(as_of, datetime.date):
        as_of = datetime.datetime.now()
    elif not isinstance(as_of, datetime.datetime):
        as_of = datetime.datetime.combine(as_of, datetime.time(18, 0))
    if force_weekday and as_of.weekday() > 4:
        as_of = bump_workday(as_of, -1)
    res = nimrod_client.get_rates_risk_model_set(as_of=as_of.date(), triggered_by=as_of)
    return res.get('default').model_slug


@xl_func
@inspect_arguments
def nimrod_fx_model(as_of: datetime.date = None, force_weekday: bool = False) -> int:
    if not isinstance(as_of, datetime.date):
        as_of = datetime.datetime.now()
    elif not isinstance(as_of, datetime.datetime):
        as_of = datetime.datetime.combine(as_of, datetime.time(18, 0))
    if force_weekday and as_of.weekday() > 4:
        as_of = bump_workday(as_of, -1)
    res = nimrod_client.get_fx_risk_model_set(as_of=as_of.date(), triggered_by=as_of)
    return res.get('default').model_slug


@xl_func
def nimrod_model_snap_time(as_of: datetime.date = None, force_weekday: bool = False) -> datetime.datetime:
    if not isinstance(as_of, datetime.date):
        as_of = datetime.datetime.now()
    elif not isinstance(as_of, datetime.datetime):
        as_of = datetime.datetime.combine(as_of, datetime.time(18, 0))
    if force_weekday and as_of.weekday() > 4:
        as_of = bump_workday(as_of, -1)
    res = nimrod_client.get_market_model_set(as_of=as_of.date(), triggered_by=as_of)
    return res.triggered_at


@xl_func
@inspect_arguments
@f3_client_auto_connect
def firm_model_get(slug: int = 0, as_of: datetime.date = None) -> object:
    if slug == 0:
        return get_model_by_ref(as_of=as_of)
    return get_model_by_slug(slug)


@xl_func
@inspect_arguments
@f3_client_auto_connect
def firm_risk_model_get(slug: int = 0, as_of: datetime.date = None, fx_points_model: bool = False) -> object:
    if slug == 0:
        return get_risk_model_by_ref(as_of=as_of, fx_points_model=fx_points_model)
    return get_model_by_slug(slug)


@xl_func
@inspect_arguments
@f3_client_auto_connect
def firm_model_slug(f3model: object) -> int:
    assert isinstance(f3model, F3Object)
    try:
        return get_slug_from_model(f3model)
    except ValueError:
        return f3model.uid


@xl_func
@inspect_arguments
@f3_client_auto_connect
def firm_model_valuation_date(f3model: Any) -> datetime.date:
    if isinstance(f3model, (int, float)):
        f3model = get_model_by_slug(int(f3model))
    assert isinstance(f3model, F3Object)
    return valuation_date(f3model)


@xl_func
@f3_client_auto_connect
def firm_model_run() -> object:
    return run_model()


@xl_func
@inspect_arguments
@f3_client_auto_connect
def firm_risk_model_run(market_model: object, save_model: bool = True, fx_points_model: bool = False) -> object:
    assert isinstance(market_model, F3Object)
    return run_risk_model(f3model=market_model, save_model=save_model, fx_points_model=fx_points_model)


@xl_func
@f3_client_auto_connect
def firm_model_apply_bump_scenario(f3model: object, bump: float) -> object:
    assert isinstance(f3model, F3Object)
    return model_apply_bump_scenario(bump=bump, f3model=f3model)


@xl_func
@f3_client_auto_connect
def firm_model_data(f3model: object) -> object:
    assert isinstance(f3model, F3Object)
    return extract_market_data(f3model)


@xl_func
@f3_client_auto_connect
def firm_model_get_timestamp_from_model(f3model: object) -> datetime:
    assert isinstance(f3model, F3Object)
    slug = get_slug_from_model(f3model)
    return utc2local(ModelSnapshot.get_one(slug=slug).created_utc)


__all__ = [i for i in globals() if i.startswith('firm_')]

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\exceltools\pnl_explained.py
----------------------------------------
import datetime
from typing import List
import pandas  # type:ignore
from pyxll import xl_func, xl_return  # type: ignore

from cerebro.client.validate import PortfolioSnap, CerebroPortfolio
from firm_f3.f3client import f3_client_auto_connect
from firm_domain import SabrCoefficient
from firm_f3.util.funcutils import inspect_arguments
from firm_f3.datalayer.sophis import SophisPortfolio
from firm_f3.reporting import (
    pnl_explained_report, irs_market_data, basis_market_data,
    ccs_market_data, ir_market_data_change, fxv_sabr_market_data, fx_spot_market_data, fx_fwd_market_data,
    fx_spot_market_data_change, pnl_explained, pnl_explained_enlist
)


@xl_func
@inspect_arguments(exclude=('trades', 'ref_market_data', 'cur_market_data'), inspect_return=False)
@f3_client_auto_connect
def firm_pnl_explained_report(
        trades: object,
        ref_model: object,
        cur_model: object,
        ref_mkt_model: object,
        cur_mkt_model: object,
        ref_market_data: object,
        cur_market_data: object,
        forward_valuation_date: datetime.date,
) -> object:
    return pnl_explained_report(trades, ref_model, cur_model, ref_mkt_model, cur_mkt_model, ref_market_data,
                                cur_market_data, forward_valuation_date)



@xl_func
@f3_client_auto_connect
def firm_irs_market_data(market_data: object, unit: float = 0.01) -> pandas.DataFrame:
    assert isinstance(market_data, list)
    return irs_market_data(market_data, unit)


@xl_func
@f3_client_auto_connect
def firm_basis_market_data(market_data: object, unit: float = 0.0001) -> pandas.DataFrame:
    assert isinstance(market_data, list)
    return basis_market_data(market_data, unit)


@xl_func
@f3_client_auto_connect
def firm_ccs_market_data(market_data: object, unit: float = 0.01) -> pandas.DataFrame:
    assert isinstance(market_data, list)
    return ccs_market_data(market_data, unit)


@xl_func
@f3_client_auto_connect
def firm_ir_market_data_change(
        curr_market_data: object,
        prev_market_data: object,
        unit: float = 1e-4,
) -> pandas.DataFrame:
    assert isinstance(curr_market_data, list)
    assert isinstance(prev_market_data, list)
    return ir_market_data_change(curr_market_data, prev_market_data, unit)


@xl_func
@f3_client_auto_connect
def firm_fxv_sabr_market_data(market_data: object, sabr_coeff: str, unit: float = 0.01) -> pandas.DataFrame:
    assert isinstance(market_data, list)
    assert sabr_coeff.upper() in [i.name for i in list(SabrCoefficient)], f'invalid SABR coefficient `{sabr_coeff}`'
    return fxv_sabr_market_data(market_data, sabr_coeff, unit)


@xl_func
@inspect_arguments(exclude=('market_data',), inspect_return=False)
@f3_client_auto_connect
def firm_fx_spot_market_data(market_data: object, unit: float = 1, index: List[str] = None) -> pandas.DataFrame:
    assert isinstance(market_data, list)
    return fx_spot_market_data(market_data, unit, index)


@xl_func
@inspect_arguments(exclude=('market_data',), inspect_return=False)
@f3_client_auto_connect
def firm_fx_fwd_market_data(market_data: object, unit: float = 1, index: List[str] = None) -> pandas.DataFrame:
    assert isinstance(market_data, list)
    return fx_fwd_market_data(market_data, unit, index)


@xl_func
@f3_client_auto_connect
def firm_fx_spot_market_data_change(
        curr_market_data: object,
        prev_market_data: object,
        unit: float = 1,
) -> pandas.Series:
    assert isinstance(curr_market_data, list)
    assert isinstance(prev_market_data, list)
    return fx_spot_market_data_change(curr_market_data, prev_market_data, unit)


@xl_func
@inspect_arguments(
    exclude=('pnl_report_result', 'risk_report_result', 'gamma_report_result', 'folio', 'ir_step', 'fx_step'),
    inspect_return=False)
@f3_client_auto_connect
def firm_pnl_explained(
        pnl_report_result: object,
        risk_report_result: object,
        unit: float,
        folio: object,
        ir_step: pandas.DataFrame,
        fx_step: pandas.Series,
) -> pandas.Series:
    if isinstance(folio, PortfolioSnap):
        folio = folio.portfolio
    assert isinstance(folio, (SophisPortfolio, CerebroPortfolio))
    return pnl_explained(pnl_report_result, risk_report_result, unit, folio, ir_step, fx_step)


@xl_func
@xl_return('dataframe', index=False, columns=True)
@inspect_arguments(
    exclude=('pnl_report_result', 'risk_report_result', 'gamma_report_result', 'root', 'ir_step', 'fx_step'),
    inspect_return=False)
@f3_client_auto_connect
def firm_pnl_explained_enlist(
        pnl_report_result: object,
        risk_report_result: object,
        unit: float,
        root: object,
        ir_step: pandas.DataFrame,
        fx_step: pandas.Series,
) -> pandas.DataFrame:
    return pnl_explained_enlist(pnl_report_result, risk_report_result, unit, root, ir_step, fx_step)


__all__ = [i for i in globals() if i.startswith('firm_')]

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\exceltools\positions.py
----------------------------------------
import os
import datetime
from typing import Dict, List, Iterable, Iterator, Tuple
import pandas
import pywintypes
from pyxll import xl_func, xl_arg, xl_return, xl_menu, xlcAlert, xl_app
from firm_domain import Trade, trade2position, CashFlow, FXForwardTrade, FutureTrade, BondFutureTrade, Position, \
    StockTrade, Ccy
from firm_domain.util.datehelper import date2datetime as ensure_datetime, bump_workday
from firm_f3.datalayer.sophis import SophisPortfolio, SophisPositionService, SophisValidator
from firm_f3.util.caching import Cacher
from firm_f3.util.funcutils import inspect_arguments
from cerebro import CerebroClient
from cerebro.client.error import RequestException
from cerebro.client.validate import PortfolioSnap
from cerebro.client.portfolio import CerebroPortfolio

from firm_f3.patch.risk_mon import load, RiskMonCalc

cerebro = CerebroClient('uat')


@xl_menu('Login', menu='Cerebro')
def on_login():
    xl = xl_app()

    try:
        username = xl.Range('login_username').Value
    except pywintypes.com_error:
        pass
    else:
        if isinstance(username, str):
            os.environ[cerebro.LOGIN_USERNAME_ENV] = username

    try:
        password = xl.Range('login_password').Value
    except pywintypes.com_error:
        pass
    else:
        if isinstance(password, str):
            os.environ[cerebro.LOGIN_PASSWORD_ENV] = password

    try:
        cerebro.login()
    except Exception as e:
        xlcAlert(str(e))
    else:
        xlcAlert(f'logged in as {cerebro.auth[0]}')


@xl_func
def firm_cerebro_portfolio_refresh(
        pid: int,
        refresh_root: bool = False,
        refresh_trades: bool = False,
        exclude=(),
        reload: bool = False,
) -> object:
    _, _ = exclude, reload  # exclude and reload is irrelevant for Cerebro, they are kept for backward compatibility
    cerebro.lazy_login()

    if refresh_root or refresh_trades:
        res = cerebro.create_position_snap(pid)
        if not res['success']:
            raise RequestException(res['error'], res['detail'])
    return cerebro.get_position_snap(pid)


@xl_func
def firm_cerebro_snap_timestamp(snap):
    if isinstance(snap, PortfolioSnap):
        return snap.modified_at
    return '-'


@xl_func
@xl_arg('exclude', 'int[]')
def firm_sophis_portfolio_refresh(
        pid: int,
        refresh_root: bool = False,
        refresh_trades: bool = False,
        exclude=(),
        reload: bool = False,
) -> object:
    """
    Fetch a portfolio object from Sophis.

    :param pid: int, PID of the root portfolio
    :param refresh_root: bool, if True refresh portfolio structure from Sophis
    :param refresh_trades: bool, if True refresh all trades from Sophis
    :param exclude: list, set of PIDs to exclude from loading trades
    :param reload: bool, if True bypass cache on the server
    :return: SophisPortfolio, object that contains the portfolio structure and trades
    """
    with SophisValidator() as validator:
        with Cacher('sophis.cache') as cacher:
            root = cacher.get(pid)

            if refresh_root or root is None:
                with SophisPositionService() as ps:
                    cacher[pid] = root = ps.get_portfolio_by_id(pid)
                    root.fetch(ps, recursive=True, exclude=set(exclude), validator=validator, reload=reload)
            elif refresh_trades:
                with SophisPositionService() as ps:
                    root.fetch(ps, recursive=True, exclude=set(exclude), validator=validator, reload=reload)
                    cacher[pid] = root

    return root


@xl_func
def firm_sophis_portfolio_enlist(
        root: object,
        indent: str = '    ',
) -> list:
    """
    Enlist the portfolio tree structure.

    :param root: SophisPortfolio, the root portfolio object
    :param indent: str, indent used to indicate the depth in the tree structure
    :return: list of list (2D array in Excel). Column1: portfolio name; Column2: PID
    """
    if isinstance(root, PortfolioSnap):
        root = root.portfolio

    def unpack():
        yield ['Portfolio Tree', 'PIDs', 'Trades', 'Size', 'Long Name']
        if isinstance(root, SophisPortfolio):
            for lv, folio in root.iter():
                name = indent * lv + folio.name
                yield [name, folio.pid, folio.trades, len(folio.trades), folio.long_name]
        elif isinstance(root, CerebroPortfolio):
            for lv, folio in root.iter_children():
                name = indent * lv + folio.name
                if isinstance(folio, CerebroPortfolio):
                    yield [name, folio.pid, folio.domain_trades, len(folio.domain_trades), folio.long_name]
        else:
            raise TypeError(f'expect Union[SophisPortfolio, CerebroPortfolio], got {type(root)} instead')

    return list(unpack())


@xl_func
def firm_sophis_portfolio_select_child_portfolio(
        root: object,
        pid: int,
) -> object:
    """
    Select a child portfolio from the root portfolio

    :param root: SophisPortfolio, the root portfolio object
    :param pid: int, PID of the child portfolio to be selected
    :return: SophisPortfolio, child portfolio object
    """
    assert isinstance(root, (SophisPortfolio, PortfolioSnap, CerebroPortfolio)), \
        f'expect Union[SophisPortfolio, PortfolioSnap, CerebroPortfolio], got {type(root)} instead'
    if isinstance(root, PortfolioSnap):
        root = root.portfolio
    return root.find(pid)


@xl_func
def firm_sophis_portfolio_long_name(
        root: object,
) -> str:
    """
    Get the long name of a portfolio object.

    :param root: SophisPortfolio, a Sophis portfolio object
    :return: str, the long name of the portfolio
    """
    assert isinstance(root, (SophisPortfolio, PortfolioSnap, CerebroPortfolio)), \
        f'expect Union[SophisPortfolio, PortfolioSnap, CerebroPortfolio], got {type(root)} instead'
    if isinstance(root, PortfolioSnap):
        root = root.portfolio
    return root.long_name


@xl_func
@xl_arg('exclude', 'int[]')
def firm_sophis_portfolio_select_trades(
        root: object,
        exclude=(),
        collapse_trades_to_date: datetime.date = None,
) -> dict:
    """
    Select trades in a Sophis portfolio.

    :param root: SophisPortfolio, a Sophis portfolio object
    :param exclude: list, set of PIDs to exclude from selecting trades
    :param collapse_trades_to_date: datetime.date, if not None, used as the reference date for trade collapse
    :return: list, a list of selected Sophis trades
    """
    assert isinstance(root, (SophisPortfolio, PortfolioSnap, CerebroPortfolio)), \
        f'expect Union[SophisPortfolio, PortfolioSnap, CerebroPortfolio], got {type(root)} instead'
    if isinstance(root, PortfolioSnap):
        root = root.portfolio

    if root.pid == 30896 and os.getenv('ASIA_RATES_SPEED_UP'):
        from firm_f3.patch.asia_rates import reduce_folio
        reduce_folio(root)

    if collapse_trades_to_date:
        root = root.collapse_by_portfolio(ref_date=collapse_trades_to_date, inplace=False)

    def unpack():
        if isinstance(root, SophisPortfolio):
            for _, folio in root.iter(exclude=list(set(exclude))):
                for i, trade in enumerate(folio.trades):
                    if abs(trade.notional) > 1e-4 and (not hasattr(trade, 'rate') or abs(trade.rate) > 1e-10):
                        uid = f'{folio.pid}|{i}'
                        yield uid, trade
        elif isinstance(root, CerebroPortfolio):
            for _, folio in root.iter_children(exclude=list(set(exclude))):
                if isinstance(folio, CerebroPortfolio):
                    for i, trade in enumerate(folio.domain_trades):
                        if abs(trade.notional) > 1e-4:  # jchi@202012 remove legacy filter for abs(trade.rate) > 1e-10
                            uid = f'{folio.pid}|{i}'
                            yield uid, trade

    return dict(unpack())


@xl_func
def firm_exclude_bond_future_trades(trades: object) -> dict:
    assert isinstance(trades, dict)
    return {k: v for k, v in trades.items() if not isinstance(v, BondFutureTrade)}


TRADE_ENLIST_MAP = {
    'pid': 'PortfolioID',
    'iid': 'InstrumentID',
    'tid': 'TradeID',
    'trade_type': 'TradeType',
    'trade_date': 'TradeDate',
    'ccy': 'Currency',
    'ccy_base': 'CurrencyBase',
    'notional': 'Notional',
    'rate': 'QuotedRate',
    'start': 'StartDate',
    'maturity': 'MaturityDate',
    'expiry': 'ExpiryDate',
    'strike': 'Strike',
    'option_type': 'OptionType',
    'fx_rate': 'FxRate',
    'is_mtm': 'IsMarkToMarket',
    'swaption_type': 'SwaptionType',
    'idx': 'Index',
    'idx_1': 'Index1',
    'idx_2': 'Index2',
    'spread_tenor': 'SpreadTenor',
    'value_date': 'ValueDate',
    'fixing_date': 'FixingDate',
    'ticker': 'Ticker',
    'price': 'TradedPrice',
    'cp_name': 'CounterParty',
    'cash_settle': 'IsCashSettled',
}
TRADE_ENLIST_FORMAT = pandas.DataFrame([], columns=list(TRADE_ENLIST_MAP))

ADDITIONAL_KEY_MAP = {
    'swaption_type': 'option_type'
}


def helper_map_dict_keys(dct: Dict) -> Dict:
    def unpack():
        for k, v in dct.items():
            yield k, v
        for old_key, new_key in ADDITIONAL_KEY_MAP.items():
            if old_key in dct:
                yield new_key, dct[old_key]

    return dict(unpack())


def filter_dataframe(
        df: pandas.DataFrame,
        include: List[str] = None,
        exclude: List[str] = None,
) -> pandas.DataFrame:
    if isinstance(include, str):
        include = include.split(';')
    if isinstance(exclude, str):
        exclude = exclude.split(';')

    def parse_conditions(conditions: List[str]) -> str:
        def unpack_and(cond: str) -> str:
            for c in cond.split(','):
                for op in ('>=', '<=', '>', '<', '!=', '=='):
                    if op in c:
                        key, _, val = c.partition(op)
                        key, val = key.strip(), val.strip()
                        try:
                            val = float(val)
                        except ValueError:
                            val = f'"{val}"'
                        yield f'(df["{key}"]{op}{val})'
                        break

        def unpack_or() -> str:
            for c in conditions:
                for cond in c.split(';'):
                    yield f"({' & '.join(unpack_and(cond))})"

        return ' | '.join(unpack_or())

    if include and exclude:
        inc_src = parse_conditions(include)
        exc_src = parse_conditions(exclude)
        src = f'({inc_src}) & (({exc_src}) == False)'
    elif include:
        src = parse_conditions(include)
    elif exclude:
        src = parse_conditions(exclude)
        src = f'({src}) == False'
    else:
        return df

    mask = eval(src)
    return df.loc[mask]


@xl_func
@xl_return('dataframe', index=True, columns=True)
@inspect_arguments(exclude=('trades',), inspect_return=False)
def firm_sophis_trades_enlist(
        trades: Dict[str, Trade],
        consolidate: bool = False,
        sort_by: List[str] = None,
        include: List[str] = None,
        exclude: List[str] = None,
        collapse_to_datetime: datetime.datetime = None,
) -> pandas.DataFrame:
    """
    Convert dict of trades into dataframe

    :param trades: dict, str to trade object mapping
    :param consolidate: bool, if True consolidate trades into positions
    :param sort_by: list of column names for sorting
    :param include: list of conditions to include entries
    :param exclude: list of conditions to exclude entries
    :return: pandas.DataFrame, a dataframe object that contains trade details
    """
    if consolidate:
        if collapse_to_datetime is None:
            collapse_to_datetime = datetime.datetime.now()
        collapse_to_datetime: datetime.datetime = ensure_datetime(collapse_to_datetime)

        # collapse past trades upon T-1 (we want to see T0 trades, i.e. trades executed on collapse date)
        cutoff_datetime: datetime.datetime = bump_workday(collapse_to_datetime, -1)
        cutoff_date: datetime.date = cutoff_datetime.date()

        # convert FX trades into cash flows
        trades = {i: v for i, v in
                  enumerate(convert_trades_to_cashflow(trades.values(), ref_datetime=collapse_to_datetime))}

        raw: Dict[str, Position] = {}
        last_trade_date: Dict[str, datetime.datetime] = {}
        for i in trades.values():
            trade_date: datetime.date = i.trade_date.date()
            if i.trade_date < cutoff_datetime:
                # trades before cut-off time
                ref_date = cutoff_date
            elif trade_date == cutoff_date:
                # trades after cut-off time but on the same cut-off date
                ref_date = collapse_to_datetime.date()
            else:
                # trades after cut-off date
                ref_date = trade_date
            key = f'{i.pid}|{i.iid}|{ref_date}'
            if isinstance(i, CashFlow):
                key += f'|{i.ccy}@{i.maturity.isoformat()}'
            elif isinstance(i, FXForwardTrade):
                if i.fixing_date is None:
                    key += f'|{i.ccy}@{i.value_date.isoformat()}'
                else:
                    key += f'|{i.ccy}@{i.fixing_date.isoformat()}-{i.value_date.isoformat()}'
            elif isinstance(i, FutureTrade):
                key += f'@{ref_date.isoformat()}'
            if isinstance(i, (FXForwardTrade, FutureTrade, StockTrade)):
                key += '|+' if i.notional >= 0 else '|-'
            pos = trade2position(i)
            try:
                p = raw[key]
            except KeyError:
                raw[key] = pos
                last_trade_date[key] = i.trade_date
                continue
            p += pos
            last_trade_date[key] = max(i.trade_date, last_trade_date[key])
        raw = {k: v for k, v in raw.items() if abs(v.notional) > 1e-6}
        df = pandas.DataFrame(
            {k: dict(trade_date=last_trade_date[k], **helper_map_dict_keys(v.to_dict())) for k, v in raw.items()}).T
    else:
        df = pandas.DataFrame({k: helper_map_dict_keys(v.to_dict()) for k, v in trades.items()}).T

    df, _ = df.align(TRADE_ENLIST_FORMAT, join='right', axis=1)
    df.columns = list(TRADE_ENLIST_MAP.values())
    df = filter_dataframe(df, include=include, exclude=exclude)

    if sort_by is None:
        sort_by = ['TradeDate', 'TradeID']
    return df.sort_values(sort_by, ascending=False)


def convert_trades_to_cashflow(itr: Iterable[Trade], ref_datetime: datetime.datetime = None) -> Iterator[Trade]:
    if ref_datetime is None:
        ref_datetime = ensure_datetime(datetime.date.today())
    ref_date = ref_datetime.date()
    ref_trade_datetime = bump_workday(ref_datetime, -1)  # collapse trades before T-1

    # jchi@202012 collapse expired futures
    expired_futures: Dict[Tuple[int, int, Ccy], float] = {}

    for trade in itr:
        if trade.trade_date < ref_trade_datetime:
            # jchi@202006 only collapse past trades
            if isinstance(trade, FXForwardTrade):
                maturity = max(ref_date, trade.value_date)
                cf1 = CashFlow(ref_trade_datetime, trade.ccy_base, maturity=maturity, notional=trade.notional)
                cf2 = CashFlow(ref_trade_datetime, trade.ccy, maturity=maturity, notional=-trade.notional * trade.rate)
                for cf in (cf1, cf2):
                    cf.pid, cf.tid, cf.iid = trade.pid, trade.tid, 0
                    yield cf
                continue
            elif isinstance(trade, CashFlow) and trade.maturity <= ref_date:
                cf = CashFlow(ref_trade_datetime, trade.ccy, maturity=ref_date, notional=trade.notional)
                cf.pid, cf.tid, cf.iid = trade.pid, trade.tid, 0
                yield cf
                continue
            elif isinstance(trade, FutureTrade) and trade.expiry <= ref_date:
                try:
                    expired_futures[trade.pid, trade.iid, trade.ccy] += trade.price * trade.notional
                except KeyError:
                    expired_futures[trade.pid, trade.iid, trade.ccy] = trade.price * trade.notional
                continue
        yield trade

    for (pid, iid, ccy), notional in expired_futures.items():
        cf = CashFlow(ref_trade_datetime, ccy, maturity=ref_date, notional=-notional)
        cf.pid, cf.tid, cf.iid = pid, 0, iid
        yield cf


@xl_func
def firm_load_cache_result() -> RiskMonCalc:
    return load()


__all__ = [i for i in globals() if i.startswith('firm_')]

if __name__ == '__main__':
    pass
    # pid = 30896  # rtau
    # root = firm_sophis_portfolio_refresh(pid, False, False)

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\exceltools\pricer.py
----------------------------------------
from typing import Dict, List
from pyxll import xl_func  # type: ignore
from f3sdk.f3 import F3Object  # type: ignore

from firm_f3.util.funcutils import inspect_arguments
from firm_f3.f3client import f3_client_auto_connect
from firm_f3.reporting import risk_pv, risk_par_rate, risk_delta, risk_dv01_delta, risk_gamma, risk_dv01_gamma, risk_iv


@xl_func
@inspect_arguments
@f3_client_auto_connect
def firm_pv(
        trades: List[object],
        f3model: List[object]
) -> List[Dict[str, float]]:
    assert isinstance(trades, list) and trades
    assert isinstance(f3model, list) and f3model
    return risk_pv(trades, f3model)


@xl_func
@inspect_arguments
@f3_client_auto_connect
def firm_par_rate(trades: object, f3model: object) -> Dict[str, float]:
    assert isinstance(trades, (list, dict)), 'trades argument is not Union[list, dict]'
    assert isinstance(f3model, F3Object), 'f3model argument is not an F3Object'
    return risk_par_rate(trades, f3model)


@xl_func
@inspect_arguments
@f3_client_auto_connect
def firm_delta(trades: object, f3model: object) -> Dict[str, float]:
    assert isinstance(trades, (list, dict)), 'trades argument is not Union[list, dict]'
    assert isinstance(f3model, F3Object), 'f3model argument is not an F3Object'
    return risk_delta(trades, f3model)


@xl_func
@inspect_arguments
@f3_client_auto_connect
def firm_dv01_delta(trades: object, f3model: object) -> Dict[str, float]:
    assert isinstance(trades, (list, dict)), 'trades argument is not Union[list, dict]'
    assert isinstance(f3model, F3Object), 'f3model argument is not an F3Object'
    return risk_dv01_delta(trades, f3model)


@xl_func
@inspect_arguments
@f3_client_auto_connect
def firm_gamma(trades: object, f3model: object) -> Dict[str, float]:
    assert isinstance(trades, (list, dict)), 'trades argument is not Union[list, dict]'
    assert isinstance(f3model, F3Object), 'f3model argument is not an F3Object'
    return risk_gamma(trades, f3model)


@xl_func
@inspect_arguments
@f3_client_auto_connect
def firm_dv01_gamma(trades: object, f3model: object) -> Dict[str, float]:
    assert isinstance(trades, (list, dict)), 'trades argument is not Union[list, dict]'
    assert isinstance(f3model, F3Object), 'f3model argument is not an F3Object'
    return risk_dv01_gamma(trades, f3model)


@xl_func
@inspect_arguments
@f3_client_auto_connect
def firm_iv(trades: object, f3model: object) -> Dict[str, float]:
    assert isinstance(trades, (list, dict)), 'trades argument is not Union[list, dict]'
    assert isinstance(f3model, F3Object), 'f3model argument is not an F3Object'
    return risk_iv(trades, f3model)


__all__ = [i for i in globals() if i.startswith('firm_')]

if __name__ == '__main__':
    pass
    # import datetime
    # from firm_f3.evaluate import *
    # from firm_f3.exceltools import *
    #
    # # f3model = firm_model_get()
    # f3model = firm_risk_model_get()
    # irs1 = firm_irs(datetime.date(2019, 9, 10), 'USD', datetime.date(2019, 9, 12), datetime.date(2021, 9, 11), 100,
    #                 0.02, '3M')
    # irs2 = firm_irs(datetime.date(2019, 9, 10), 'EUR', datetime.date(2022, 9, 12), datetime.date(2027, 9, 11), 100,
    #                 -0.00165, '6M')
    # swaption1 = firm_swaption(datetime.date(2019, 9, 15), 'EUR', datetime.date(2022, 9, 19), 'Receiver',
    #                           datetime.date(2022, 9, 21), datetime.date(2027, 9, 21), '6M', -0.00165, 100)
    # trades = {'irs1': irs1, 'irs2': irs2, 'swaption1': swaption1}
    #
    # firm_pv(trades, f3model)
    # firm_iv(trades, f3model)
    # firm_dv01_delta(trades, f3model)

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\exceltools\py_utils.py
----------------------------------------
from typing import List, Any

import pandas
from pyxll import xl_func, xl_arg, xl_return  # type: ignore
from firm_f3.util.utils import flatten
from firm_f3.util.funcutils import inspect_arguments

PROD_MODE = True


@xl_func
@inspect_arguments(prod=PROD_MODE)
def py_size(x) -> int:
    """
    Return size of a python object.

    :param x: object, python Iterable
    :return: int, the size (len) of the object
    """
    return len(x)


@xl_func
@inspect_arguments(prod=PROD_MODE)
def py_stringify(x) -> str:
    """
    Return a string representation of an object.

    :param x: var, any object type
    :return: str, a string representation
    """
    return str(x)


@xl_func
@inspect_arguments(prod=PROD_MODE)
def py_dict(keys: List[Any] = None, values: List[Any] = None) -> object:
    """
    Construct a python dict.

    :param keys: list, keys to be used to construct the dict
    :param values: list, values to be used to construct the dict
    :return: dict, a key-value mapping
    """
    if keys and values:
        return dict(zip(keys, values))
    return dict()


@xl_func
@xl_return('var[]')
@inspect_arguments(prod=PROD_MODE)
def py_dict_keys(dct: object) -> List[Any]:
    if isinstance(dct, dict):
        return list(dct.keys())
    raise TypeError(f'expect a dict type but got a {type(dct)} instead')


@xl_func
@xl_return('var[]')
@inspect_arguments(prod=PROD_MODE)
def py_dict_values(dct: object) -> List[Any]:
    if isinstance(dct, dict):
        return list(dct.values())
    raise TypeError(f'expect a dict type but got a {type(dct)} instead')


@xl_func
@inspect_arguments(prod=PROD_MODE)
def py_dict_getitem(dct: object, key: str) -> object:
    if isinstance(dct, dict):
        return dct[key]
    raise TypeError(f'expect a dict type but got a {type(dct)} instead')


@xl_func
@inspect_arguments(prod=PROD_MODE)
def py_dict_getvalue(dct: object, key: str) -> Any:
    if isinstance(dct, dict):
        return dct[key]
    raise TypeError(f'expect a dict type but got a {type(dct)} instead')


@xl_func
def py_dict_lookup(d, k):
    return d[k]


@xl_func
@inspect_arguments(prod=PROD_MODE)
def py_flatten(x, recursive: bool = False) -> object:
    """
    Flatten a nested python object.

    :param x: Iterable, if x is a dict object, flatten through its values
    :param recursive: bool, if True flatten object recursively, else flatten by 1 level down
    :return: list, a flattened list of elements
    """
    if recursive:
        return list(flatten(x, level=-1))
    return list(flatten(x, level=1))


@xl_func
@inspect_arguments(prod=PROD_MODE)
def py_details(x) -> str:
    """
    Return detail information about an object. If info is not defined, return a string representation.

    :param x: var, any object type
    :return: str, info/string representation
    """
    if hasattr(x, 'name'):
        return x.name
    elif hasattr(x, 'uid'):
        return x.uid
    return repr(x)


@xl_func
@xl_arg('mask', 'bool[]')
@inspect_arguments(prod=PROD_MODE)
def py_concat(array, mask: List[bool] = None) -> object:
    """
    Return concatenated list of python lists.

    :param array: object, python Iterable
    :param mask: [optional] list of bool that is used to filter the array elements
    :return: list, a concatenated list of items
    """
    if mask:
        array = [i for i, j in zip(array, mask) if j]
    return list(filter(None, py_flatten(array)))


@xl_func
@inspect_arguments(prod=PROD_MODE)
def py_list_concat(lst1: list, lst2: list) -> list:
    assert isinstance(lst1, list)
    assert isinstance(lst2, list)
    return lst1 + lst2


@xl_func(auto_resize=True)
@inspect_arguments(prod=PROD_MODE)
def py_enlist(array) -> list:
    """
    Enlist elements in a python list.

    :param array: list or a python Iterable
    :return: an Excel Range with string representation of the elements
    """
    return [py_stringify(i) for i in py_concat(array)]


@xl_func
@inspect_arguments(prod=PROD_MODE)
def py_dataframe(
        data: List[List[Any]],
        index: List[Any] = None,
        columns: List[Any] = None
) -> pandas.DataFrame:
    return pandas.DataFrame(data, index=index, columns=columns)


@xl_func
@inspect_arguments(prod=PROD_MODE)
def py_dataframe_getitem(df: pandas.DataFrame, keys: List[str]) -> pandas.DataFrame:
    if isinstance(df, pandas.DataFrame):
        return df[keys]
    raise TypeError(f'expect a pandas.DataFrame type but got a {type(df)} instead')


@xl_func
@inspect_arguments(prod=PROD_MODE)
def py_dataframe_drop_duplicates(
        df: pandas.DataFrame,
        subset: List[str] = None,
        keep: str = 'first',
) -> pandas.DataFrame:
    if keep.lower() == 'false':
        keep = False
    return df.drop_duplicates(subset=subset, keep=keep)


@xl_func
@xl_return('dataframe', index=True, columns=True)
@inspect_arguments(prod=PROD_MODE)
def py_dataframe_to_excel(df: pandas.DataFrame) -> pandas.DataFrame:
    return df


@xl_func
@inspect_arguments(prod=PROD_MODE)
def py_dataframe_from_excel(data: List[List[Any]], index: Any = True, columns: Any = True) -> pandas.DataFrame:
    _col = None
    if columns is True:
        _col = data.pop(0)
        if index is True:
            assert len(_col) > 1
            _col = _col[1:]
    elif isinstance(columns, list):
        _col = list(flatten(columns))

    if index is True:
        _idx, _data = list(zip(*((i, v) for i, *v in data)))
        return pandas.DataFrame(list(_data), index=list(_idx), columns=_col)
    elif isinstance(index, list):
        _idx = list(flatten(index))
        return pandas.DataFrame(data, index=_idx, columns=_col)
    return pandas.DataFrame(data, columns=_col)


@xl_func
@inspect_arguments(prod=PROD_MODE)
def py_dataframe_add(
        df1: pandas.DataFrame,
        df2: pandas.DataFrame,
        axis: int = 0,
        fill_value: float = None,
) -> pandas.DataFrame:
    return df1.add(df2, axis=axis, fill_value=fill_value)


@xl_func
@inspect_arguments(prod=PROD_MODE)
def py_dataframe_sub(
        df1: pandas.DataFrame,
        df2: pandas.DataFrame,
        axis: int = 0,
        fill_value: float = None,
) -> pandas.DataFrame:
    return df1.sub(df2, axis=axis, fill_value=fill_value)


@xl_func
@inspect_arguments(prod=PROD_MODE)
def py_dataframe_mul(
        df1: pandas.DataFrame,
        df2: pandas.DataFrame,
        axis: int = 0,
        fill_value: float = None,
) -> pandas.DataFrame:
    return df1.mul(df2, axis=axis, fill_value=fill_value)


@xl_func
@inspect_arguments(prod=PROD_MODE)
def py_dataframe_div(
        df1: pandas.DataFrame,
        df2: pandas.DataFrame,
        axis: int = 0,
        fill_value: float = None,
) -> pandas.DataFrame:
    return df1.div(df2, axis=axis, fill_value=fill_value)


__all__ = [i for i in globals() if i.startswith('py_')]

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\exceltools\risk_report.py
----------------------------------------
from typing import Union, Dict, List, Any

import pandas  # type:ignore
from pyxll import xl_func  # type: ignore

from firm_f3.reporting import GammaReportResult, ScenarioResult, calc_risk_report, gamma_risk_report, \
    fx_gamma_risk_report, scenario_risk_report, ir_scenario, ir_gamma, irs_risk, basis_risk, ccs_risk, inflation_risk, \
    flat_dv01_risk, flat_irv_vega, fx_risk, flat_fx_risk, fxv_risk, flat_fxv_risk, fx_fwd_risk, irv_vega
from firm_f3.util.funcutils import inspect_arguments
from firm_domain import SabrCoefficient
from firm_f3.f3client import f3_client_auto_connect


@xl_func
@inspect_arguments(exclude=('trades',), inspect_return=False)
@f3_client_auto_connect
def firm_risk_report(
        trades: List[object],
        risk_model: List[object],
) -> List[object]:
    assert isinstance(trades, list) and trades
    assert isinstance(risk_model, list) and risk_model
    return calc_risk_report(trades, risk_model)


@xl_func
@f3_client_auto_connect
def firm_gamma_risk_report(
        trades: object,
        risk_model: object,
        bump: float = 0.0001,
) -> object:
    assert bump > 0
    return gamma_risk_report(trades, risk_model, bump)


@xl_func
@f3_client_auto_connect
def firm_fx_gamma_risk_report(
        trades: object,
        risk_model: object,
        baseline_market_data: object,
        bump: float = 0.0025,
) -> object:
    assert bump > 0
    return fx_gamma_risk_report(trades, risk_model, baseline_market_data, bump)


@xl_func
@f3_client_auto_connect
def firm_scenario_risk_report(
        trades: object,
        risk_model: object,
) -> object:
    return scenario_risk_report(trades, risk_model)


@xl_func
@inspect_arguments(exclude=('scenario_result', 'folio'), inspect_return=False)
@f3_client_auto_connect
def firm_ir_scenario(
        scenario_result: object,
        scenario: str,
        unit: float = 1000,
        folio: Any = None
) -> pandas.DataFrame:
    assert isinstance(scenario_result, ScenarioResult)
    return ir_scenario(scenario_result, scenario, unit, folio)


@xl_func
@inspect_arguments(exclude=('risk_report_result', 'folio'), inspect_return=False)
@f3_client_auto_connect
def firm_ir_gamma(
        risk_report_result: object,
        unit: float = 1000,
        folio: Any = None,
        pids: str = None,
) -> pandas.DataFrame:
    assert isinstance(risk_report_result, GammaReportResult)
    return ir_gamma(risk_report_result, unit, folio, pids)


@xl_func
@inspect_arguments(exclude=('risk_report_result', 'folio'), inspect_return=False)
def firm_irs_risk(
        risk_report_result: Union[Dict, List],
        unit: float = 1000,
        folio: Any = None,
        pids: str = None,
) -> pandas.DataFrame:
    return irs_risk(risk_report_result, unit, folio, pids)


@xl_func
@inspect_arguments(exclude=('risk_report_result', 'folio'), inspect_return=False)
@f3_client_auto_connect
def firm_basis_risk(
        risk_report_result: Union[Dict, List],
        unit: float = 1000,
        folio: Any = None,
        pids: str = None,
) -> pandas.DataFrame:
    return basis_risk(risk_report_result, unit, folio, pids)


@xl_func
@inspect_arguments(exclude=('risk_report_result', 'folio'), inspect_return=False)
@f3_client_auto_connect
def firm_ccs_risk(
        risk_report_result: Union[Dict, List],
        unit: float = 1000,
        folio: Any = None,
        pids: str = None,
) -> pandas.DataFrame:
    return ccs_risk(risk_report_result, unit, folio, pids)


@xl_func
@inspect_arguments(exclude=('risk_report_result', 'folio'), inspect_return=False)
@f3_client_auto_connect
def firm_inflation_risk(
        risk_report_result: Union[Dict, List],
        unit: float = 1000,
        folio: Any = None,
        pids: str = None,
) -> pandas.DataFrame:
    return inflation_risk(risk_report_result, unit, folio, pids)


@xl_func
@inspect_arguments(exclude=('risk_report_result', 'folio'))
@f3_client_auto_connect
def firm_flat_dv01_risk(
        risk_report_result: Union[Dict, List],
        unit: float = 1000,
        folio: Any = None
) -> float:
    return flat_dv01_risk(risk_report_result, unit, folio)


@xl_func
@inspect_arguments(exclude=('risk_report_result', 'folio'), inspect_return=False)
@f3_client_auto_connect
def firm_irv_vega(
        risk_report_result: Union[Dict, List],
        ccy: str = None,
        unit: float = 1000,
        folio: Any = None,
        pids: str = None,
) -> pandas.DataFrame:
    return irv_vega(risk_report_result, ccy, unit, folio, pids)


@xl_func
@inspect_arguments(exclude=('risk_report_result', 'folio'))
@f3_client_auto_connect
def firm_flat_irv_vega(
        risk_report_result: Union[Dict, List],
        unit: float = 1000,
        folio: Any = None
) -> float:
    return flat_irv_vega(risk_report_result, unit, folio)


@xl_func
@inspect_arguments(exclude=('risk_report_result', 'gamma_report_result', 'folio'), inspect_return=False)
@f3_client_auto_connect
def firm_fx_risk(
        risk_report_result: Union[Dict, List],
        gamma_report_result: Any,
        unit: float = 1_000_000,
        folio: Any = None,
        pids: str = None,
) -> pandas.DataFrame:
    return fx_risk(risk_report_result, gamma_report_result, unit, folio, pids)


@xl_func
@inspect_arguments(exclude=('risk_report_result', 'folio'))
@f3_client_auto_connect
def firm_flat_fx_risk(
        risk_report_result: Union[Dict, List],
        unit: float = 1_000_000,
        folio: Any = None
) -> float:
    return flat_fx_risk(risk_report_result, unit, folio)


@xl_func
@inspect_arguments(exclude=('risk_report_result', 'folio'), inspect_return=False)
@f3_client_auto_connect
def firm_fx_fwd_risk(
        risk_report_result: Union[Dict, List],
        unit: float = 1_000_000,
        folio: Any = None,
        pids: str = None,
) -> pandas.DataFrame:
    return fx_fwd_risk(risk_report_result, unit, folio, pids)


@xl_func
@inspect_arguments(exclude=('risk_report_result', 'folio'), inspect_return=False)
@f3_client_auto_connect
def firm_fxv_risk(
        risk_report_result: Union[Dict, List],
        unit: float = 1_000,
        folio: Any = None,
        sabr_coeff: str = 'Alpha',
        pids: str = None,
) -> pandas.DataFrame:
    assert sabr_coeff.upper() in [i.name for i in list(SabrCoefficient)], f'invalid SABR coefficient `{sabr_coeff}`'
    return fxv_risk(risk_report_result, unit, folio, sabr_coeff, pids)


@xl_func
@inspect_arguments(exclude=('risk_report_result', 'folio'))
@f3_client_auto_connect
def firm_flat_fxv_risk(
        risk_report_result: Union[Dict, List],
        unit: float = 1_000,
        folio: Any = None
) -> float:
    return flat_fxv_risk(risk_report_result, unit, folio)


__all__ = [i for i in globals() if i.startswith('firm_')]

if __name__ == '__main__':
    pass
    # import datetime
    # from firm_domain import *
    # from ExcelTools import *
    #
    # f3model = firm_model_get()
    # f3risk = firm_risk_model_get()
    #
    # swaption1 = SwaptionTrade(datetime.datetime(2019, 9, 12), Ccy.EUR, datetime.datetime(2022, 9, 12),
    #                           datetime.datetime(2022, 9, 13), datetime.datetime(2027, 9, 12), -0.0022,
    #                           SwaptionType.RECEIVER, -100 * 1e6)
    # swaption2 = SwaptionTrade(datetime.datetime(2019, 9, 12), Ccy.EUR, datetime.datetime(2022, 9, 12),
    #                           datetime.datetime(2022, 9, 13), datetime.datetime(2027, 9, 12), -0.0022,
    #                           SwaptionType.PAYER, -100 * 1e6)
    #
    # firm_pv([swaption1, swaption2], f3model)

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\exceltools\timeseries.py
----------------------------------------
import pandas  # type: ignore
from pyxll import xl_func, xl_arg, xl_return  # type: ignore


@xl_func
@xl_arg('df', 'dataframe<index=0, columns=0, dtype=float>')
@xl_return('dataframe', index=False, columns=False)
def firm_diff(df: pandas.DataFrame) -> pandas.DataFrame:
    return df.diff()


@xl_func
@xl_arg('df', 'dataframe<index=0, columns=0, dtype=float>')
@xl_return('dataframe', index=False, columns=False)
def firm_pct_change(df: pandas.DataFrame) -> pandas.DataFrame:
    return df.pct_change()


@xl_func
@xl_arg('df', 'dataframe<index=0, columns=0, dtype=float>')
@xl_return('dataframe', index=False, columns=False)
def firm_cov(df: pandas.DataFrame) -> pandas.DataFrame:
    return df.cov()


@xl_func
@xl_arg('df', 'dataframe<index=0, columns=0, dtype=float>')
@xl_return('dataframe', index=False, columns=False)
def firm_corr(df: pandas.DataFrame) -> pandas.DataFrame:
    return df.corr()


@xl_func
@xl_arg('df', 'dataframe<index=0, columns=0, dtype=float>')
@xl_return('dataframe', index=False, columns=False)
def firm_ffill(df: pandas.DataFrame) -> pandas.DataFrame:
    return df.ffill()


@xl_func
@xl_arg('df', 'dataframe<index=0, columns=0, dtype=float>')
@xl_return('dataframe', index=False, columns=False)
def firm_fillna(df: pandas.DataFrame, value: float) -> pandas.DataFrame:
    return df.fillna(value)


@xl_func
@xl_arg('df', 'dataframe<index=0, columns=0, dtype=float>')
@xl_return('dataframe', index=False, columns=False)
def firm_svd(df: pandas.DataFrame) -> pandas.DataFrame:
    vec, eig, _ = pandas.np.linalg.svd(df)
    return vec * eig


@xl_func
@xl_arg('vec', 'float[]')
def firm_modulo(vec) -> float:
    return sum(i ** 2 for i in vec) ** 0.5


@xl_func
@xl_arg('df', 'dataframe<index=0, columns=0, dtype=float>')
@xl_return('dataframe', index=True, columns=False)
def firm_pca(
        df: pandas.DataFrame,
        differentiator: str = '',
        demean: bool = True,
        transpose: bool = True,
) -> pandas.DataFrame:
    if differentiator in ('d', 'diff'):
        df = firm_diff(df)
    elif differentiator in ('p', 'pct', 'pct_change'):
        df = firm_pct_change(df)
    if demean:
        df = df.sub(df.mean())

    corr = firm_corr(df)
    eig_vec = firm_svd(corr)
    rv = pandas.DataFrame(eig_vec, columns=[f'pc{i}' for i in range(len(eig_vec))])

    if transpose:
        rv = rv.T
    return rv


__all__ = [i for i in globals() if i.startswith('firm_')]

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\exceltools\trades.py
----------------------------------------
import datetime
from typing import List
from pyxll import xl_func, xl_arg  # type: ignore
from firm_domain.util.datehelper import date2datetime
from firm_domain import (
    Ccy, Tenor, OptionType, SwaptionType, FXForwardTrade, IRSTrade, OISTrade, TenorBasisTrade, CrossCurrencySwapTrade,
    SwaptionTrade, XccyBasisTrade, FXOptionTrade, Trade, CashFlow
)
from firm_f3.util.funcutils import inspect_arguments


# Can add more irs conventions here
# [fixed rate convention, floating rate index, floating rate convention, maturity convention]
IRS_MARKET_CONVENTIONS = {
    'EUR': ['SwapEURAnnual30360', 'Euribor6m', 'SwapEUR6m'],
    'USD': ['SwapUSDSemiAB', 'LiborUSD3m', 'SwapUSD3mFloating'],
    'KRW': ['SwapKRWQuarterly', 'KRWCD3m', 'SwapKRW3m'],
    'AUD3m': ['SwapBBSWQuarterlyFixed', 'BBSW3m', 'SwapBBSW3m'],
    'AUD6m': ['SwapBBSWSemiFixed', 'BBSW6m', 'SwapBBSW6mFloating']
}


@xl_func
def firm_get_irs_market_conventions(ccy: str):
    return IRS_MARKET_CONVENTIONS[ccy]


@xl_func
@xl_arg('trades', 'var[]')
@inspect_arguments
def firm_name_trades(names: List[str], trades: list) -> dict:
    return {k: v for k, v in zip(names, trades) if k and isinstance(v, Trade)}


@xl_func
@inspect_arguments
def firm_fx_forward(
        tradeDate: datetime.date,
        curncy: str,
        curncyBase: str,
        paymentDate: datetime.date,
        notional: float,
        fxRate: float,
        fixingDate: datetime.date
) -> object:
    trade_date = date2datetime(tradeDate)
    value_date = date2datetime(paymentDate)
    if fixingDate == datetime.date(1899, 12, 31):
        # default date of an empty cell
        fixing_date = None
    else:
        fixing_date = date2datetime(fixingDate)
    ccy = Ccy[curncy]
    ccy_base = Ccy[curncyBase]

    return FXForwardTrade(
        trade_date=trade_date,
        ccy=ccy,
        value_date=value_date,
        rate=fxRate,
        notional=notional,
        ccy_base=ccy_base,
        fixing_date=fixing_date,
    )


@xl_func
@inspect_arguments
def firm_irs(
        tradeDate: datetime.date,
        curncy: str,
        startDate: datetime.date,
        maturityDate: datetime.date,
        notional: float,
        rate: float,
        index: str
) -> object:
    trade_date = date2datetime(tradeDate)
    start_date = date2datetime(startDate)
    maturity = date2datetime(maturityDate)
    ccy = Ccy[curncy]
    idx = Tenor[f'T_{index.upper()}']

    return IRSTrade(
        trade_date=trade_date,
        ccy=ccy,
        start=start_date,
        maturity=maturity,
        rate=rate,
        notional=notional,
        idx=idx,
    )


@xl_func
@inspect_arguments
def firm_ois(
        tradeDate: datetime.date,
        curncy: str,
        startDate: datetime.date,
        maturityDate: datetime.date,
        notional: float,
        rate: float
) -> object:
    trade_date = date2datetime(tradeDate)
    start_date = date2datetime(startDate)
    maturity = date2datetime(maturityDate)
    ccy = Ccy[curncy]

    return OISTrade(
        trade_date=trade_date,
        ccy=ccy,
        start=start_date,
        maturity=maturity,
        rate=rate,
        notional=notional,
    )


@xl_func
@inspect_arguments
def firm_tenor_basis(
        tradeDate: datetime.date,
        curncy: str,
        startDate: datetime.date,
        maturityDate: datetime.date,
        notional: float,
        rate: float,
        index1: str,
        index2: str
) -> object:
    trade_date = date2datetime(tradeDate)
    start_date = date2datetime(startDate)
    maturity = date2datetime(maturityDate)
    ccy = Ccy[curncy]
    idx_1 = Tenor[f'T_{index1.upper()}']
    idx_2 = Tenor[f'T_{index2.upper()}']

    return TenorBasisTrade(
        trade_date=trade_date,
        ccy=ccy,
        start=start_date,
        maturity=maturity,
        rate=rate,
        notional=notional,
        idx_1=idx_1,
        idx_2=idx_2,
    )


@xl_func
@inspect_arguments
def firm_ccs(
        tradeDate: datetime.date,
        curncy: str,
        curncyBase: str,
        startDate: datetime.date,
        maturityDate: datetime.date,
        notional: float,
        rate: float,
        fxRate: float,
        index: str,
) -> object:
    trade_date = date2datetime(tradeDate)
    start_date = date2datetime(startDate)
    maturity = date2datetime(maturityDate)
    ccy = Ccy[curncy]
    ccy_base = Ccy[curncyBase]
    idx = Tenor[f'T_{index.upper()}']

    return CrossCurrencySwapTrade(
        trade_date=trade_date,
        ccy=ccy,
        start=start_date,
        maturity=maturity,
        rate=rate,
        notional=notional,
        fx_rate=fxRate,
        idx=idx,
        ccy_base=ccy_base,
    )


@xl_func
@inspect_arguments
def firm_xccy(
        tradeDate: datetime.date,
        curncy: str,
        curncyBase: str,
        startDate: datetime.date,
        maturityDate: datetime.date,
        notional: float,
        rate: float,
        fxRate: float,
) -> object:
    trade_date = date2datetime(tradeDate)
    start_date = date2datetime(startDate)
    maturity = date2datetime(maturityDate)
    ccy = Ccy[curncy]
    ccy_base = Ccy[curncyBase]

    return XccyBasisTrade(
        trade_date=trade_date,
        ccy=ccy,
        start=start_date,
        maturity=maturity,
        rate=rate,
        notional=notional,
        fx_rate=fxRate,
        ccy_base=ccy_base,
    )


@xl_func
@inspect_arguments
def firm_swaption(
        tradeDate: datetime.date,
        curncy: str,
        expiryDate: datetime.date,
        payRec: str,
        startDate: datetime.date,
        maturityDate: datetime.date,
        index: str,
        strike: float,
        notional: float,
) -> object:
    trade_date = date2datetime(tradeDate)
    expiry_date = date2datetime(expiryDate)
    start_date = date2datetime(startDate)
    maturity = date2datetime(maturityDate)
    ccy = Ccy[curncy]
    pay_rec = SwaptionType[payRec.upper()]
    idx = Tenor[f'T_{index.upper()}']

    return SwaptionTrade(
        trade_date=trade_date,
        ccy=ccy,
        expiry=expiry_date,
        start=start_date,
        maturity=maturity,
        strike=strike,
        swaption_type=pay_rec,
        notional=notional,
        idx=idx,
    )


@xl_func
@inspect_arguments
def firm_fx_option(
        tradeDate: datetime.date,
        curncy: str,
        curncyBase: str,
        expiryDate: datetime.date,
        callPut: str,
        strike: float,
        notional: float,
) -> object:
    trade_date = date2datetime(tradeDate)
    expiry_date = date2datetime(expiryDate)
    ccy = Ccy[curncy]
    ccy_base = Ccy[curncyBase]
    call_put = OptionType[callPut.upper()]

    return FXOptionTrade(
        trade_date=trade_date,
        ccy=ccy,
        expiry=expiry_date,
        strike=strike,
        option_type=call_put,
        notional=notional,
        ccy_base=ccy_base,
    )


@xl_func
@inspect_arguments
def firm_cash_flow(
        tradeDate: datetime.date,
        curncy: str,
        maturityDate: datetime.date,
        notional: float,
):
    trade_date = date2datetime(tradeDate)
    ccy = Ccy[curncy]
    maturity = date2datetime(maturityDate)

    return CashFlow(
        trade_date=trade_date,
        ccy=ccy,
        maturity=maturity,
        notional=notional,
    )


__all__ = [i for i in globals() if i.startswith('firm_')]

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\exceltools\__init__.py
----------------------------------------
from .f3api import *
from .py_utils import *
from .timeseries import *
from .datalayer import *
from .trades import *
from .positions import *
from .pricer import *
from .models import *
from .risk_report import *
from .pnl_explained import *
import logging
import sys

logging.getLogger('f3sdk').propagate = False
sys.setrecursionlimit(3000)
logging.getLogger(__name__).info(f'python recursion limit set at {sys.getrecursionlimit()}')

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\mapping\bond.py
----------------------------------------
from firm_domain import Ccy


def f3_bond_settlement_convention(ccy: Ccy) -> str:
    return f'{str(ccy)}_bond_settlement_convention'


def f3_bond_type(ccy: Ccy) -> str:
    return f'{str(ccy)}_govt_bondtype'

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\mapping\discount_curve_tag.py
----------------------------------------
from functools import singledispatch
from typing import List

from f3sdk.f3 import F3Object  # type: ignore
from f3sdk.lib.coroutine import wait  # type: ignore
import firm_f3.f3client # type:ignore
from firm_domain import Instrument, Ccy, Tenor, Rate, Trade

from .utils import trade_to_collateral_ccy
from .index import f3index


async def f3discount_curve_tag_async(inst, *instruments) -> List[str]:
    from firm_f3.evaluate import f3_evaluate_async, scalar_handler
    if instruments:
        req = [req_discount_curve_tag_single(i) for i in (inst, *instruments)]
    else:
        req = req_discount_curve_tag_single(inst)
    return await f3_evaluate_async(req, callback=scalar_handler)


def f3discount_curve_tag(inst, *instruments) -> List[str]:
    return wait(f3discount_curve_tag_async(inst, *instruments))


@singledispatch
def req_discount_curve_tag_single(inst: Instrument) -> F3Object:
    if isinstance(inst, F3Object):
        return inst
    raise TypeError(f'expect Instrument, got type {type(inst)} instead')


@req_discount_curve_tag_single.register
def req_discount_curve_tag_single_by_str(ccy: str) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.DiscountCurveTag(
        Currency=ccy,
    )


@req_discount_curve_tag_single.register
def req_discount_curve_tag_single_by_tuple(ccy_collateral: tuple) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    currency, collateral = ccy_collateral
    assert isinstance(currency, Ccy)
    assert isinstance(collateral, Rate)
    return f3.DiscountCurveTag(
        Currency=currency.name,
        CollateralAgreement=f3index(collateral)
    )


@req_discount_curve_tag_single.register
def req_discount_curve_tag_single_by_rate(rate: Rate) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    currency: Ccy = rate.ccy
    collateral: str = f3index(rate)
    return f3.DiscountCurveTag(
        Currency=currency.name,
        CollateralAgreement=collateral
    )


@req_discount_curve_tag_single.register
def req_discount_curve_tag_single_by_ccy(ccy: Ccy) -> F3Object:
    rate = Rate(ccy, Tenor.T_1D)
    return req_discount_curve_tag_single_by_rate(rate)


@req_discount_curve_tag_single.register
def req_discount_curve_tag_single_by_trade(trade: Trade) -> F3Object:
    currency = trade_to_collateral_ccy(trade)
    return req_discount_curve_tag_single_by_ccy(currency)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\mapping\index.py
----------------------------------------
from functools import singledispatch

from firm_domain import Tenor, Ccy, Rate, FXForward, InflationIndex
from .utils import ccy_to_f3pair


@singledispatch
def f3index(rate, is_compounded = False) -> str:
    _ = is_compounded
    if isinstance(rate, str):
        return rate
    raise TypeError(f'expect Union[Rate], got type {type(rate)} instead')


F3_INDEX_BY_RATE = {
    Rate(Ccy.EUR, Tenor.T_1D): 'EONIA',
    Rate(Ccy.EUR, Tenor.T_1M): 'Euribor1m',
    Rate(Ccy.EUR, Tenor.T_3M): 'Euribor3m',
    Rate(Ccy.EUR, Tenor.T_6M): 'Euribor6m',
    Rate(Ccy.GBP, Tenor.T_1D): 'SONIA',
    Rate(Ccy.GBP, Tenor.T_3M): 'LiborGBP3m',
    Rate(Ccy.GBP, Tenor.T_6M): 'LiborGBP6m',
    Rate(Ccy.AUD, Tenor.T_1D): 'AUInterbankOvernight',
    Rate(Ccy.AUD, Tenor.T_1M): 'BBSW1m',
    Rate(Ccy.AUD, Tenor.T_3M): 'BBSW3m',
    Rate(Ccy.AUD, Tenor.T_6M): 'BBSW6m',
    Rate(Ccy.NZD, Tenor.T_1D): 'NZOCR',
    Rate(Ccy.NZD, Tenor.T_3M): 'BKBM3m',
    Rate(Ccy.USD, Tenor.T_1D): 'OvernightUSD',
    Rate(Ccy.USD, Tenor.T_1M): 'LiborUSD1m',
    Rate(Ccy.USD, Tenor.T_3M): 'LiborUSD3m',
    Rate(Ccy.USD, Tenor.T_6M): 'LiborUSD6m',
    Rate(Ccy.CAD, Tenor.T_1D): 'CORRA',
    Rate(Ccy.CAD, Tenor.T_3M): 'CDOR3m',
    Rate(Ccy.SEK, Tenor.T_1D): 'OvernightSEK',
    Rate(Ccy.SEK, Tenor.T_3M): 'Stibor3m',
    Rate(Ccy.JPY, Tenor.T_1D): 'TONAR',
    Rate(Ccy.JPY, Tenor.T_3M): 'LiborJPY3m',
    Rate(Ccy.JPY, Tenor.T_6M): 'LiborJPY6m',
    Rate(Ccy.SGD, Tenor.T_1D): 'OvernightSGD',
    Rate(Ccy.SGD, Tenor.T_3M): 'SOR3m',
    Rate(Ccy.SGD, Tenor.T_6M): 'SOR6m',
    Rate(Ccy.HKD, Tenor.T_1D): 'HiborON',
    Rate(Ccy.HKD, Tenor.T_1M): 'Hibor1m',
    Rate(Ccy.HKD, Tenor.T_3M): 'Hibor3m',
    Rate(Ccy.CNY, Tenor.T_1W): 'ChinaRepo7d',
    Rate(Ccy.KRW, Tenor.T_3M): 'KRWCD3m',
    Rate(Ccy.MYR, Tenor.T_3M): 'Klibor3m',
    Rate(Ccy.TWD, Tenor.T_3M): 'Taibor3m',
    Rate(Ccy.NTO, Tenor.T_3M): 'Taibor3m_NTO',
    Rate(Ccy.THB, Tenor.T_6M): 'Bibor6m',
    Rate(Ccy.ILS, Tenor.T_1D): 'OvernightILS',
    Rate(Ccy.ILS, Tenor.T_3M): 'Telbor3m',
    Rate(Ccy.ZAR, Tenor.T_1D): 'OvernightZAR',
    Rate(Ccy.ZAR, Tenor.T_3M): 'Jibar3m',
    Rate(Ccy.SAR, Tenor.T_1D): 'OvernightSAR',
    Rate(Ccy.SAR, Tenor.T_3M): 'SAIBOR3m',
    Rate(Ccy.HUF, Tenor.T_1D): 'OvernightHUF',
    Rate(Ccy.HUF, Tenor.T_3M): 'Bubor3m',
    Rate(Ccy.HUF, Tenor.T_6M): 'Bubor6m',
    Rate(Ccy.PLN, Tenor.T_1D): 'OvernightPLN',
    Rate(Ccy.PLN, Tenor.T_3M): 'Wibor3m',
    Rate(Ccy.PLN, Tenor.T_6M): 'Wibor6m',
    Rate(Ccy.INR, Tenor.T_1D): 'OvernightINR',
    Rate(Ccy.INO, Tenor.T_1D): 'OvernightINO',
    Rate(Ccy.CHF, Tenor.T_1D): 'OvernightCHF',
    Rate(Ccy.CHF, Tenor.T_3M): 'LiborCHF3m',
    Rate(Ccy.CHF, Tenor.T_6M): 'LiborCHF6m',
    Rate(Ccy.NOK, Tenor.T_1D): 'OvernightNOK',
    Rate(Ccy.NOK, Tenor.T_3M): 'Nibor3m',
    Rate(Ccy.NOK, Tenor.T_6M): 'Nibor6m'
}

F3_COMPOUNDED_INDEX_BY_RATE = {
    Rate(Ccy.USD, Tenor.T_1M): 'LiborUSD1mCompounded',
    Rate(Ccy.USD, Tenor.T_3M): 'LiborUSD3mCompounded',
    Rate(Ccy.CAD, Tenor.T_3M): 'CDOR3mCompounded',
    Rate(Ccy.CNY, Tenor.T_1W): 'ChinaRepo7dCompounded',
    Rate(Ccy.INO, Tenor.T_1D): 'OvernightINOCompounded',
}


@f3index.register
def f3index_by_rate(rate: Rate, is_compounded: bool = False) -> str:
    if is_compounded:
        return F3_COMPOUNDED_INDEX_BY_RATE[rate]
    return F3_INDEX_BY_RATE[rate]


@f3index.register
def f3index_by_ccy(ccy: Ccy, is_compounded: bool = False) -> str:
    _ = is_compounded
    is_rev = ccy < Ccy.USD
    return ccy_to_f3pair(ccy, is_rev)


@f3index.register
def f3index_by_fx_spot(inst: FXForward, is_compounded: bool = False) -> str:
    _ = is_compounded
    assert inst.tenor is Tenor.SPOT
    return inst.ccy_base.name + inst.ccy.name


F3_INDEX_BY_INFLATION_INDEX = {
    InflationIndex.CPURNSA: 'USCPIMonthly',
    InflationIndex.AUCPI: 'AUCPIQuarterly',
    InflationIndex.UKRPI: 'UKRPIMonthly',
}


@f3index.register
def f3index_by_inflation_index(idx: InflationIndex, is_compounded: bool = False) -> str:
    _ = is_compounded
    return F3_INDEX_BY_INFLATION_INDEX[idx]


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\mapping\instrument.py
----------------------------------------
import logging
from functools import singledispatch
from typing import Union, Tuple, List

import firm_domain as domain
from firm_domain import Ccy, Tenor, Rate, InflationIndex, OptionStrat

INSTRUMENT_TYPES = Union[domain.Instrument, str, domain.OISTrade, domain.IRSTrade, domain.SwaptionTrade]


def f3instrument_type(inst: INSTRUMENT_TYPES, *instruments: Tuple[INSTRUMENT_TYPES]) -> Union[str, List[str]]:
    if instruments:
        return [f3instrument_type_single(i) for i in (inst, *instruments)]
    return f3instrument_type_single(inst)


@singledispatch
def f3instrument_type_single(inst: INSTRUMENT_TYPES) -> str:
    if isinstance(inst, str):
        return inst
    elif isinstance(inst, domain.Trade) and not isinstance(inst, domain.SwaptionTrade):
        # jchi@201907
        # This is for the sake of maintaining the original behaviour. Implementation for specific type should be
        # implemented explicitly, instead of returning an empty string implicitly.
        logging.warning('returning empty string... this should not happen, please check implementation!')
        return ''
    raise TypeError(f'expect Instrument, got type {type(inst)} instead')


F3_INSTRUMENT_TYPE_BY_IRS = {
    Ccy.USD: {
        Tenor.T_3M: 'USD-IRS-Semi-Libor-3m',
        Tenor.T_1M: 'USD-IRS-Semi-Libor-1m',
        Tenor.T_6M: 'USD-IRS-Semi-Libor-6m'
    },
    Ccy.EUR: {
        Tenor.T_1M: 'EUR-IRS-Annual-Euribor-1m',
        Tenor.T_3M: 'EUR-IRS-Annual-Euribor-3m',
        Tenor.T_6M: 'EUR-IRS-Annual-Euribor-6m'
    },
    Ccy.AUD: {
        Tenor.T_3M: 'AUD-IRS-Quarterly-BBSW-3m',
        Tenor.T_6M: 'AUD-IRS-Semi-BBSW-6m'
    },
    Ccy.KRW: {
        Tenor.T_3M: 'KRW-IRS-Quarterly-KRWCD-3m-Uncollat'
    },
    Ccy.GBP: {
        Tenor.T_3M: 'GBP-IRS-Annual-Libor-3m',
        Tenor.T_6M: 'GBP-IRS-Semi-Libor-6m',
    },
    Ccy.NZD: {
        Tenor.T_3M: 'NZD-IRS-Semi-BKBM-3m'
    },
    Ccy.ILS: {
        Tenor.T_3M: 'ILS-IRS-Annual-Telbor-3m',  # custom instrument type
    },
    Ccy.PLN: {
        Tenor.T_6M: 'PLN-IRS-Annual-Wibor-6m'
    },
    Ccy.HUF: {
        Tenor.T_6M: 'HUF-IRS-Annual-Bubor-6m'
    },
    Ccy.HKD: {
        Tenor.T_3M: 'HKD-IRS-Quarterly-Hibor-3m'
    },
    Ccy.JPY: {
        Tenor.T_6M: 'JPY-IRS-Semi-Libor-6m'
    },
    Ccy.CAD: {
        Tenor.T_3M: 'CAD-IRS-Semi-CDOR-3m'
    },
    Ccy.SEK: {
        Tenor.T_3M: 'SEK-IRS-Annual-Stibor-3m'
    },
    Ccy.ZAR: {
        Tenor.T_3M: 'ZAR-IRS-Quarterly-Jibar-3m',  # custom instrument type
    },
    Ccy.SAR: {
        Tenor.T_3M: 'SAR-IRS-Annual-SAIBOR-3m',  # custom instrument type
    },
    Ccy.CNY: {
        Tenor.T_1W: 'CNY-IRS-Quarterly-ChinaRepo-7d-Uncollat'
    },
    Ccy.SGD: {
        Tenor.T_6M: 'SGD-IRS-Semi-SOR-6m',
        Tenor.T_3M: 'SGD-IRS-Quarterly-SOR-3m',  # custom instrument type
    },
    Ccy.MYR: {
        Tenor.T_3M: 'MYR-IRS-Quarterly-Klibor-3m-Uncollat'
    },
    Ccy.TWD: {
        Tenor.T_3M: 'TWD-IRS-Quarterly-Taibor-3m'
    },
    Ccy.NTO: {
        Tenor.T_3M: 'NTO-IRS-Quarterly-Taibor-3m'
    },
    Ccy.THB: {
        Tenor.T_6M: 'THB-IRS-Semi-Bibor-6m-Uncollat'
    },
    Ccy.CHF: {
        Tenor.T_6M: 'CHF-IRS-Annual-Libor-6m'
    },
    Ccy.NOK: {
        Tenor.T_6M: 'NOK-IRS-Annual-Nibor-6m'
    },
}


@f3instrument_type_single.register
def f3instrument_type_single_by_irs(irs: domain.IRS):
    return F3_INSTRUMENT_TYPE_BY_IRS[irs.ccy][irs.idx]


F3_INSTRUMENT_BY_RATE = {
    Rate(Ccy.EUR, Tenor.T_1M): 'EUR-CashDepo_1m_Inst_Type',
    Rate(Ccy.EUR, Tenor.T_3M): 'EUR-CashDepo_3m_Inst_Type',
    Rate(Ccy.EUR, Tenor.T_6M): 'EUR-CashDepo_6m_Inst_Type',
    Rate(Ccy.GBP, Tenor.T_3M): 'GBP-CashDepo_3m_Inst_Type',
    Rate(Ccy.GBP, Tenor.T_6M): 'GBP-CashDepo_6m_Inst_Type',
    Rate(Ccy.AUD, Tenor.T_1M): 'AUD-CashDepo_1m_Inst_Type',
    Rate(Ccy.AUD, Tenor.T_3M): 'AUD-CashDepo_3m_Inst_Type',
    Rate(Ccy.AUD, Tenor.T_6M): 'AUD-CashDepo_6m_Inst_Type',
    Rate(Ccy.NZD, Tenor.T_3M): 'NZD-CashDepo_3m_Inst_Type',
    Rate(Ccy.USD, Tenor.T_1M): 'USD-CashDepo_1m_Inst_Type',
    Rate(Ccy.USD, Tenor.T_3M): 'USD-CashDepo_3m_Inst_Type',
    Rate(Ccy.USD, Tenor.T_6M): 'USD-CashDepo_6m_Inst_Type',
    Rate(Ccy.CAD, Tenor.T_3M): 'CAD-CashDepo_3m_Inst_Type',
    Rate(Ccy.SEK, Tenor.T_3M): 'SEK-CashDepo_3m_Inst_Type',
    Rate(Ccy.JPY, Tenor.T_3M): 'JPY-CashDepo_3m_Inst_Type',
    Rate(Ccy.JPY, Tenor.T_6M): 'JPY-CashDepo_6m_Inst_Type',
    Rate(Ccy.SGD, Tenor.T_3M): 'SGD-CashDepo_3m_Inst_Type',
    Rate(Ccy.SGD, Tenor.T_6M): 'SGD-CashDepo_6m_Inst_Type',
    Rate(Ccy.HKD, Tenor.T_1M): 'HKD-CashDepo_1m_Inst_Type',
    Rate(Ccy.HKD, Tenor.T_3M): 'HKD-CashDepo_3m_Inst_Type',
    Rate(Ccy.KRW, Tenor.T_3M): 'KRW-CashDepo_3m_Inst_Type',
    Rate(Ccy.MYR, Tenor.T_3M): 'MYR-CashDepo_3m_Inst_Type',
    Rate(Ccy.TWD, Tenor.T_3M): 'TWD-CashDepo_3m_Inst_Type',
    Rate(Ccy.NTO, Tenor.T_3M): 'NTO-CashDepo_3m_Inst_Type',
    Rate(Ccy.THB, Tenor.T_6M): 'THB-CashDepo_6m_Inst_Type',
    Rate(Ccy.ILS, Tenor.T_3M): 'ILS-CashDepo_3m_Inst_Type',
    Rate(Ccy.ZAR, Tenor.T_3M): 'ZAR-CashDepo_3m_Inst_Type',
    Rate(Ccy.SAR, Tenor.T_3M): 'SAR-CashDepo_3m_Inst_Type',
    Rate(Ccy.HUF, Tenor.T_3M): 'HUF-CashDepo_3m_Inst_Type',
    Rate(Ccy.HUF, Tenor.T_6M): 'HUF-CashDepo_6m_Inst_Type',
    Rate(Ccy.PLN, Tenor.T_3M): 'PLN-CashDepo_3m_Inst_Type',
    Rate(Ccy.PLN, Tenor.T_6M): 'PLN-CashDepo_6m_Inst_Type',
    Rate(Ccy.CHF, Tenor.T_3M): 'CHF-CashDepo_3m_Inst_Type',
    Rate(Ccy.CHF, Tenor.T_6M): 'CHF-CashDepo_6m_Inst_Type',
    Rate(Ccy.NOK, Tenor.T_3M): 'NOK-CashDepo_3m_Inst_Type',
    Rate(Ccy.NOK, Tenor.T_6M): 'NOK-CashDepo_6m_Inst_Type',
}


@f3instrument_type_single.register
def f3instrument_type_single_by_rate(rate: Rate):
    return F3_INSTRUMENT_BY_RATE[rate]


F3_INSTRUMENT_BY_XCCY_BASIS = {
    Ccy.KRW: 'KRWUSD-XccySwap-KRWCD3m-LiborUSD6m',
    Ccy.EUR: 'EURUSD-XccySwap-Euribor3m-LiborUSD3m',
    Ccy.AUD: 'AUDUSD-XccySwap-BBSW3m-LiborUSD3m',
    Ccy.GBP: 'GBPUSD-XccySwap-LiborGBP3m-LiborUSD3m',
    Ccy.NZD: 'NZDUSD-XccySwap-BKBM3m-LiborUSD3m',
    Ccy.ILS: 'ILSUSD-XccySwap-Telbor3m-LiborUSD3m',
    Ccy.PLN: 'PLNEUR-XccySwap-Wibor3m-Euribor3m',
    Ccy.HUF: 'HUFEUR-XccySwap-Bubor3m-Euribor3m',
    Ccy.HKD: 'HKDUSD-XccySwap-Hibor3m-LiborUSD3m',
    Ccy.JPY: 'JPYUSD-XccySwap-LiborJPY3m-LiborUSD3m',
    Ccy.CAD: 'CADUSD-XccySwap-CDOR3m-LiborUSD3m',
    Ccy.SEK: 'SEKUSD-XccySwap-Stibor3m-LiborUSD3m',
    Ccy.ZAR: 'ZARUSD-XccySwap-Jibar3m-LiborUSD3m',
    Ccy.SAR: 'SARUSD-XccySwap-SAIBOR3m-LiborUSD3m',
    Ccy.SGD: 'SGDUSD-XccySwap-SOR6m-LiborUSD6m',
    Ccy.CHF: 'CHFUSD-XccySwap-LiborCHF3m-LiborUSD3m',
    Ccy.NOK: 'NOKUSD-XccySwap-NiborNOK3m-LiborUSD3m',
    # Ccy.INR: 'INRUSD-XccySwap-Mifor6m-LiborUSD6m',
}


@f3instrument_type_single.register
def f3instrument_type_single_by_xccy_basis(xccy_basis: domain.XccyBasis):
    return F3_INSTRUMENT_BY_XCCY_BASIS[xccy_basis.ccy]


F3_INSTRUMENT_BY_INFLATION_SWAP = {
    InflationIndex.CPURNSA: 'USD-ZCISwap-USCPI',
    InflationIndex.AUCPI: 'AUD-ZCISwap-AUCPI',
    InflationIndex.UKRPI: 'GBP-ZCISwap-UKRPI'
}


@f3instrument_type_single.register
def f3instrument_type_single_by_inf_swap(inf_swap: domain.InflationSwap):
    return F3_INSTRUMENT_BY_INFLATION_SWAP[inf_swap.index]


F3_INSTRUMENT_BY_FX_FWD = {
    (Ccy.USD, Ccy.KRW): 'KRW_NDF_Inst_Type',
    (Ccy.USD, Ccy.PHP): 'PHP_NDF_Inst_Type',
    (Ccy.USD, Ccy.INR): 'INR_NDF_Inst_Type',
    (Ccy.USD, Ccy.INO): 'INO_NDF_Inst_Type',
    (Ccy.USD, Ccy.CNH): 'CNH_FX_Inst_Type',
    (Ccy.USD, Ccy.CNY): 'CNY_NDF_Inst_Type',
    (Ccy.USD, Ccy.IDR): 'IDR_NDF_Inst_Type',
    (Ccy.USD, Ccy.THB): 'THB_FX_Inst_Type',
    (Ccy.USD, Ccy.SGD): 'SGD_FX_Inst_Type',
    (Ccy.USD, Ccy.HKD): 'HKD_FX_Inst_Type',
    (Ccy.USD, Ccy.PLN): 'USDPLN_FX_Inst_Type',
    (Ccy.EUR, Ccy.PLN): 'PLN_FX_Inst_Type',
    (Ccy.EUR, Ccy.HUF): 'HUF_FX_Inst_Type',
    (Ccy.USD, Ccy.ZAR): 'ZAR_FX_Inst_Type',
    (Ccy.USD, Ccy.SAR): 'SAR_FX_Inst_Type',
    (Ccy.USD, Ccy.ILS): 'ILS_FX_Inst_Type',
    (Ccy.USD, Ccy.TWD): 'TWD_NDF_Inst_Type',
    (Ccy.USD, Ccy.NTO): 'NTO_NDF_Inst_Type',
    (Ccy.USD, Ccy.SEK): 'SEK_FX_Inst_Type',
    (Ccy.USD, Ccy.RUB): 'RUB_FX_Inst_Type',
    (Ccy.USD, Ccy.MXN): 'MXN_FX_Inst_Type',
    (Ccy.USD, Ccy.TRY): 'TRY_FX_Inst_Type',
    (Ccy.USD, Ccy.MYR): 'MYR_NDF_Inst_Type',
    (Ccy.USD, Ccy.CHF): 'USDCHF-Forward-PointsAtPremium',
    (Ccy.USD, Ccy.NOK): 'NOK_FX_Inst_Type',
    (Ccy.NZD, Ccy.USD): 'NZDUSD-Forward-PointsAtPremium',
    (Ccy.EUR, Ccy.USD): 'EURUSD-Forward-PointsAtPremium',
    (Ccy.GBP, Ccy.USD): 'GBPUSD-Forward-PointsAtPremium',
    (Ccy.USD, Ccy.JPY): 'USDJPY-Forward-PointsAtPremium',
    (Ccy.AUD, Ccy.USD): 'AUDUSD-Forward-PointsAtPremium',
    (Ccy.USD, Ccy.CAD): 'USDCAD-Forward-PointsAtPremium'
}


@f3instrument_type_single.register
def f3instrument_type_single_by_fx_forward(fwd: domain.FXForward):
    return F3_INSTRUMENT_BY_FX_FWD[fwd.ccy_base, fwd.ccy]


def _unpack_f3_fx_fwd_outright():
    for left, right in F3_INSTRUMENT_BY_FX_FWD:
        if domain.Conventions.trades_as_ndf(left) or domain.Conventions.trades_as_ndf(right):
            inst_type = f'{left}{right}-NDForward-RateOutright'
        else:
            inst_type = f'{left}{right}-Forward-RateOutright'
        yield (left, right), inst_type


F3_INSTRUMENT_BY_FX_FWD_OUTRIGHT = dict(_unpack_f3_fx_fwd_outright())


@f3instrument_type_single.register
def f3instrument_type_single_by_fx_forward_outright(fwd: domain.FXForwardOutright):
    return F3_INSTRUMENT_BY_FX_FWD_OUTRIGHT[fwd.ccy_base, fwd.ccy]


F3_INSTRUMENT_TYPE_BY_TENOR_BASIS = {
    Ccy.USD: {
        (Tenor.T_1D, Tenor.T_3M): 'USD-BasisSwap-OIS-Libor-3m',
        (Tenor.T_1M, Tenor.T_3M): 'USD-BasisSwap-Libor-1m-3m',
        (Tenor.T_3M, Tenor.T_6M): 'USD-BasisSwap-Libor-3m-6m'
    },
    Ccy.AUD: {
        (Tenor.T_1D, Tenor.T_3M): 'AUD-BasisSwap-OIS-BBSW-3m',
        (Tenor.T_1D, Tenor.T_6M): 'AUD-BasisSwap-OIS-BBSW-6m',
        (Tenor.T_1M, Tenor.T_3M): 'AUD-BasisSwap-BBSW-1m-3m',
        (Tenor.T_3M, Tenor.T_6M): 'AUD-BasisSwap-BBSW-3m-6m',
        (Tenor.T_1M, Tenor.T_6M): 'AUD-BasisSwap-BBSW-1m-6m',
    },
    Ccy.EUR: {
        (Tenor.T_3M, Tenor.T_6M): 'EUR-BasisSwap-Euribor-3m-6m',
        (Tenor.T_1D, Tenor.T_6M): 'EUR-BasisSwap-OIS-Euribor-6m'
    },
    Ccy.GBP: {
        (Tenor.T_1D, Tenor.T_3M): 'GBP-BasisSwap-OIS-Libor-3m',
        (Tenor.T_1D, Tenor.T_6M): 'GBP-BasisSwap-OIS-Libor-6m',
        (Tenor.T_3M, Tenor.T_6M): 'GBP-BasisSwap-Libor-3m-6m'
    },
    Ccy.PLN: {
        (Tenor.T_1D, Tenor.T_6M): 'PLN-BasisSwap-OIS-Wibor-6m',
        # (Tenor.T_3M, Tenor.T_6M): 'PLN-BasisSwap-Wibor-3m-6m-Uncollat',
        (Tenor.T_3M, Tenor.T_6M): 'PLN-BasisSwap-Wibor-3m-6m'
    },
    Ccy.HUF: {
        (Tenor.T_1D, Tenor.T_6M): 'HUF-BasisSwap-OIS-Bubor-6m',
        # (Tenor.T_3M, Tenor.T_6M): 'HUF-BasisSwap-Bubor-3m-6m-Uncollat',
        (Tenor.T_3M, Tenor.T_6M): 'HUF-BasisSwap-Bubor-3m-6m'
    },
    Ccy.HKD: {
        (Tenor.T_1D, Tenor.T_3M): 'HKD-BasisSwap-OIS-Hibor-3m',
        (Tenor.T_1M, Tenor.T_3M): 'HKD-BasisSwap-Hibor-1m-3m',
        # (Tenor.T_1M, Tenor.T_3M): 'HKD-BasisSwap-Libor-1m-3m'
    },
    Ccy.JPY: {
        (Tenor.T_3M, Tenor.T_6M): 'JPY-BasisSwap-Libor-3m-6m',
        (Tenor.T_1D, Tenor.T_6M): 'JPY-BasisSwap-OIS-Libor-6m'
    },
    Ccy.NZD: {
        (Tenor.T_1D, Tenor.T_3M): 'NZD-BasisSwap-OIS-BKBM-3m'
    },
    Ccy.CAD: {
        (Tenor.T_1D, Tenor.T_3M): 'CAD-BasisSwap-OIS-CDOR-3m'
    },
    Ccy.SEK: {
        (Tenor.T_1D, Tenor.T_3M): 'SEK-BasisSwap-OIS-Stibor-3m'
    },
    Ccy.ZAR: {
        (Tenor.T_1D, Tenor.T_3M): 'ZAR-BasisSwap-OIS-Jibar-3m'
    },
    Ccy.SAR: {
        (Tenor.T_1D, Tenor.T_3M): 'SAR-BasisSwap-OIS-SAIBOR-3m'
    },
    Ccy.SGD: {
        (Tenor.T_1D, Tenor.T_6M): 'SGD-BasisSwap-OIS-SOR-6m',
        (Tenor.T_3M, Tenor.T_6M): 'SGD-BasisSwap-SOR-3m-6m'
    },
    Ccy.ILS: {
        (Tenor.T_1D, Tenor.T_3M): 'ILS-BasisSwap-OIS-Telbor-3m'
    },
    Ccy.CHF: {
        (Tenor.T_1D, Tenor.T_6M): 'CHF-BasisSwap-OIS-Libor-6m',
        (Tenor.T_3M, Tenor.T_6M): 'CHF-BasisSwap-Libor-3m-6m'
    },
    Ccy.NOK: {
        (Tenor.T_3M, Tenor.T_6M): 'NOK-BasisSwap-Nibor-3m-6m',
        (Tenor.T_1D, Tenor.T_6M): 'NOK-BasisSwap-OIS-Nibor-6m'
    }
}


@f3instrument_type_single.register
def f3instrument_type_single_by_tenor_basis(tenor_basis: domain.TenorBasis):
    return F3_INSTRUMENT_TYPE_BY_TENOR_BASIS[tenor_basis.ccy][tenor_basis.idx_1, tenor_basis.idx_2]


F3_INSTRUMENT_TYPE_BY_OIS = {
    (Ccy.USD, Tenor.T_1Y): 'USD-OIS',
    (Ccy.EUR, Tenor.T_1Y): 'EUR-OIS',
    (Ccy.AUD, Tenor.T_1Y): 'AUD-OIS',
    (Ccy.GBP, Tenor.T_1Y): 'GBP-OIS',
    (Ccy.JPY, Tenor.T_1Y): 'JPY-OIS',
    (Ccy.CAD, Tenor.T_1Y): 'CAD-OIS-Annual',
    (Ccy.NZD, Tenor.T_1Y): 'NZD-OIS',
    (Ccy.PLN, Tenor.T_1Y): 'PLN-OIS',
    (Ccy.SEK, Tenor.T_1Y): 'SEK-OIS',
    (Ccy.INR, Tenor.T_1Y): 'INR-OIS-Annual-Uncollat',
    (Ccy.INO, Tenor.T_1Y): 'INO-OIS-Annual-Uncollat',
    (Ccy.INR, Tenor.T_6M): 'INR-OIS-Semi-Uncollat',
    (Ccy.INO, Tenor.T_6M): 'INO-OIS-Semi-Uncollat',
    (Ccy.CHF, Tenor.T_1Y): 'CHF-OIS'
}


@f3instrument_type_single.register
def f3instrument_type_single_by_ois(ois: domain.OIS):
    return F3_INSTRUMENT_TYPE_BY_OIS[ois.ccy, ois.fixed_freq]


F3_INSTRUMENT_TYPE_BY_IMMOIS = {
    Ccy.EUR: 'EUR-OIS',
}


@f3instrument_type_single.register
def f3instrument_type_single_by_immois(ecbois: domain.IMMOIS):
    return F3_INSTRUMENT_TYPE_BY_IMMOIS[ecbois.ccy]


F3_INSTRUMENT_TYPE_BY_ECBOIS = {
    Ccy.EUR: 'EUR-OIS',
}


@f3instrument_type_single.register
def f3instrument_type_single_by_ois(ecbois: domain.ECBOIS):
    return F3_INSTRUMENT_TYPE_BY_ECBOIS[ecbois.ccy]


F3_INSTRUMENT_TYPE_BY_FRA = {
    Ccy.USD: {
        Tenor.T_1M: 'USD-FRA-Libor-1m',
        Tenor.T_3M: 'USD-FRA-Libor-3m',
        Tenor.T_6M: 'USD-FRA-Libor-6m'
    },
    Ccy.EUR: {
        Tenor.T_3M: 'EUR-FRA-Euribor-3m',
        Tenor.T_6M: 'EUR-FRA-Euribor-6m'
    },
    Ccy.GBP: {
        Tenor.T_3M: 'GBP-FRA-Libor-3m',
        Tenor.T_6M: 'GBP-FRA-Libor-6m'
    },
    Ccy.JPY: {
        Tenor.T_3M: 'JPY-FRA-Libor-3m',
        Tenor.T_6M: 'JPY-FRA-Libor-6m'
    },
    Ccy.KRW: {
        Tenor.T_3M: 'KRW-FRA-KRWCD-3m-Uncollat'
    },
    Ccy.SGD: {
        # Tenor.T_6M: 'SGD-FRA-SOR-3m-Uncollat',
        Tenor.T_6M: 'SGD-FRA-SOR-6m',  # custom instrument type
        Tenor.T_3M: 'SGD-FRA-SOR-3m'  # custom instrument type
    },
    Ccy.HKD: {
        # Tenor.T_1M: 'HKD-FRA-Hibor-1m-Uncollat',
        Tenor.T_1M: 'HKD-FRA-Hibor-1m',
        # Tenor.T_3M: 'HKD-FRA-Hibor-3m-Uncollat',
        Tenor.T_3M: 'HKD-FRA-Hibor-3m',
    },
    Ccy.PLN: {
        # Tenor.T_3M: 'PLN-FRA-Wibor-3m-Uncollat',
        Tenor.T_3M: 'PLN-FRA-Wibor-3m',
        # Tenor.T_6M: 'PLN-FRA-Wibor-6m-Uncollat',
        Tenor.T_6M: 'PLN-FRA-Wibor-6m',
    },
    Ccy.HUF: {
        # Tenor.T_3M: 'HUF-FRA-Bubor-3m-Uncollat',
        Tenor.T_3M: 'HUF-FRA-Bubor-3m',
        # Tenor.T_6M: 'HUF-FRA-Bubor-6m-Uncollat',
        Tenor.T_6M: 'HUF-FRA-Bubor-6m',
    },
    Ccy.SEK: {
        Tenor.T_3M: 'SEK-FRA-Stibor-3m_NonIMM'
    },
    Ccy.NZD: {
        Tenor.T_3M: 'NZD-FRA-NZOCR-3m'
    },
    Ccy.ZAR: {
        # Tenor.T_3M: 'ZAR-FRA-Jibar-3m-Uncollat',
        Tenor.T_3M: 'ZAR-FRA-Jibar-3m',  # custom instrument type
    },
    Ccy.SAR: {
        Tenor.T_3M: 'SAR-FRA-SAIBOR-3m',  # custom instrument type
    },
    Ccy.ILS: {
        # Tenor.T_3M: 'ILS-FRA-Telbor-3m-Uncollat',
        Tenor.T_3M: 'ILS-FRA-Telbor-3m',  # custom instrument type
    },
    Ccy.AUD: {
        Tenor.T_3M: 'AUD-FRA-BBSW-3m',
        Tenor.T_6M: 'AUD-FRA-BBSW-6m'
    },
    Ccy.CAD: {
        Tenor.T_3M: 'CAD-FRA-CDOR-3m'
    },
    Ccy.MYR: {
        Tenor.T_3M: 'MYR-FRA-Klibor-3m-Uncollat'
    },
    Ccy.THB: {
        Tenor.T_6M: 'THB-FRA-Bibor-6m-Uncollat'
    },
    Ccy.CHF: {
        Tenor.T_6M: 'CHF-FRA-Libor-6m',
        Tenor.T_3M: 'CHF-FRA-Libor-3m',
    },
    Ccy.NOK: {
        Tenor.T_6M: 'NOK-FRA-Nibor-6m',
        Tenor.T_3M: 'NOK-FRA-Nibor-3m',
    }
}


@f3instrument_type_single.register
def f3instrument_type_single_by_fra(fra: domain.FRA):
    return F3_INSTRUMENT_TYPE_BY_FRA[fra.ccy][fra.tenor]


F3_INSTRUMENT_TYPE_BY_IMMFRA = {
    Ccy.NOK: {
        Tenor.T_3M: 'NOK-IMMFRA-Nibor-3m',
        Tenor.T_6M: 'NOK-IMMFRA-Nibor-6m'
    }
}


@f3instrument_type_single.register
def f3instrument_type_single_by_immfra(immfra: domain.IMMFRA):
    return F3_INSTRUMENT_TYPE_BY_IMMFRA[immfra.ccy][immfra.tenor]


F3_INSTRUMENT_TYPE_BY_CCS = {
    Ccy.INR: 'INR_CCS_Inst_Type',
    Ccy.INO: 'INO_CCS_Inst_Type',
    Ccy.RUB: 'RUB_CCS_Inst_Type',
    Ccy.CNH: 'CNH_CCS_Inst_Type',
    Ccy.TRY: 'TRY_CCS_Inst_Type',
    Ccy.TWD: 'TWD_CCS_Inst_Type'
}


@f3instrument_type_single.register
def f3instrument_type_single_by_ccs(xccy: domain.CrossCurrencySwap):
    return F3_INSTRUMENT_TYPE_BY_CCS[xccy.ccy]


F3_INSTRUMENT_TYPE_BY_SWAPTION = {
    'AUD-IRS-Quarterly-BBSW-3m': 'AUD_Swaption_Inst_Type_3m',
    'AUD-IRS-Semi-BBSW-6m': 'AUD_Swaption_Inst_Type_6m',
    'USD-IRS-Semi-Libor-3m': 'USD-Swaption-Semi-Libor-3m',
    'EUR-IRS-Annual-Euribor-6m': 'EUR-Swaption-Annual-Euribor-6m',
    'KRW-IRS-Quarterly-KRWCD-3m-Uncollat': 'KRW-Swaption-Quarterly-CD-3m-Uncollat',
    'JPY-IRS-Semi-Libor-6m': 'JPY-Swaption-Semi-Libor-6m',
    'GBP-IRS-Semi-Libor-6m': 'GBP-Swaption-Semi-Libor-6m',
    'TWD-IRS-Quarterly-Taibor-3m': 'TWD-Swaption-Quarterly-Taibor-3m',
    'NTO-IRS-Quarterly-Taibor-3m': 'NTO-Swaption-Quarterly-Taibor-3m',
    'SAR-IRS-Annual-SAIBOR-3m': 'SAR-Swaption-Annual-SAIBOR-3m',
    'PLN-IRS-Annual-Wibor-6m': 'PLN-Swaption-Annual-Wibor-6m-USD-Collat',
}


@f3instrument_type_single.register
def f3instrument_type_single_by_swaption(swaption: domain.Swaption):
    return F3_INSTRUMENT_TYPE_BY_SWAPTION[f3instrument_type_single(swaption.get_swap())]


F3_INSTRUMENT_TYPE_BY_CCSSWAPTION = {
    'CNH_CCS_Inst_Type': 'CNH_Swaption_Inst_Type',
    'TRY_CCS_Inst_Type': 'TRY_Swaption_Inst_Type'
}


@f3instrument_type_single.register
def f3instrument_type_single_by_ccs_swaption(swaption: domain.CCSSwaption):
    return f'{F3_INSTRUMENT_TYPE_BY_CCSSWAPTION[f3instrument_type_single(swaption.get_swap())]}_{str(swaption.tenor)}'


F3_INSTRUMENT_TYPE_BY_FX_OPTION = {
    (Ccy.USD, Ccy.JPY): {OptionStrat.STRAD: 'USDJPY-ATMStraddle_User',
                         OptionStrat.RR: 'USDJPY-RR-Market_User',
                         OptionStrat.FLY: 'USDJPY-BF-Market_User'},
    (Ccy.EUR, Ccy.USD): {OptionStrat.STRAD: 'EURUSD-ATMStraddle_User',
                         OptionStrat.RR: 'EURUSD-RR-Market_User',
                         OptionStrat.FLY: 'EURUSD-BF-Market_User'},
    (Ccy.GBP, Ccy.USD): {OptionStrat.STRAD: 'GBPUSD-ATMStraddle_User',
                         OptionStrat.RR: 'GBPUSD-RR-Market_User',
                         OptionStrat.FLY: 'GBPUSD-BF-Market_User'},
    (Ccy.AUD, Ccy.USD): {OptionStrat.STRAD: 'AUDUSD-ATMStraddle_User',
                         OptionStrat.RR: 'AUDUSD-RR-Market_User',
                         OptionStrat.FLY: 'AUDUSD-BF-Market_User'},
    (Ccy.USD, Ccy.TWD): {OptionStrat.STRAD: 'USDTWD-ATMStraddle_User',
                         OptionStrat.RR: 'USDTWD-RR-Market_User',
                         OptionStrat.FLY: 'USDTWD-BF-Market_User'},
    (Ccy.USD, Ccy.INR): {OptionStrat.STRAD: 'USDINR-ATMStraddle_User',
                         OptionStrat.RR: 'USDINR-RR-Market_User',
                         OptionStrat.FLY: 'USDINR-BF-Market_User'},
    (Ccy.USD, Ccy.HKD): {OptionStrat.STRAD: 'USDHKD-ATMStraddle_User',
                         OptionStrat.RR: 'USDHKD-RR-Market_User',
                         OptionStrat.FLY: 'USDHKD-BF-Market_User'},
    (Ccy.USD, Ccy.IDR): {OptionStrat.STRAD: 'USDIDR-ATMStraddle_User',
                         OptionStrat.RR: 'USDIDR-RR-Market_User',
                         OptionStrat.FLY: 'USDIDR-BF-Market_User'},
    (Ccy.USD, Ccy.KRW): {OptionStrat.STRAD: 'USDKRW-ATMStraddle_User',
                         OptionStrat.RR: 'USDKRW-RR-Market_User',
                         OptionStrat.FLY: 'USDKRW-BF-Market_User'},
    (Ccy.USD, Ccy.PHP): {OptionStrat.STRAD: 'USDPHP-ATMStraddle_User',
                         OptionStrat.RR: 'USDPHP-RR-Market_User',
                         OptionStrat.FLY: 'USDPHP-BF-Market_User'},
    (Ccy.USD, Ccy.SGD): {OptionStrat.STRAD: 'USDSGD-ATMStraddle_User',
                         OptionStrat.RR: 'USDSGD-RR-Market_User',
                         OptionStrat.FLY: 'USDSGD-BF-Market_User'},
    (Ccy.USD, Ccy.CNH): {OptionStrat.STRAD: 'USDCNH-ATMStraddle_User',
                         OptionStrat.RR: 'USDCNH-RR-Market_User',
                         OptionStrat.FLY: 'USDCNH-BF-Market_User'},
    (Ccy.USD, Ccy.CAD): {OptionStrat.STRAD: 'USDCAD-ATMStraddle_User',
                         OptionStrat.RR: 'USDCAD-RR-Market_User',
                         OptionStrat.FLY: 'USDCAD-BF-Market_User'},
    (Ccy.USD, Ccy.CNY): {OptionStrat.STRAD: 'USDCNY-ATMStraddle_User',
                         OptionStrat.RR: 'USDCNY-RR-Market_User',
                         OptionStrat.FLY: 'USDCNY-BF-Market_User'},
    (Ccy.USD, Ccy.MXN): {OptionStrat.STRAD: 'USDMXN-ATMStraddle_User',
                         OptionStrat.RR: 'USDMXN-RR-Market_User',
                         OptionStrat.FLY: 'USDMXN-BF-Market_User'},
    (Ccy.USD, Ccy.RUB): {OptionStrat.STRAD: 'USDRUB-ATMStraddle_User',
                         OptionStrat.RR: 'USDRUB-RR-Market_User',
                         OptionStrat.FLY: 'USDRUB-BF-Market_User'},
    (Ccy.USD, Ccy.SAR): {OptionStrat.STRAD: 'USDSAR-ATMStraddle_User',
                         OptionStrat.RR: 'USDSAR-RR-Market_User',
                         OptionStrat.FLY: 'USDSAR-BF-Market_User'},
    (Ccy.USD, Ccy.TRY): {OptionStrat.STRAD: 'USDTRY-ATMStraddle_User',
                         OptionStrat.RR: 'USDTRY-RR-Market_User',
                         OptionStrat.FLY: 'USDTRY-BF-Market_User'},
    (Ccy.USD, Ccy.ZAR): {OptionStrat.STRAD: 'USDZAR-ATMStraddle_User',
                         OptionStrat.RR: 'USDZAR-RR-Market_User',
                         OptionStrat.FLY: 'USDZAR-BF-Market_User'},
}


@f3instrument_type_single.register
def f3instrument_type_single_by_fx_option(opt: domain.FXOption):
    return F3_INSTRUMENT_TYPE_BY_FX_OPTION[opt.ccy_base, opt.ccy][opt.strat_type]


F3_INSTRUMENT_TYPE_BY_RATES_FUTURE = {
    Ccy.USD: {
        Tenor.T_3M: 'USD-Futures-Libor-3m',
    }
}


@f3instrument_type_single.register
def f3instrument_type_single_by_rates_future(inst: domain.RatesFuture):
    return F3_INSTRUMENT_TYPE_BY_RATES_FUTURE[inst.ccy][inst.idx]


RATE_BY_F3_INSTRUMENT = {v: k for k, v in F3_INSTRUMENT_BY_RATE.items()}


def rate_by_f3instrument_type(it: str) -> domain.Rate:
    return RATE_BY_F3_INSTRUMENT[it]


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\mapping\instrument_strategy.py
----------------------------------------
import logging
from functools import singledispatch

from colorama import Fore
from f3sdk.f3 import F3Object  # type: ignore
from f3sdk.lib.coroutine import wait  # type: ignore
import firm_domain as domain
import firm_f3.f3client  # type:ignore
from typing import List

from .market_data_tag import f3market_data_tag_async

logger = logging.getLogger(__name__)


def __log_tags(market_data_tags: List[List[str]]):
    s = '\n'.join(str(tag) for tag in market_data_tags)
    #logger.debug(f'create instrument strategy from market data tags:\n' + Fore.GREEN + s)


async def f3instrument_strategy_async(inst: domain.Instrument, *instruments) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    if instruments:
        market_data_tags = await f3market_data_tag_async(inst, *instruments)
        __log_tags(market_data_tags)

        # jchi@201907
        # f3.CreateConcatenatedInstrumentStrategy is the old way,
        # in some cases f3.CreateElementInstrumentStrategyCollection is recommended, see f3instrument_strategy2_async
        return f3.CreateConcatenatedInstrumentStrategy(
            InstrumentStrategies=f3.ArrayStack(*[
                f3.CreateElementInstrumentStrategy(MarketDataTag=tag) for tag in market_data_tags
            ])
        )
    return await f3instrument_strategy_single_async(inst)


def f3instrument_strategy(inst: domain.Instrument, *instruments) -> F3Object:
    return wait(f3instrument_strategy_async(inst, *instruments))


async def f3instrument_strategy2_async(inst: domain.Instrument, *instruments) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    if instruments:
        market_data_tags = await f3market_data_tag_async(inst, *instruments)

        # jchi@201907
        # f3.CreateElementInstrumentStrategyCollection is recommended vs f3.CreateConcatenatedInstrumentStrategy
        return f3.CreateElementInstrumentStrategyCollection(
            MarketDataTags=market_data_tags,
            Sort=True,
        )
    return await f3instrument_strategy_single_async(inst)


def f3instrument_strategy2(inst: domain.Instrument, *instruments) -> F3Object:
    return wait(f3instrument_strategy2_async(inst, *instruments))


@singledispatch
async def f3instrument_strategy_single_async(inst: domain.Instrument) -> F3Object:
    if isinstance(inst, F3Object):
        return inst
    raise TypeError(f'expect Instrument, got type {type(inst)} instead')


@f3instrument_strategy_single_async.register
async def f3instrument_strategy_single_by_instrument_async(inst: domain.Instrument) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    tag: List[str] = await f3market_data_tag_async(inst)
    __log_tags([tag])
    return f3.CreateElementInstrumentStrategy(
        MarketDataTag=tag
    )


def f3instrument_strategy_single(inst: domain.Instrument) -> F3Object:
    return wait(f3instrument_strategy_single_async(inst))


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\mapping\market_convention.py
----------------------------------------
from functools import singledispatch
from typing import List, Any

from f3sdk.f3 import F3Object  # type: ignore
from f3sdk.lib.coroutine import wait  # type: ignore

import firm_f3.f3client
import firm_domain as domain
from .instrument import f3instrument_type


def _market_conv_handler(res: List[List[str]]) -> str:
    for mkt_conv, tag in res:
        if tag == 'MarketConventions':
            return mkt_conv


async def f3market_convention_async(inst: Any, *instruments) -> List[str]:
    from firm_f3.evaluate import f3_evaluate_async
    if instruments:
        req = [req_market_convention_single(i) for i in (inst, *instruments)]
    else:
        req = req_market_convention_single(inst)
    return await f3_evaluate_async(req, callback=_market_conv_handler)


def f3market_convention(inst: Any, *instruments) -> List[str]:
    return wait(f3market_convention_async(inst, *instruments))


@singledispatch
def req_market_convention_single(inst: domain.Instrument) -> F3Object:
    raise TypeError(f'expect Instrument, got type {type(inst)} instead')


@req_market_convention_single.register
def req_market_convention_single_by_str(inst: str) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    if not inst.endswith('-Uncollat'):
        if 'AUD_Swaption' not in inst:
            # jchi@202001
            # exclude AUD Swaption from appending "-Uncollat" tail
            # the reason being AUD_Swaption_Inst_Type_6m or AUD_Swaption_Inst_Type_3m is itself un-collateralized
            inst += '-Uncollat'
    return f3.ObjectInfo(
        RepositoryName='InstrumentType',
        ObjectName=inst,
        Requests='ObjectDependencies'
    )


@req_market_convention_single.register
def req_market_convention_single_by_swaption(inst: domain.Swaption) -> F3Object:
    inst_type = f3instrument_type(inst)
    return req_market_convention_single_by_str(inst_type)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\mapping\market_data.py
----------------------------------------
from functools import singledispatch
from f3sdk.f3 import F3Object  # type:ignore
from firm_domain import market_data
import firm_f3.f3client
from .platform import PLATFORM_INDEX_CURVE, PLATFORM_INSTRUMENT_TYPE, default_instrument_type


def f3market_data(data: market_data.MarketData, *more_data: market_data.MarketData) -> F3Object:
    if more_data:
        return firm_f3.f3client.get_platform_client().CombineMarketDataSets(
            InputMarketDataSets=[f3market_data_single(i) for i in (data, *more_data)]
        )
    return f3market_data_single(data)


@singledispatch
def f3market_data_single(data: market_data.MarketData) -> F3Object:
    raise TypeError(data)


@f3market_data_single.register
def f3market_data_fx_spot(data: market_data.FxSpotMarketData) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    fx_name, fx_type = data.name
    return f3.CreateFXMarketData(
        FXRateName=fx_name,
        FXRateType=fx_type,
        FXIndices=[PLATFORM_INDEX_CURVE[i] for i in data.index],
        FXRates=data.values,
    )


@f3market_data_single.register
def f3market_data_curve(data: market_data.CurveMarketData) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    inst_type = PLATFORM_INSTRUMENT_TYPE.lookup(data.name, key=default_instrument_type)
    if isinstance(inst_type, set):
        # jchi@202001
        # Temp measure due to the fact that both FX outright and FX point instrument types map to the same market data
        #   tag. A choice has to be made before there is a better implementation. Currently here assume the FX market
        #   data tag always maps to the FX point instrument type.
        for inst_type in inst_type:
            if '_FX_Inst_Type' in inst_type or '-Forward-PointsAtPremium' in inst_type:
                break
    else:
        raise KeyError(data.name)

    return f3.CreateCurveMarketData(
        InstrumentType=inst_type,
        Maturities=[str(i).lower() for i in data.index],
        Quotes=data.values,
    )


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\mapping\market_data_tag.py
----------------------------------------
from functools import singledispatch
from typing import List, Union, Optional

from f3sdk.f3 import F3Object  # type: ignore
from f3sdk.lib.coroutine import wait  # type: ignore
import firm_domain as domain
import firm_f3.f3client  # type:ignore

from .instrument import f3instrument_type, rate_by_f3instrument_type


async def f3market_data_tag_async(inst: domain.Instrument, *instruments) -> Union[List[str], List[List[str]]]:
    from firm_f3.evaluate import f3_evaluate_async, scalar_handler
    if instruments:
        req = [req_market_data_tag_single(i) for i in (inst, *instruments)]
    else:
        req = req_market_data_tag_single(inst)
    return await f3_evaluate_async(req, callback=scalar_handler)


def f3market_data_tag(inst: domain.Instrument, *instruments) -> List[List[str]]:
    return wait(f3market_data_tag_async(inst, *instruments))


@singledispatch
def req_market_data_tag_single(inst: domain.Instrument) -> F3Object:
    raise TypeError(f'expect Instrument, got type {type(inst)} instead')


@req_market_data_tag_single.register
def req_market_data_tag_single_by_f3obj(f3obj: F3Object) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ObjectInfo(
        RepositoryName='MarketDataSet',
        ObjectName=f3obj,
        Requests='MarketDataTags'
    )


@req_market_data_tag_single.register
def req_market_data_tag_single_by_swaption(inst: domain.Swaption) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    f3obj = f3.CreateCommonStrikeSwaptionMarketData(
        InstrumentType=f3instrument_type(inst),
        Strike=['ATM', inst.strike],
    )
    return req_market_data_tag_single_by_f3obj(f3obj)


@req_market_data_tag_single.register
def req_market_data_tag_single_by_instrument(inst: domain.Instrument) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    f3obj = f3.CreateMarketData(
        InstrumentType=f3instrument_type(inst),
        MarketDataTagMethod=mkt_data_tag_override(inst)
    )
    return req_market_data_tag_single_by_f3obj(f3obj)


@req_market_data_tag_single.register
def req_market_data_tag_single_by_str(inst: str) -> F3Object:
    # noinspection PyTypeChecker
    return req_market_data_tag_single_by_instrument(inst)


def mkt_data_tag_override(it: Union[str, domain.Instrument]) -> Optional[List[str]]:
    it = f3instrument_type(it)
    try:
        inst = rate_by_f3instrument_type(it)
        return [it, f'CashDepoCollateralizedBy:{inst}']
    except KeyError:
        return None


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\mapping\platform.py
----------------------------------------
from typing import Set, Union
from f3sdk.lib.coroutine import wait  # type: ignore
import firm_f3.f3client
from firm_f3.util.reversible_dict import ReversibleDict

PLATFORM_INDEX = ReversibleDict()
PLATFORM_INSTRUMENT_TYPE = ReversibleDict()

PLATFORM_INDEX_CURVE = {}
PLATFORM_MARKET_DATA_TAG = {}


def default_index(indices: Set[str]) -> Union[str, Set[str]]:
    if len(indices) == 1:  # if index curve maps to a unique index name
        return next(iter(indices))

    filtered_candidates = set(i for i in indices if len(i) == 6 and i.upper() == i)
    if len(filtered_candidates) == 1:  # if index curve maps to a unique FX pair
        return next(iter(filtered_candidates))

    filtered_candidates = set(i.partition('Lag')[0] for i in indices)
    if len(filtered_candidates) == 1:  # if index curve maps to a unique un-lagged index
        return next(iter(filtered_candidates))

    for key_word in ('Overnight', 'CDOR', 'ChinaRepo', 'Libor', 'Taibor'):
        filtered_candidates = set(i for i in indices if i.startswith(key_word))
        if len(filtered_candidates) == 1:  # if index curve maps to a unique index name by key word
            return next(iter(filtered_candidates))

    return indices


def default_instrument_type(inst_types: Set[str]) -> Union[str, Set[str]]:
    if len(inst_types) == 1:  # if market data tag maps to a unique instrument type
        return next(iter(inst_types))

    for key_word in ('-Swaption-', '_CCS_Inst_Type', '_Swaption_Inst_Type', '-CashDepo', '-ATMStraddle', '-BF-',
                     'RR-', 'FRA-', '-OIS-', '-IRS-', '-BasisSwap-', '-XccySwap-', '-MeetingTimes', '-Futures-'):
        filtered_candidates = set(i for i in inst_types if key_word in i)
        if len(filtered_candidates) == 1:  # if market data tag maps to a unique instrument type by key word
            return next(iter(filtered_candidates))

    return inst_types


async def _fetch_async():
    from firm_f3.evaluate import f3_evaluate_async, scalar_handler
    f3 = firm_f3.f3client.get_platform_client()

    index_name, instrument_type = await f3_evaluate_async([
        f3.ListMembers('Index'),
        f3.ListMembers('InstrumentType'),
    ], callback=scalar_handler)

    index_curve_name, market_data_tag1, market_data_tag2 = await f3_evaluate_async(
        [f3.ObjectInfo('Index', i, 'UniqueStateVariableIdentifier') for i in index_name],
        [f3.ObjectInfo('InstrumentType', i, 'SpecificDescription') for i in instrument_type],
        [f3.ObjectInfo('InstrumentType', i, 'TypeName') for i in instrument_type],
        callback=scalar_handler
    )

    for idx, idx_curve in zip(index_name, index_curve_name):  # index names are unique
        if isinstance(idx_curve, str):  # if index name maps to a valid index curve
            PLATFORM_INDEX[idx] = idx_curve

    for inst, tag1, tag2 in zip(instrument_type, market_data_tag1, market_data_tag2):  # instrument types are unique
        if isinstance(tag1, str) and isinstance(tag2, str):
            PLATFORM_INSTRUMENT_TYPE[inst] = tag1, tag2

    for idx_curve, idx_candidates in PLATFORM_INDEX.rev.items():
        idx = default_index(idx_candidates)
        if isinstance(idx, str):
            PLATFORM_INDEX_CURVE[idx_curve] = idx

    for tag, inst_candidates in PLATFORM_INSTRUMENT_TYPE.rev.items():
        inst = default_instrument_type(inst_candidates)
        if isinstance(inst, str):
            PLATFORM_MARKET_DATA_TAG[tag] = inst


async def initiate_platform_objects_async():
    if not any([PLATFORM_INDEX, PLATFORM_INSTRUMENT_TYPE]):
        await _fetch_async()


def initiate_platform_objects():
    wait(initiate_platform_objects_async())


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\mapping\product.py
----------------------------------------
import datetime
from functools import singledispatch
from typing import Tuple, Union, List
from f3sdk.f3 import F3Object  # type:ignore

import firm_domain as domain
from firm_domain import Ccy, Tenor, Rate, InflationIndex, Instrument, Swaption, IRSTrade, TRSTrade
import firm_f3.f3client  # type:ignore

from .utils import trade_to_collateral_ccy, ccy_to_f3pair
from .index import f3index
from .instrument import f3instrument_type
from .quote_spec import f3quote_spec
from .security import f3_security_entity


FX_DIGITAL_CALL_SPREAD_WIDTH = 0.001


def f3products_from_instruments(inst: Instrument, *instruments: Tuple[Instrument],
                                valuation_date: datetime.date) -> Union[F3Object, List[F3Object]]:
    if instruments:
        return f3products_from_instruments_many([inst, *instruments], valuation_date=valuation_date)
    return f3products_from_instruments_single(inst, valuation_date=valuation_date)


def f3products_from_instruments_many(instruments: List[Instrument], valuation_date: datetime.date) -> List[F3Object]:
    return [f3products_from_instruments_single(i, valuation_date=valuation_date) for i in instruments]


@singledispatch
def f3products_from_instruments_single(inst: Instrument, valuation_date: datetime.date) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.CreateVanillaMarketProduct(
        TradeDate=valuation_date,
        InstrumentType=f3instrument_type(inst),
        QuoteSpecification=f3quote_spec(inst, valuation_date),
        Quote=0,
    )


@f3products_from_instruments_single.register
def f3products_from_instruments_single_by_swaption(inst: Swaption, valuation_date: datetime.date) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.CreateVanillaMarketProduct(
        TradeDate=valuation_date,
        InstrumentType=f3instrument_type(inst),
        QuoteSpecification=f3quote_spec(inst, valuation_date),
        Quote=None,
        Notional=1,
        PayRec='pay',
    )


def ccy_to_collateral(ccy: Ccy) -> str:
    return f3index(Rate(ccy, Tenor.T_1D))


def f3products(trade, *trades):
    if trades:
        return [f3products_single(t) for t in (trade, *trades)]
    return f3products_single(trade)


@singledispatch
def f3products_single(trade):
    if isinstance(trade, F3Object):
        return trade
    raise TypeError(f'expect Trade object, got type {type(trade)} instead')


F3_CONVENTION_BY_IRS_INSTRUMENT_TYPE = {
    'AUD-IRS-Quarterly-BBSW-3m': ('SwapBBSWQuarterlyFixed', 'BBSW3m', 'SwapBBSW3m'),
    'AUD-IRS-Semi-BBSW-6m': ('SwapBBSWSemiFixed', 'BBSW6m', 'SwapBBSW6mFloating'),
    'USD-IRS-Semi-Libor-1m': ('SwapUSDSemi30360', 'LiborUSD1m', 'SwapUSD1mFloating'),
    'USD-IRS-Semi-Libor-3m': ('SwapUSDSemi30360', 'LiborUSD3m', 'SwapUSD3mFloating'),
    'USD-IRS-Semi-Libor-6m': ('SwapUSDSemi30360', 'LiborUSD6m', 'SwapUSD6mFloating'),
    'EUR-IRS-Annual-Euribor-6m': ('SwapEURAnnual30360', 'Euribor6m', 'SwapEUR6m'),
    'EUR-IRS-Annual-Euribor-3m': ('SwapEURAnnual30360', 'Euribor3m', 'SwapEUR3m'),
    'GBP-IRS-Annual-Libor-3m': ('SwapGBPAnnual', 'LiborGBP3m', 'SwapGBP3mFloating'),
    'GBP-IRS-Semi-Libor-6m': ('SwapGBPSemi', 'LiborGBP6m', 'SwapGBP6mFloating'),
    'NZD-IRS-Semi-BKBM-3m': ('SwapBKBMSemi', 'BKBM3m', 'SwapBKBM3m'),
    'ILS-IRS-Annual-Telbor-3m-Uncollat': ('SwapILSAnnual', 'Telbor3m', 'SwapILS3m'),
    'PLN-IRS-Annual-Wibor-6m': ('SwapPLNAnnual-act/actISDA', 'Wibor6m', 'SwapPLN6m'),
    'HUF-IRS-Annual-Bubor-6m': ('SwapHUFAnnual-act/365f', 'Bubor6m', 'SwapHUF6m'),
    'HKD-IRS-Quarterly-Hibor-3m': ('HKD-IRS-Quarterly-Hibor-3m', 'Hibor3m', 'SwapHKD3m'),
    'JPY-IRS-Semi-Libor-6m': ('SwapJPYSemi', 'LiborJPY6m', 'SwapJPY6m'),
    'CAD-IRS-Semi-CDOR-3m': ('SwapCDORSemi', 'CDOR3mCompounded', 'SwapCDORSemi'),
    'SEK-IRS-Annual-Stibor-3m': ('SwapSEKAnnual-30/360', 'Stibor3m', 'SwapSEK3m'),
    'ZAR-IRS-Quarterly-Jibar-3m-Uncollat': ('SwapZARQuarterly', 'Jibar3m', 'SwapZAR3m'),
    'ZAR-IRS-Quarterly-Jibar-3m': ('SwapZARQuarterly', 'Jibar3m', 'SwapZAR3m'),
    'SAR-IRS-Annual-SAIBOR-3m': ('SwapSARAnnual', 'SAIBOR3m', 'SwapSAR3m'),
    'SGD-IRS-Semi-SOR-6m': ('SwapSGDSemi', 'SOR6m', 'SwapSGD6m'),
    'SGD-IRS-Quarterly-SOR-3m': ('SwapSGDQuarterly', 'SOR3m', 'SwapSGD3m'),
    'HKD-IRS-Quarterly-Hibor-3m-Uncollat': ('SwapHKDQuarterly', 'Hibor3m', 'SwapHKD3m'),
    'KRW-IRS-Quarterly-KRWCD-3m-Uncollat': ('SwapKRWQuarterly', 'KRWCD3m', 'SwapKRW3m'),
    'MYR-IRS-Quarterly-Klibor-3m-Uncollat': ('SwapMYRQuarterly', 'Klibor3m', 'SwapMYR3m'),
    'TWD-IRS-Quarterly-Taibor-3m': ('SwapTWDQuarterly', 'Taibor3m', 'SwapTWD3m'),
    'NTO-IRS-Quarterly-Taibor-3m': ('SwapTWDQuarterly', 'Taibor3m_NTO', 'SwapTWD3m'),
    'THB-IRS-Semi-Bibor-6m-Uncollat': ('SwapTHBSemi', 'Bibor6m', 'SwapTHB6m'),
    'ILS-IRS-Annual-Telbor-3m': ('SwapILSAnnual', 'Telbor3m', 'SwapILS3m'),
    'CNY-IRS-Quarterly-ChinaRepo-7d-Uncollat': ('SwapCNYQuarterly', 'ChinaRepo7dCompounded', 'SwapCNYQuarterly'),
    'CHF-IRS-Annual-Libor-6m': ('SwapCHFAnnual30360', 'LiborCHF6m', 'SwapCHF6m'),
    'NOK-IRS-Annual-Nibor-6m': ('SwapNOKAnnual-30/360', 'Nibor6m', 'SwapNOK6m')
}


@f3products_single.register
def f3products_single_by_irs_trade(trade: domain.IRSTrade):
    f3 = firm_f3.f3client.get_platform_client()
    ins_type = f3instrument_type(domain.IRS(trade.ccy, None, None, idx=trade.idx))
    conv, idx, floating_conv = F3_CONVENTION_BY_IRS_INSTRUMENT_TYPE[ins_type]
    pay_rec = 'pay' if trade.notional < 0 else 'rec'

    collateral_ccy = trade_to_collateral_ccy(trade)
    collateral = ccy_to_collateral(collateral_ccy)
    try:
        margin = trade.spread
    except AttributeError:
        margin = 0

    return f3.CreateCollateralizedProduct(
        UnderlyingProduct=f3.CreateInterestRateSwap(
            StartDate=trade.start,
            Maturity=trade.maturity,
            Notional=abs(trade.notional),
            Currency=str(trade.ccy),
            FixedCoupon=trade.rate,
            MarketConvention=conv,
            FloatingRateIndex=idx,
            Margin=margin,
            PayRec=pay_rec,
            FloatingLegMarketConventions=floating_conv
        ),
        CollateralAgreement=collateral
    )


F3_CONVENTION_BY_OIS_INSTRUMENT_TYPE = {
    'INR-OIS-Annual-Uncollat': ('OISINRAnnual', 'OvernightINRCompounded', 'OISINRAnnual'),
    'INO-OIS-Annual-Uncollat': ('OISINRAnnual', 'OvernightINOCompounded', 'OISINRAnnual'),
    'INR-OIS-Semi-Uncollat': ('OISINRSemi', 'OvernightINRCompounded', 'OISINRSemi'),
    'INO-OIS-Semi-Uncollat': ('OISINRSemi', 'OvernightINOCompounded', 'OISINRSemi'),
    'AUD-OIS': ('SwapBBSWAnnual', 'OvernightAUDCompounded', 'SwapBBSWAnnual'),
    'NZD-OIS': ('SwapBKBMAnnual', 'OvernightNZDCompounded', 'SwapBKBMAnnual'),
    'USD-OIS': ('SwapUSD12m', 'OvernightUSDCompounded', 'SwapUSD12m'),
    'GBP-OIS': ('SwapGBP12m', 'OvernightGBPCompounded', 'SwapGBP12m'),
}


@f3products_single.register
def f3products_single_by_ois_trade(trade: domain.OISTrade):
    f3 = firm_f3.f3client.get_platform_client()
    ins_type = f3instrument_type(domain.OIS(trade.ccy, None, None, trade.fixed_freq))
    conv, idx, floating_conv = F3_CONVENTION_BY_OIS_INSTRUMENT_TYPE[ins_type]
    pay_rec = 'pay' if trade.notional < 0 else 'rec'

    collateral_ccy = trade_to_collateral_ccy(trade)
    collateral = ccy_to_collateral(collateral_ccy)

    return f3.CreateCollateralizedProduct(
        UnderlyingProduct=f3.CreateInterestRateSwap(
            StartDate=trade.start,
            Maturity=trade.maturity,
            Notional=abs(trade.notional),
            Currency=str(trade.ccy),
            FixedCoupon=trade.rate,
            MarketConvention=conv,
            FloatingRateIndex=idx,
            Margin=0,
            PayRec=pay_rec,
            FloatingLegMarketConventions=floating_conv
        ),
        CollateralAgreement=collateral
    )


F3_CCS_CONVENTIONS = {
    Ccy.INR: ('LiborUSD6m', 'SwapINRUSD6m-act/365f', 'FrontBack', 'SwapUSD6mFloating'),
    Ccy.KRW: ('LiborUSD6m', 'SwapKRWUSD3m-act/365f', 'FrontBack', 'SwapKRWUSD6mFloating'),
    Ccy.RUB: ('LiborUSD3m', 'SwapRUBUSDAnn-act/act', 'FrontBack', 'SwapRUBUSD3m-act/360'),
    Ccy.CNH: ('LiborUSD3m', 'SwapCNHUSD3m-act/360', 'FrontBack', 'SwapCNHUSD3m-act/360'),
    Ccy.TRY: ('LiborUSD3m', 'SwapTRYUSDAnn-act/360', 'FrontBack', 'SwapTRYUSD3m-act/360'),
    Ccy.TWD: ('LiborUSD6m', 'SwapTWDUSDA6m-act/365', 'FrontBack', 'SwapTWDUSD6m-act/360'),
}


@f3products_single.register
def f3products_single_by_ccs_trade(trade: domain.CrossCurrencySwapTrade):
    f3 = firm_f3.f3client.get_platform_client()
    direction = 'Rec' if trade.notional < 0 else 'Pay'
    asset_idx, mkt_conv, notional_exch, ccy_conv = F3_CCS_CONVENTIONS[trade.ccy]

    collateral_ccy = trade_to_collateral_ccy(trade)
    collateral = ccy_to_collateral(collateral_ccy)

    return f3.CreateCollateralizedProduct(
        UnderlyingProduct=f3.CreateCrossCurrencySwap(
            StartDate=trade.start,
            Maturity=trade.maturity,
            Notional=abs(trade.notional) / trade.fx_rate,
            FXRateIndex=ccy_to_f3pair(trade.ccy),
            AssetRateIndex=asset_idx,
            AssetMargin=0.,
            MarketConvention=mkt_conv,
            NumeraireRateIndex='ZeroConstant',
            NumeraireMargin=trade.rate,
            ContractFXRate=trade.fx_rate,
            NotionalExchange=notional_exch,
            PayRec=direction,
            AssetCurrencyLegMarketConventions=ccy_conv
        ),
        CollateralAgreement=collateral
    )


F3_XCCY_BASIS_CONVENTIONS = {
    (Ccy.KRW, Ccy.USD): (f3index(Rate(Ccy.KRW, Tenor.T_3M)),
                         'SwapKRWUSD3m-act/365f',
                         f3index(Rate(Ccy.USD, Tenor.T_6M)),
                         'SwapKRWUSD6m-act/360'),
    (Ccy.AUD, Ccy.USD): (f3index(Rate(Ccy.AUD, Tenor.T_3M)),
                         'SwapAUDUSD3m-act/365f',
                         f3index(Rate(Ccy.USD, Tenor.T_3M)),
                         'SwapAUDUSD3m-act/360'),
    (Ccy.GBP, Ccy.USD): (f3index(Rate(Ccy.GBP, Tenor.T_3M)),
                         'SwapGBPUSD3m-act/365f',
                         f3index(Rate(Ccy.USD, Tenor.T_3M)),
                         'SwapGBPUSD3m-act/360'),
    (Ccy.EUR, Ccy.USD): (f3index(Rate(Ccy.EUR, Tenor.T_3M)),
                         'SwapEURUSD3m-act/360',
                         f3index(Rate(Ccy.USD, Tenor.T_3M)),
                         'SwapEURUSD3m-act/360'),
    (Ccy.NZD, Ccy.USD): (f3index(Rate(Ccy.NZD, Tenor.T_3M)),
                         'SwapNZDUSD3m-act/365f',
                         f3index(Rate(Ccy.USD, Tenor.T_3M)),
                         'SwapNZDUSD3m-act/360'),
    (Ccy.JPY, Ccy.USD): (f3index(Rate(Ccy.JPY, Tenor.T_3M)),
                         'SwapJPYUSD3m-act/360',
                         f3index(Rate(Ccy.USD, Tenor.T_3M)),
                         'SwapJPYUSD3m-act/360'),
    (Ccy.CAD, Ccy.USD): ('CDOR3mCompounded',
                         'SwapCADUSD3m-act/365f',
                         f3index(Rate(Ccy.USD, Tenor.T_3M)),
                         'SwapCADUSD3m-act/360'),
    (Ccy.SGD, Ccy.USD): (f3index(Rate(Ccy.SGD, Tenor.T_6M)),
                         'SwapSGDUSD6m-act/365f',
                         f3index(Rate(Ccy.USD, Tenor.T_6M)),
                         'SwapSGDUSD6m-act/360'),
    (Ccy.ZAR, Ccy.USD): (f3index(Rate(Ccy.ZAR, Tenor.T_3M)),
                         'SwapZARUSD3m-act/365f',
                         f3index(Rate(Ccy.USD, Tenor.T_3M)),
                         'SwapZARUSD3m-act/360'),
    (Ccy.SAR, Ccy.USD): (f3index(Rate(Ccy.SAR, Tenor.T_3M)),
                         'SwapSARUSD3m-act/360',
                         f3index(Rate(Ccy.USD, Tenor.T_3M)),
                         'SwapSARUSD3m-act/360'),
    (Ccy.HUF, Ccy.EUR): (f3index(Rate(Ccy.HUF, Tenor.T_3M)),
                         'SwapHUF3m',
                         f3index(Rate(Ccy.EUR, Tenor.T_3M)),
                         'SwapEUR3m'),
    (Ccy.ILS, Ccy.USD): (f3index(Rate(Ccy.ILS, Tenor.T_3M)),
                         'SwapILS3m',
                         f3index(Rate(Ccy.USD, Tenor.T_3M)),
                         'SwapUSD3m'),
    (Ccy.SEK, Ccy.USD): (f3index(Rate(Ccy.SEK, Tenor.T_3M)),
                         'SwapSEK3m',
                         f3index(Rate(Ccy.USD, Tenor.T_3M)),
                         'SwapUSD3m',),
    (Ccy.NOK, Ccy.USD): (f3index(Rate(Ccy.NOK, Tenor.T_3M)),
                         'SwapNOKUSD_Xccy_NOK_Float_Conv',
                         f3index(Rate(Ccy.USD, Tenor.T_3M)),
                         'SwapNOKUSD_Xccy_USD_Float_Conv',),
    (Ccy.SEK, Ccy.EUR): (f3index(Rate(Ccy.SEK, Tenor.T_3M)),
                         'SwapSEK3m',
                         f3index(Rate(Ccy.EUR, Tenor.T_3M)),
                         'SwapEUR3m',),
    (Ccy.PLN, Ccy.EUR): (f3index(Rate(Ccy.PLN, Tenor.T_3M)),
                         'SwapPLN3m',
                         f3index(Rate(Ccy.EUR, Tenor.T_3M)),
                         'SwapEUR3m'),
    (Ccy.HKD, Ccy.USD): (f3index(Rate(Ccy.HKD, Tenor.T_3M)),
                         'SwapHKDUSD3m-act/365f',
                         f3index(Rate(Ccy.USD, Tenor.T_3M)),
                         'SwapHKDUSD3m-act/360'),
    (Ccy.CHF, Ccy.USD): (f3index(Rate(Ccy.CHF, Tenor.T_3M)),
                         'SwapCHFUSD3m-act/360',
                         f3index(Rate(Ccy.USD, Tenor.T_3M)),
                         'SwapCHFUSD3m-act/360'),
}


@f3products_single.register
def f3products_single_by_xccy_basis_trade(trade: domain.XccyBasisTrade):
    f3 = firm_f3.f3client.get_platform_client()
    if trade.is_mtm:
        notional_exchange = 'MarkToMarket'
        direction = 'Rec' if trade.notional > 0 else 'Pay'
        pair = str(trade.ccy) + str(trade.ccy_base)

        idx1, conv1, idx2, conv2 = F3_XCCY_BASIS_CONVENTIONS[trade.ccy, trade.ccy_base]

        collateral_ccy = trade_to_collateral_ccy(trade)
        collateral = ccy_to_collateral(collateral_ccy)

        return f3.CreateCollateralizedProduct(
            UnderlyingProduct=f3.CreateVanillaCrossCurrencySwap(
                StartDate=trade.start,
                Maturity=trade.maturity,
                Notional=abs(trade.notional),
                FXRateIndex=pair,
                MarginLegRateIndex=idx1,
                Margin=trade.rate,
                MarketConventions=conv1,
                OffsettingLegRateIndex=idx2,
                OffsettingLegMarketConventions=conv2,
                NotionalAdjustment=['OffsettingLeg', notional_exchange],
                PayRec=direction
            ),
            CollateralAgreement=collateral
        )
    else:
        notional_exchange = 'FrontBack'
        direction = 'Pay' if trade.notional > 0 else 'Rec'
        pair = str(trade.ccy_base) + str(trade.ccy)

        idx1, conv1, idx2, conv2 = F3_XCCY_BASIS_CONVENTIONS[trade.ccy, trade.ccy_base]

        collateral_ccy = trade_to_collateral_ccy(trade)
        collateral = ccy_to_collateral(collateral_ccy)

        return f3.CreateCollateralizedProduct(
            UnderlyingProduct=f3.CreateCrossCurrencySwap(
                StartDate=trade.start,
                Maturity=trade.maturity,
                Notional=abs(trade.notional) / trade.fx_rate,
                FXRateIndex=pair,
                AssetRateIndex=idx2,
                AssetMargin=0.,
                MarketConvention=conv1,
                NumeraireRateIndex=idx1,
                NumeraireMargin=trade.rate,
                ContractFXRate=trade.fx_rate,
                NotionalExchange=notional_exchange,
                PayRec=direction,
                AssetCurrencyLegMarketConventions=conv2,
            ),
            CollateralAgreement=collateral
        )


@f3products_single.register
def f3products_single_by_fx_forward_trade(trade: domain.FXForwardTrade):
    f3 = firm_f3.f3client.get_platform_client()
    buy_sell = 'rec' if trade.notional > 0 else 'pay'

    collateral_ccy = trade_to_collateral_ccy(trade)
    collateral = ccy_to_collateral(collateral_ccy)

    if trade.ndf:
        f3trade = f3.CreateVanillaFXNonDeliverableForward(
            PaymentDate=trade.value_date,
            PaymentCurrency=str(trade.ccy_base),
            Notional=abs(trade.notional),
            FXRateIndex=ccy_to_f3pair(trade.ccy),
            ContractRate=trade.rate,
            PayRec=buy_sell
        )
    else:
        f3trade = f3.CreateVanillaFXForward(
            PaymentDate=trade.value_date,
            Notional=abs(trade.notional),
            AssetCurrency=str(trade.ccy_base),
            NumeraireCurrency=str(trade.ccy),
            ContractRate=trade.rate,
            PayRec=buy_sell
        )
    return f3.CreateCollateralizedProduct(
        UnderlyingProduct=f3trade,
        CollateralAgreement=collateral
    )


@f3products_single.register
def f3products_single_by_swaption_trade(trade: domain.SwaptionTrade):
    f3 = firm_f3.f3client.get_platform_client()
    underlying: domain.IRSTrade = trade.get_swap()
    conv, idx, floating_conv = F3_CONVENTION_BY_IRS_INSTRUMENT_TYPE[f3instrument_type(domain.IRS(underlying.ccy,
                                                                                                 None, None,
                                                                                                 underlying.idx))]

    buy_sell = 'Sell' if trade.notional < 0 else 'Buy'
    payoff = 'Payer' if trade.swaption_type is domain.SwaptionType.PAYER else 'Receiver'

    und_collateral_ccy = trade_to_collateral_ccy(underlying)
    und_collateral = ccy_to_collateral(und_collateral_ccy)
    collateral_ccy = trade_to_collateral_ccy(trade)
    collateral = ccy_to_collateral(collateral_ccy)

    if trade.cash_settle:
        return f3.CreateCollateralizedProduct(
            UnderlyingProduct=f3.CreateParYieldCashSettledSwaption(
                ExpiryDate=trade.expiry,
                Maturity=trade.maturity,
                Notional=abs(trade.notional),
                Currency=str(trade.ccy),
                Strike=trade.strike,
                Payoff=payoff,
                FixedLegMarketConvention=conv,
                FloatingRateIndex=idx,
                BuySell=buy_sell,
                FloatingLegMarketConvention=floating_conv,
                SwapRateCollateralAgreement=und_collateral
            ),
            CollateralAgreement=collateral
        )

    else:
        return f3.CreateCollateralizedProduct(
            UnderlyingProduct=f3.CreateVanillaInterestRateSwaption(
                Expiry=trade.expiry,
                Maturity=trade.maturity,
                Notional=abs(trade.notional),
                Currency=str(trade.ccy),
                Strike=trade.strike,
                Payoff=payoff,
                FixedLegMarketConvention=conv,
                FloatingRateIndex=idx,
                BuySell=buy_sell,
                FloatingLegMarketConvention=floating_conv,
                SwapCollateralAgreement=und_collateral
            ),
            CollateralAgreement=collateral
        )


@f3products_single.register
def f3products_single_by_cash_flow(cf: domain.CashFlow):
    f3 = firm_f3.f3client.get_platform_client()
    buy_sell = 'pay' if cf.notional < 0 else 'rec'
    return f3.CreateSingleCashflowProduct(
        RollDates=cf.maturity,
        Index=1,
        Notional=abs(cf.notional),
        Currency=str(cf.ccy),
        PayRec=buy_sell
    )


F3_INDIVIDUAL_LEG_CONVENTION_BY_RATE = {
    (Rate(Ccy.USD, Tenor.T_1M), Rate(Ccy.USD, Tenor.T_3M)): ('SwapUSD3mFloating', 'SwapUSD3mFloating'),
    (Rate(Ccy.USD, Tenor.T_3M), Rate(Ccy.USD, Tenor.T_6M)): ('SwapUSD6mFloating', 'SwapUSD6mFloating'),
    (Rate(Ccy.AUD, Tenor.T_1M), Rate(Ccy.AUD, Tenor.T_3M)): ('SwapAUD1mFloating', 'SwapAUD3mFloating'),
    (Rate(Ccy.AUD, Tenor.T_3M), Rate(Ccy.AUD, Tenor.T_6M)): ('SwapAUD3mFloating', 'SwapAUD6mFloating'),
    (Rate(Ccy.EUR, Tenor.T_3M), Rate(Ccy.EUR, Tenor.T_6M)): ('SwapEUR3mFloating', 'SwapEUR6mFloating'),
    (Rate(Ccy.SGD, Tenor.T_3M), Rate(Ccy.SGD, Tenor.T_6M)): ('SwapSGD3m', 'SwapSGD6m'),
    (Rate(Ccy.HKD, Tenor.T_1M), Rate(Ccy.HKD, Tenor.T_3M)): ('SwapHKD1m', 'SwapHKD3mFloating'),
    (Rate(Ccy.NOK, Tenor.T_3M), Rate(Ccy.NOK, Tenor.T_6M)): ('SwapNOK3m', 'SwapNOK6m'),
}


TENOR_BASIS_COMPOUNDED = [
    (Rate(Ccy.USD, Tenor.T_1M), Rate(Ccy.USD, Tenor.T_3M)),
    (Rate(Ccy.USD, Tenor.T_3M), Rate(Ccy.USD, Tenor.T_6M)),
]


def tenor_basis_f3index(rate1, rate2) -> Tuple[str, str]:
    if (rate1, rate2) in TENOR_BASIS_COMPOUNDED:
        return f3index(rate1, is_compounded=True), f3index(rate2, is_compounded=False)
    return f3index(rate1), f3index(rate2)


@f3products_single.register
def f3products_single_by_tenor_basis_trade(trade: domain.TenorBasisTrade):
    f3 = firm_f3.f3client.get_platform_client()
    buy_sell = 'pay' if trade.notional < 0 else 'rec'
    margin_tenor = trade.spread_tenor
    other_tenor = trade.idx_1 if margin_tenor == trade.idx_2 else trade.idx_2

    rate_margin, rate_other = Rate(trade.ccy, margin_tenor), Rate(trade.ccy, other_tenor)
    index_margin, index_other = tenor_basis_f3index(rate_margin, rate_other)
    conv_margin, conv_other = F3_INDIVIDUAL_LEG_CONVENTION_BY_RATE[rate_margin, rate_other]

    collateral_ccy = trade_to_collateral_ccy(trade)
    collateral = ccy_to_collateral(collateral_ccy)

    return f3.CreateCollateralizedProduct(
        UnderlyingProduct=f3.CreateRateBasisSwap(
            StartDate=trade.start,
            Maturity=trade.maturity,
            Notional=abs(trade.notional),
            Currency=str(trade.ccy),
            Margin=trade.rate,
            MarginFloatingRateIndex=index_margin,
            OpposingFloatingRateIndex=index_other,
            PayRec=buy_sell,
            MarginLegMarketConventions=conv_margin,
            OpposingLegMarketConventions=conv_other,
        ),
        CollateralAgreement=collateral
    )


F3_SWAP_INDEX_BY_INFLATION_INDEX = {
    InflationIndex.CPURNSA: 'USCPIDailyLag3m',
    InflationIndex.AUCPI: 'AUCPIQuarterlyLag1q',
    InflationIndex.UKRPI: 'UKRPIMonthlyLag2m'
}

F3_SWAP_FLT_MKT_CONV_BY_INFLATION_INDEX = {
    InflationIndex.CPURNSA: 'InflationSwapUSD12m',
    InflationIndex.AUCPI: 'InflationSwapAUD12m',
    InflationIndex.UKRPI: 'InflationSwapGBP12m'
}

F3_SWAP_FIX_MKT_CONV_BY_INFLATION_INDEX = {
    InflationIndex.CPURNSA: 'InflationSwapUSDAnnual',
    InflationIndex.AUCPI: 'InflationSwapAUDAnnual',
    InflationIndex.UKRPI: 'InflationSwapGBPAnnual'
}


@f3products_single.register
def f3products_single_by_inflation_swap_trade(trade: domain.InflationSwapTrade):
    f3 = firm_f3.f3client.get_platform_client()
    buy_sell = 'rec' if trade.notional < 0 else 'pay'

    collateral_ccy = trade_to_collateral_ccy(trade)
    collateral = ccy_to_collateral(collateral_ccy)

    return f3.CreateCollateralizedProduct(
        UnderlyingProduct=f3.CreateZeroCouponInflationSwap(
            StartDate=trade.start,
            Maturity=trade.maturity,
            Notional=abs(trade.notional),
            ZeroCoupon=trade.rate,
            FixedLegMarketConvention=F3_SWAP_FIX_MKT_CONV_BY_INFLATION_INDEX[trade.index],
            InflationPriceIndex=F3_SWAP_INDEX_BY_INFLATION_INDEX[trade.index],
            InflationLegMarketConvention=F3_SWAP_FLT_MKT_CONV_BY_INFLATION_INDEX[trade.index],
            Margin=None,
            PayRec=buy_sell,

        ),
        CollateralAgreement=collateral
    )


@f3products_single.register
def f3products_single_by_fx_option_trade(trade: domain.FXOptionTrade):
    f3 = firm_f3.f3client.get_platform_client()
    buy_sell = 'Buy' if trade.notional > 0 else 'Sell'
    collateral_ccy = trade_to_collateral_ccy(trade)
    collateral = ccy_to_collateral(collateral_ccy)
    ccy_pair = str(trade.ccy_base) + str(trade.ccy)

    if trade.option_type in (domain.OptionType.DIGITAL_PUT, domain.OptionType.DIGITAL_CALL):
        if trade.option_type is domain.OptionType.DIGITAL_CALL:
            rep_type = domain.OptionType.CALL
            notional_mult = 1
        else:
            rep_type = domain.OptionType.PUT
            notional_mult = -1

        strike_low = trade.strike * (1 - FX_DIGITAL_CALL_SPREAD_WIDTH/2)
        strike_high = trade.strike * (1 + FX_DIGITAL_CALL_SPREAD_WIDTH / 2)

        notional_low = trade.notional * trade.strike / strike_low / FX_DIGITAL_CALL_SPREAD_WIDTH * notional_mult
        notional_high = trade.notional * trade.strike / strike_high / FX_DIGITAL_CALL_SPREAD_WIDTH * notional_mult * -1

        fx_option_low = domain.FXOptionTrade(trade.trade_date, trade.ccy, trade.expiry, strike_low, rep_type,
                                             notional_low, trade.value_date, trade.ccy_base)
        fx_option_high = domain.FXOptionTrade(trade.trade_date, trade.ccy, trade.expiry, strike_high, rep_type,
                                              notional_high, trade.value_date, trade.ccy_base)

        return f3.CreatePortfolioProduct(
            WeightedConstituents=[f3products(fx_option_high), f3products(fx_option_low)]
        )

    else:
        payoff = 'Call' if trade.option_type is domain.OptionType.CALL else 'Put'
        return f3.CreateCollateralizedProduct(
            UnderlyingProduct=f3.CreateEuropeanFXOption(
                FXRate=ccy_pair,
                ExpiryDate=trade.expiry,
                Notional=abs(trade.notional),
                Strike=trade.strike,
                Payoff=payoff,
                BuySell=buy_sell
            ),
            CollateralAgreement=collateral
        )


def get_ccs_index_name(ccy: Ccy, tenor: Tenor) -> str:
    return f'{ccy}_{tenor}_ccs_swaption_index'


def get_ccs_pvbp_index_name(ccy: Ccy, tenor: Tenor) -> str:
    return f'{ccy}_{tenor}_ccs_swaption_pvbp_index'


@f3products_single.register
def f3products_single_by_ccs_swaption_trade(trade: domain.CrossCurrencySwaptionTrade):
    f3 = firm_f3.f3client.get_platform_client()
    buy_sell = 'Buy' if trade.notional > 0 else 'Sell'
    call_put = 'Call' if trade.swaption_type is domain.SwaptionType.PAYER else 'Put'
    tenor = Tenor[f'T_{int(round((trade.maturity - trade.start).days / 365, 0))}Y']

    swap_index = get_ccs_index_name(ccy=trade.ccy, tenor=tenor)
    pvbp_index = get_ccs_pvbp_index_name(ccy=trade.ccy, tenor=tenor)
    eoi = f3.CreateEuropeanOptionIndex(UnderlyingIndex=swap_index,
                                       Strike=trade.strike,
                                       Payoff=call_put)

    collateral_ccy = trade_to_collateral_ccy(trade)
    collateral = ccy_to_collateral(collateral_ccy)

    return f3.CreateCollateralizedProduct(
        UnderlyingProduct=f3.CreateReweightedFlowsProduct(
            Underlying=f3.CreateSingleCashflowProduct(
                RollDates=trade.expiry,
                Index=eoi,
                Notional=abs(trade.notional),
                Currency=str(trade.ccy),
                PayRec=buy_sell
            ),
            WeightIndex=pvbp_index
        ),
        CollateralAgreement=collateral
    )


@f3products_single.register
def f3products_single_by_bond_future_trade(trade: domain.BondFutureTrade):
    # jchi@201910
    # mock bond future to a zero notional cash flow
    mocked_product = domain.CashFlow(trade_date=trade.trade_date, ccy=Ccy.USD, maturity=trade.trade_date, notional=0)
    return f3products_single_by_cash_flow(mocked_product)


@f3products_single.register
def f3products_single_by_bond_trade(trade: domain.BondTrade):
    # sfarrell@202001
    # mock bond future to a zero notional cash flow
    mocked_product = domain.CashFlow(trade_date=trade.trade_date, ccy=Ccy.USD, maturity=trade.trade_date, notional=0)
    return f3products_single_by_cash_flow(mocked_product)


@f3products_single.register
def f3products_single_by_rate_future_trade(trade: domain.RatesFutureTrade):
    # sfarrell@202001
    # mock bond future to a zero notional cash flow
    mocked_product = domain.CashFlow(trade_date=trade.trade_date, ccy=Ccy.USD, maturity=trade.trade_date, notional=0)
    return f3products_single_by_cash_flow(mocked_product)


@f3products_single.register
def f3products_single_by_trs_trade(trade: TRSTrade):
    f3 = firm_f3.f3client.get_platform_client()
    buy_sell = 'Buy' if trade.notional > 0 else 'Sell'
    bond_leg = f3.CreateEquityProduct(Equity=f3_security_entity(trade.underlying),
                                      SettlementDetails=[trade.start, 'NoSchedule'],
                                      SharePrice=trade.price,
                                      NumberOfShares=abs(trade.notional) * trade.underlying.contract_mult,
                                      BuySell=buy_sell)
    temp_irs = IRSTrade(trade_date=trade.trade_date,
                    ccy=trade.ccy_funding,
                    start=trade.start,
                    maturity=trade.maturity,
                    rate= 0,
                    notional=trade.notional / trade.fx_rate * trade.price / 100,
                    idx=trade.idx)

    swap_leg = f3.CreateLegProductFromSwap(Swap=f3products(temp_irs),
                                           ExtractCouponBearingLeg=False,
                                           ExtraFlowsPolicy='FrontBack')

    return f3.CreatePortfolioProduct(WeightedConstituents=[bond_leg, swap_leg])


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\mapping\quote_spec.py
----------------------------------------
from bisect import bisect
from datetime import datetime, timedelta
from functools import singledispatch
from typing import List

import firm_domain as domain
from firm_domain import Tenor, IMMOIS
from firm_domain.datalayer.bbg_mapping import bbg_code


@singledispatch
def calc_quote(inst, quotes) -> float:
    codes = bbg_code(inst)
    return quotes[codes[0]]


@calc_quote.register
def calc_quote_for_bbg_name(bbg_name: str, quotes) -> float:
    return quotes[bbg_name]


@calc_quote.register
def calc_quote_for_immois(inst: IMMOIS, quotes) -> float:
    codes = bbg_code(inst)
    return ((100 - quotes[codes[1]]) - (quotes[codes[0]] / 100)) / 100


@singledispatch
def f3quote_spec(inst, eval_date: datetime = None) -> str:
    if isinstance(inst, str):
        return inst
    raise TypeError(f'expect Union[Tenor, Instrument], got type {type(inst)} instead')


F3_QUOTE_SPEC_BY_TENOR = {
    Tenor.SPOT: '0b',
    Tenor.T_0D: '0b',
    Tenor.T_1D: '1b',
    Tenor.T_2D: '2b',
    Tenor.T_1W: '1w',
    Tenor.T_2W: '2w',
    Tenor.T_3W: '3w',
    Tenor.T_1M: '1m',
    Tenor.T_2M: '2m',
    Tenor.T_3M: '3m',
    Tenor.T_4M: '4m',
    Tenor.T_5M: '5m',
    Tenor.T_6M: '6m',
    Tenor.T_7M: '7m',
    Tenor.T_8M: '8m',
    Tenor.T_9M: '9m',
    Tenor.T_10M: '10m',
    Tenor.T_11M: '11m',
    Tenor.T_1Y: '1y',
    Tenor.T_13M: '13m',
    Tenor.T_14M: '14m',
    Tenor.T_15M: '15m',
    Tenor.T_16M: '16m',
    Tenor.T_17M: '17m',
    Tenor.T_18M: '18m',
    Tenor.T_21M: '21m',
    Tenor.T_2Y: '2y',
    Tenor.T_3Y: '3y',
    Tenor.T_4Y: '4y',
    Tenor.T_5Y: '5y',
    Tenor.T_6Y: '6y',
    Tenor.T_7Y: '7y',
    Tenor.T_8Y: '8y',
    Tenor.T_9Y: '9y',
    Tenor.T_10Y: '10y',
    Tenor.T_11Y: '11y',
    Tenor.T_12Y: '12y',
    Tenor.T_13Y: '13y',
    Tenor.T_14Y: '14y',
    Tenor.T_15Y: '15y',
    Tenor.T_20Y: '20y',
    Tenor.T_25Y: '25y',
    Tenor.T_30Y: '30y',
    Tenor.T_35Y: '35y',
    Tenor.T_40Y: '40y',
    Tenor.T_45Y: '45y',
    Tenor.T_50Y: '50y',
    Tenor.T_60Y: '60y'
}


@f3quote_spec.register
def f3quote_spec_by_tenor(tenor: Tenor, eval_date: datetime = None) -> str:
    # jchi: can this be replaced by str(tenor).lower()?
    return [F3_QUOTE_SPEC_BY_TENOR[tenor]]


# TODO: move to DB or Atom
ECB_DATES = [
    datetime(2009, 1, 15), datetime(2009, 2, 5), datetime(2009, 3, 5), datetime(2009, 4, 2),
    datetime(2009, 5, 7), datetime(2009, 6, 4), datetime(2009, 7, 2), datetime(2009, 8, 6),
    datetime(2009, 9, 3), datetime(2009, 10, 8), datetime(2009, 11, 5), datetime(2009, 12, 3),

    datetime(2010, 1, 14), datetime(2010, 2, 4), datetime(2010, 3, 4), datetime(2010, 4, 8),
    datetime(2010, 5, 6), datetime(2010, 6, 10), datetime(2010, 7, 8), datetime(2010, 8, 5),
    datetime(2010, 9, 2), datetime(2010, 10, 7), datetime(2010, 11, 4), datetime(2010, 12, 2),

    datetime(2011, 1, 13), datetime(2011, 2, 3), datetime(2011, 3, 3), datetime(2011, 4, 7),
    datetime(2011, 5, 5), datetime(2011, 6, 9), datetime(2011, 7, 7), datetime(2011, 8, 4),
    datetime(2011, 9, 8), datetime(2011, 10, 6), datetime(2011, 11, 3), datetime(2011, 12, 8),

    datetime(2012, 1, 12), datetime(2012, 2, 9), datetime(2012, 3, 8), datetime(2012, 4, 4),
    datetime(2012, 5, 3), datetime(2012, 6, 6), datetime(2012, 7, 5), datetime(2012, 8, 2),
    datetime(2012, 9, 6), datetime(2012, 10, 4), datetime(2012, 11, 8), datetime(2012, 12, 6),

    datetime(2013, 1, 10), datetime(2013, 2, 7), datetime(2013, 3, 7), datetime(2013, 4, 4),
    datetime(2013, 5, 2), datetime(2013, 6, 6), datetime(2013, 7, 4), datetime(2013, 8, 1),
    datetime(2013, 9, 5), datetime(2013, 10, 2), datetime(2013, 11, 7), datetime(2013, 12, 5),

    datetime(2014, 1, 9), datetime(2014, 2, 6), datetime(2014, 3, 6), datetime(2014, 4, 3),
    datetime(2014, 5, 8), datetime(2014, 6, 5), datetime(2014, 7, 3), datetime(2014, 8, 7),
    datetime(2014, 9, 4), datetime(2014, 10, 2), datetime(2014, 11, 6), datetime(2014, 12, 4),

    datetime(2015, 1, 22), datetime(2015, 3, 5), datetime(2015, 4, 15), datetime(2015, 6, 3),
    datetime(2015, 7, 16), datetime(2015, 9, 3), datetime(2015, 10, 22), datetime(2015, 12, 3),

    datetime(2016, 1, 21), datetime(2016, 3, 10), datetime(2016, 4, 21), datetime(2016, 6, 2),
    datetime(2016, 7, 21), datetime(2016, 9, 8), datetime(2016, 10, 20), datetime(2016, 12, 8),

    datetime(2017, 1, 19), datetime(2017, 3, 9), datetime(2017, 4, 27), datetime(2017, 6, 8),
    datetime(2017, 7, 20), datetime(2017, 9, 7), datetime(2017, 10, 26), datetime(2017, 12, 14),

    datetime(2018, 1, 25), datetime(2018, 3, 8), datetime(2018, 4, 26), datetime(2018, 6, 14),
    datetime(2018, 7, 26), datetime(2018, 9, 13), datetime(2018, 10, 25), datetime(2018, 12, 13),

    datetime(2019, 1, 24), datetime(2019, 3, 7), datetime(2019, 4, 10), datetime(2019, 6, 6),
    datetime(2019, 7, 25), datetime(2019, 9, 12), datetime(2019, 10, 24), datetime(2019, 12, 12),

    datetime(2020, 1, 23), datetime(2020, 3, 12), datetime(2020, 4, 30), datetime(2020, 6, 4),
    datetime(2020, 7, 16), datetime(2020, 9, 10), datetime(2020, 10, 29), datetime(2020, 12, 10),

    datetime(2021, 1, 2), datetime(2021, 3, 11), datetime(2021, 4, 22), datetime(2021, 6, 10),
    datetime(2021, 7, 22), datetime(2021, 9, 9), datetime(2021, 10, 28), datetime(2021, 12, 16)
]

ECB_MAINTENANCE_START_DATES = [d + timedelta(days=6) for d in ECB_DATES]


@f3quote_spec.register
def f3quote_spec_by_imm(imm: domain.IMM, eval_date: datetime = None) -> str:
    return [domain.next_imm_date_rates(eval_date.date(), imm.ith).strftime('%Y-%m-%d'),
            domain.next_imm_date_rates(eval_date.date(), imm.ith + 1).strftime('%Y-%m-%d')]


@f3quote_spec.register
def f3quote_spec_by_ecb(ecb: domain.ECB, eval_date: datetime = None) -> str:
    curr_i = bisect(ECB_MAINTENANCE_START_DATES, eval_date + timedelta(days=1))
    result_i = curr_i + (ecb.idx - 1)
    return [ECB_MAINTENANCE_START_DATES[result_i].strftime('%Y-%m-%d'),
            ECB_MAINTENANCE_START_DATES[result_i + 1].strftime('%Y-%m-%d')]


@f3quote_spec.register
def f3quote_spec_by_future_expiry(exp: domain.FutureExpiry, eval_date: datetime = None) -> str:
    return [f'ED {exp.month.code()}{str(exp.year)[-2:]}']


@f3quote_spec.register
def f3quote_spec_by_fx_fwd(fwd: domain.FXForward, eval_date: datetime = None) -> str:
    return f3quote_spec_by_tenor(fwd.tenor, eval_date)


@f3quote_spec.register
def f3quote_spec_by_swap(swap: domain.Swap, eval_date: datetime = None) -> str:
    return f3quote_spec_by_tenor(swap.tenor, eval_date)


@f3quote_spec.register
def f3quote_spec_by_immois(immois: domain.IMMOIS, eval_date: datetime = None) -> str:
    return f3quote_spec_by_imm(immois.start, eval_date)


@f3quote_spec.register
def f3quote_spec_by_ecbois(ecbois: domain.ECBOIS, eval_date: datetime = None) -> str:
    return f3quote_spec_by_ecb(ecbois.start, eval_date)


@f3quote_spec.register
def f3quote_spec_by_fra(fra: domain.FRA, eval_date: datetime = None) -> str:
    return f3quote_spec_by_tenor(fra.start, eval_date)


@f3quote_spec.register
def f3quote_spec_by_immfra(immfra: domain.IMMFRA, eval_date: datetime = None) -> str:
    return [f'ED {immfra.start.month.code()}{str(immfra.start.year)[-2:]}']


@f3quote_spec.register
def f3quote_spec_by_rates_future(inst: domain.RatesFuture, eval_date: datetime = None) -> str:
    return f3quote_spec_by_future_expiry(inst.tenor, eval_date)


@f3quote_spec.register
def f3quote_spec_by_rate(rate: domain.Rate, eval_date: datetime = None) -> str:
    return f3quote_spec_by_tenor(rate.tenor, eval_date)


@f3quote_spec.register
def f3quote_spec_by_fx_option(opt: domain.FXOption, eval_date: datetime = None) -> str:
    return f3quote_spec_by_tenor(opt.expiry, eval_date)


@f3quote_spec.register
def f3quote_spec_by_swaption(inst: domain.Swaption, eval_date: datetime = None) -> List:
    return [['ATM', inst.strike, f3quote_spec_by_tenor(inst.expiry, eval_date), f3quote_spec_by_tenor(inst.tenor, eval_date)]]


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\mapping\scenario.py
----------------------------------------
from firm_domain import Ccy


def f3scenario_single(ccy, bump) -> str:
    if isinstance(ccy, str):
        ccy = Ccy[ccy]
    assert isinstance(ccy, Ccy)
    assert isinstance(bump, (float, int))
    if bump == 0:
        return 'IdentityScenario'
    s = 'Up' if bump > 0 else 'Down'
    return f'{ccy}{abs(int(bump*10000))}bp{s}'

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\mapping\seasonality.py
----------------------------------------
from typing import Tuple, List
from firm_domain import InflationIndex

F3_SEASONALITY_INSTRUMENT_TYPE_BY_INFLATION_INDEX = {
    InflationIndex.CPURNSA: (
        'USCPI-Seasonality',
        ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
    ),
    InflationIndex.AUCPI: (
        'AUCPI-Seasonality',
        ['Q1', 'Q2', 'Q3', 'Q4']
    ),
    InflationIndex.UKRPI: (
        'UKRPI-Seasonality',
        ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
    ),
}


def f3seasonality(idx: InflationIndex) -> Tuple[str, List[str]]:
    assert isinstance(idx, InflationIndex)
    return F3_SEASONALITY_INSTRUMENT_TYPE_BY_INFLATION_INDEX[idx]


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\mapping\security.py
----------------------------------------
from functools import singledispatch
from typing import Union, Tuple, List

from firm_domain import Security


def f3_security_entity(sec: Security, *secs: Tuple[Security]) -> Union[str, List[str]]:
    if secs:
        return [f3_security_entity_single(i) for i in (sec, *secs)]
    return f3_security_entity_single(sec)


@singledispatch
def f3_security_entity_single(sec) -> str:
    raise TypeError(f'expect Security, got type {type(sec)} instead')


@f3_security_entity_single.register
def f3_security_entity_single_by_security(sec: Security):
    return sec.name + '_Entity'


@f3_security_entity_single.register
def f3_security_entity_single_by_string(sec: str):
    return sec + '_Entity'


def f3_security_index(sec: Security, *secs: Tuple[Security]) -> Union[str, List[str]]:
    if secs:
        return [f3_security_index_single(i) for i in (sec, *secs)]
    return f3_security_index_single(sec)


@singledispatch
def f3_security_index_single(sec) -> str:
    raise TypeError(f'expect Security, got type {type(sec)} instead')


@f3_security_index_single.register
def f3_security_index_single_by_security(sec: Security):
    return sec.name + '_Index'


@f3_security_index_single.register
def f3_security_index_single_by_string(sec: str):
    return sec + '_Index'

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\mapping\utils.py
----------------------------------------
from firm_domain import Ccy, Trade, IRSTrade, TenorBasisTrade, Conventions, OISTrade


def trade_to_collateral_ccy(trade: Trade) -> Ccy:
    if isinstance(trade, (IRSTrade, TenorBasisTrade, OISTrade)) and \
            trade.ccy in [Ccy.EUR, Ccy.AUD, Ccy.GBP, Ccy.CAD, Ccy.NZD, Ccy.JPY, Ccy.USD, Ccy.SEK, Ccy.ZAR,
                          Ccy.NOK, Ccy.CHF, Ccy.SAR, Ccy.HKD]:
        return trade.ccy
    return Ccy.USD


def ccy_to_f3pair(c: Ccy, rev: bool = False) -> str:
    base = Conventions.get_base_ccy(c)
    if (c < base) ^ rev:
        return str(c) + str(base)
    return str(base) + str(c)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\mapping\__init__.py
----------------------------------------
from .bond import *
from .seasonality import *
from .platform import *
from .market_data import *
from .utils import *
from .index import *
from .instrument import *
from .quote_spec import *
from .discount_curve_tag import *
from .market_convention import *
from .market_data_tag import *
from .instrument_strategy import *
from .product import *
from .security import *

OvernightUSD = Rate(Ccy.USD, Tenor.T_1D)
OvernightEUR = Rate(Ccy.EUR, Tenor.T_1D)
LiborUSD1m = Rate(Ccy.USD, Tenor.T_1M)
LiborUSD3m = Rate(Ccy.USD, Tenor.T_3M)
LiborUSD6m = Rate(Ccy.USD, Tenor.T_6M)
Euribor3m = Rate(Ccy.EUR, Tenor.T_3M)
Euribor6m = Rate(Ccy.EUR, Tenor.T_6M)

__all__ = [k for k, v in globals().items() if getattr(v, '__module__', '').startswith(__name__)]

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\mapping\__pycache__\seasonality.cpython-37.pyc
----------------------------------------
B

    y  d                   @   s    d dl mZmZ d dlmZ ejddddd dd	d
d
dd
ddgfejdddddgfej ddddd dd	d
d
dd
ddgfiZeee	ee	 f d dd Z
e
dkr dS )     ) Tuple List) InflationIndexzUSCPI-Seasonality Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov DeczAUCPI-SeasonalityZQ1ZQ2ZQ3ZQ4zUKRPI-Seasonality) idx returnc             C   s   t | t st t|  S )N) 
isinstancer    AssertionError 1F3_SEASONALITY_INSTRUMENT_TYPE_BY_INFLATION_INDEX)r     r    LE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/mapping/seasonality.py 
f3seasonality   s    r    __main__N) typingr   r   Z
firm_domainr   Z CPURNSAZAUCPIZUKRPIr    strr    __name__r   r   r   r    <module>   s    
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\mapping\__pycache__\utils.cpython-37.pyc
----------------------------------------
B

    y  d                   @   sP   d dl mZmZmZmZmZmZ eed dd Z d
eee	d d d Z
e
d	krLd
S )     ) Ccy Trade IRSTrade TenorBasisTrade 
Conventions OISTrade) trade returnc             C   sZ   t | tttf rT| jtjtj tjtj	tj
tj
tjtj
tjtjtjtjtjg
krT| jS tjS )N) 
isinstancer   r   r    Zccyr   ZEURZAUDZGBPZCADZNZDZJPY USDZSEKZZARZNOKZCHFZSARZHKD)r     r    FE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/mapping/utils.py trade_to_collateral_ccy   s
    (r   F) c revr	   c             C   s6   t  |  }| |k |A r&t|  t|  S t| t|   S )N)r   Zget_base_ccy str)r   r    baser   r   r
    
ccy_to_f3pair   s    
r    __main__N)F)Z
firm_domainr   r   r   r   r   r    r    boolr   r    __name__r   r   r   r
    <module>   s     
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\mapping\__pycache__\__init__.cpython-37.pyc
----------------------------------------
B

    y  d                   @   s    d dl T d dlT d dlT d dlT d dlT d dlT d dlT d dl T d dlT d dl	T d dl
T d dl
T d dlT d dl
T eejej Zeejej Zeejej Zeejej Zeejej Zeejej Zeejej Zdd  e     D  Z dS )    ) *c             C   s&   g | ]\}}t |d d  t r| qS ) 
__module__  )  getattr 
startswith __name__) .0 k v  r
    IE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/mapping/__init__.py 
<listcomp>   s    r
   N)!ZbondZ
seasonality platformZ
market_data utils indexZ
instrumentZ
quote_specZdiscount_curve_tagZmarket_conventionZmarket_data_tagZinstrument_strategy  product securityZRateZCcy USDZTenorZT_1DZOvernightUSDZEURZOvernightEURZT_1MZ
LiborUSD1mZT_3MZ
LiborUSD3mZT_6MZ
LiborUSD6mZ	Euribor3mZ	Euribor6m  globals items  __all__r
   r
   r
   r    <module>   s*   
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\market_data\fixings.py
----------------------------------------
import logging
import asyncio

from firm_f3.datalayer import MarketDataProvider, MarketDataProviderBpipe
from firm_f3.datalayer.datalayer import bbg_code, bdh_async
from typing import Dict, Callable, Optional
from datetime import date, datetime, timedelta

import numpy as np  # type: ignore
import pandas as pd  # type: ignore
from dateutil.relativedelta import relativedelta

from firm_f3.market_data.mdobject import MDObject
from firm_domain.core import Tenor, Ccy
import firm_f3.f3client  # type:ignore
from firm_f3.core.crud import update_or_create_async, MAX_SEMAPHORE_COUNT

from firm_domain import FXForward, Rate, InflationIndex
from firm_f3 import mapping as f3map, fincadutil as fu
import firm_f3.modelconfig as conf
import firm_f3.market_data.marketdata as fm
from f3sdk.lib.coroutine import wait  # type: ignore # Allows to wait for a coroutine to complete.

from firm_f3.util.utils import chunks_dict, timer

logger = logging.getLogger(__name__)
environment_for_fixings: MarketDataProvider = MarketDataProviderBpipe('prd')  # todo: hardcoded

RATES_MAPPING = {
    Ccy.USD: [Tenor.T_1M, Tenor.T_3M, Tenor.T_6M, Tenor.T_1D],
    Ccy.EUR: [Tenor.T_1M, Tenor.T_3M, Tenor.T_6M, Tenor.T_1D],
    Ccy.AUD: [Tenor.T_1M, Tenor.T_3M, Tenor.T_6M, Tenor.T_1D],
    Ccy.GBP: [Tenor.T_3M, Tenor.T_6M, Tenor.T_1D],
    Ccy.KRW: [Tenor.T_3M],
    Ccy.SGD: [Tenor.T_6M, Tenor.T_1D, Tenor.T_3M],
    Ccy.HKD: [Tenor.T_3M, Tenor.T_1D, Tenor.T_1M],
    Ccy.ILS: [Tenor.T_3M, Tenor.T_1D],
    Ccy.CAD: [Tenor.T_3M, Tenor.T_1D],
    Ccy.JPY: [Tenor.T_3M, Tenor.T_6M, Tenor.T_1D],
    Ccy.ZAR: [Tenor.T_3M, Tenor.T_1D],
    Ccy.MYR: [Tenor.T_3M],
    Ccy.TWD: [Tenor.T_3M],
    Ccy.NTO: [Tenor.T_3M],
    Ccy.THB: [Tenor.T_6M],
    Ccy.NZD: [Tenor.T_3M, Tenor.T_1D],
    Ccy.HUF: [Tenor.T_3M, Tenor.T_6M, Tenor.T_1D],
    Ccy.PLN: [Tenor.T_3M, Tenor.T_6M, Tenor.T_1D],
    Ccy.SEK: [Tenor.T_1D, Tenor.T_3M],
    Ccy.INR: [Tenor.T_1D],
    Ccy.INO: [Tenor.T_1D],
    Ccy.NOK: [Tenor.T_1D, Tenor.T_3M, Tenor.T_6M],
    Ccy.CHF: [Tenor.T_1D, Tenor.T_3M, Tenor.T_6M],
    Ccy.CNY: [Tenor.T_7D],
}

CCY_MAPPING = {
    fu.ccy_to_f3pair(Ccy.INR): ('INRRATE CURNCY', 1, False),
    # fu.ccy_to_f3pair(CCY.INO): ('INRRATE CURNCY', 1, False),
    fu.ccy_to_f3pair(Ccy.KRW): ('KOBRUSD INDEX', 1, False),
    fu.ccy_to_f3pair(Ccy.CNY): ('CNYMUSD CURNCY', 1, False),
    fu.ccy_to_f3pair(Ccy.PHP): ('PHFRRATE CURNCY', 1, False),
    fu.ccy_to_f3pair(Ccy.IDR): ('JISDOR CURNCY', 1, False),
    fu.ccy_to_f3pair(Ccy.MYR): ('MYR BNMK CURNCY', 1, False),
    fu.ccy_to_f3pair(Ccy.TWD): ('TWDT1100 INDEX', 1, False),
    # fu.ccy_to_f3pair(Ccy.NTO): ('TWDT1100 INDEX', 1, False),
    fu.ccy_to_f3pair(Ccy.CNH): (bbg_code(FXForward(Ccy.CNH, Tenor.SPOT))[0], 1, fu.ccy_to_f3pair(Ccy.CNH, True)),
    fu.ccy_to_f3pair(Ccy.SGD): (bbg_code(FXForward(Ccy.SGD, Tenor.SPOT))[0], 1, fu.ccy_to_f3pair(Ccy.SGD, True)),
    fu.ccy_to_f3pair(Ccy.HKD): (bbg_code(FXForward(Ccy.HKD, Tenor.SPOT))[0], 1, fu.ccy_to_f3pair(Ccy.HKD, True)),
    fu.ccy_to_f3pair(Ccy.THB): (bbg_code(FXForward(Ccy.THB, Tenor.SPOT))[0], 1, False),
    fu.ccy_to_f3pair(Ccy.EUR): (bbg_code(FXForward(Ccy.EUR, Tenor.SPOT))[0], 1, fu.ccy_to_f3pair(Ccy.EUR, True)),
    fu.ccy_to_f3pair(Ccy.NZD): (bbg_code(FXForward(Ccy.NZD, Tenor.SPOT))[0], 1, fu.ccy_to_f3pair(Ccy.NZD, True)),
    fu.ccy_to_f3pair(Ccy.CAD): (bbg_code(FXForward(Ccy.CAD, Tenor.SPOT))[0], 1, fu.ccy_to_f3pair(Ccy.CAD, True)),
    fu.ccy_to_f3pair(Ccy.GBP): (bbg_code(FXForward(Ccy.GBP, Tenor.SPOT))[0], 1, fu.ccy_to_f3pair(Ccy.GBP, True)),
    fu.ccy_to_f3pair(Ccy.ILS): (bbg_code(FXForward(Ccy.ILS, Tenor.SPOT))[0], 1, fu.ccy_to_f3pair(Ccy.ILS, True)),
    fu.ccy_to_f3pair(Ccy.TRY): (bbg_code(FXForward(Ccy.TRY, Tenor.SPOT))[0], 1, fu.ccy_to_f3pair(Ccy.TRY, True)),
    fu.ccy_to_f3pair(Ccy.MXN): (bbg_code(FXForward(Ccy.MXN, Tenor.SPOT))[0], 1, fu.ccy_to_f3pair(Ccy.MXN, True)),
    fu.ccy_to_f3pair(Ccy.JPY): (bbg_code(FXForward(Ccy.JPY, Tenor.SPOT))[0], 1, fu.ccy_to_f3pair(Ccy.JPY, True)),
    fu.ccy_to_f3pair(Ccy.HUF): (bbg_code(FXForward(Ccy.HUF, Tenor.SPOT))[0], 1, False),
    fu.ccy_to_f3pair(Ccy.PLN): (bbg_code(FXForward(Ccy.PLN, Tenor.SPOT))[0], 1, fu.ccy_to_f3pair(Ccy.PLN, True)),
    fu.ccy_to_f3pair(Ccy.RUB): (bbg_code(FXForward(Ccy.RUB, Tenor.SPOT))[0], 1, fu.ccy_to_f3pair(Ccy.RUB, True)),
    fu.ccy_to_f3pair(Ccy.SEK): (bbg_code(FXForward(Ccy.SEK, Tenor.SPOT))[0], 1, fu.ccy_to_f3pair(Ccy.SEK, True)),
    fu.ccy_to_f3pair(Ccy.ZAR): (bbg_code(FXForward(Ccy.ZAR, Tenor.SPOT))[0], 1, fu.ccy_to_f3pair(Ccy.ZAR, True)),
    fu.ccy_to_f3pair(Ccy.SAR): (bbg_code(FXForward(Ccy.SAR, Tenor.SPOT))[0], 1, fu.ccy_to_f3pair(Ccy.SAR, True)),
    fu.ccy_to_f3pair(Ccy.CHF): (bbg_code(FXForward(Ccy.CHF, Tenor.SPOT))[0], 1, fu.ccy_to_f3pair(Ccy.CHF, True)),
    fu.ccy_to_f3pair(Ccy.NOK): (bbg_code(FXForward(Ccy.NOK, Tenor.SPOT))[0], 1, fu.ccy_to_f3pair(Ccy.NOK, True)),
    fu.ccy_to_f3pair(Ccy.AUD): (bbg_code(FXForward(Ccy.AUD, Tenor.SPOT))[0], 1, fu.ccy_to_f3pair(Ccy.AUD, True))
}


async def get_fixings_data_async(start_date: datetime,
                                 dataprovider: MarketDataProvider,
                                 fix_filter: Callable[[str], bool] = lambda c: True) \
        -> Dict[str, Dict[date, float]]:
    rate_obj = [Rate(c, t) for c, v in RATES_MAPPING.items() for t in v if fix_filter(c.name)]
    ccy_tickers = [v[0] for k, v in CCY_MAPPING.items() if fix_filter(k)]
    with timer('fixings - get rates', logstart=True):
        data_rate = await bdh_async(rate_obj, start=start_date, nan_cleanup_function=lambda df: df,
                                    dataprovider=dataprovider)
    with timer('fixings - get ccy', logstart=True):
        data_ccy = await bdh_async(ccy_tickers, start=start_date, nan_cleanup_function=lambda df: df,
                                   dataprovider=dataprovider)
    with timer('fixings - get infl', logstart=True):
        data_inf = await bdh_async(conf.INFLATION_INDICES, start=start_date, nan_cleanup_function=lambda df: df,
                                   dataprovider=dataprovider)

    fixings_data = {}

    for r, v in data_rate.ffill().items():  # jchi@201911 some fixings are published with 1-day lag, .ffill() the NaNs
        fixings_data[f3map.f3index(r)] = v.dropna(inplace=False).to_dict()

    for r in data_inf.columns:
        fixings_data[fu.f3index_by_inflation_index(r)] = data_inf[r].dropna(inplace=False).to_dict()

    for f, v in CCY_MAPPING.items():
        if not fix_filter(f):
            continue
        data_use = data_ccy[v[0]].dropna(inplace=False) / v[1]
        fixings_data[f] = data_use.to_dict()

        if v[2]:
            data_ccy[v[2]] = 1 / data_use
            fixings_data[v[2]] = data_ccy[v[2]].dropna(inplace=False).to_dict()

    if f3map.ccy_to_f3pair(Ccy.INR) in fixings_data:
        fixings_data[f3map.ccy_to_f3pair(Ccy.INO)] = fixings_data[f3map.ccy_to_f3pair(Ccy.INR)]
    if f3map.ccy_to_f3pair(Ccy.TWD) in fixings_data:
        fixings_data[f3map.ccy_to_f3pair(Ccy.NTO)] = fixings_data[f3map.ccy_to_f3pair(Ccy.TWD)]

    return fixings_data


async def get_fixings_inflation_async(start_date: datetime,
                                      dataprovider: MarketDataProvider) -> Dict[InflationIndex, Dict[datetime, float]]:
    data_inf = await bdh_async(conf.INFLATION_INDICES, start=start_date, nan_cleanup_function=lambda df: df,
                               dataprovider=dataprovider)

    fixings_data = {}
    for r in data_inf.columns:
        fixings_data[r] = data_inf[r].dropna(inplace=False).to_dict()

    return fixings_data


def year_frac(ref_date: date, value_date: date) -> float:
    rd = relativedelta(value_date, ref_date)
    return rd.years + rd.months / 12 + rd.days / 365


def calc_inf_seasonality(ref_date: datetime, index_hist: Dict[datetime, float],
                         inflation_seasonality_years: int = 5, ) -> Dict[int, float]:
    dates = sorted(list(index_hist.keys()))
    changes = {}
    for i in range(1, len(index_hist)):
        changes[dates[i]] = index_hist[dates[i]] / index_hist[dates[i - 1]] - 1
    adj_ref_date = pd.Timestamp(year=ref_date.year, month=ref_date.month, day=1)
    rel_range = {d: changes[d] for d in changes
                 if year_frac(d, adj_ref_date) <= inflation_seasonality_years}
    months = list(set(d.month for d in rel_range))
    seasonality = {m: np.mean([rel_range[d] for d in rel_range if d.month == m]) for m in months}
    avg_seasonality = np.mean(list(seasonality.values()))
    return {m: seasonality[m] - avg_seasonality for m in seasonality}


async def update_fixings_inflation_async(tail: Optional[str],
                                         ref: str,
                                         stream_type,
                                         ref_date: datetime,
                                         dataprovider: MarketDataProvider) -> Dict[str, object]:
    f3 = firm_f3.f3client.get_platform_client()
    if ref_date is None:
        ref_date = pd.Timestamp.today()

    if not tail:
        tail = f'{ref}_{stream_type}'

    sd = ref_date - pd.Timedelta(days=365 * 10)
    fixings = await get_fixings_inflation_async(start_date=sd, dataprovider=dataprovider)

    results = dict()

    for fixings_chunk in chunks_dict(fixings, MAX_SEMAPHORE_COUNT):
        results_keys = []
        results_values = []

        for index, index_fixings in fixings_chunk.items():
            seasonlity = calc_inf_seasonality(ref_date, index_fixings)
            seasonality_ins, seasonality_labels = fu.f3_seasonality_ins_type_by_inf_index(index)
            seasonality_mkt_data = MDObject(f3.CreateLabelledValuesMarketData(seasonality_ins, [float(s)
                                                                                                for s in
                                                                                                seasonlity.values()]))

            mkt_data = {seasonality_ins: seasonality_mkt_data}
            await fm.update_market_data_async(mkt_data=mkt_data,
                                              tail=tail,
                                              ts=datetime.utcnow())

            index_name = fu.f3index_by_inflation_index(index)
            name = f"{index_name}_Fixing_{tail}"
            fix_data = [{'fixing_date': d.isoformat(), 'fixing_value': str(index_fixings[d])} for d in index_fixings]
            new_obj = {'name': name, 'index_name': index_name, 'fixings_data': fix_data}
            results_keys.append(index_name)
            results_values.append(
                update_or_create_async("index_fixings", name, query={"index_name": index_name}, new_obj=new_obj))

        logger.debug(f"waiting for {len(results_values)} coroutines (update_fixings_inflation)")
        results_values = await asyncio.gather(*results_values)
        results.update(dict(zip(results_keys, results_values)))

    return results


def update_fixings(tail: Optional[str] = None, ref: str = 'prd', stream_type='intraday',
                   start_date: datetime = None, ref_date: datetime = None) -> Dict[str, object]:
    return wait(
        update_fixings_async(tail=tail, ref=ref, stream_type=stream_type, start_date=start_date, ref_date=ref_date))


async def update_fixings_async(tail: Optional[str] = None, ref: str = 'prd', stream_type='intraday',
                               start_date: datetime = None, ref_date: datetime = None) -> Dict[str, object]:
    if ref_date is None:
        ref_date = datetime.now()
    if start_date is None:
        start_date = datetime(2019, 1, 1)  # Asia Rate book roughly started from start of 2019

    with timer("Updating fixings", logstart=True):
        fixings_normal = await update_fixings_normal_async(tail=tail, ref=ref, stream_type=stream_type,
                                                           start_date=start_date, dataprovider=environment_for_fixings)
        fixings_inflation = await update_fixings_inflation_async(tail=tail, ref=ref, stream_type=stream_type,
                                                                 ref_date=ref_date,
                                                                 dataprovider=environment_for_fixings)

        return {**fixings_normal, **fixings_inflation}


async def update_fixings_normal_async(tail: Optional[str],
                                      ref: str,
                                      stream_type,
                                      start_date: datetime,
                                      dataprovider: MarketDataProvider) -> Dict[str, object]:
    if not tail:
        tail = f'{ref}_{stream_type}'

    fixings = await get_fixings_data_async(start_date=start_date, dataprovider=dataprovider)

    results = dict()

    for fixings_chunk in chunks_dict(fixings, MAX_SEMAPHORE_COUNT):
        results_keys = []
        results_values = []

        for index_name, index_fixings in fixings_chunk.items():
            name = f"{index_name}_Fixing_{tail}"
            fix_data = [{'fixing_date': d.isoformat(), 'fixing_value': str(index_fixings[d])} for d in index_fixings]
            new_obj = {'name': name, 'index_name': index_name, 'fixings_data': fix_data}
            results_keys.append(index_name)
            results_values.append(
                update_or_create_async("index_fixings", name, query={"index_name": index_name}, new_obj=new_obj))

        logger.debug(f"waiting for {len(results_values)} coroutines (update_fixings_normal)")
        results_values = await asyncio.gather(*results_values)
        results.update(dict(zip(results_keys, results_values)))

    return results

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\market_data\futures.py
----------------------------------------
from datetime import date

from firm_domain import Month


def get_eurodollar_future_bbg_ticker(d: date, today: date):
    # "today" date is needed because blomberg is using simplified ticker notation for futures which expire in this decade
    return get_future_bbg_ticker(d, today, "ED")


def get_ff_future_bbg_ticker(d: date, today: date):
    return get_future_bbg_ticker(d, today, "FF")


def get_future_bbg_ticker(d: date, today: date, bloomberg_prefix: str):
    monthcode = Month(d.month - 1).code()
    this_decade = d.year // 10 == today.year // 10
    if this_decade:
        yearcode = "%i" % (d.year % 10)
    else:
        yearcode = "%02i" % (d.year % 100)
    bbg = f"{bloomberg_prefix}{monthcode}{yearcode} Comdty"

    yearcode = "%02i" % (d.year % 100)
    label = f"ED {monthcode}{yearcode}"
    return bbg, label


def test_get_eurodollar_future_bbg_ticker():
    assert get_eurodollar_future_bbg_ticker(date(2020, 6, 20), date(2020, 1, 7)) == ("EDM0 Comdty", "ED M20")
    assert get_eurodollar_future_bbg_ticker(date(2030, 6, 20), date(2020, 1, 7)) == ("EDM30 Comdty", "ED M30")
    assert get_eurodollar_future_bbg_ticker(date(2007, 3, 20), date(2020, 1, 7)) == ("EDH07 Comdty", "ED H07")

    assert get_ff_future_bbg_ticker(date(2020, 6, 20), date(2020, 1, 7)) == ("FFM0 Comdty", "ED M20")
    assert get_ff_future_bbg_ticker(date(2030, 6, 20), date(2020, 1, 7)) == ("FFM30 Comdty", "ED M30")
    assert get_ff_future_bbg_ticker(date(2007, 3, 20), date(2020, 1, 7)) == ("FFH07 Comdty", "ED H07")

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\market_data\marketdata.py
----------------------------------------
import asyncio
import logging
from datetime import datetime, date, timedelta
from typing import Dict, Any, List, Tuple, Optional, Callable, Mapping

import pandas as pd  # type: ignore
from firm_domain import Ccy, Tenor, FXForward, Swaption, TenorBasis, IRS, Instrument
from firm_domain import Security
from firm_domain.market_date import MarketDate
from firm_domain.util import next_imm_date_rates
from f3sdk.lib.coroutine import wait  # type:ignore

import firm_f3.f3client  # type:ignore
import firm_f3.fincadutil as fu
import firm_f3.modelconfig as conf
from firm_f3.core import endpoints as EP
from firm_f3.core.crud import create_async, update_or_create_async, MAX_SEMAPHORE_COUNT
from firm_f3.datalayer import MarketDataProviderBpipe, MarketDataProvider
from firm_f3.datalayer.datalayer import get_market_data_snapshot_async, get_vol_surface
from firm_f3.evaluate import f3_asset_curve_tag_async
from firm_f3.mapping import f3quote_spec, f3instrument_type, mkt_data_tag_override, f3_security_index
from firm_f3.market_data.futures import get_eurodollar_future_bbg_ticker
from firm_f3.market_data.mdobject import MDObjectBase, MDObject
from firm_f3.util.utils import chunks_dict, timer

logger = logging.getLogger(__name__)

CURVE_MARKET_DATA_OVERRIDES = {
    # XccyBasis(Ccy.KRW, Tenor.T_5Y): {XccyBasis(Ccy.KRW, Tenor.T_2Y): -0.0055,
    #                                  XccyBasis(Ccy.KRW, Tenor.T_3Y): -0.0052,
    #                                  XccyBasis(Ccy.KRW, Tenor.T_5Y): -0.0050,
    #                                  XccyBasis(Ccy.KRW, Tenor.T_10Y): -0.0038},
    # CrossCurrencySwap(Ccy.INR, Tenor.T_5Y): {CrossCurrencySwap(Ccy.INR, Tenor.T_2Y): 0.061125,
    #                                  CrossCurrencySwap(Ccy.INR, Tenor.T_3Y): 0.0626,
    #                                  CrossCurrencySwap(Ccy.INR, Tenor.T_5Y): 0.063575,
    #                                  CrossCurrencySwap(Ccy.INR, Tenor.T_10Y): 0.0616875},
}

FX_FORWARD_DATA_OVERRIDES = {
    # (Ccy.KRW, Ccy.USD): {Tenor.T_1M: -0.72,
    #                      Tenor.T_2M: -1.504,
    #                      Tenor.T_3M: -2.454,
    #                      Tenor.T_6M: -5.229,
    #                      Tenor.T_9M: -8.167,
    #                      Tenor.T_1Y: -11.204
    #                      },
    # (Ccy.PHP, Ccy.USD): {Tenor.T_1M: 0.05,
    #                      Tenor.T_2M: 0.114,
    #                      Tenor.T_3M: 0.171,
    #                      Tenor.T_6M: 0.3525,
    #                      Tenor.T_9M: 0.545,
    #                      Tenor.T_1Y: 0.747,
    #                      Tenor.T_2Y: 1.572
    #                      },
    # (Ccy.INR, Ccy.USD): {Tenor.T_1M: .2275,
    #                      Tenor.T_2M: .4475,
    #                      Tenor.T_3M: .745,
    #                      Tenor.T_6M: 1.5275,
    #                      Tenor.T_9M: 2.3275,
    #                      Tenor.T_1Y: 3.10,
    #                      }
}


def _bps_per_day_to_annuals(x):
    return x / 10000 * (252 ** 0.5)


CCS_VOL_DATA_OVERRIDES = {
    # WARNING these CCS vol marks are updated via model fragment, need to run update_model for it to take effect
    # jchi@20201130 lower vol to 46 bps annual vol
    # jchi@20210302 update vol to 55 bps (according to Tim/Henry)
    Ccy.CNH: {'Default': {'Expiries': ['1y', '2y', '3y', '4y', '5y'],
                          'Strikes': [['ATM', 0]],
                          'Quotes': [[0.0055, 0.0055, 0.0055, 0.0055, 0.0055]]
                          },
              # Tenor.T_2Y: {'Expiries': ['1y', '2y', '3y', '4y', '5y'],
              #              'Strikes': [['ATM', 0]],
              #              'Quotes': [[0.0050, 0.0050, 0.0050, 0.0050, 0.0050]]
              #              },
              # Tenor.T_4Y: {'Expiries': ['1y', '2y', '3y', '4y', '5y'],
              #              'Strikes': [['ATM', 0]],
              #              'Quotes': [[0.0050, 0.0050, 0.0050, 0.0050, 0.0050]]
              #              },
              # Tenor.T_5Y: {'Expiries': ['1y', '2y', '3y', '4y', '5y'],
              #              'Strikes': [['ATM', 0]],
              #              'Quotes': [[0.0050, 0.0050, 0.0050, 0.0050, 0.0050]]
              #              },
              },
    # from JPM as of 2020227
    # jchi@20200624 lower vol by 1 bps each
    # jchi@20200706 lower vol by another 0.5 bps each
    # jchi@20200710 lower vol by another 0.5 bps each
    Ccy.TRY: {'Default': {'Expiries': ['2y', '5y'],
                          'Strikes': [['Rel', -0.04], ['Rel', -0.02], ['ATM', 0], ['Rel', 0.02], ['Rel', 0.04]],
                          'Quotes': [[_bps_per_day_to_annuals(14.7), _bps_per_day_to_annuals(11.6)],
                                     [_bps_per_day_to_annuals(16.3), _bps_per_day_to_annuals(12.1)],
                                     [_bps_per_day_to_annuals(18.0), _bps_per_day_to_annuals(13.2)],
                                     [_bps_per_day_to_annuals(20.0), _bps_per_day_to_annuals(14.8)],
                                     [_bps_per_day_to_annuals(22.0), _bps_per_day_to_annuals(15.9)]],
                          },
              Tenor.T_5Y: {'Expiries': ['2y'],
                           'Strikes': [['Rel', -0.04], ['Rel', -0.02], ['ATM', 0], ['Rel', 0.02], ['Rel', 0.04]],
                           'Quotes': [[_bps_per_day_to_annuals(13.3)],
                                      [_bps_per_day_to_annuals(14.8)],
                                      [_bps_per_day_to_annuals(16.5)],
                                      [_bps_per_day_to_annuals(19.2)],
                                      [_bps_per_day_to_annuals(21.9)]],
                           }
              }
}


def update_all_mkt_data(tail: str, eval_date: MarketDate) -> None:
    wait(update_all_mkt_data_async(tail=tail, eval_date=eval_date))


async def update_all_mkt_data_async(tail: str, eval_date: MarketDate) -> None:
    with timer("update_all_mkt_data_async", logstart=True):
        ts = eval_date.timestamp
        dtprov = MarketDataProviderBpipe('prd')

        mkt_data_filter: Callable[[str], bool] = lambda key: True
        instrument_filter: Callable[[str], bool] = lambda key: True

        data_fx = await get_fx_mkt_data_async(eval_date, dtprov, instrument_filter, mkt_data_filter)
        await update_market_data_async(data_fx, tail, ts)

        data_swaption = await _get_swaption_mkt_data_async(eval_date, mkt_data_filter)
        await update_market_data_async(data_swaption, tail, ts)

        data_futures = await get_futures_mkt_data_async(eval_date, dtprov, mkt_data_filter)
        await update_market_data_async(data_futures, tail, ts)

        data_curve = await get_curve_mkt_data_async(eval_date, dtprov, instrument_filter, mkt_data_filter)
        await update_market_data_async(data_curve, tail, ts)

        data_security = await _get_security_mkt_data_async(eval_date, dtprov)
        await update_market_data_async(data_security, tail, ts)

        # data_ccs_swaption = await _get_ccs_swaption_data_async()
        # await update_market_data_async(data_ccs_swaption)

        data_fxvol = await _get_fx_vol_mkt_data_async(eval_date, dtprov, instrument_filter, mkt_data_filter)
        await update_market_data_async(data_fxvol, tail, ts)

        # data_bond = await get_bond_market_data_async(eval_date, with_prices=True)
        # await update_market_data_async(data_bond, tail, ts, mkt_data_filter)


async def update_market_data_single_async(s: str, tail: str, data: Optional[MDObjectBase], ts: datetime) -> Tuple[
    str, Dict, Dict]:
    mkt_data_stream = await update_or_create_marketdata_stream_async(s, tail)

    market_data_snapshot = None
    if data:
        market_data_snapshot = await create_marketdata_snapshot_async(s=s, tail=tail,
                                                                      mkt_data_stream_slug=mkt_data_stream['slug'],
                                                                      mkt_data=data, timestamp=ts)

    return s, mkt_data_stream, market_data_snapshot


async def update_market_data_async(mkt_data: Mapping[str, MDObjectBase],
                                   tail: str,
                                   ts: datetime) -> None:
    assert all(isinstance(i, MDObjectBase) for i in mkt_data.values())

    for mkt_data_sub in chunks_dict(mkt_data, MAX_SEMAPHORE_COUNT):
        coros = []
        for s, data in mkt_data_sub.items():
            coro = update_market_data_single_async(s, tail, data, ts)
            coros.append(coro)
        logger.debug(f"waiting for {len(coros)} coroutines (update_market_data)")
        await asyncio.gather(*coros)


async def _get_fx_vol_mkt_data_async(eval_date: MarketDate,
                                     dataprovider: MarketDataProvider,
                                     instrument_filter: Callable[[str], bool],
                                     mkt_data_filter: Callable[[str], bool]) -> Mapping[str, MDObject]:
    f3 = firm_f3.f3client.get_platform_client()
    ins: List[Instrument] = conf.get_fx_vol_ins()
    ins = [i for i in ins if instrument_filter(str(i))]
    data = await get_market_data_snapshot_async(ins, eval_date, dataprovider, field='LAST_PRICE')

    df = pd.DataFrame(data=list(data.items()), columns=['instrument', 'quote'])
    df['instrument_type'] = df['instrument'].map(fu.get_instrument_type)
    # df['tenor'] = df['instrument'].map(conf.get_quote_spec)
    df['tenor'] = df['instrument'].map(lambda x: f3quote_spec(x, eval_date.timestamp.replace(tzinfo=None)))
    df['delta'] = df['instrument'].map(lambda x: [fu.fx_delta_to_fincad(x.delta), 'ForwardPremiumDelta'])
    df['quote'] = df['quote'].map(lambda x: [x])
    df['qst'] = df['instrument'].map(fu.get_quote_spec_tenor)
    # df['quote'] = df['instrument'].map(lambda x: 0 if x.strat_type != OPTION_STRAT.STRAD else 0.05)
    df = df.sort_values('qst')

    gb = pd.DataFrame(data=df, columns=['instrument_type', 'tenor', 'quote', 'delta']).groupby('instrument_type')
    mkt_data_lists = {it: d.to_dict(orient='list') for it, d in gb}
    mkt_data = {it: f3.CreateFXOptionMarketData(it, mkt_data_lists[it]['tenor'], mkt_data_lists[it]['quote'], None,
                                                mkt_data_lists[it]['delta']) for it in mkt_data_lists}
    return {k: MDObject(v) for k, v in mkt_data.items() if mkt_data_filter(k)}


async def _get_curve_mkt_data_base_async(eval_date: MarketDate,
                                         dataprovider: MarketDataProvider,
                                         instrument_filter: Callable[[str], bool]) -> Dict[str, Dict[str, List]]:
    ins: List[Instrument] = [i for i in conf.get_curve_ins() if not isinstance(i, FXForward)]
    ins = [i for i in ins if instrument_filter(str(i))]

    raw_data = await get_market_data_snapshot_async(ins, eval_date, dataprovider, field='LAST_PRICE')

    df = pd.DataFrame(data=[(k, [v]) for k, v in raw_data.items()], columns=['instrument', 'quote'])
    df['instrument_type'] = df['instrument'].map(f3instrument_type)
    df['tenor'] = df['instrument'].map(lambda x: f3quote_spec(x, eval_date.timestamp.replace(tzinfo=None)))

    gb = pd.DataFrame(data=df, columns=['instrument_type', 'tenor', 'quote']).groupby('instrument_type')
    mkt_data_lists = {it: d.to_dict(orient='list') for it, d in gb}

    # remove duplicated anchor points (e.g. when a ECB OIS falls into the same start date than an IMM OIS)
    for mkt_data_list in mkt_data_lists.values():
        seen_start_dates = set({})
        dupe_indexes = []
        for i, tenor in enumerate(mkt_data_list["tenor"]):
            if tenor[0] not in seen_start_dates:
                seen_start_dates.add(tenor[0])
            else:
                dupe_indexes.append(i)
        for i in dupe_indexes:
            del mkt_data_list["instrument_type"][i]
            del mkt_data_list["tenor"][i]
            del mkt_data_list["quote"][i]
    return mkt_data_lists


def _get_curve_mkt_data_override(eval_date: datetime, mkt_data_lists: Dict[str, Dict[str, List]],
                                 instrument_filter: Callable[[str], bool]) -> Dict[str, Dict[str, List]]:
    from firm_f3.mapping import f3instrument_type

    def unpack():
        for ccy in (Ccy.SAR, Ccy.ZAR, Ccy.ILS, Ccy.SGD, Ccy.HKD, Ccy.HUF, Ccy.PLN, Ccy.NOK):
            irs_base = IRS(ccy, Tenor.T_5Y)
            ois_basis = TenorBasis(ccy, Tenor.T_5Y, Tenor.T_1D, irs_base.idx)
            key: str = f3instrument_type(irs_base)
            if not instrument_filter(key):
                continue
            tenors = mkt_data_lists[key]['tenor']
            yield f3instrument_type(ois_basis), {
                'tenor': tenors,
                'quote': list(0. for _ in range(len(tenors)))
            }
        for i, d in CURVE_MARKET_DATA_OVERRIDES.items():
            tenors = [f3quote_spec(k, eval_date) for k in d]
            quotes = [v for v in d.values()]
            yield f3instrument_type(i), {
                'tenor': tenors,
                'quote': quotes
            }

    o = dict(unpack())
    return o


async def get_curve_mkt_data_async(eval_date: MarketDate,
                                   dataprovider: MarketDataProvider,
                                   instrument_filter: Callable[[str], bool],
                                   mkt_data_filter: Callable[[str], bool]) \
        -> Dict[str, MDObject]:
    f3 = firm_f3.f3client.get_platform_client()
    mkt_data_base = await _get_curve_mkt_data_base_async(eval_date, dataprovider, instrument_filter)
    mkt_data_override = _get_curve_mkt_data_override(eval_date, mkt_data_base, instrument_filter)
    overridden_mkt_data = {**mkt_data_base, **mkt_data_override}
    # assert len(mkt_data_base) + len(mkt_data_override) == len(overridden_mkt_data)
    o = {it: (f3.CreateMarketData(it, val['tenor'], val['quote'], mkt_data_tag_override(it)), val['tenor'])
         for it, val
         in overridden_mkt_data.items()}
    return {k: MDObject(f3obj, tenors) for k, (f3obj, tenors) in o.items() if mkt_data_filter(k)}


async def get_futures_mkt_data_async(eval_date: MarketDate,
                                     dataprovider: MarketDataProvider,
                                     mkt_data_filter: Callable[[str], bool]) -> Dict[str, MDObject]:
    f3 = firm_f3.f3client.get_platform_client()

    ref_date = date.today() + timedelta(days=7)
    tickers = {}
    for i in range(1, 6):
        code, label = get_eurodollar_future_bbg_ticker(next_imm_date_rates(ref_date, i), ref_date)
        tickers[code] = label

    ins = {'USD-Futures-Libor-3m': tickers}
    bbg = [b for k in ins for b in ins[k]]

    data = await get_market_data_snapshot_async(bbg, eval_date, dataprovider, field='LAST_PRICE')

    mkt_data: Dict[str, MDObject] = {}

    for ins_k, ins_v in ins.items():
        if not mkt_data_filter(ins_k):
            continue
        mats = [ins_v[k] for k in ins_v]
        quotes = [data[k] for k in ins_v]
        mkt_data[ins_k] = MDObject(f3.CreateCurveMarketData(ins_k, mats, quotes), mats)

    return mkt_data


async def _get_swaption_mkt_data_async(eval_date: MarketDate,
                                       mkt_data_filter: Callable[[str], bool]) -> Dict[str, MDObject]:
    f3 = firm_f3.f3client.get_platform_client()
    # todo: eval_date is unused in _get_swaption_mkt_data

    raw_data = get_vol_surface()
    if not raw_data:
        return dict()

    aud_swaption_tag_suffix_6m = 'VanillaPhysicallySettledSwaption'
    aud_swaption_tag_prefix_6m = 'SwaptionInstrument:SwapBBSWSemi:BBSW6m:SwapBBSW6m:{s}'
    aud_swaption_tag_suffix_3m = 'VanillaPhysicallySettledSwaption'
    aud_swaption_tag_prefix_3m = 'SwaptionInstrument:SwapBBSWQuarterly:BBSW3m:SwapBBSW3m:{s}'

    tags = {'AUD': (aud_swaption_tag_prefix_6m, aud_swaption_tag_suffix_6m)}
    swaptions = {'AUD': Swaption(Ccy.AUD, Tenor.T_5Y, Tenor.T_5Y),
                 'EUR': Swaption(Ccy.EUR, Tenor.T_5Y, Tenor.T_5Y),
                 'USD': Swaption(Ccy.USD, Tenor.T_5Y, Tenor.T_5Y),
                 'SAR': Swaption(Ccy.SAR, Tenor.T_5Y, Tenor.T_5Y),
                 'KRW': Swaption(Ccy.KRW, Tenor.T_5Y, Tenor.T_5Y),
                 'JPY': Swaption(Ccy.JPY, Tenor.T_5Y, Tenor.T_5Y),
                 'GBP': Swaption(Ccy.GBP, Tenor.T_5Y, Tenor.T_5Y),
                 'TWD': Swaption(Ccy.TWD, Tenor.T_5Y, Tenor.T_5Y),
                 'NTO': Swaption(Ccy.NTO, Tenor.T_5Y, Tenor.T_5Y),
                 'PLN': Swaption(Ccy.PLN, Tenor.T_5Y, Tenor.T_5Y),
                 }

    tenors = {'AUD': '6m'}
    name = 'mktData_{c}Swaption{t}_ATM{s}'
    mkt_data: Dict[str, MDObject] = {}
    for c in raw_data:
        for s in raw_data[c]['quote']:
            tag = [tags.get(c, None)[0].format(s=s), tags.get(c, None)[1]] if tags.get(c, None) else None
            s_str = str(int(round(s * 10000, 0))).replace('-', '_')
            mkt_data[name.format(c=c, s=s_str, t=tenors.get(c, ''))] = MDObject(f3.CreateCommonStrikeSwaptionMarketData(
                fu.get_instrument_type(swaptions[c]),
                raw_data[c]['expiry'],
                raw_data[c]['tenor'],
                ['ATM', s],
                raw_data[c]['quote'][s],
                None,
                tag))
            if c == 'AUD':
                tag_3m = [aud_swaption_tag_prefix_3m.format(s=s), aud_swaption_tag_suffix_3m]
                mkt_data[name.format(c=c, s=s_str, t='3m')] = MDObject(f3.CreateCommonStrikeSwaptionMarketData(
                    fu.get_instrument_type(Swaption(Ccy.AUD, Tenor.T_1Y, Tenor.T_1Y)),
                    raw_data[c]['expiry'],
                    raw_data[c]['tenor'],
                    ['ATM', s],
                    raw_data[c]['quote'][s],
                    None,
                    tag_3m))
    return {k: v for k, v in mkt_data.items() if mkt_data_filter(k)}


fx_spot_market_data_key: str = 'fx_spot_md'


async def get_fx_mkt_data_async(eval_date: MarketDate,
                                dataprovider: MarketDataProvider,
                                instrument_filter: Callable[[str], bool],
                                mkt_data_filter: Callable[[str], bool]) -> Dict[str, MDObject]:
    f3 = firm_f3.f3client.get_platform_client()
    all_ins = conf.get_curve_ins()
    ins: List[FXForward] = sorted([i for i in all_ins if type(i) == FXForward], key=lambda f: f.tenor)
    ins = [i for i in ins if instrument_filter(str(i))]

    ccys = {(fx.ccy, fx.ccy_base) for fx in ins}
    ins = ins + [FXForward(c, Tenor.SPOT, c_base) for c, c_base in ccys]

    ins = [i for i in ins if instrument_filter(str(i))]

    data = await get_market_data_snapshot_async(ins, eval_date, dataprovider, field='LAST_PRICE')

    spot_pairs = [f'{c_base}{c}' for c, c_base in ccys]
    spot_rates = [data[FXForward(c, Tenor.SPOT, c_base)] for c, c_base in ccys]

    mkt_data = {}
    for c, c_base in ccys:
        if (c, c_base) in FX_FORWARD_DATA_OVERRIDES:
            tenors = [k for k in FX_FORWARD_DATA_OVERRIDES[c, c_base]]
            mats = [fu.f3quote_spec(t, eval_date.timestamp.replace(tzinfo=None)) for t in tenors]
            quotes = [v for v in FX_FORWARD_DATA_OVERRIDES[c, c_base].values()]
        else:
            tenors = [fx.tenor for fx in ins if (fx.ccy == c and fx.ccy_base == c_base and fx.tenor != Tenor.SPOT)]
            mats = [fu.f3quote_spec(t, eval_date.timestamp.replace(tzinfo=None)) for t in tenors]
            quotes = [data[FXForward(c, t, c_base)] - data[FXForward(c, Tenor.SPOT, c_base)] for t in tenors]
        f3_mkt_data = f3.CreateCurveMarketData(fu.ccy_to_fx_inst_type(c, c_base), mats, quotes)
        mkt_data[fu.get_instrument_type(FXForward(c, Tenor.T_1M, c_base))] = f3_mkt_data, mats

    mkt_data[fx_spot_market_data_key] = f3.CreateFXMarketData('UniqueFXRates', 'FXSpotQuotes', spot_pairs,
                                                              spot_rates), spot_pairs

    return {k: MDObject(f3obj, keys) for k, (f3obj, keys) in mkt_data.items() if mkt_data_filter(k)}


# def _get_fixings_data(start_date: datetime = None) -> Dict[str, Dict[pd.Timestamp, float]]:
#     rates = {Ccy.USD: [Tenor.T_1M, Tenor.T_3M, Tenor.T_6M, Tenor.T_1D],
#              Ccy.EUR: [Tenor.T_3M, Tenor.T_6M, Tenor.T_1D],
#              Ccy.AUD: [Tenor.T_3M, Tenor.T_6M, Tenor.T_1D],
#              Ccy.GBP: [Tenor.T_3M, Tenor.T_6M, Tenor.T_1D],
#              Ccy.KRW: [Tenor.T_3M],
#              Ccy.SGD: [Tenor.T_6M],
#              Ccy.HKD: [Tenor.T_3M],
#              Ccy.ILS: [Tenor.T_3M],
#              Ccy.CAD: [Tenor.T_3M, Tenor.T_1D],
#              Ccy.JPY: [Tenor.T_3M, Tenor.T_6M, Tenor.T_1D],
#              Ccy.ZAR: [Tenor.T_3M],
#              Ccy.MYR: [Tenor.T_3M],
#              Ccy.TWD: [Tenor.T_3M],
#              Ccy.NTO: [Tenor.T_3M],
#              Ccy.NZD: [Tenor.T_3M, Tenor.T_1D],
#              Ccy.HUF: [Tenor.T_3M, Tenor.T_6M],
#              Ccy.PLN: [Tenor.T_3M, Tenor.T_6M],
#              Ccy.SEK: [Tenor.T_3M]}
#     ccy = {fu.ccy_to_f3pair(Ccy.INR): ('INRRATE CURNCY', 1, False),
#            fu.ccy_to_f3pair(Ccy.KRW): ('KOBRUSD INDEX', 1, False),
#            fu.ccy_to_f3pair(Ccy.CNY): ('CNYMUSD CURNCY', 1, False),
#            fu.ccy_to_f3pair(Ccy.PHP): ('PHFRRATE CURNCY', 1, False),
#            fu.ccy_to_f3pair(Ccy.IDR): ('JISDOR CURNCY', 1, False),
#            fu.ccy_to_f3pair(Ccy.TWD): ('TWDT1100 INDEX', 1, False),
#            fu.ccy_to_f3pair(Ccy.NTO): ('TWDT1100 INDEX', 1, False),
#            fu.ccy_to_f3pair(Ccy.CNH): (bbg_code(FXForward(Ccy.CNH, Tenor.SPOT)), 1, fu.ccy_to_f3pair(Ccy.CNH, True)),
#            fu.ccy_to_f3pair(Ccy.TRY): (bbg_code(FXForward(Ccy.TRY, Tenor.SPOT)), 1, fu.ccy_to_f3pair(Ccy.TRY, True)),
#            fu.ccy_to_f3pair(Ccy.SGD): (bbg_code(FXForward(Ccy.SGD, Tenor.SPOT)), 1, fu.ccy_to_f3pair(Ccy.SGD, True)),
#            fu.ccy_to_f3pair(Ccy.HKD): (bbg_code(FXForward(Ccy.HKD, Tenor.SPOT)), 1, fu.ccy_to_f3pair(Ccy.HKD, True)),
#            fu.ccy_to_f3pair(Ccy.THB): (bbg_code(FXForward(Ccy.THB, Tenor.SPOT)), 1, False),
#            fu.ccy_to_f3pair(Ccy.EUR): (bbg_code(FXForward(Ccy.EUR, Tenor.SPOT)), 1, fu.ccy_to_f3pair(Ccy.EUR, True)),
#            fu.ccy_to_f3pair(Ccy.NZD): (bbg_code(FXForward(Ccy.NZD, Tenor.SPOT)), 1, fu.ccy_to_f3pair(Ccy.NZD, True)),
#            fu.ccy_to_f3pair(Ccy.CAD): (bbg_code(FXForward(Ccy.CAD, Tenor.SPOT)), 1, fu.ccy_to_f3pair(Ccy.CAD, True)),
#            fu.ccy_to_f3pair(Ccy.GBP): (bbg_code(FXForward(Ccy.GBP, Tenor.SPOT)), 1, fu.ccy_to_f3pair(Ccy.GBP, True)),
#            fu.ccy_to_f3pair(Ccy.ILS): (bbg_code(FXForward(Ccy.ILS, Tenor.SPOT)), 1, False),
#            fu.ccy_to_f3pair(Ccy.JPY): (bbg_code(FXForward(Ccy.JPY, Tenor.SPOT)), 1, fu.ccy_to_f3pair(Ccy.JPY, True)),
#            fu.ccy_to_f3pair(Ccy.HUF): (bbg_code(FXForward(Ccy.HUF, Tenor.SPOT)), 1, False),
#            fu.ccy_to_f3pair(Ccy.PLN): (bbg_code(FXForward(Ccy.PLN, Tenor.SPOT)), 1, fu.ccy_to_f3pair(Ccy.PLN, True)),
#            fu.ccy_to_f3pair(Ccy.RUB): (bbg_code(FXForward(Ccy.RUB, Tenor.SPOT)), 1, fu.ccy_to_f3pair(Ccy.RUB, True)),
#            fu.ccy_to_f3pair(Ccy.SEK): (bbg_code(FXForward(Ccy.SEK, Tenor.SPOT)), 1, fu.ccy_to_f3pair(Ccy.SEK, True)),
#            fu.ccy_to_f3pair(Ccy.ZAR): (bbg_code(FXForward(Ccy.ZAR, Tenor.SPOT)), 1, fu.ccy_to_f3pair(Ccy.ZAR, True)),
#            fu.ccy_to_f3pair(Ccy.AUD): (bbg_code(FXForward(Ccy.AUD, Tenor.SPOT)), 1, fu.ccy_to_f3pair(Ccy.AUD, True))}
#
#     rate_obj = [Rate(c, t) for c in rates for t in rates[c]]
#     data_rate = bdh_async(rate_obj, start=start_date, nan_cleanup_function=lambda df: df)
#
#     ccy_tickers = [ccy[f][0] for f in ccy]
#     data_ccy = bdh_async(ccy_tickers, start=start_date, nan_cleanup_function=lambda df: df)
#
#     fixings_data = {}
#
#     for r in data_rate.columns:
#         fixings_data[fu.rate_to_fincad(r)] = data_rate[r].dropna(inplace=False).to_dict()
#
#     for f in ccy:
#         data_use = data_ccy[ccy[f][0]].dropna(inplace=False) / ccy[f][1]
#         fixings_data[f] = data_use.to_dict()
#
#         if ccy[f][2]:
#             data_ccy[ccy[f][2]] = data_use ** -1
#             fixings_data[ccy[f][2]] = data_ccy[ccy[f][2]].to_dict()
#
#     return fixings_data


# def update_fixings_deprecated(tail: str = 'prd', start_date: pd.Timestamp = None) -> Dict[str, object]:
#     import warnings
#     warnings.warn('use FINCAD.market_data.fixings.update_fixings instead', DeprecationWarning)
#
#     fixings = _get_fixings_data(start_date=start_date)
#     results = {}
#     for index_name in fixings:
#         name = f"{index_name}_Fixing_{tail}"
#         fix_data = [{'fixing_date': d.isoformat(), 'fixing_value': str(fixings[index_name][d])} for d in
#                     fixings[index_name]]
#         new_obj = {'name': name, 'index_name': index_name, 'fixings_data': fix_data}
#         results[index_name] = update_or_create("index_fixings", name, query={"index_name": index_name}, new_obj=new_obj)
#     return results


async def _get_security_mkt_data_async(eval_date: MarketDate,
                                       dataprovider: MarketDataProvider) -> Dict[str, MDObject]:
    f3 = firm_f3.f3client.get_platform_client()
    securities = [s for s in Security]
    mkt_data_base = await get_market_data_snapshot_async(securities, eval_date, dataprovider, field='LAST_PRICE')
    curve_tags = await f3_asset_curve_tag_async(*securities)
    if len(securities) == 1:
        curve_tags = [curve_tags]
    md = f3.CreateEquityMarketData(EquityIndices=f3_security_index(*securities),
                                   SpotPrices=[v for v in mkt_data_base.values()],
                                   MarketDataTagMethods=[[ct[0], 'Stock'] for ct in curve_tags])
    return {'SecurityIndexMarketData': MDObject(md)}


async def update_or_create_marketdata_stream_async(s: str, tail: str) -> Dict[str, Any]:
    name = f"{s}_MktData_stream_{tail}"
    des = f"{s}_MktData_stream_{tail}_description"

    logger.debug(f"update_marketdata_stream(), name: {name}")
    query = {'name': name, 'description': des}
    return await update_or_create_async(EP.MarketDataStream, name=name, new_obj=query)


async def create_marketdata_snapshot_async(s: str,
                                           tail: str,
                                           mkt_data_stream_slug: int,
                                           mkt_data: MDObjectBase,
                                           timestamp: datetime) -> Dict:
    from firm_f3.util.f3ml import to_f3ml
    assert timestamp is not None

    name = f'{s}_MktData_snap_{tail}'
    des = f'{s}_MktData_snap_{tail}_description'

    f3ml = to_f3ml(await mkt_data.f3_mkt_data_object_async())

    new_obj = {'name': name,
               'description': des,
               'format': 'f3ml',
               'ordering_timepoint': timestamp,
               'market_data_stream_slug': str(mkt_data_stream_slug),
               'input_f3ml': f3ml}

    return await create_async(endpoint=EP.MarketDataSnapshot, new_obj=new_obj)

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\market_data\marketdata_placeholder.py
----------------------------------------
import copy
import logging
import datetime
from typing import Dict

import pandas as pd  # type:ignore

from firm_f3.evaluate import f3_asset_curve_tag_async
from firm_f3.model_fragments.model_usd import fx_spot_market_data_key
from firm_domain import (
    Ccy, Tenor, FXForward, Swaption, IRS, FRA, CrossCurrencySwap, OIS, Instrument, FXOption, TenorBasis,
    Security)
import firm_f3.f3client  # type:ignore
from firm_f3.mapping.market_data_tag import mkt_data_tag_override

import firm_f3.fincadutil as fu
import firm_f3.modelconfig as conf
from firm_f3.mapping import f3instrument_type, f3_security_index
from firm_f3.market_data.mdobject import MDObjectBase, MDObject


def __placeholder_quote(instrument: Instrument) -> float:
    if isinstance(instrument, (IRS, FRA, OIS, CrossCurrencySwap, FXOption)):
        return 0.01
    elif isinstance(instrument, FXForward):
        return 0
    else:
        return 0


async def __get_mkt_data_async(ref_date: datetime.datetime) -> Dict[str, MDObject]:
    f3 = firm_f3.f3client.get_platform_client()
    ins = conf.get_curve_ins()
    ccys = {i.ccy for i in ins if i.ccy != Ccy.USD}

    data = [(fu.get_instrument_type(i), fu.get_quote_spec(i, ref_date), __placeholder_quote(i), i,
             getattr(fu.get_quote_spec_tenor(i), 'value', None)  # jchi@20200710 ECB tenor has no value attribute
             ) for i in ins]
    data = sorted([i for i in data if i[4] is not None], key=lambda d: d[4])  # jchi@20200710 filter out invalid values
    gb = pd.DataFrame(data=data, columns=['ins_type', 'maturity', 'quote', 'instrument', 'qst']).groupby('ins_type')
    mkt_data = {it: d.to_dict(orient='list') for it, d in gb}

    mkt_data = {
        it: f3.CreateCurveMarketData(it, mkt_data[it]['maturity'], mkt_data[it]['quote'], mkt_data_tag_override(it))
        for it in mkt_data}

    mkt_data[fx_spot_market_data_key] = f3.CreateFXMarketData(None, None, [fu.ccy_to_f3pair(c) for c in ccys],
                                                              [1 for c in ccys])

    future_maturities = await f3.evaluate(f3.FuturesExpiryList(ref_date, 'Standard', None, 0, 6))
    mkt_data['USD-Futures-Libor-3m'] = f3.CreateCurveMarketData("USD-Futures-Libor-3m", future_maturities,
                                                                [99 for f in future_maturities])
    # jchi@201911
    # CNH CCS Swaption market data is added in model fragment, no need to attach this market data stream to recipe
    # for ccy in conf.CCS_SWAPTION_CCY:
    #     for t in conf.CCS_SWAPTION_TENORS:
    #         ccs_swaption_ins_type = f3instrument_type(CCSSwaption(ccy, Tenor.T_1Y, t))
    #
    #         mkt_data[ccs_swaption_ins_type] = f3.CreateOptionMarketData(InstrumentType=ccs_swaption_ins_type,
    #                                                                     Expiries=['1y'],
    #                                                                     Strikes=[['ATM, 0']],
    #                                                                     Quotes=[[0.005]],
    #                                                                     Payoffs='Call')

    # jchi@201908
    # placeholder to create market data streams, which are then attached to the model recipe
    for ccy in (Ccy.SAR, Ccy.ZAR, Ccy.ILS, Ccy.SGD, Ccy.HKD, Ccy.HUF, Ccy.PLN, Ccy.NOK):
        irs_base = IRS(ccy, Tenor.T_5Y)
        ois_basis = TenorBasis(ccy, Tenor.T_5Y, Tenor.T_1D, irs_base.idx)
        inst = f3instrument_type(ois_basis)
        mkt_data[inst] = f3.CreateCurveMarketData(inst, ['1y'], [0.])
    return {k: MDObject(v) for k, v in mkt_data.items()}


def __get_swaption_md() -> Dict[str, MDObject]:
    f3 = firm_f3.f3client.get_platform_client()
    data_EUR_Swaptions = __get_data_EUR_Swaptions()
    data_PLN_Swaptions = copy.deepcopy(data_EUR_Swaptions)
    data_JPY_Swaptions = copy.deepcopy(data_EUR_Swaptions)
    data_USD_Swaptions = __get_data_USD_Swaptions()
    data_SAR_Swaptions = __get_data_SAR_Swaptions()
    data_AUD_Swaptions = __get_data_AUD_Swaptions()
    data_KRW_Swaptions = __get_data_KRW_Swaptions()
    data_TWD_Swaptions = __get_data_TWD_Swaptions()
    data_NTO_Swaptions = __get_data_NTO_Swaptions()

    eur_swaption = Swaption(Ccy.EUR, Tenor.T_5Y, Tenor.T_5Y)
    pln_swaption = Swaption(Ccy.PLN, Tenor.T_5Y, Tenor.T_5Y)
    jpy_swaption = Swaption(Ccy.JPY, Tenor.T_5Y, Tenor.T_5Y)
    usd_swaption = Swaption(Ccy.USD, Tenor.T_5Y, Tenor.T_5Y)
    sar_swaption = Swaption(Ccy.SAR, Tenor.T_5Y, Tenor.T_5Y)
    krw_swaption = Swaption(Ccy.KRW, Tenor.T_5Y, Tenor.T_5Y)
    twd_swaption = Swaption(Ccy.TWD, Tenor.T_5Y, Tenor.T_5Y)
    nto_swaption = Swaption(Ccy.NTO, Tenor.T_5Y, Tenor.T_5Y)
    aud_swaption_3m = Swaption(Ccy.AUD, Tenor.T_1Y, Tenor.T_1Y)
    aud_swaption_6m = Swaption(Ccy.AUD, Tenor.T_5Y, Tenor.T_5Y)

    mktData_EURSwaption_ATM0 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(eur_swaption),
                                                                       data_EUR_Swaptions['expiry'],
                                                                       data_EUR_Swaptions['tenor'],
                                                                       ['ATM', 0],
                                                                       data_EUR_Swaptions['quote'][0])
    mktData_EURSwaption_ATM25 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(eur_swaption),
                                                                        data_EUR_Swaptions['expiry'],
                                                                        data_EUR_Swaptions['tenor'],
                                                                        ['ATM', 0.0025],
                                                                        data_EUR_Swaptions['quote'][0.0025])
    mktData_EURSwaption_ATM_25 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(eur_swaption),
                                                                         data_EUR_Swaptions['expiry'],
                                                                         data_EUR_Swaptions['tenor'],
                                                                         ['ATM', -0.0025],
                                                                         data_EUR_Swaptions['quote'][-0.0025])
    mktData_EURSwaption_ATM50 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(eur_swaption),
                                                                        data_EUR_Swaptions['expiry'],
                                                                        data_EUR_Swaptions['tenor'],
                                                                        ['ATM', 0.005],
                                                                        data_EUR_Swaptions['quote'][0.005])
    mktData_EURSwaption_ATM_50 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(eur_swaption),
                                                                         data_EUR_Swaptions['expiry'],
                                                                         data_EUR_Swaptions['tenor'],
                                                                         ['ATM', -0.005],
                                                                         data_EUR_Swaptions['quote'][-0.005])
    mktData_EURSwaption_ATM100 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(eur_swaption),
                                                                         data_EUR_Swaptions['expiry'],
                                                                         data_EUR_Swaptions['tenor'],
                                                                         ['ATM', 0.01],
                                                                         data_EUR_Swaptions['quote'][0.01])
    mktData_EURSwaption_ATM_100 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(eur_swaption),
                                                                          data_EUR_Swaptions['expiry'],
                                                                          data_EUR_Swaptions['tenor'],
                                                                          ['ATM', -0.01],
                                                                          data_EUR_Swaptions['quote'][0.01])

    mktData_PLNSwaption_ATM0 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(pln_swaption),
                                                                       data_PLN_Swaptions['expiry'],
                                                                       data_PLN_Swaptions['tenor'],
                                                                       ['ATM', 0],
                                                                       data_PLN_Swaptions['quote'][0])
    mktData_PLNSwaption_ATM25 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(pln_swaption),
                                                                        data_PLN_Swaptions['expiry'],
                                                                        data_PLN_Swaptions['tenor'],
                                                                        ['ATM', 0.0025],
                                                                        data_PLN_Swaptions['quote'][0.0025])
    mktData_PLNSwaption_ATM_25 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(pln_swaption),
                                                                         data_PLN_Swaptions['expiry'],
                                                                         data_PLN_Swaptions['tenor'],
                                                                         ['ATM', -0.0025],
                                                                         data_PLN_Swaptions['quote'][-0.0025])
    mktData_PLNSwaption_ATM50 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(pln_swaption),
                                                                        data_PLN_Swaptions['expiry'],
                                                                        data_PLN_Swaptions['tenor'],
                                                                        ['ATM', 0.005],
                                                                        data_PLN_Swaptions['quote'][0.005])
    mktData_PLNSwaption_ATM_50 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(pln_swaption),
                                                                         data_PLN_Swaptions['expiry'],
                                                                         data_PLN_Swaptions['tenor'],
                                                                         ['ATM', -0.005],
                                                                         data_PLN_Swaptions['quote'][-0.005])
    mktData_PLNSwaption_ATM100 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(pln_swaption),
                                                                         data_PLN_Swaptions['expiry'],
                                                                         data_PLN_Swaptions['tenor'],
                                                                         ['ATM', 0.01],
                                                                         data_PLN_Swaptions['quote'][0.01])
    mktData_PLNSwaption_ATM_100 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(pln_swaption),
                                                                          data_PLN_Swaptions['expiry'],
                                                                          data_PLN_Swaptions['tenor'],
                                                                          ['ATM', -0.01],
                                                                          data_PLN_Swaptions['quote'][0.01])

    mktData_JPYSwaption_ATM0 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(jpy_swaption),
                                                                       data_JPY_Swaptions['expiry'],
                                                                       data_JPY_Swaptions['tenor'],
                                                                       ['ATM', 0],
                                                                       data_JPY_Swaptions['quote'][0])
    mktData_JPYSwaption_ATM25 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(jpy_swaption),
                                                                        data_JPY_Swaptions['expiry'],
                                                                        data_JPY_Swaptions['tenor'],
                                                                        ['ATM', 0.0025],
                                                                        data_JPY_Swaptions['quote'][0.0025])
    mktData_JPYSwaption_ATM_25 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(jpy_swaption),
                                                                         data_JPY_Swaptions['expiry'],
                                                                         data_JPY_Swaptions['tenor'],
                                                                         ['ATM', -0.0025],
                                                                         data_JPY_Swaptions['quote'][-0.0025])
    mktData_JPYSwaption_ATM50 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(jpy_swaption),
                                                                        data_JPY_Swaptions['expiry'],
                                                                        data_JPY_Swaptions['tenor'],
                                                                        ['ATM', 0.005],
                                                                        data_JPY_Swaptions['quote'][0.005])
    mktData_JPYSwaption_ATM_50 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(jpy_swaption),
                                                                         data_JPY_Swaptions['expiry'],
                                                                         data_JPY_Swaptions['tenor'],
                                                                         ['ATM', -0.005],
                                                                         data_JPY_Swaptions['quote'][-0.005])
    mktData_JPYSwaption_ATM100 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(jpy_swaption),
                                                                         data_JPY_Swaptions['expiry'],
                                                                         data_JPY_Swaptions['tenor'],
                                                                         ['ATM', 0.01],
                                                                         data_JPY_Swaptions['quote'][0.01])
    mktData_JPYSwaption_ATM_100 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(jpy_swaption),
                                                                          data_JPY_Swaptions['expiry'],
                                                                          data_JPY_Swaptions['tenor'],
                                                                          ['ATM', -0.01],
                                                                          data_JPY_Swaptions['quote'][0.01])

    mktData_USDSwaption_ATM0 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(usd_swaption),
                                                                       data_USD_Swaptions['expiry'],
                                                                       data_USD_Swaptions['tenor'],
                                                                       ['ATM', 0],
                                                                       data_USD_Swaptions['quote'][0])
    mktData_USDSwaption_ATM25 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(usd_swaption),
                                                                        data_USD_Swaptions['expiry'],
                                                                        data_USD_Swaptions['tenor'],
                                                                        ['ATM', 0.0025],
                                                                        data_USD_Swaptions['quote'][0.0025])
    mktData_USDSwaption_ATM_25 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(usd_swaption),
                                                                         data_USD_Swaptions['expiry'],
                                                                         data_USD_Swaptions['tenor'],
                                                                         ['ATM', -0.0025],
                                                                         data_USD_Swaptions['quote'][-0.0025])
    mktData_USDSwaption_ATM50 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(usd_swaption),
                                                                        data_USD_Swaptions['expiry'],
                                                                        data_USD_Swaptions['tenor'],
                                                                        ['ATM', 0.005],
                                                                        data_USD_Swaptions['quote'][0.005])
    mktData_USDSwaption_ATM_50 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(usd_swaption),
                                                                         data_USD_Swaptions['expiry'],
                                                                         data_USD_Swaptions['tenor'],
                                                                         ['ATM', -0.005],
                                                                         data_USD_Swaptions['quote'][-0.005])
    mktData_USDSwaption_ATM100 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(usd_swaption),
                                                                         data_USD_Swaptions['expiry'],
                                                                         data_USD_Swaptions['tenor'],
                                                                         ['ATM', 0.01],
                                                                         data_USD_Swaptions['quote'][0.01])
    mktData_USDSwaption_ATM_100 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(usd_swaption),
                                                                          data_USD_Swaptions['expiry'],
                                                                          data_USD_Swaptions['tenor'],
                                                                          ['ATM', -0.01],
                                                                          data_USD_Swaptions['quote'][0.01])

    mktData_SARSwaption_ATM0 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(sar_swaption),
                                                                       data_SAR_Swaptions['expiry'],
                                                                       data_SAR_Swaptions['tenor'],
                                                                       ['ATM', 0],
                                                                       data_SAR_Swaptions['quote'][0])
    mktData_SARSwaption_ATM25 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(sar_swaption),
                                                                        data_SAR_Swaptions['expiry'],
                                                                        data_SAR_Swaptions['tenor'],
                                                                        ['ATM', 0.0025],
                                                                        data_SAR_Swaptions['quote'][0.0025])
    mktData_SARSwaption_ATM_25 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(sar_swaption),
                                                                         data_SAR_Swaptions['expiry'],
                                                                         data_SAR_Swaptions['tenor'],
                                                                         ['ATM', -0.0025],
                                                                         data_SAR_Swaptions['quote'][-0.0025])
    mktData_SARSwaption_ATM50 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(sar_swaption),
                                                                        data_SAR_Swaptions['expiry'],
                                                                        data_SAR_Swaptions['tenor'],
                                                                        ['ATM', 0.005],
                                                                        data_SAR_Swaptions['quote'][0.005])
    mktData_SARSwaption_ATM_50 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(sar_swaption),
                                                                         data_SAR_Swaptions['expiry'],
                                                                         data_SAR_Swaptions['tenor'],
                                                                         ['ATM', -0.005],
                                                                         data_SAR_Swaptions['quote'][-0.005])
    mktData_SARSwaption_ATM100 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(sar_swaption),
                                                                         data_SAR_Swaptions['expiry'],
                                                                         data_SAR_Swaptions['tenor'],
                                                                         ['ATM', 0.01],
                                                                         data_SAR_Swaptions['quote'][0.01])
    mktData_SARSwaption_ATM_100 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(sar_swaption),
                                                                          data_SAR_Swaptions['expiry'],
                                                                          data_SAR_Swaptions['tenor'],
                                                                          ['ATM', -0.01],
                                                                          data_SAR_Swaptions['quote'][0.01])

    AUD_Swaption_Tag_suffix_6m = 'VanillaPhysicallySettledSwaption'
    AUD_Swaption_Tag_prefix_6m = 'SwaptionInstrument:SwapBBSWSemi:BBSW6m:SwapBBSW6m:{s}'
    AUD_Swaption_Tag_suffix_3m = 'VanillaPhysicallySettledSwaption'
    AUD_Swaption_Tag_prefix_3m = 'SwaptionInstrument:SwapBBSWQuarterly:BBSW3m:SwapBBSW3m:{s}'

    mktData_AUDSwaption3m_ATM0 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(aud_swaption_3m),
                                                                         data_AUD_Swaptions['expiry'],
                                                                         data_AUD_Swaptions['tenor'],
                                                                         ['ATM', 0],
                                                                         data_AUD_Swaptions['quote'][0],
                                                                         None,
                                                                         [AUD_Swaption_Tag_prefix_3m.format(s='0.0'),
                                                                          AUD_Swaption_Tag_suffix_3m])
    mktData_AUDSwaption3m_ATM25 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(aud_swaption_3m),
                                                                          data_AUD_Swaptions['expiry'],
                                                                          data_AUD_Swaptions['tenor'],
                                                                          ['ATM', 0.0025],
                                                                          data_AUD_Swaptions['quote'][0.0025],
                                                                          None,
                                                                          [AUD_Swaption_Tag_prefix_3m.format(
                                                                              s='0.0025'),
                                                                              AUD_Swaption_Tag_suffix_3m])
    mktData_AUDSwaption3m_ATM_25 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(aud_swaption_3m),
                                                                           data_AUD_Swaptions['expiry'],
                                                                           data_AUD_Swaptions['tenor'],
                                                                           ['ATM', -0.0025],
                                                                           data_AUD_Swaptions['quote'][-0.0025],
                                                                           None,
                                                                           [AUD_Swaption_Tag_prefix_3m.format(
                                                                               s='-0.0025'),
                                                                               AUD_Swaption_Tag_suffix_3m])
    mktData_AUDSwaption3m_ATM50 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(aud_swaption_3m),
                                                                          data_AUD_Swaptions['expiry'],
                                                                          data_AUD_Swaptions['tenor'],
                                                                          ['ATM', 0.005],
                                                                          data_AUD_Swaptions['quote'][0.005],
                                                                          None,
                                                                          [AUD_Swaption_Tag_prefix_3m.format(s='0.005'),
                                                                           AUD_Swaption_Tag_suffix_3m])
    mktData_AUDSwaption3m_ATM_50 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(aud_swaption_3m),
                                                                           data_AUD_Swaptions['expiry'],
                                                                           data_AUD_Swaptions['tenor'],
                                                                           ['ATM', -0.005],
                                                                           data_AUD_Swaptions['quote'][-0.005],
                                                                           None,
                                                                           [AUD_Swaption_Tag_prefix_3m.format(
                                                                               s='-0.005'),
                                                                               AUD_Swaption_Tag_suffix_3m])
    mktData_AUDSwaption3m_ATM100 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(aud_swaption_3m),
                                                                           data_AUD_Swaptions['expiry'],
                                                                           data_AUD_Swaptions['tenor'],
                                                                           ['ATM', 0.01],
                                                                           data_AUD_Swaptions['quote'][0.01],
                                                                           None,
                                                                           [AUD_Swaption_Tag_prefix_3m.format(s='0.01'),
                                                                            AUD_Swaption_Tag_suffix_3m])
    mktData_AUDSwaption3m_ATM_100 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(aud_swaption_3m),
                                                                            data_AUD_Swaptions['expiry'],
                                                                            data_AUD_Swaptions['tenor'],
                                                                            ['ATM', -0.01],
                                                                            data_AUD_Swaptions['quote'][0.01],
                                                                            None,
                                                                            [AUD_Swaption_Tag_prefix_3m.format(
                                                                                s='-0.01'),
                                                                                AUD_Swaption_Tag_suffix_3m])
    mktData_AUDSwaption6m_ATM0 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(aud_swaption_6m),
                                                                         data_AUD_Swaptions['expiry'],
                                                                         data_AUD_Swaptions['tenor'],
                                                                         ['ATM', 0],
                                                                         data_AUD_Swaptions['quote'][0],
                                                                         None,
                                                                         [AUD_Swaption_Tag_prefix_6m.format(s='0.0'),
                                                                          AUD_Swaption_Tag_suffix_6m])
    mktData_AUDSwaption6m_ATM25 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(aud_swaption_6m),
                                                                          data_AUD_Swaptions['expiry'],
                                                                          data_AUD_Swaptions['tenor'],
                                                                          ['ATM', 0.0025],
                                                                          data_AUD_Swaptions['quote'][0.0025],
                                                                          None,
                                                                          [AUD_Swaption_Tag_prefix_6m.format(
                                                                              s='0.0025'),
                                                                              AUD_Swaption_Tag_suffix_6m])
    mktData_AUDSwaption6m_ATM_25 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(aud_swaption_6m),
                                                                           data_AUD_Swaptions['expiry'],
                                                                           data_AUD_Swaptions['tenor'],
                                                                           ['ATM', -0.0025],
                                                                           data_AUD_Swaptions['quote'][-0.0025],
                                                                           None,
                                                                           [AUD_Swaption_Tag_prefix_6m.format(
                                                                               s='-0.0025'),
                                                                               AUD_Swaption_Tag_suffix_6m])
    mktData_AUDSwaption6m_ATM50 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(aud_swaption_6m),
                                                                          data_AUD_Swaptions['expiry'],
                                                                          data_AUD_Swaptions['tenor'],
                                                                          ['ATM', 0.005],
                                                                          data_AUD_Swaptions['quote'][0.005],
                                                                          None,
                                                                          [AUD_Swaption_Tag_prefix_6m.format(s='0.005'),
                                                                           AUD_Swaption_Tag_suffix_6m])
    mktData_AUDSwaption6m_ATM_50 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(aud_swaption_6m),
                                                                           data_AUD_Swaptions['expiry'],
                                                                           data_AUD_Swaptions['tenor'],
                                                                           ['ATM', -0.005],
                                                                           data_AUD_Swaptions['quote'][-0.005],
                                                                           None,
                                                                           [AUD_Swaption_Tag_prefix_6m.format(
                                                                               s='-0.005'),
                                                                               AUD_Swaption_Tag_suffix_6m])
    mktData_AUDSwaption6m_ATM100 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(aud_swaption_6m),
                                                                           data_AUD_Swaptions['expiry'],
                                                                           data_AUD_Swaptions['tenor'],
                                                                           ['ATM', 0.01],
                                                                           data_AUD_Swaptions['quote'][0.01],
                                                                           None,
                                                                           [AUD_Swaption_Tag_prefix_6m.format(s='0.01'),
                                                                            AUD_Swaption_Tag_suffix_6m])
    mktData_AUDSwaption6m_ATM_100 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(aud_swaption_6m),
                                                                            data_AUD_Swaptions['expiry'],
                                                                            data_AUD_Swaptions['tenor'],
                                                                            ['ATM', -0.01],
                                                                            data_AUD_Swaptions['quote'][0.01],
                                                                            None,
                                                                            [AUD_Swaption_Tag_prefix_6m.format(
                                                                                s='-0.01'),
                                                                                AUD_Swaption_Tag_suffix_6m])

    mktData_KRWSwaption_ATM0 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(krw_swaption),
                                                                       data_KRW_Swaptions['expiry'],
                                                                       data_KRW_Swaptions['tenor'],
                                                                       ['ATM', 0],
                                                                       data_KRW_Swaptions['quote'][0])
    mktData_KRWSwaption_ATM25 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(krw_swaption),
                                                                        data_KRW_Swaptions['expiry'],
                                                                        data_KRW_Swaptions['tenor'],
                                                                        ['ATM', 0.0025],
                                                                        data_KRW_Swaptions['quote'][0.0025])
    mktData_KRWSwaption_ATM_25 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(krw_swaption),
                                                                         data_KRW_Swaptions['expiry'],
                                                                         data_KRW_Swaptions['tenor'],
                                                                         ['ATM', -0.0025],
                                                                         data_KRW_Swaptions['quote'][-0.0025])
    mktData_KRWSwaption_ATM50 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(krw_swaption),
                                                                        data_KRW_Swaptions['expiry'],
                                                                        data_KRW_Swaptions['tenor'],
                                                                        ['ATM', 0.005],
                                                                        data_KRW_Swaptions['quote'][0.005])
    mktData_KRWSwaption_ATM_50 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(krw_swaption),
                                                                         data_KRW_Swaptions['expiry'],
                                                                         data_KRW_Swaptions['tenor'],
                                                                         ['ATM', -0.005],
                                                                         data_KRW_Swaptions['quote'][-0.005])
    mktData_KRWSwaption_ATM100 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(krw_swaption),
                                                                         data_KRW_Swaptions['expiry'],
                                                                         data_KRW_Swaptions['tenor'],
                                                                         ['ATM', 0.01],
                                                                         data_KRW_Swaptions['quote'][0.01])
    mktData_KRWSwaption_ATM_100 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(krw_swaption),
                                                                          data_KRW_Swaptions['expiry'],
                                                                          data_KRW_Swaptions['tenor'],
                                                                          ['ATM', -0.01],
                                                                          data_KRW_Swaptions['quote'][0.01])

    mktData_TWDSwaption_ATM0 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(twd_swaption),
                                                                       data_TWD_Swaptions['expiry'],
                                                                       data_TWD_Swaptions['tenor'],
                                                                       ['ATM', 0],
                                                                       data_TWD_Swaptions['quote'][0])
    mktData_TWDSwaption_ATM25 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(twd_swaption),
                                                                        data_TWD_Swaptions['expiry'],
                                                                        data_TWD_Swaptions['tenor'],
                                                                        ['ATM', 0.0025],
                                                                        data_TWD_Swaptions['quote'][0.0025])
    mktData_TWDSwaption_ATM_25 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(twd_swaption),
                                                                         data_TWD_Swaptions['expiry'],
                                                                         data_TWD_Swaptions['tenor'],
                                                                         ['ATM', -0.0025],
                                                                         data_TWD_Swaptions['quote'][-0.0025])
    mktData_TWDSwaption_ATM50 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(twd_swaption),
                                                                        data_TWD_Swaptions['expiry'],
                                                                        data_TWD_Swaptions['tenor'],
                                                                        ['ATM', 0.005],
                                                                        data_TWD_Swaptions['quote'][0.005])
    mktData_TWDSwaption_ATM_50 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(twd_swaption),
                                                                         data_TWD_Swaptions['expiry'],
                                                                         data_TWD_Swaptions['tenor'],
                                                                         ['ATM', -0.005],
                                                                         data_TWD_Swaptions['quote'][-0.005])
    mktData_TWDSwaption_ATM100 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(twd_swaption),
                                                                         data_TWD_Swaptions['expiry'],
                                                                         data_TWD_Swaptions['tenor'],
                                                                         ['ATM', 0.01],
                                                                         data_TWD_Swaptions['quote'][0.01])
    mktData_TWDSwaption_ATM_100 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(twd_swaption),
                                                                          data_TWD_Swaptions['expiry'],
                                                                          data_TWD_Swaptions['tenor'],
                                                                          ['ATM', -0.01],
                                                                          data_TWD_Swaptions['quote'][0.01])

    mktData_NTOSwaption_ATM0 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(nto_swaption),
                                                                       data_NTO_Swaptions['expiry'],
                                                                       data_NTO_Swaptions['tenor'],
                                                                       ['ATM', 0],
                                                                       data_NTO_Swaptions['quote'][0])
    mktData_NTOSwaption_ATM25 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(nto_swaption),
                                                                        data_NTO_Swaptions['expiry'],
                                                                        data_NTO_Swaptions['tenor'],
                                                                        ['ATM', 0.0025],
                                                                        data_NTO_Swaptions['quote'][0.0025])
    mktData_NTOSwaption_ATM_25 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(nto_swaption),
                                                                         data_NTO_Swaptions['expiry'],
                                                                         data_NTO_Swaptions['tenor'],
                                                                         ['ATM', -0.0025],
                                                                         data_NTO_Swaptions['quote'][-0.0025])
    mktData_NTOSwaption_ATM50 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(nto_swaption),
                                                                        data_NTO_Swaptions['expiry'],
                                                                        data_NTO_Swaptions['tenor'],
                                                                        ['ATM', 0.005],
                                                                        data_NTO_Swaptions['quote'][0.005])
    mktData_NTOSwaption_ATM_50 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(nto_swaption),
                                                                         data_NTO_Swaptions['expiry'],
                                                                         data_NTO_Swaptions['tenor'],
                                                                         ['ATM', -0.005],
                                                                         data_NTO_Swaptions['quote'][-0.005])
    mktData_NTOSwaption_ATM100 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(nto_swaption),
                                                                         data_NTO_Swaptions['expiry'],
                                                                         data_NTO_Swaptions['tenor'],
                                                                         ['ATM', 0.01],
                                                                         data_NTO_Swaptions['quote'][0.01])
    mktData_NTOSwaption_ATM_100 = f3.CreateCommonStrikeSwaptionMarketData(fu.get_instrument_type(nto_swaption),
                                                                          data_NTO_Swaptions['expiry'],
                                                                          data_NTO_Swaptions['tenor'],
                                                                          ['ATM', -0.01],
                                                                          data_NTO_Swaptions['quote'][0.01])

    swaption_md = {'mktData_EURSwaption_ATM0': mktData_EURSwaption_ATM0,
                   'mktData_EURSwaption_ATM25': mktData_EURSwaption_ATM25,
                   'mktData_EURSwaption_ATM_25': mktData_EURSwaption_ATM_25,
                   'mktData_EURSwaption_ATM50': mktData_EURSwaption_ATM50,
                   'mktData_EURSwaption_ATM_50': mktData_EURSwaption_ATM_50,
                   'mktData_EURSwaption_ATM100': mktData_EURSwaption_ATM100,
                   'mktData_EURSwaption_ATM_100': mktData_EURSwaption_ATM_100,
                   'mktData_PLNSwaption_ATM0': mktData_PLNSwaption_ATM0,
                   'mktData_PLNSwaption_ATM25': mktData_PLNSwaption_ATM25,
                   'mktData_PLNSwaption_ATM_25': mktData_PLNSwaption_ATM_25,
                   'mktData_PLNSwaption_ATM50': mktData_PLNSwaption_ATM50,
                   'mktData_PLNSwaption_ATM_50': mktData_PLNSwaption_ATM_50,
                   'mktData_PLNSwaption_ATM100': mktData_PLNSwaption_ATM100,
                   'mktData_PLNSwaption_ATM_100': mktData_PLNSwaption_ATM_100,
                   'mktData_JPYSwaption_ATM0': mktData_JPYSwaption_ATM0,
                   'mktData_JPYSwaption_ATM25': mktData_JPYSwaption_ATM25,
                   'mktData_JPYSwaption_ATM_25': mktData_JPYSwaption_ATM_25,
                   'mktData_JPYSwaption_ATM50': mktData_JPYSwaption_ATM50,
                   'mktData_JPYSwaption_ATM_50': mktData_JPYSwaption_ATM_50,
                   'mktData_JPYSwaption_ATM100': mktData_JPYSwaption_ATM100,
                   'mktData_JPYSwaption_ATM_100': mktData_JPYSwaption_ATM_100,
                   'mktData_USDSwaption_ATM0': mktData_USDSwaption_ATM0,
                   'mktData_USDSwaption_ATM25': mktData_USDSwaption_ATM25,
                   'mktData_USDSwaption_ATM_25': mktData_USDSwaption_ATM_25,
                   'mktData_USDSwaption_ATM50': mktData_USDSwaption_ATM50,
                   'mktData_USDSwaption_ATM_50': mktData_USDSwaption_ATM_50,
                   'mktData_USDSwaption_ATM100': mktData_USDSwaption_ATM100,
                   'mktData_USDSwaption_ATM_100': mktData_USDSwaption_ATM_100,
                   'mktData_SARSwaption_ATM0': mktData_SARSwaption_ATM0,
                   'mktData_SARSwaption_ATM25': mktData_SARSwaption_ATM25,
                   'mktData_SARSwaption_ATM_25': mktData_SARSwaption_ATM_25,
                   'mktData_SARSwaption_ATM50': mktData_SARSwaption_ATM50,
                   'mktData_SARSwaption_ATM_50': mktData_SARSwaption_ATM_50,
                   'mktData_SARSwaption_ATM100': mktData_SARSwaption_ATM100,
                   'mktData_SARSwaption_ATM_100': mktData_SARSwaption_ATM_100,
                   'mktData_AUDSwaption3m_ATM0': mktData_AUDSwaption3m_ATM0,
                   'mktData_AUDSwaption3m_ATM25': mktData_AUDSwaption3m_ATM25,
                   'mktData_AUDSwaption3m_ATM_25': mktData_AUDSwaption3m_ATM_25,
                   'mktData_AUDSwaption3m_ATM50': mktData_AUDSwaption3m_ATM50,
                   'mktData_AUDSwaption3m_ATM_50': mktData_AUDSwaption3m_ATM_50,
                   'mktData_AUDSwaption3m_ATM100': mktData_AUDSwaption3m_ATM100,
                   'mktData_AUDSwaption3m_ATM_100': mktData_AUDSwaption3m_ATM_100,
                   'mktData_AUDSwaption6m_ATM0': mktData_AUDSwaption6m_ATM0,
                   'mktData_AUDSwaption6m_ATM25': mktData_AUDSwaption6m_ATM25,
                   'mktData_AUDSwaption6m_ATM_25': mktData_AUDSwaption6m_ATM_25,
                   'mktData_AUDSwaption6m_ATM50': mktData_AUDSwaption6m_ATM50,
                   'mktData_AUDSwaption6m_ATM_50': mktData_AUDSwaption6m_ATM_50,
                   'mktData_AUDSwaption6m_ATM100': mktData_AUDSwaption6m_ATM100,
                   'mktData_AUDSwaption6m_ATM_100': mktData_AUDSwaption6m_ATM_100,
                   'mktData_KRWSwaption_ATM0': mktData_KRWSwaption_ATM0,
                   'mktData_KRWSwaption_ATM25': mktData_KRWSwaption_ATM25,
                   'mktData_KRWSwaption_ATM_25': mktData_KRWSwaption_ATM_25,
                   'mktData_KRWSwaption_ATM50': mktData_KRWSwaption_ATM50,
                   'mktData_KRWSwaption_ATM_50': mktData_KRWSwaption_ATM_50,
                   'mktData_KRWSwaption_ATM100': mktData_KRWSwaption_ATM100,
                   'mktData_KRWSwaption_ATM_100': mktData_KRWSwaption_ATM_100,
                   'mktData_TWDSwaption_ATM0': mktData_TWDSwaption_ATM0,
                   'mktData_TWDSwaption_ATM25': mktData_TWDSwaption_ATM25,
                   'mktData_TWDSwaption_ATM_25': mktData_TWDSwaption_ATM_25,
                   'mktData_TWDSwaption_ATM50': mktData_TWDSwaption_ATM50,
                   'mktData_TWDSwaption_ATM_50': mktData_TWDSwaption_ATM_50,
                   'mktData_TWDSwaption_ATM100': mktData_TWDSwaption_ATM100,
                   'mktData_TWDSwaption_ATM_100': mktData_TWDSwaption_ATM_100,
                   'mktData_NTOSwaption_ATM0': mktData_NTOSwaption_ATM0,
                   'mktData_NTOSwaption_ATM25': mktData_NTOSwaption_ATM25,
                   'mktData_NTOSwaption_ATM_25': mktData_NTOSwaption_ATM_25,
                   'mktData_NTOSwaption_ATM50': mktData_NTOSwaption_ATM50,
                   'mktData_NTOSwaption_ATM_50': mktData_NTOSwaption_ATM_50,
                   'mktData_NTOSwaption_ATM100': mktData_NTOSwaption_ATM100,
                   'mktData_NTOSwaption_ATM_100': mktData_NTOSwaption_ATM_100
                   }

    return {k: MDObject(v) for k, v in swaption_md.items()}


def __get_fx_opt_mkt_data() -> Dict[str, MDObject]:
    f3 = firm_f3.f3client.get_platform_client()
    fx_opt_ins = conf.get_fx_vol_ins()
    opt_data = sorted([(fu.get_instrument_type(i), fu.get_quote_spec(i, None), __placeholder_quote(i),
                        [fu.fx_delta_to_fincad(i.delta), 'ForwardRawDelta'], fu.get_quote_spec_tenor(i).value)
                       for i in fx_opt_ins], key=lambda d: d[4])
    gb_fx_opt = pd.DataFrame(data=opt_data,
                             columns=['ins_type', 'maturity', 'quote', 'delta', 'qst']).groupby('ins_type')
    fx_opt_dict = {it: d.to_dict(orient='list') for it, d in gb_fx_opt}

    fx_opt_mkt_data = {it: f3.CreateFXOptionMarketData(it, fx_opt_dict[it]['maturity'], fx_opt_dict[it]['quote'], None,
                                                       fx_opt_dict[it]['delta']) for it in fx_opt_dict}
    return {k: MDObject(v) for k, v in fx_opt_mkt_data.items()}


def __get_inf_seasonality_mkt_data() -> Dict[str, MDObject]:
    f3 = firm_f3.f3client.get_platform_client()
    inf_seasonality_mkt_data = {}
    for idx in conf.INFLATION_INDICES:
        seasonality_ins, seasonality_labels = fu.f3_seasonality_ins_type_by_inf_index(idx)
        seasonality_mkt_data = f3.CreateLabelledValuesMarketData(seasonality_ins,
                                                                 [0] * len(seasonality_labels))
        inf_seasonality_mkt_data[seasonality_ins] = seasonality_mkt_data

    return {k: MDObject(v) for k, v in inf_seasonality_mkt_data.items()}


async def __get_security_mkt_data_async() -> Dict[str, MDObject]:
    f3 = firm_f3.f3client.get_platform_client()
    securities = [s for s in Security]
    curve_tags = await f3_asset_curve_tag_async(*securities)
    if len(securities) == 1:
        curve_tags = [curve_tags]
    md = f3.CreateEquityMarketData(EquityIndices=f3_security_index(*securities),
                                   SpotPrices=[100] * len(securities),
                                   MarketDataTagMethods=[[ct[0], 'Stock'] for ct in curve_tags])
    return {'SecurityIndexMarketData': MDObject(md)}


# def combine_mkt_data_placeholder(full_set: Dict[str, Any]) -> F3Object:
#    return f3.CombineMarketDataSets(f3.ArrayStack(*full_set.values()))


async def get_mkt_data_placeholder_async(ref_date: datetime.datetime) -> Dict[str, MDObjectBase]:
    from firm_f3.util.utils import filter_dict

    mkt_data = await __get_mkt_data_async(ref_date)
    swaption_md = __get_swaption_md()
    fx_opt_mkt_data = __get_fx_opt_mkt_data()
    inf_seasonality_mkt_data = __get_inf_seasonality_mkt_data()
    security_mkt_data = await __get_security_mkt_data_async()

    full_set: Dict[str, MDObjectBase] = {}
    full_set.update(mkt_data)
    full_set.update(swaption_md)
    full_set.update(fx_opt_mkt_data)
    full_set.update(inf_seasonality_mkt_data)
    full_set.update(security_mkt_data)

    full_set = filter_dict(full_set, lambda key: True)

    logging.debug("get_mkt_data_placeholder finished")

    assert all(isinstance(i, MDObjectBase) for i in full_set.values())

    return full_set


def __get_data_EUR_Swaptions():
    return {'tenor': ['1y', '2y', '5y', '7y', '10y', '15y', '20y', '30y'],
            'expiry': ['1m',
                       '3m',
                       '6m',
                       '1y',
                       '2y',
                       '3y',
                       '5y',
                       '7y',
                       '10y',
                       '15y',
                       '20y',
                       '30y'],
            'quote': {-0.01: [[0.002265029,
                               0.0027120390000000003,
                               0.004515552,
                               0.004928302,
                               0.005221021,
                               0.005347508000000001,
                               0.005488018000000001,
                               0.0063671809999999995],
                              [0.002327283,
                               0.002794902,
                               0.0044160729999999995,
                               0.004793087,
                               0.005142629,
                               0.005205222,
                               0.005296963000000001,
                               0.006162465],
                              [0.001732147,
                               0.002259334,
                               0.0034080940000000004,
                               0.00380087,
                               0.004150719000000001,
                               0.004268157,
                               0.004394421,
                               0.004632221],
                              [0.002401928,
                               0.0028257309999999997,
                               0.003626929,
                               0.003882418,
                               0.004101005,
                               0.004269275,
                               0.004452083,
                               0.0046289090000000005],
                              [0.002664042,
                               0.002940941,
                               0.003459658,
                               0.003711613,
                               0.0038773370000000002,
                               0.00395176,
                               0.004071514,
                               0.004143893],
                              [0.003243882,
                               0.003421286,
                               0.003885741,
                               0.0040195940000000005,
                               0.004108197,
                               0.004071635,
                               0.004142,
                               0.0041699070000000005],
                              [0.003900861,
                               0.003870014,
                               0.004410459,
                               0.004429873,
                               0.004463707,
                               0.004270147,
                               0.0042400879999999995,
                               0.004172593],
                              [0.00465157,
                               0.004594293,
                               0.004798939,
                               0.004774978,
                               0.004752685,
                               0.0044669079999999995,
                               0.00437904,
                               0.004240558],
                              [0.005294226,
                               0.00523686,
                               0.005111351,
                               0.0050379479999999996,
                               0.004926642,
                               0.004597723,
                               0.004451237,
                               0.004200859],
                              [0.005194476,
                               0.005139269,
                               0.00499784,
                               0.0049207009999999995,
                               0.004812177,
                               0.004476565,
                               0.00432161,
                               0.003964172],
                              [0.004980516,
                               0.004928069,
                               0.004839240999999999,
                               0.004767051,
                               0.004642099,
                               0.004334991,
                               0.0041212670000000005,
                               0.003663589],
                              [0.004674301,
                               0.004623879,
                               0.004540148,
                               0.006536064,
                               0.004267313,
                               0.0039564629999999995,
                               0.003731517,
                               0.0032428459999999997]],
                      -0.005: [[0.001372867,
                                0.001750156,
                                0.003319235,
                                0.003819871,
                                0.004259015,
                                0.00439756,
                                0.004554839000000001,
                                0.0051241],
                               [0.0014224779999999998,
                                0.00182066,
                                0.0032347120000000003,
                                0.003705393,
                                0.004180838,
                                0.00425872,
                                0.004362974,
                                0.0049215940000000005],
                               [0.001065852,
                                0.0015347829999999999,
                                0.002801832,
                                0.003247442,
                                0.003663753,
                                0.003773887,
                                0.003890128,
                                0.003997434],
                               [0.001813641,
                                0.002242676,
                                0.0032420609999999996,
                                0.0035440579999999997,
                                0.003808937,
                                0.0039175,
                                0.004035844,
                                0.0041622759999999995],
                               [0.00258142,
                                0.002870975,
                                0.0034999740000000003,
                                0.003757765,
                                0.003915822,
                                0.003937777,
                                0.004004311,
                                0.004048926],
                               [0.0033614820000000003,
                                0.003543235,
                                0.0039985279999999995,
                                0.0041189059999999994,
                                0.004181739,
                                0.004103976,
                                0.004132411,
                                0.0041358309999999995],
                               [0.004339105,
                                0.004312649,
                                0.004623771,
                                0.00461367,
                                0.004601457,
                                0.004391563,
                                0.004342548,
                                0.004260522],
                               [0.004960178,
                                0.004905331,
                                0.0049805940000000005,
                                0.004939395,
                                0.004890399,
                                0.0045992920000000005,
                                0.0045044970000000005,
                                0.004376105],
                               [0.005419583,
                                0.005363071999999999,
                                0.005243525,
                                0.005171935,
                                0.005063894,
                                0.004745983,
                                0.0046098020000000005,
                                0.004405819],
                               [0.005330417,
                                0.005275948000000001,
                                0.0051435579999999995,
                                0.005072697,
                                0.00497425,
                                0.00464873,
                                0.004503513,
                                0.004241447],
                               [0.005124396,
                                0.005072325999999999,
                                0.004994924,
                                0.004934083,
                                0.004826607,
                                0.0045294409999999995,
                                0.004325725,
                                0.00400647],
                               [0.004813479,
                                0.004763401,
                                0.0046909690000000006,
                                0.004606294,
                                0.004448706,
                                0.004148828,
                                0.003934951,
                                0.003585485]],
                      -0.0025: [[0.000878263,
                                 0.00124761,
                                 0.002826817,
                                 0.003401629,
                                 0.003903485,
                                 0.0040637040000000004,
                                 0.004236655,
                                 0.004551838],
                                [0.000923142,
                                 0.001318896,
                                 0.0027512979999999997,
                                 0.0032998090000000003,
                                 0.003824507,
                                 0.003924737,
                                 0.004040182,
                                 0.004343685999999999],
                                [0.000727433,
                                 0.001266006,
                                 0.002721895,
                                 0.0031867379999999997,
                                 0.003610656,
                                 0.003699482,
                                 0.0037889890000000004,
                                 0.003859642],
                                [0.0016335999999999998,
                                 0.002093462,
                                 0.0032006340000000004,
                                 0.0035099709999999998,
                                 0.0037722790000000003,
                                 0.003845264,
                                 0.003922225,
                                 0.003985607],
                                [0.002725284,
                                 0.00301377,
                                 0.0036722940000000004,
                                 0.003892449,
                                 0.004000224,
                                 0.0039981159999999995,
                                 0.004038332,
                                 0.004048407],
                                [0.003550849,
                                 0.003732073,
                                 0.004153869,
                                 0.004246336,
                                 0.004269522,
                                 0.004173712,
                                 0.004182065,
                                 0.0041585829999999996],
                                [0.004584254,
                                 0.00455944,
                                 0.004750654,
                                 0.004727666,
                                 0.004694966,
                                 0.004478085,
                                 0.004420131,
                                 0.004326534],
                                [0.005137602,
                                 0.005083998,
                                 0.0050900929999999995,
                                 0.00504052,
                                 0.004978388,
                                 0.00468474,
                                 0.004586146,
                                 0.0044603],
                                [0.0055014980000000005,
                                 0.005445595,
                                 0.005326455,
                                 0.005253731,
                                 0.005144384,
                                 0.004830381,
                                 0.004697521,
                                 0.004515783],
                                [0.005408998000000001,
                                 0.005355014,
                                 0.005224812,
                                 0.005155558,
                                 0.0050599009999999995,
                                 0.004739493,
                                 0.004599107,
                                 0.004380104],
                                [0.005198716,
                                 0.005146898,
                                 0.00507301,
                                 0.005016765,
                                 0.004916428,
                                 0.0042443870000000005,
                                 0.004428822,
                                 0.004170312],
                                [0.004885158,
                                 0.00483532,
                                 0.004766369,
                                 0.004686808,
                                 0.004536952,
                                 0.004244291,
                                 0.004037718,
                                 0.003749197]],
                      0.0: [[0.000999987,
                             0.0014248639999999999,
                             0.00297122,
                             0.003465292,
                             0.003859107,
                             0.004034998,
                             0.004212098,
                             0.004186649000000001],
                            [0.001051913,
                             0.001500159,
                             0.002913453,
                             0.003380529,
                             0.003782234,
                             0.00390035,
                             0.004016352,
                             0.003970965999999999],
                            [0.0012466019999999999,
                             0.001777688,
                             0.003033847,
                             0.003439383,
                             0.003795582,
                             0.003838573,
                             0.003877657,
                             0.0038409409999999996],
                            [0.001863713,
                             0.00229986,
                             0.003350961,
                             0.003630731,
                             0.003851662,
                             0.0038887870000000003,
                             0.003922999,
                             0.003889455],
                            [0.00300912,
                             0.003290214,
                             0.003943291,
                             0.00410214,
                             0.004130996,
                             0.004108635,
                             0.004125989,
                             0.004088104],
                            [0.0038190240000000003,
                             0.003997947,
                             0.004371862,
                             0.0044246120000000005,
                             0.004392597,
                             0.004281628,
                             0.004272469,
                             0.0042131040000000005],
                            [0.00483527,
                             0.004816707,
                             0.004890268,
                             0.004855809,
                             0.004804923,
                             0.0045817620000000005,
                             0.004515609,
                             0.004408095999999999],
                            [0.005327839,
                             0.005275099,
                             0.005211732,
                             0.005154126,
                             0.005079335,
                             0.004783038,
                             0.004680536,
                             0.004555505],
                            [0.005597049000000001,
                             0.005541735999999999,
                             0.005421107,
                             0.005345854000000001,
                             0.005233153,
                             0.004921787,
                             0.004790995,
                             0.004630309],
                            [0.005495351,
                             0.005441832,
                             0.0053120319999999995,
                             0.0052433819999999996,
                             0.0051489890000000005,
                             0.0048336229999999996,
                             0.0046979859999999995,
                             0.0045185270000000005],
                            [0.005275513000000001,
                             0.005223951,
                             0.005151981,
                             0.005099627,
                             0.005005337,
                             0.004722287,
                             0.0045328320000000005,
                             0.004329754],
                            [0.004959715999999999,
                             0.004910113,
                             0.004843061,
                             0.004767831,
                             0.004624533,
                             0.004339946,
                             0.004141564,
                             0.003908538]],
                      0.0025: [[0.002075656,
                                0.002417077,
                                0.0038272,
                                0.004100741,
                                0.004224851,
                                0.004388037,
                                0.004546371,
                                0.004248068],
                               [0.002116392,
                                0.002480197,
                                0.0037762140000000004,
                                0.004693065,
                                0.004153205,
                                0.004262018,
                                0.004359241,
                                0.004037945],
                               [0.002165525,
                                0.0026237870000000003,
                                0.003614392,
                                0.003934298,
                                0.00418612,
                                0.004173463,
                                0.004154354,
                                0.003963026],
                               [0.0023973320000000003,
                                0.002793067,
                                0.003674313,
                                0.003898125,
                                0.004047813,
                                0.004055027,
                                0.004054096,
                                0.003903373],
                               [0.0033789859999999996,
                                0.003651756,
                                0.004281805,
                                0.004370291,
                                0.004303266,
                                0.004265273,
                                0.004265075,
                                0.004169981],
                               [0.004140125,
                                0.004317199,
                                0.004638716,
                                0.004645403,
                                0.004547913,
                                0.004424913,
                                0.00440183,
                                0.004300133],
                               [0.005103931,
                                0.005080567,
                                0.0050415370000000004,
                                0.004997041,
                                0.004930324,
                                0.004701595,
                                0.004628236,
                                0.004505014],
                               [0.005528999000000001,
                                0.005476998,
                                0.005344985,
                                0.005279629,
                                0.005192849,
                                0.004893785,
                                0.004787382,
                                0.0046616159999999995],
                               [0.00570622,
                                0.005651443000000001,
                                0.005527219,
                                0.005448252,
                                0.005330309,
                                0.005020359,
                                0.00489042,
                                0.004749794],
                               [0.005589999,
                                0.005536888,
                                0.00540567,
                                0.005336684,
                                0.005242082,
                                0.0049315470000000005,
                                0.004800469,
                                0.0046573759999999995],
                               [0.0053556359999999996,
                                0.005304281,
                                0.005232617,
                                0.005183408,
                                0.005094031,
                                0.004819255,
                                0.004638229000000001,
                                0.004485749],
                               [0.0050378720000000005,
                                0.0049884840000000005,
                                0.004921699,
                                0.004850077,
                                0.004712198,
                                0.004436407,
                                0.004246855999999999,
                                0.004064361]],
                      0.005: [[0.002978748,
                               0.0033183920000000003,
                               0.004801234000000001,
                               0.004927308,
                               0.004821212,
                               0.0049616370000000005,
                               0.0050968870000000005,
                               0.004680569],
                              [0.003019027,
                               0.003382903,
                               0.0047457129999999995,
                               0.004843394,
                               0.004751801,
                               0.00483956,
                               0.004914914,
                               0.004479782],
                              [0.002950253,
                               0.003404375,
                               0.004264863,
                               0.004522611,
                               0.004682797,
                               0.004620212,
                               0.004550401,
                               0.004202547],
                              [0.002966651,
                               0.003354752,
                               0.0040930440000000005,
                               0.004259585,
                               0.004331018,
                               0.004317142,
                               0.004293092,
                               0.004029827],
                              [0.003782469,
                               0.004053112,
                               0.004658029,
                               0.004677037,
                               0.00450848,
                               0.004459360999999999,
                               0.004447176,
                               0.004291145],
                              [0.004491223,
                               0.0046674229999999995,
                               0.004938805,
                               0.004897665,
                               0.004729987,
                               0.004597857,
                               0.004564599,
                               0.004417334],
                              [0.0053718,
                               0.00534835,
                               0.005202769,
                               0.005149608,
                               0.005069535,
                               0.004835705,
                               0.00475612,
                               0.004616011],
                              [0.005738624,
                               0.005686855,
                               0.0054884619999999995,
                               0.005415823,
                               0.005134194,
                               0.005015705,
                               0.004905422,
                               0.004777415],
                              [0.005828221999999999,
                               0.005773824,
                               0.005644195,
                               0.005560339,
                               0.0054353380000000005,
                               0.005125456,
                               0.0049952090000000005,
                               0.004873078],
                              [0.005692483000000001,
                               0.005639665,
                               0.005505219,
                               0.005435004,
                               0.005338771,
                               0.005032827,
                               0.004906125999999999,
                               0.004795853],
                              [0.005439016999999999,
                               0.0053878269999999995,
                               0.0053148430000000005,
                               0.005268094,
                               0.005182535,
                               0.004916724,
                               0.004744737,
                               0.0046381999999999994],
                              [0.005120065,
                               0.005070837,
                               0.005002704,
                               0.004933827,
                               0.00480008,
                               0.004533589,
                               0.004353376,
                               0.004216671]],
                      0.01: [[0.00458477,
                              0.004943741,
                              0.006684236999999999,
                              0.006622053,
                              0.006186107,
                              0.006289225,
                              0.006391872,
                              0.00592056],
                             [0.004626267,
                              0.005015557,
                              0.006612729,
                              0.006516608,
                              0.0061130030000000005,
                              0.0061618919999999995,
                              0.0062045469999999995,
                              0.005717756],
                             [0.004350171,
                              0.0048270990000000005,
                              0.005564313,
                              0.0057458809999999996,
                              0.005771155,
                              0.0056289719999999994,
                              0.005482349,
                              0.004872284],
                             [0.004059022,
                              0.004470516,
                              0.005024168,
                              0.0050992979999999995,
                              0.005032495,
                              0.004995112,
                              0.004950494000000001,
                              0.004513835],
                             [0.004611402,
                              0.0048891690000000005,
                              0.005455253,
                              0.00534996,
                              0.004984399999999999,
                              0.004922827,
                              0.004899700999999999,
                              0.004625869],
                             [0.005229811,
                              0.0054079209999999996,
                              0.005593275,
                              0.005460331999999999,
                              0.005151865,
                              0.0050077590000000005,
                              0.004963453,
                              0.0047250420000000005],
                             [0.005913113,
                              0.005888319,
                              0.005549043000000001,
                              0.005482148,
                              0.00538191,
                              0.005138813,
                              0.005049576,
                              0.00487415],
                             [0.006176263,
                              0.006123854000000001,
                              0.005801264,
                              0.005715368,
                              0.0055975109999999995,
                              0.005288168,
                              0.0051703420000000005,
                              0.005034205999999999],
                             [0.006106536,
                              0.006052333000000001,
                              0.005907061,
                              0.005810673000000001,
                              0.005667043,
                              0.005353536999999999,
                              0.00521957,
                              0.005129927],
                             [0.00591981,
                              0.005867147,
                              0.005721259,
                              0.005646253,
                              0.005542919,
                              0.005245138000000001,
                              0.00512646,
                              0.005072107],
                             [0.005616439,
                              0.005565359000000001,
                              0.005485091,
                              0.005441242,
                              0.0053601000000000005,
                              0.005113783,
                              0.0049613159999999995,
                              0.004934186],
                             [0.005297362,
                              0.0052482380000000006,
                              0.0051727940000000005,
                              0.00510691,
                              0.0049776740000000005,
                              0.004730761,
                              0.004570111,
                              0.004512372]]}}


def __get_data_USD_Swaptions():
    return {'tenor': ['1y', '2y', '5y', '7y', '10y', '15y', '20y', '30y'],
            'expiry': ['1m',
                       '3m',
                       '6m',
                       '1y',
                       '2y',
                       '3y',
                       '5y',
                       '7y',
                       '10y',
                       '15y',
                       '20y',
                       '30y'],
            'quote': {-0.01: [[0.007391543,
                               0.008627216,
                               0.008810066,
                               0.008573133,
                               0.007968034,
                               0.00752134,
                               0.0070818719999999995,
                               0.006838268000000001],
                              [0.007687006999999999,
                               0.008846386,
                               0.008743544,
                               0.008372987,
                               0.00784105,
                               0.007402506999999999,
                               0.006977662,
                               0.006798506],
                              [0.008599564,
                               0.008814568,
                               0.008221794000000001,
                               0.007920735,
                               0.007456582,
                               0.007128857,
                               0.006859361,
                               0.006603372],
                              [0.008420774,
                               0.008116082,
                               0.007107097,
                               0.006952964,
                               0.006749754,
                               0.006473144,
                               0.00621754,
                               0.006026592],
                              [0.007936145,
                               0.007141471999999999,
                               0.006902488000000001,
                               0.006694622,
                               0.006414439,
                               0.006047658000000001,
                               0.00574125,
                               0.005673],
                              [0.0078625,
                               0.0072751859999999995,
                               0.004867095,
                               0.006713792,
                               0.006449058000000001,
                               0.006122299,
                               0.005869263,
                               0.005766541],
                              [0.007402944,
                               0.006960489,
                               0.006685899,
                               0.006542721,
                               0.006342406,
                               0.005969044000000001,
                               0.005678693,
                               0.005534789],
                              [0.007015107,
                               0.006684593000000001,
                               0.006561386,
                               0.006433763,
                               0.006246373,
                               0.005897202,
                               0.005649788,
                               0.005597953],
                              [0.006585781,
                               0.0063549719999999995,
                               0.006264931,
                               0.006188206,
                               0.006095225,
                               0.005747756,
                               0.005534753000000001,
                               0.005460931],
                              [0.006241694,
                               0.0060587359999999995,
                               0.006016761,
                               0.0059109309999999995,
                               0.00581113,
                               0.005563461,
                               0.005413338,
                               0.005306902],
                              [0.005842454,
                               0.0057268219999999995,
                               0.005702845,
                               0.005610502,
                               0.0054659980000000006,
                               0.005297412,
                               0.005197473,
                               0.00508435],
                              [0.005026237,
                               0.004878456,
                               0.0048264729999999995,
                               0.0049198720000000005,
                               0.0050495240000000005,
                               0.004921344,
                               0.004775105,
                               0.004742840999999999]],
                      -0.005: [[0.005878090999999999,
                                0.00728717,
                                0.003885225,
                                0.007250436,
                                0.006742545,
                                0.006393512,
                                0.006053431999999999,
                                0.0057576630000000005],
                               [0.00616705,
                                0.0075039980000000004,
                                0.007356112,
                                0.007051381999999999,
                                0.006615903,
                                0.006274985,
                                0.005948105,
                                0.005717188000000001],
                               [0.007071177,
                                0.0075474190000000005,
                                0.00715271,
                                0.006903527,
                                0.006515695,
                                0.006214326,
                                0.005971238,
                                0.005703532],
                               [0.007387202,
                                0.007310359000000001,
                                0.006589354,
                                0.006423771,
                                0.006202153,
                                0.0059385409999999994,
                                0.005695525,
                                0.005463264000000001],
                               [0.007277409,
                                0.006878445,
                                0.006574793000000001,
                                0.006383966,
                                0.006129236999999999,
                                0.005789236,
                                0.00550927,
                                0.005371185],
                               [0.007323629,
                                0.00699099,
                                0.006597118000000001,
                                0.00643162,
                                0.006176959,
                                0.005841832,
                                0.005579687,
                                0.005458148],
                               [0.007066263000000001,
                                0.0068071880000000005,
                                0.006521841,
                                0.006377191999999999,
                                0.006174563,
                                0.005807428000000001,
                                0.005523229,
                                0.0053795909999999995],
                               [0.006776904,
                                0.006583118000000001,
                                0.006436007,
                                0.0062991819999999995,
                                0.0060978180000000005,
                                0.005741063,
                                0.0054954140000000005,
                                0.005414096],
                               [0.0064255580000000005,
                                0.006294168,
                                0.006195936,
                                0.006087181999999999,
                                0.005946639,
                                0.005600395,
                                0.0053889359999999996,
                                0.005317305],
                               [0.006099946,
                                0.005982514,
                                0.005913603000000001,
                                0.005793678000000001,
                                0.005673346,
                                0.005428001,
                                0.0052799809999999996,
                                0.005197162],
                               [0.00570172,
                                0.005634734000000001,
                                0.005565213,
                                0.005477148,
                                0.005339027,
                                0.005173463,
                                0.005076489,
                                0.00500846],
                               [0.004935289,
                                0.004888244,
                                0.004865595,
                                0.004910449,
                                0.004965782,
                                0.004880494,
                                0.004776923,
                                0.0047652879999999995]],
                      -0.0025: [[0.005082823,
                                 0.00659208,
                                 0.006740824,
                                 0.006621688000000001,
                                 0.006191693000000001,
                                 0.0059002709999999995,
                                 0.005617718000000001,
                                 0.00528467],
                                [0.005375842,
                                 0.00681023,
                                 0.00667363,
                                 0.006419731999999999,
                                 0.006062537,
                                 0.005779799,
                                 0.005510603,
                                 0.005243335],
                                [0.0062681790000000005,
                                 0.006913730999999999,
                                 0.006652516999999999,
                                 0.006443924,
                                 0.006118149,
                                 0.005832166999999999,
                                 0.005604709,
                                 0.0053326219999999995],
                                [0.006861021,
                                 0.0069293919999999995,
                                 0.0063844719999999995,
                                 0.006220109000000001,
                                 0.00600017,
                                 0.005744836,
                                 0.005509752,
                                 0.005256966],
                                [0.006964693,
                                 0.006769743000000001,
                                 0.00645027,
                                 0.00626944,
                                 0.006029711,
                                 0.005706058000000001,
                                 0.005442479,
                                 0.005269291999999999],
                                [0.0070666209999999995,
                                 0.006858663,
                                 0.006481268,
                                 0.006323336999999999,
                                 0.006079787,
                                 0.005746205999999999,
                                 0.005485525,
                                 0.005349208],
                                [0.0069290390000000006,
                                 0.006760248000000001,
                                 0.006470259,
                                 0.006323504000000001,
                                 0.006117573,
                                 0.005755154,
                                 0.005475583000000001,
                                 0.005332167],
                                [0.006681055,
                                 0.006551406,
                                 0.006394611999999999,
                                 0.006254201,
                                 0.006047296,
                                 0.005689838000000001,
                                 0.005445846999999999,
                                 0.005349108000000001],
                                [0.0063716,
                                 0.006285879,
                                 0.006189545,
                                 0.006064423,
                                 0.00589885,
                                 0.005552745,
                                 0.005341375,
                                 0.0052693340000000005],
                                [0.006054091,
                                 0.005967131999999999,
                                 0.0058875180000000004,
                                 0.0057602109999999995,
                                 0.005628686999999999,
                                 0.005384525,
                                 0.005237586,
                                 0.005163701],
                                [0.005656363,
                                 0.005612262,
                                 0.005518963000000001,
                                 0.005432908,
                                 0.005297689,
                                 0.005134194,
                                 0.005039224,
                                 0.004989299],
                                [0.004903253,
                                 0.004903291,
                                 0.004890918,
                                 0.0049153159999999994,
                                 0.004938110999999999,
                                 0.004872507,
                                 0.004788133,
                                 0.004784888]],
                      0.0: [[0.004328122,
                             0.005913555,
                             0.0061416000000000005,
                             0.006101214000000001,
                             0.00578766,
                             0.005555239,
                             0.005331463000000001,
                             0.004962210999999999],
                            [0.0046350490000000005,
                             0.006135824000000001,
                             0.006072281,
                             0.005892491999999999,
                             0.005652981999999999,
                             0.005432511,
                             0.005222695,
                             0.004919136],
                            [0.0054880680000000005,
                             0.006328691,
                             0.00623186,
                             0.006078581,
                             0.005842123,
                             0.005574621,
                             0.005365249,
                             0.005096815],
                            [0.0063480690000000005,
                             0.006589996999999999,
                             0.0062403730000000004,
                             0.0060856719999999994,
                             0.005880786999999999,
                             0.005635209,
                             0.005409731,
                             0.0051423],
                            [0.00668123,
                             0.00668334,
                             0.006364221,
                             0.006194118,
                             0.005970623,
                             0.005665193000000001,
                             0.005419657,
                             0.0052148609999999995],
                            [0.006827008000000001,
                             0.006736992,
                             0.006393598,
                             0.006246430999999999,
                             0.006019008,
                             0.00569254,
                             0.005439064,
                             0.005284692],
                            [0.006823468,
                             0.006738691999999999,
                             0.006444835,
                             0.006294881,
                             0.006084073000000001,
                             0.005727482,
                             0.005453698000000001,
                             0.0053106609999999995],
                            [0.006608069,
                             0.006535714000000001,
                             0.006371238,
                             0.0062282069999999995,
                             0.006017211,
                             0.005661773,
                             0.00542016,
                             0.005308195],
                            [0.006341673000000001,
                             0.006294908,
                             0.006205149,
                             0.006063857,
                             0.00587369,
                             0.005527262,
                             0.0053157280000000005,
                             0.0052421429999999995],
                            [0.0060295240000000005,
                             0.005970112,
                             0.005882235,
                             0.005747611,
                             0.005604974,
                             0.005361833000000001,
                             0.005216063,
                             0.005148394000000001],
                            [0.005632463000000001,
                             0.005609134,
                             0.005492174,
                             0.005407909,
                             0.0052754230000000004,
                             0.005114429,
                             0.005021842,
                             0.004985669],
                            [0.004883234,
                             0.004926075,
                             0.00492059,
                             0.004927783,
                             0.00492275,
                             0.004874811,
                             0.0048076759999999994,
                             0.004811431]],
                      0.0025: [[0.0038248320000000002,
                                0.005331631999999999,
                                0.0057497730000000006,
                                0.005810404,
                                0.005646526,
                                0.005464401999999999,
                                0.005287851,
                                0.004902233],
                               [0.004142642,
                                0.005560776999999999,
                                0.005678702,
                                0.005599786,
                                0.005512494000000001,
                                0.005342191,
                                0.005179931,
                                0.004859829],
                               [0.004841654,
                                0.005877013,
                                0.005967592,
                                0.005885505,
                                0.005755958,
                                0.005509258,
                                0.005319816999999999,
                                0.005069763],
                               [0.005901287,
                                0.006329849,
                                0.00618033,
                                0.006043129,
                                0.00586632,
                                0.005632156,
                                0.00541749,
                                0.005145523],
                               [0.006449872,
                                0.006626666,
                                0.006326834,
                                0.006167299,
                                0.005959407,
                                0.005672878,
                                0.005446128000000001,
                                0.005216177],
                               [0.006627895,
                                0.0066348430000000005,
                                0.0063413259999999996,
                                0.00620775,
                                0.006001347,
                                0.005687789,
                                0.005447781,
                                0.005272914],
                               [0.006756577,
                                0.00674562,
                                0.006448594,
                                0.006294474,
                                0.006077133,
                                0.0057274859999999995,
                                0.005460648,
                                0.005318134],
                               [0.006560925,
                                0.006537979,
                                0.006368143000000001,
                                0.006223593,
                                0.006010209,
                                0.005659754,
                                0.0054213659999999995,
                                0.005295338],
                               [0.006333238000000001,
                                0.006322725,
                                0.00624408,
                                0.006087578000000001,
                                0.00587392,
                                0.00552701,
                                0.0046157179999999996,
                                0.005238446],
                               [0.0060289969999999995,
                                0.005993084,
                                0.005899958,
                                0.005758188000000001,
                                0.00560476,
                                0.0053627530000000005,
                                0.005218053,
                                0.005153435],
                               [0.005633157,
                                0.005627155,
                                0.005487998000000001,
                                0.00540514,
                                0.005274776,
                                0.005116663,
                                0.005026845,
                                0.004999207],
                               [0.004876613,
                                0.004957528,
                                0.004955417,
                                0.004948822,
                                0.004921358,
                                0.00488844,
                                0.004835546,
                                0.00484493]],
                      0.005: [[0.003856977,
                               0.00499275,
                               0.005693865,
                               0.005847013000000001,
                               0.005821056999999999,
                               0.005658384,
                               0.005499905,
                               0.005124514],
                              [0.00415723,
                               0.005222574000000001,
                               0.005623846,
                               0.005640551999999999,
                               0.005689553000000001,
                               0.0055395,
                               0.005395144,
                               0.005083194],
                              [0.00458856,
                               0.0056700990000000005,
                               0.005920511999999999,
                               0.005909059,
                               0.005884104,
                               0.00565513,
                               0.005481808,
                               0.00525927],
                              [0.005572931,
                               0.006180796999999999,
                               0.006211614,
                               0.006100186,
                               0.005963394,
                               0.005739777,
                               0.005535356999999999,
                               0.005269836],
                              [0.006291636,
                               0.006602546,
                               0.006342222,
                               0.006192581,
                               0.005999486,
                               0.005731321,
                               0.005522648000000001,
                               0.005276067],
                              [0.006475755,
                               0.006552645,
                               0.006328858000000001,
                               0.006211813,
                               0.006030356999999999,
                               0.005735129,
                               0.005514084,
                               0.005317832],
                              [0.00673594,
                               0.006783014,
                               0.00648381,
                               0.00632439,
                               0.006099008,
                               0.0057571309999999995,
                               0.005497991,
                               0.005356219000000001],
                              [0.006544940999999999,
                               0.006559664000000001,
                               0.006387038,
                               0.00624218,
                               0.006028324,
                               0.005685754,
                               0.005451165,
                               0.005312831],
                              [0.006353961,
                               0.006369891999999999,
                               0.006306791999999999,
                               0.006136656,
                               0.005901391999999999,
                               0.005553646999999999,
                               0.005340470999999999,
                               0.005260195],
                              [0.0060544019999999995,
                               0.00603657,
                               0.005941573,
                               0.005793228,
                               0.005629802,
                               0.00538888,
                               0.005245265,
                               0.005180186],
                              [0.0056598080000000005,
                               0.005667424,
                               0.005507893000000001,
                               0.005426149,
                               0.005297413000000001,
                               0.005142417,
                               0.005055704,
                               0.005030909],
                              [0.004885248,
                               0.004997576,
                               0.004995195,
                               0.004978725,
                               0.004935353,
                               0.004914295,
                               0.00487285,
                               0.004886414]],
                      0.01: [[0.004763263,
                              0.005228712,
                              0.006378621,
                              0.00662196,
                              0.006738706,
                              0.006551626999999999,
                              0.006370329,
                              0.006027011999999999],
                             [0.005048602,
                              0.00544315,
                              0.00631243,
                              0.006423290999999999,
                              0.006610011,
                              0.006435818,
                              0.006268115,
                              0.005985724],
                             [0.005159615,
                              0.006025478000000001,
                              0.0064040090000000004,
                              0.006482058000000001,
                              0.006588863,
                              0.006372144000000001,
                              0.006209915999999999,
                              0.006032583],
                             [0.005479413000000001,
                              0.006275881999999999,
                              0.006528985,
                              0.006476261999999999,
                              0.006426809,
                              0.006215559,
                              0.0060232359999999995,
                              0.005785301],
                             [0.006255241999999999,
                              0.0066641009999999995,
                              0.006531198,
                              0.006396139,
                              0.006224906,
                              0.005986701999999999,
                              0.00580723,
                              0.00555107],
                             [0.0063615519999999995,
                              0.006468956999999999,
                              0.006431025,
                              0.006350731,
                              0.006223988000000001,
                              0.005974276,
                              0.005798378000000001,
                              0.005562273],
                             [0.006841196,
                              0.006948559,
                              0.006647018,
                              0.006474557,
                              0.006229678000000001,
                              0.005903938,
                              0.00566081,
                              0.005520496999999999],
                             [0.006612046,
                              0.006663474,
                              0.006492621,
                              0.00635058,
                              0.006141112,
                              0.0058211930000000005,
                              0.005595032,
                              0.005438965],
                             [0.006478016,
                              0.006521584,
                              0.006499927,
                              0.006306889,
                              0.006037614,
                              0.00568699,
                              0.005470600999999999,
                              0.0053799419999999995],
                             [0.006183322,
                              0.0061852719999999995,
                              0.0060951059999999994,
                              0.005935472,
                              0.005755552,
                              0.005516691,
                              0.005374528000000001,
                              0.005298768000000001],
                             [0.0057916669999999995,
                              0.005813382,
                              0.005621305,
                              0.005540448000000001,
                              0.005413011999999999,
                              0.005264702,
                              0.005184218,
                              0.005148599],
                             [0.004950705,
                              0.005104008,
                              0.005090489,
                              0.00506632,
                              0.005011517,
                              0.005003598,
                              0.0049753340000000005,
                              0.004993224]]}}


def __get_data_SAR_Swaptions():
    return {'tenor': ['1y', '2y', '5y', '7y', '10y', '15y', '20y', '30y'],
            'expiry': ['1m',
                       '3m',
                       '6m',
                       '1y',
                       '2y',
                       '3y',
                       '5y',
                       '7y',
                       '10y',
                       '15y',
                       '20y',
                       '30y'],
            'quote': {-0.01: [[0.007391543,
                               0.008627216,
                               0.008810066,
                               0.008573133,
                               0.007968034,
                               0.00752134,
                               0.0070818719999999995,
                               0.006838268000000001],
                              [0.007687006999999999,
                               0.008846386,
                               0.008743544,
                               0.008372987,
                               0.00784105,
                               0.007402506999999999,
                               0.006977662,
                               0.006798506],
                              [0.008599564,
                               0.008814568,
                               0.008221794000000001,
                               0.007920735,
                               0.007456582,
                               0.007128857,
                               0.006859361,
                               0.006603372],
                              [0.008420774,
                               0.008116082,
                               0.007107097,
                               0.006952964,
                               0.006749754,
                               0.006473144,
                               0.00621754,
                               0.006026592],
                              [0.007936145,
                               0.007141471999999999,
                               0.006902488000000001,
                               0.006694622,
                               0.006414439,
                               0.006047658000000001,
                               0.00574125,
                               0.005673],
                              [0.0078625,
                               0.0072751859999999995,
                               0.004867095,
                               0.006713792,
                               0.006449058000000001,
                               0.006122299,
                               0.005869263,
                               0.005766541],
                              [0.007402944,
                               0.006960489,
                               0.006685899,
                               0.006542721,
                               0.006342406,
                               0.005969044000000001,
                               0.005678693,
                               0.005534789],
                              [0.007015107,
                               0.006684593000000001,
                               0.006561386,
                               0.006433763,
                               0.006246373,
                               0.005897202,
                               0.005649788,
                               0.005597953],
                              [0.006585781,
                               0.0063549719999999995,
                               0.006264931,
                               0.006188206,
                               0.006095225,
                               0.005747756,
                               0.005534753000000001,
                               0.005460931],
                              [0.006241694,
                               0.0060587359999999995,
                               0.006016761,
                               0.0059109309999999995,
                               0.00581113,
                               0.005563461,
                               0.005413338,
                               0.005306902],
                              [0.005842454,
                               0.0057268219999999995,
                               0.005702845,
                               0.005610502,
                               0.0054659980000000006,
                               0.005297412,
                               0.005197473,
                               0.00508435],
                              [0.005026237,
                               0.004878456,
                               0.0048264729999999995,
                               0.0049198720000000005,
                               0.0050495240000000005,
                               0.004921344,
                               0.004775105,
                               0.004742840999999999]],
                      -0.005: [[0.005878090999999999,
                                0.00728717,
                                0.003885225,
                                0.007250436,
                                0.006742545,
                                0.006393512,
                                0.006053431999999999,
                                0.0057576630000000005],
                               [0.00616705,
                                0.0075039980000000004,
                                0.007356112,
                                0.007051381999999999,
                                0.006615903,
                                0.006274985,
                                0.005948105,
                                0.005717188000000001],
                               [0.007071177,
                                0.0075474190000000005,
                                0.00715271,
                                0.006903527,
                                0.006515695,
                                0.006214326,
                                0.005971238,
                                0.005703532],
                               [0.007387202,
                                0.007310359000000001,
                                0.006589354,
                                0.006423771,
                                0.006202153,
                                0.0059385409999999994,
                                0.005695525,
                                0.005463264000000001],
                               [0.007277409,
                                0.006878445,
                                0.006574793000000001,
                                0.006383966,
                                0.006129236999999999,
                                0.005789236,
                                0.00550927,
                                0.005371185],
                               [0.007323629,
                                0.00699099,
                                0.006597118000000001,
                                0.00643162,
                                0.006176959,
                                0.005841832,
                                0.005579687,
                                0.005458148],
                               [0.007066263000000001,
                                0.0068071880000000005,
                                0.006521841,
                                0.006377191999999999,
                                0.006174563,
                                0.005807428000000001,
                                0.005523229,
                                0.0053795909999999995],
                               [0.006776904,
                                0.006583118000000001,
                                0.006436007,
                                0.0062991819999999995,
                                0.0060978180000000005,
                                0.005741063,
                                0.0054954140000000005,
                                0.005414096],
                               [0.0064255580000000005,
                                0.006294168,
                                0.006195936,
                                0.006087181999999999,
                                0.005946639,
                                0.005600395,
                                0.0053889359999999996,
                                0.005317305],
                               [0.006099946,
                                0.005982514,
                                0.005913603000000001,
                                0.005793678000000001,
                                0.005673346,
                                0.005428001,
                                0.0052799809999999996,
                                0.005197162],
                               [0.00570172,
                                0.005634734000000001,
                                0.005565213,
                                0.005477148,
                                0.005339027,
                                0.005173463,
                                0.005076489,
                                0.00500846],
                               [0.004935289,
                                0.004888244,
                                0.004865595,
                                0.004910449,
                                0.004965782,
                                0.004880494,
                                0.004776923,
                                0.0047652879999999995]],
                      -0.0025: [[0.005082823,
                                 0.00659208,
                                 0.006740824,
                                 0.006621688000000001,
                                 0.006191693000000001,
                                 0.0059002709999999995,
                                 0.005617718000000001,
                                 0.00528467],
                                [0.005375842,
                                 0.00681023,
                                 0.00667363,
                                 0.006419731999999999,
                                 0.006062537,
                                 0.005779799,
                                 0.005510603,
                                 0.005243335],
                                [0.0062681790000000005,
                                 0.006913730999999999,
                                 0.006652516999999999,
                                 0.006443924,
                                 0.006118149,
                                 0.005832166999999999,
                                 0.005604709,
                                 0.0053326219999999995],
                                [0.006861021,
                                 0.0069293919999999995,
                                 0.0063844719999999995,
                                 0.006220109000000001,
                                 0.00600017,
                                 0.005744836,
                                 0.005509752,
                                 0.005256966],
                                [0.006964693,
                                 0.006769743000000001,
                                 0.00645027,
                                 0.00626944,
                                 0.006029711,
                                 0.005706058000000001,
                                 0.005442479,
                                 0.005269291999999999],
                                [0.0070666209999999995,
                                 0.006858663,
                                 0.006481268,
                                 0.006323336999999999,
                                 0.006079787,
                                 0.005746205999999999,
                                 0.005485525,
                                 0.005349208],
                                [0.0069290390000000006,
                                 0.006760248000000001,
                                 0.006470259,
                                 0.006323504000000001,
                                 0.006117573,
                                 0.005755154,
                                 0.005475583000000001,
                                 0.005332167],
                                [0.006681055,
                                 0.006551406,
                                 0.006394611999999999,
                                 0.006254201,
                                 0.006047296,
                                 0.005689838000000001,
                                 0.005445846999999999,
                                 0.005349108000000001],
                                [0.0063716,
                                 0.006285879,
                                 0.006189545,
                                 0.006064423,
                                 0.00589885,
                                 0.005552745,
                                 0.005341375,
                                 0.0052693340000000005],
                                [0.006054091,
                                 0.005967131999999999,
                                 0.0058875180000000004,
                                 0.0057602109999999995,
                                 0.005628686999999999,
                                 0.005384525,
                                 0.005237586,
                                 0.005163701],
                                [0.005656363,
                                 0.005612262,
                                 0.005518963000000001,
                                 0.005432908,
                                 0.005297689,
                                 0.005134194,
                                 0.005039224,
                                 0.004989299],
                                [0.004903253,
                                 0.004903291,
                                 0.004890918,
                                 0.0049153159999999994,
                                 0.004938110999999999,
                                 0.004872507,
                                 0.004788133,
                                 0.004784888]],
                      0.0: [[0.004328122,
                             0.005913555,
                             0.0061416000000000005,
                             0.006101214000000001,
                             0.00578766,
                             0.005555239,
                             0.005331463000000001,
                             0.004962210999999999],
                            [0.0046350490000000005,
                             0.006135824000000001,
                             0.006072281,
                             0.005892491999999999,
                             0.005652981999999999,
                             0.005432511,
                             0.005222695,
                             0.004919136],
                            [0.0054880680000000005,
                             0.006328691,
                             0.00623186,
                             0.006078581,
                             0.005842123,
                             0.005574621,
                             0.005365249,
                             0.005096815],
                            [0.0063480690000000005,
                             0.006589996999999999,
                             0.0062403730000000004,
                             0.0060856719999999994,
                             0.005880786999999999,
                             0.005635209,
                             0.005409731,
                             0.0051423],
                            [0.00668123,
                             0.00668334,
                             0.006364221,
                             0.006194118,
                             0.005970623,
                             0.005665193000000001,
                             0.005419657,
                             0.0052148609999999995],
                            [0.006827008000000001,
                             0.006736992,
                             0.006393598,
                             0.006246430999999999,
                             0.006019008,
                             0.00569254,
                             0.005439064,
                             0.005284692],
                            [0.006823468,
                             0.006738691999999999,
                             0.006444835,
                             0.006294881,
                             0.006084073000000001,
                             0.005727482,
                             0.005453698000000001,
                             0.0053106609999999995],
                            [0.006608069,
                             0.006535714000000001,
                             0.006371238,
                             0.0062282069999999995,
                             0.006017211,
                             0.005661773,
                             0.00542016,
                             0.005308195],
                            [0.006341673000000001,
                             0.006294908,
                             0.006205149,
                             0.006063857,
                             0.00587369,
                             0.005527262,
                             0.0053157280000000005,
                             0.0052421429999999995],
                            [0.0060295240000000005,
                             0.005970112,
                             0.005882235,
                             0.005747611,
                             0.005604974,
                             0.005361833000000001,
                             0.005216063,
                             0.005148394000000001],
                            [0.005632463000000001,
                             0.005609134,
                             0.005492174,
                             0.005407909,
                             0.0052754230000000004,
                             0.005114429,
                             0.005021842,
                             0.004985669],
                            [0.004883234,
                             0.004926075,
                             0.00492059,
                             0.004927783,
                             0.00492275,
                             0.004874811,
                             0.0048076759999999994,
                             0.004811431]],
                      0.0025: [[0.0038248320000000002,
                                0.005331631999999999,
                                0.0057497730000000006,
                                0.005810404,
                                0.005646526,
                                0.005464401999999999,
                                0.005287851,
                                0.004902233],
                               [0.004142642,
                                0.005560776999999999,
                                0.005678702,
                                0.005599786,
                                0.005512494000000001,
                                0.005342191,
                                0.005179931,
                                0.004859829],
                               [0.004841654,
                                0.005877013,
                                0.005967592,
                                0.005885505,
                                0.005755958,
                                0.005509258,
                                0.005319816999999999,
                                0.005069763],
                               [0.005901287,
                                0.006329849,
                                0.00618033,
                                0.006043129,
                                0.00586632,
                                0.005632156,
                                0.00541749,
                                0.005145523],
                               [0.006449872,
                                0.006626666,
                                0.006326834,
                                0.006167299,
                                0.005959407,
                                0.005672878,
                                0.005446128000000001,
                                0.005216177],
                               [0.006627895,
                                0.0066348430000000005,
                                0.0063413259999999996,
                                0.00620775,
                                0.006001347,
                                0.005687789,
                                0.005447781,
                                0.005272914],
                               [0.006756577,
                                0.00674562,
                                0.006448594,
                                0.006294474,
                                0.006077133,
                                0.0057274859999999995,
                                0.005460648,
                                0.005318134],
                               [0.006560925,
                                0.006537979,
                                0.006368143000000001,
                                0.006223593,
                                0.006010209,
                                0.005659754,
                                0.0054213659999999995,
                                0.005295338],
                               [0.006333238000000001,
                                0.006322725,
                                0.00624408,
                                0.006087578000000001,
                                0.00587392,
                                0.00552701,
                                0.0046157179999999996,
                                0.005238446],
                               [0.0060289969999999995,
                                0.005993084,
                                0.005899958,
                                0.005758188000000001,
                                0.00560476,
                                0.0053627530000000005,
                                0.005218053,
                                0.005153435],
                               [0.005633157,
                                0.005627155,
                                0.005487998000000001,
                                0.00540514,
                                0.005274776,
                                0.005116663,
                                0.005026845,
                                0.004999207],
                               [0.004876613,
                                0.004957528,
                                0.004955417,
                                0.004948822,
                                0.004921358,
                                0.00488844,
                                0.004835546,
                                0.00484493]],
                      0.005: [[0.003856977,
                               0.00499275,
                               0.005693865,
                               0.005847013000000001,
                               0.005821056999999999,
                               0.005658384,
                               0.005499905,
                               0.005124514],
                              [0.00415723,
                               0.005222574000000001,
                               0.005623846,
                               0.005640551999999999,
                               0.005689553000000001,
                               0.0055395,
                               0.005395144,
                               0.005083194],
                              [0.00458856,
                               0.0056700990000000005,
                               0.005920511999999999,
                               0.005909059,
                               0.005884104,
                               0.00565513,
                               0.005481808,
                               0.00525927],
                              [0.005572931,
                               0.006180796999999999,
                               0.006211614,
                               0.006100186,
                               0.005963394,
                               0.005739777,
                               0.005535356999999999,
                               0.005269836],
                              [0.006291636,
                               0.006602546,
                               0.006342222,
                               0.006192581,
                               0.005999486,
                               0.005731321,
                               0.005522648000000001,
                               0.005276067],
                              [0.006475755,
                               0.006552645,
                               0.006328858000000001,
                               0.006211813,
                               0.006030356999999999,
                               0.005735129,
                               0.005514084,
                               0.005317832],
                              [0.00673594,
                               0.006783014,
                               0.00648381,
                               0.00632439,
                               0.006099008,
                               0.0057571309999999995,
                               0.005497991,
                               0.005356219000000001],
                              [0.006544940999999999,
                               0.006559664000000001,
                               0.006387038,
                               0.00624218,
                               0.006028324,
                               0.005685754,
                               0.005451165,
                               0.005312831],
                              [0.006353961,
                               0.006369891999999999,
                               0.006306791999999999,
                               0.006136656,
                               0.005901391999999999,
                               0.005553646999999999,
                               0.005340470999999999,
                               0.005260195],
                              [0.0060544019999999995,
                               0.00603657,
                               0.005941573,
                               0.005793228,
                               0.005629802,
                               0.00538888,
                               0.005245265,
                               0.005180186],
                              [0.0056598080000000005,
                               0.005667424,
                               0.005507893000000001,
                               0.005426149,
                               0.005297413000000001,
                               0.005142417,
                               0.005055704,
                               0.005030909],
                              [0.004885248,
                               0.004997576,
                               0.004995195,
                               0.004978725,
                               0.004935353,
                               0.004914295,
                               0.00487285,
                               0.004886414]],
                      0.01: [[0.004763263,
                              0.005228712,
                              0.006378621,
                              0.00662196,
                              0.006738706,
                              0.006551626999999999,
                              0.006370329,
                              0.006027011999999999],
                             [0.005048602,
                              0.00544315,
                              0.00631243,
                              0.006423290999999999,
                              0.006610011,
                              0.006435818,
                              0.006268115,
                              0.005985724],
                             [0.005159615,
                              0.006025478000000001,
                              0.0064040090000000004,
                              0.006482058000000001,
                              0.006588863,
                              0.006372144000000001,
                              0.006209915999999999,
                              0.006032583],
                             [0.005479413000000001,
                              0.006275881999999999,
                              0.006528985,
                              0.006476261999999999,
                              0.006426809,
                              0.006215559,
                              0.0060232359999999995,
                              0.005785301],
                             [0.006255241999999999,
                              0.0066641009999999995,
                              0.006531198,
                              0.006396139,
                              0.006224906,
                              0.005986701999999999,
                              0.00580723,
                              0.00555107],
                             [0.0063615519999999995,
                              0.006468956999999999,
                              0.006431025,
                              0.006350731,
                              0.006223988000000001,
                              0.005974276,
                              0.005798378000000001,
                              0.005562273],
                             [0.006841196,
                              0.006948559,
                              0.006647018,
                              0.006474557,
                              0.006229678000000001,
                              0.005903938,
                              0.00566081,
                              0.005520496999999999],
                             [0.006612046,
                              0.006663474,
                              0.006492621,
                              0.00635058,
                              0.006141112,
                              0.0058211930000000005,
                              0.005595032,
                              0.005438965],
                             [0.006478016,
                              0.006521584,
                              0.006499927,
                              0.006306889,
                              0.006037614,
                              0.00568699,
                              0.005470600999999999,
                              0.0053799419999999995],
                             [0.006183322,
                              0.0061852719999999995,
                              0.0060951059999999994,
                              0.005935472,
                              0.005755552,
                              0.005516691,
                              0.005374528000000001,
                              0.005298768000000001],
                             [0.0057916669999999995,
                              0.005813382,
                              0.005621305,
                              0.005540448000000001,
                              0.005413011999999999,
                              0.005264702,
                              0.005184218,
                              0.005148599],
                             [0.004950705,
                              0.005104008,
                              0.005090489,
                              0.00506632,
                              0.005011517,
                              0.005003598,
                              0.0049753340000000005,
                              0.004993224]]}}


def __get_data_AUD_Swaptions():
    return {'tenor': ['1y', '2y', '5y', '7y', '10y', '15y', '20y', '30y'],
            'expiry': ['1m',
                       '3m',
                       '6m',
                       '1y',
                       '2y',
                       '3y',
                       '5y',
                       '7y',
                       '10y',
                       '15y',
                       '20y',
                       '30y'],
            'quote': {-0.01: [[0.005917227,
                               0.006823938000000001,
                               0.007164825,
                               0.0070295390000000004,
                               0.007088121,
                               0.00690832,
                               0.006957631999999999,
                               0.006982215],
                              [0.0061838069999999995,
                               0.006350186999999999,
                               0.006787707,
                               0.006742738000000001,
                               0.006847294,
                               0.006568088000000001,
                               0.006562539,
                               0.006485144],
                              [0.005997364,
                               0.0061871190000000005,
                               0.006314736,
                               0.0063933290000000005,
                               0.006432934,
                               0.006107915,
                               0.006112291,
                               0.006028563000000001],
                              [0.005920592,
                               0.005881216999999999,
                               0.005817545,
                               0.006162854000000001,
                               0.005771254,
                               0.006003802,
                               0.006003238,
                               0.006173774],
                              [0.006125668000000001,
                               0.006047649,
                               0.006234849000000001,
                               0.0054132419999999995,
                               0.005917406,
                               0.005999254,
                               0.005934495,
                               0.005681561],
                              [0.006145031,
                               0.006170772,
                               0.006142763000000001,
                               0.005594755999999999,
                               0.005869211,
                               0.005865228,
                               0.005750137,
                               0.005406518000000001],
                              [0.005704016,
                               0.005990294,
                               0.005844741,
                               0.005859581,
                               0.005689626,
                               0.005509971999999999,
                               0.00530932,
                               0.004805383],
                              [0.0059039240000000005,
                               0.005974286,
                               0.005734884,
                               0.005715926,
                               0.005564063,
                               0.0053256269999999994,
                               0.005039657,
                               0.004533442],
                              [0.006250848000000001,
                               0.00591711,
                               0.00554973,
                               0.005415619,
                               0.005317072,
                               0.00501183,
                               0.004676238,
                               0.004222814],
                              [0.005939006,
                               0.005687866,
                               0.0052662030000000006,
                               0.005029367,
                               0.0048903,
                               0.004566247,
                               0.006376565,
                               0.00386655],
                              [0.005456094,
                               0.005392809,
                               0.004920185,
                               0.004568717,
                               0.004471096,
                               0.004193954000000001,
                               0.003975697,
                               0.003515865],
                              [0.005373681,
                               0.005329926,
                               0.004881198,
                               0.004614924,
                               0.004444502,
                               0.004431612,
                               0.004215261,
                               0.003763463]],
                      -0.005: [[0.00487345,
                                0.00573962,
                                0.006231301999999999,
                                0.00620548,
                                0.006241494,
                                0.006087326999999999,
                                0.006086171,
                                0.006095056999999999],
                               [0.005230637,
                                0.00550665,
                                0.006022385,
                                0.0060504980000000005,
                                0.006116565,
                                0.005923115,
                                0.005875948000000001,
                                0.0057907869999999995],
                               [0.005307954,
                                0.005530141,
                                0.005762133000000001,
                                0.005869261999999999,
                                0.005908861999999999,
                                0.0057010640000000005,
                                0.005658573,
                                0.005575964],
                               [0.005351189,
                                0.005375675,
                                0.005496002,
                                0.005735179,
                                0.005614566999999999,
                                0.005676997,
                                0.005638076999999999,
                                0.005754233],
                               [0.005697618000000001,
                                0.005669054000000001,
                                0.005898129,
                                0.005579764,
                                0.005771505,
                                0.005734171,
                                0.005643024,
                                0.0053888569999999995],
                               [0.005950636,
                                0.005943409,
                                0.005944985,
                                0.0057101999999999995,
                                0.005794034,
                                0.005692386999999999,
                                0.005554893000000001,
                                0.005212565],
                               [0.0059358480000000005,
                                0.006045579000000001,
                                0.0059063380000000006,
                                0.005872225,
                                0.005745198000000001,
                                0.005511581999999999,
                                0.005297029,
                                0.0047983290000000005],
                               [0.005995019,
                                0.006015151999999999,
                                0.005795306,
                                0.0057466159999999995,
                                0.005617005,
                                0.0053434,
                                0.005047745,
                                0.00454449],
                               [0.00610722,
                                0.005935414,
                                0.005607437,
                                0.005471903,
                                0.0053654359999999995,
                                0.00505203,
                                0.004713129,
                                0.0042598029999999995],
                               [0.005898321999999999,
                                0.0057328069999999995,
                                0.005327431,
                                0.005133368,
                                0.004963481,
                                0.004641172,
                                0.004406834,
                                0.003940825],
                               [0.00561392,
                                0.005512202,
                                0.00500889,
                                0.004726922,
                                0.004578108,
                                0.004315954,
                                0.004095817,
                                0.003638207],
                               [0.005518087,
                                0.00544462,
                                0.004959923,
                                0.004710887,
                                0.0045470779999999995,
                                0.004421458,
                                0.0042052190000000005,
                                0.003754013]],
                      -0.0025: [[0.004388399,
                                 0.005253905,
                                 0.005812451999999999,
                                 0.005846166,
                                 0.005877495,
                                 0.005740047,
                                 0.005711796999999999,
                                 0.005714706],
                                [0.0048050359999999995,
                                 0.005142725,
                                 0.005696888000000001,
                                 0.0057681040000000005,
                                 0.005816555,
                                 0.005662237,
                                 0.005592229000000001,
                                 0.005503241999999999],
                                [0.0050134229999999995,
                                 0.005265895,
                                 0.005548661999999999,
                                 0.00567064,
                                 0.00571409,
                                 0.005556291999999999,
                                 0.005490244,
                                 0.0054065269999999995],
                                [0.0051206820000000005,
                                 0.005182984,
                                 0.005389233,
                                 0.005576843000000001,
                                 0.005580248,
                                 0.005565413000000001,
                                 0.005507683,
                                 0.005572639],
                                [0.0055430359999999994,
                                 0.005536345,
                                 0.005790946999999999,
                                 0.0056789990000000005,
                                 0.005745773000000001,
                                 0.005655905,
                                 0.005552395,
                                 0.005298867],
                                [0.005902986999999999,
                                 0.00587671,
                                 0.005894823,
                                 0.005785453,
                                 0.005792498,
                                 0.005650138000000001,
                                 0.005502708,
                                 0.005162145],
                                [0.006050024,
                                 0.006086214,
                                 0.0059502209999999995,
                                 0.00589841,
                                 0.00578498,
                                 0.005531594,
                                 0.005311476,
                                 0.004815883],
                                [0.006057619,
                                 0.006046866999999999,
                                 0.005835575,
                                 0.00577857,
                                 0.00565319,
                                 0.005367256,
                                 0.005068569,
                                 0.004568894],
                                [0.006074724,
                                 0.005953215,
                                 0.005641841,
                                 0.005511561999999999,
                                 0.0053959590000000005,
                                 0.005080798,
                                 0.004742383,
                                 0.004293465],
                                [0.005904466999999999,
                                 0.0057617530000000005,
                                 0.005362942,
                                 0.00519023,
                                 0.0050029259999999996,
                                 0.004683257,
                                 0.004451175,
                                 0.003986917],
                                [0.005696165,
                                 0.005572547,
                                 0.005056036,
                                 0.004803285,
                                 0.004632221,
                                 0.004375756,
                                 0.004154844,
                                 0.0036993559999999996],
                                [0.0055951840000000004,
                                 0.005501464,
                                 0.005001166,
                                 0.004759597,
                                 0.004598285,
                                 0.004413606,
                                 0.004197485999999999,
                                 0.003746825]],
                      0.0: [[0.004071046,
                             0.00491924,
                             0.005493876,
                             0.005578424,
                             0.005613119000000001,
                             0.005494708,
                             0.005443491999999999,
                             0.005444289000000001],
                            [0.0045310820000000005,
                             0.004895201,
                             0.005466405,
                             0.00557787,
                             0.005611713000000001,
                             0.005484643000000001,
                             0.0053944069999999995,
                             0.005302814],
                            [0.00482345,
                             0.005101051,
                             0.005417356,
                             0.005549719,
                             0.005601315,
                             0.0054742440000000005,
                             0.00538869,
                             0.005303963],
                            [0.004990335,
                             0.00507535,
                             0.00534482,
                             0.005490167,
                             0.005588065,
                             0.005511782,
                             0.0054390390000000005,
                             0.005620614],
                            [0.005462951,
                             0.005469834,
                             0.005751564,
                             0.005791152,
                             0.005763875999999999,
                             0.005628167,
                             0.00552162,
                             0.005268206],
                            [0.005902573,
                             0.005855541,
                             0.005893801999999999,
                             0.00587516,
                             0.005823709,
                             0.005650807,
                             0.005497327,
                             0.0051584890000000005],
                            [0.006177205,
                             0.0061457859999999994,
                             0.006009465,
                             0.005943957,
                             0.005838662,
                             0.005572201999999999,
                             0.0053481940000000006,
                             0.004854969000000001],
                            [0.006147454,
                             0.006089328000000001,
                             0.00588662,
                             0.005826384,
                             0.005700841,
                             0.005408885,
                             0.005106325,
                             0.004611911],
                            [0.0060794709999999995,
                             0.005982309,
                             0.005685012,
                             0.005565279,
                             0.0054367880000000006,
                             0.005122283,
                             0.004784251,
                             0.004343281],
                            [0.005938402,
                             0.005805975,
                             0.005412052,
                             0.0052590580000000005,
                             0.005052572,
                             0.004735469,
                             0.0045050690000000004,
                             0.004043051],
                            [0.005765894000000001,
                             0.005643358,
                             0.005110974,
                             0.004880654,
                             0.004690110999999999,
                             0.0044360879999999995,
                             0.004216407,
                             0.00376098],
                            [0.005653411999999999,
                             0.005566334,
                             0.005051742,
                             0.004813892,
                             0.00465327,
                             0.004409004,
                             0.004193102,
                             0.0037418679999999998]],
                      0.0025: [[0.003961028,
                                0.004848608,
                                0.005347165,
                                0.0054565840000000004,
                                0.005507168000000001,
                                0.005407176999999999,
                                0.0053419819999999995,
                                0.005347213000000001],
                               [0.004436787,
                                0.004825117,
                                0.005376636999999999,
                                0.005518047,
                                0.005546407,
                                0.00542417,
                                0.005318153000000001,
                                0.005227158],
                               [0.005970623,
                                0.005067145,
                                0.0053901669999999995,
                                0.0055275409999999995,
                                0.005585945,
                                0.005468828,
                                0.005367772,
                                0.005283431],
                               [0.00492369,
                                0.00505391,
                                0.005352313,
                                0.005468255,
                                0.005627897,
                                0.005506424,
                                0.005420145,
                                0.005328961],
                               [0.005456374,
                                0.005469939,
                                0.005770183000000001,
                                0.005907824,
                                0.005815287,
                                0.005656256,
                                0.00553542,
                                0.005288438],
                               [0.005946615,
                                0.005880231999999999,
                                0.005927742,
                                0.0059713119999999995,
                                0.005876144,
                                0.00568228,
                                0.005521428,
                                0.005188417],
                               [0.006275819,
                                0.006197023,
                                0.006066836,
                                0.0059956259999999996,
                                0.005890951,
                                0.005615173,
                                0.00538757,
                                0.004898935],
                               [0.006218316999999999,
                                0.006136206999999999,
                                0.005938422,
                                0.005879222,
                                0.005747189000000001,
                                0.005448621,
                                0.005148001,
                                0.00465971],
                               [0.006110031,
                                0.006009530999999999,
                                0.005723569,
                                0.005615871999999999,
                                0.005471664,
                                0.0051576999999999994,
                                0.004824831,
                                0.004393763],
                               [0.005978987,
                                0.0058351769999999996,
                                0.005445435,
                                0.005313255,
                                0.005088782,
                                0.004776868,
                                0.004550944,
                                0.004098059],
                               [0.00587626,
                                0.005694849,
                                0.00515821,
                                0.004951442,
                                0.0047425620000000005,
                                0.004493945,
                                0.00427186,
                                0.0038214440000000002],
                               [0.005761504000000001,
                                0.005617405,
                                0.005091116,
                                0.004861384,
                                0.004703206,
                                0.004397509,
                                0.00418168,
                                0.003732202]],
                      0.005: [[0.0041955809999999994,
                               0.00508135,
                               0.005419099,
                               0.005514275999999999,
                               0.005588775,
                               0.005502651,
                               0.005439783,
                               0.005454754],
                              [0.0046261159999999996,
                               0.00496853,
                               0.005457836,
                               0.005607783000000001,
                               0.00563856,
                               0.005496686999999999,
                               0.005385681,
                               0.005298031999999999],
                              [0.004811408,
                               0.005187737,
                               0.005482745,
                               0.0056154709999999995,
                               0.005682751999999999,
                               0.005545497,
                               0.005438062,
                               0.005354666],
                              [0.00500389,
                               0.0051514659999999995,
                               0.0054360580000000006,
                               0.0055393280000000005,
                               0.0057136059999999995,
                               0.005572405,
                               0.00547961,
                               0.005295739],
                              [0.005548096,
                               0.005555331,
                               0.0058692580000000005,
                               0.006036025,
                               0.005913023000000001,
                               0.005742711,
                               0.005618532,
                               0.005377081],
                              [0.006043883000000001,
                               0.005958669000000001,
                               0.006016171999999999,
                               0.00608099,
                               0.005962574,
                               0.005760746999999999,
                               0.005597284,
                               0.005269596999999999],
                              [0.006387688000000001,
                               0.006267753,
                               0.0061398419999999995,
                               0.0060671909999999996,
                               0.005957425,
                               0.005679326,
                               0.00544991,
                               0.004964807],
                              [0.006315935999999999,
                               0.006194501,
                               0.00600134,
                               0.0059482319999999995,
                               0.005805375,
                               0.005506626999999999,
                               0.005207066,
                               0.00472619],
                              [0.006181226999999999,
                               0.0060489540000000005,
                               0.005771347,
                               0.005680685,
                               0.005517327,
                               0.005206260999999999,
                               0.004878312,
                               0.004460235999999999],
                              [0.006048554,
                               0.005880298000000001,
                               0.005492833000000001,
                               0.005379467,
                               0.0051355229999999995,
                               0.004827325,
                               0.004606019,
                               0.004162769],
                              [0.005969627,
                               0.005758558,
                               0.005212903,
                               0.005023522,
                               0.004799016,
                               0.004552616,
                               0.004330139,
                               0.003882603],
                              [0.005851126,
                               0.00567743,
                               0.005140866,
                               0.004915259,
                               0.004757506,
                               0.004391101,
                               0.004175401,
                               0.0037264240000000003]],
                      0.01: [[0.00509818,
                              0.006023719,
                              0.006047043,
                              0.006053124,
                              0.006178363,
                              0.006101139,
                              0.006068116,
                              0.006105271],
                             [0.005437612,
                              0.005664145,
                              0.006010429,
                              0.0061350680000000005,
                              0.006186835,
                              0.005963522,
                              0.005863594000000001,
                              0.00578455],
                             [0.00532959,
                              0.005757916,
                              0.005950202,
                              0.006058215,
                              0.006140828,
                              0.005907727,
                              0.005807151,
                              0.005730135],
                             [0.0054583669999999996,
                              0.00560809,
                              0.00578102,
                              0.0059015230000000005,
                              0.0059950409999999996,
                              0.005876154000000001,
                              0.005785081,
                              0.005440805999999999],
                             [0.005959995,
                              0.005931103,
                              0.006253299,
                              0.006315611,
                              0.006218062,
                              0.006065618,
                              0.00594381,
                              0.005713358000000001],
                             [0.006371697,
                              0.0062551759999999994,
                              0.006320968000000001,
                              0.006329774,
                              0.006215799,
                              0.0060296130000000005,
                              0.005867818,
                              0.005550558000000001],
                             [0.006609807,
                              0.006439215999999999,
                              0.006314143,
                              0.006253881,
                              0.0061164999999999995,
                              0.005850162,
                              0.005620548,
                              0.00514152],
                             [0.00654255,
                              0.00633834,
                              0.006149768000000001,
                              0.006121814000000001,
                              0.005943832,
                              0.005656090999999999,
                              0.005361999,
                              0.004897767],
                             [0.0064226959999999994,
                              0.006151337,
                              0.005881198000000001,
                              0.005834631999999999,
                              0.005624678,
                              0.005324138000000001,
                              0.005008999,
                              0.004622983],
                             [0.006248556,
                              0.0059881019999999995,
                              0.0056003730000000005,
                              0.005523131999999999,
                              0.005237057,
                              0.004940792,
                              0.00473027,
                              0.004309223],
                             [0.006175091,
                              0.005887896,
                              0.005330039,
                              0.005164259,
                              0.004914834,
                              0.00466963,
                              0.004446754,
                              0.004006452],
                             [0.006043059,
                              0.005803194,
                              0.005251535999999999,
                              0.005030267,
                              0.0048714890000000005,
                              0.004385683,
                              0.004170108,
                              0.00372164]]}}


def __get_data_KRW_Swaptions():
    return {'tenor': ['1y', '2y', '5y', '7y', '10y', '15y', '20y', '30y'],
            'expiry': ['1m',
                       '3m',
                       '6m',
                       '1y',
                       '2y',
                       '3y',
                       '5y',
                       '7y',
                       '10y',
                       '15y',
                       '20y'],
            'quote': {-0.01: [[0.001609555,
                               0.002056775,
                               0.0024236410000000003,
                               0.0023395770000000002,
                               0.0022597629999999997,
                               0.002247388,
                               0.002186452,
                               0.001961499],
                              [0.001688034,
                               0.002029126,
                               0.002507648,
                               0.002603959,
                               0.002493768,
                               0.002469481,
                               0.002393232,
                               0.002146372],
                              [0.001851435,
                               0.002059822,
                               0.00249476,
                               0.002468943,
                               0.002520662,
                               0.002455058,
                               0.002378257,
                               0.00213177],
                              [0.002064054,
                               0.0021966679999999997,
                               0.002485417,
                               0.0024881120000000002,
                               0.002550163,
                               0.0024657529999999998,
                               0.00240037,
                               0.002148158],
                              [0.002261019,
                               0.002219533,
                               0.002484835,
                               0.002503492,
                               0.002554367,
                               0.002430611,
                               0.002358604,
                               0.0021017279999999998],
                              [0.002405795,
                               0.002352732,
                               0.002457834,
                               0.002447037,
                               0.002557637,
                               0.002425239,
                               0.002308058,
                               0.002048673],
                              [0.002544072,
                               0.002448455,
                               0.002443325,
                               0.002444519,
                               0.002557311,
                               0.002381969,
                               0.002227574,
                               0.001962932],
                              [0.0027735209999999997,
                               0.002665411,
                               0.00252179,
                               0.002407208,
                               0.002567352,
                               0.002343119,
                               0.002185891,
                               0.00191516],
                              [0.003076174,
                               0.002912587,
                               0.002460403,
                               0.002323987,
                               0.002450421,
                               0.002282511,
                               0.002073223,
                               0.001810719],
                              [0.0027093309999999997,
                               0.002391895,
                               0.001985233,
                               0.001990655,
                               0.002162554,
                               0.001997715,
                               0.001885224,
                               0.001650199],
                              [0.002368639,
                               0.002173557,
                               0.001715116,
                               0.0017872729999999998,
                               0.001996602,
                               0.0018700479999999998,
                               0.001764129,
                               0.0015417410000000001]],
                      -0.005: [[0.002121834,
                                0.00262253,
                                0.003123736,
                                0.00301435,
                                0.0028878109999999997,
                                0.002849767,
                                0.0027860370000000003,
                                0.002576969],
                               [0.002133451,
                                0.00260278,
                                0.003239943,
                                0.003220217,
                                0.0031884229999999997,
                                0.0031334170000000003,
                                0.003052345,
                                0.0028231109999999997],
                               [0.0023610429999999997,
                                0.0026567490000000003,
                                0.0032299090000000004,
                                0.003186698,
                                0.003222595,
                                0.003117117,
                                0.003036881,
                                0.00280794],
                               [0.002686992,
                                0.0028552820000000002,
                                0.00322456,
                                0.0032107740000000004,
                                0.003256619,
                                0.003132285,
                                0.003070487,
                                0.002836592],
                               [0.00293445,
                                0.002878482,
                                0.003217176,
                                0.00321324,
                                0.00324459,
                                0.003085806,
                                0.003024217,
                                0.002786243],
                               [0.003117639,
                                0.0030576440000000004,
                                0.0031626209999999996,
                                0.0031239909999999996,
                                0.00323857,
                                0.003078085,
                                0.002967806,
                                0.002727836],
                               [0.003277185,
                                0.0031544140000000003,
                                0.003098451,
                                0.003077685,
                                0.0032169670000000003,
                                0.0030221420000000002,
                                0.002883138,
                                0.002639104],
                               [0.0034962540000000003,
                                0.0033533720000000003,
                                0.0031485190000000002,
                                0.00301025,
                                0.00322914,
                                0.002994229,
                                0.0028549490000000003,
                                0.002606456],
                               [0.0038147190000000003,
                                0.0036057959999999997,
                                0.0030707340000000003,
                                0.00292495,
                                0.003109561,
                                0.002978225,
                                0.00277105,
                                0.0025332370000000002],
                               [0.0034904890000000003,
                                0.003085205,
                                0.002569914,
                                0.002624495,
                                0.002910955,
                                0.0027674229999999998,
                                0.002682134,
                                0.002477974],
                               [0.0033037709999999996,
                                0.003046733,
                                0.002440979,
                                0.002569637,
                                0.002915643,
                                0.002807381,
                                0.002727781,
                                0.002547715]],
                      -0.0025: [[0.0021965120000000003,
                                 0.00287245,
                                 0.0034308679999999997,
                                 0.003310407,
                                 0.003164589,
                                 0.003116015,
                                 0.0030503979999999997,
                                 0.00284409],
                                [0.002330829,
                                 0.0028550409999999996,
                                 0.00356077,
                                 0.00353764,
                                 0.0034944340000000003,
                                 0.003427061,
                                 0.003343062,
                                 0.003116753],
                                [0.0025863,
                                 0.0029184959999999996,
                                 0.003551627,
                                 0.0035013970000000003,
                                 0.003531828,
                                 0.003409772,
                                 0.0033271259999999997,
                                 0.00310111],
                                [0.002958838,
                                 0.003142938,
                                 0.003547704,
                                 0.0035275999999999997,
                                 0.003568023,
                                 0.003426905,
                                 0.0033656,
                                 0.003134698],
                                [0.003228827,
                                 0.003166638,
                                 0.003537699,
                                 0.003525287,
                                 0.003549703,
                                 0.003375506,
                                 0.0033169759999999997,
                                 0.003082038],
                                [0.0034290559999999998,
                                 0.003365563,
                                 0.0034720809999999997,
                                 0.003422449,
                                 0.003540068,
                                 0.0033667859999999997,
                                 0.003257548,
                                 0.0030206440000000003],
                                [0.0035988920000000002,
                                 0.003464195,
                                 0.003388295,
                                 0.0033588690000000004,
                                 0.0035100440000000004,
                                 0.003305282,
                                 0.0031700440000000003,
                                 0.002929143],
                                [0.003817027,
                                 0.0036590140000000004,
                                 0.003428063,
                                 0.0032789990000000003,
                                 0.003523181,
                                 0.003281112,
                                 0.003146368,
                                 0.0029011059999999997],
                                [0.004145335,
                                 0.003916381,
                                 0.003343019,
                                 0.0031918790000000003,
                                 0.003401078,
                                 0.003281456,
                                 0.0030713840000000004,
                                 0.002836859],
                                [0.0038333679999999998,
                                 0.003389306,
                                 0.002825866,
                                 0.0028993390000000003,
                                 0.0032320179999999997,
                                 0.003092745,
                                 0.003014345,
                                 0.002813597],
                                [0.0036978479999999997,
                                 0.003413722,
                                 0.002743635,
                                 0.002894178,
                                 0.003293918,
                                 0.0031877859999999997,
                                 0.0031130529999999997,
                                 0.0029366979999999997]],
                      0.0: [[0.002367499,
                             0.003107705,
                             0.003719695,
                             0.003588842,
                             0.003425223,
                             0.003367283,
                             0.003299642,
                             0.003094518],
                            [0.002517065,
                             0.003092448,
                             0.003862335,
                             0.003836086,
                             0.003782592,
                             0.003703947,
                             0.0036169279999999997,
                             0.00339191],
                            [0.002798478,
                             0.003164601,
                             0.003853927,
                             0.003797252,
                             0.003823025,
                             0.003685695,
                             0.003600489,
                             0.003375767],
                            [0.0032140420000000003,
                             0.003413056,
                             0.003851242,
                             0.003825474,
                             0.0038613379999999997,
                             0.003704658,
                             0.00364347,
                             0.00341387],
                            [0.003505333,
                             0.003437434,
                             0.003838883,
                             0.00381894,
                             0.003837353,
                             0.003648645,
                             0.003592513,
                             0.003358867],
                            [0.0037217459999999997,
                             0.0036547240000000003,
                             0.003763179,
                             0.003703578,
                             0.0038244729999999997,
                             0.003639,
                             0.00353011,
                             0.003294487],
                            [0.003901452,
                             0.003755536,
                             0.0036616340000000004,
                             0.003624385,
                             0.003786833,
                             0.0035722690000000003,
                             0.0034396340000000004,
                             0.00319999],
                            [0.004119868,
                             0.003947668,
                             0.003692436,
                             0.003533085,
                             0.003800886,
                             0.003551284,
                             0.003419787,
                             0.003175764],
                            [0.0044584229999999996,
                             0.00421049,
                             0.003600447,
                             0.003443851,
                             0.0036759659999999997,
                             0.0035660170000000003,
                             0.003352134,
                             0.00311878],
                            [0.004155988,
                             0.003675279,
                             0.003066402,
                             0.0031568559999999996,
                             0.003531883,
                             0.003395313,
                             0.003322211,
                             0.003122561],
                            [0.004064115,
                             0.0037545609999999996,
                             0.003024128,
                             0.0031945709999999998,
                             0.003643405,
                             0.0035381009999999997,
                             0.003466709,
                             0.0032914859999999997]],
                      0.0025: [[0.0025306079999999997,
                                0.003331624,
                                0.003994253,
                                0.0038535320000000002,
                                0.0036732329999999997,
                                0.0036066059999999996,
                                0.003536891,
                                0.00333204],
                               [0.002694508,
                                0.003318244,
                                0.004148915,
                                0.004119754000000001,
                                0.004056771,
                                0.003967644,
                                0.003877585,
                                0.00365286],
                               [0.0030003990000000004,
                                0.0033985240000000004,
                                0.0041411420000000004,
                                0.0040784409999999995,
                                0.004100098,
                                0.0039484590000000005,
                                0.0038606359999999998,
                                0.003636194],
                               [0.00345636,
                                0.003669581,
                                0.004139566,
                                0.004108593,
                                0.004140461,
                                0.003969146,
                                0.00390784,
                                0.0036785040000000004],
                               [0.003767975,
                                0.0036944779999999997,
                                0.004125043,
                                0.004098226,
                                0.0041112729999999995,
                                0.0039087620000000005,
                                0.003854592,
                                0.003621177],
                               [0.003999615,
                                0.003929345999999999,
                                0.004039951,
                                0.003971121,
                                0.004095404,
                                0.003898242,
                                0.003789271,
                                0.003553845],
                               [0.004189089,
                                0.004032505,
                                0.003921976,
                                0.003877505,
                                0.0040507270000000005,
                                0.0038265409999999997,
                                0.00369577,
                                0.003456257],
                               [0.004408534,
                                0.0042228759999999995,
                                0.003944737,
                                0.003775517,
                                0.004065658,
                                0.0038083590000000003,
                                0.0036792870000000003,
                                0.003435315],
                               [0.004757498,
                                0.00449169,
                                0.003846332,
                                0.003684266,
                                0.003937767,
                                0.0038361479999999997,
                                0.0036179579999999997,
                                0.003384554],
                               [0.004462544000000001,
                                0.003947134000000001,
                                0.00329496,
                                0.0034010579999999998,
                                0.003815643,
                                0.003680853,
                                0.00361207,
                                0.003412285],
                               [0.004409652,
                                0.004075953,
                                0.003288255,
                                0.0034772159999999996,
                                0.003971881,
                                0.003866707,
                                0.0037978129999999997,
                                0.003622416]],
                      0.005: [[0.0026872840000000003,
                               0.0035463340000000004,
                               0.004257276,
                               0.0041071070000000005,
                               0.003910987,
                               0.0038361940000000002,
                               0.0037643909999999997,
                               0.003559213],
                              [0.002864777,
                               0.00353463,
                               0.004423395,
                               0.004391481,
                               0.004319608,
                               0.004220598,
                               0.004127505,
                               0.003902412],
                              [0.003193992,
                               0.003622602,
                               0.004416183,
                               0.004347778,
                               0.004365709000000001,
                               0.004200507,
                               0.004110043,
                               0.003885225],
                              [0.0036883040000000003,
                               0.0039151559999999995,
                               0.004415624,
                               0.0043797870000000004,
                               0.004408067,
                               0.004222834,
                               0.004161258,
                               0.003931512],
                              [0.0040194409999999995,
                               0.003940694000000001,
                               0.004399078,
                               0.004365872,
                               0.004374012,
                               0.004158271,
                               0.00410576,
                               0.0038718859999999997],
                              [0.004265792,
                               0.004192254,
                               0.004305134,
                               0.004227632,
                               0.0043553509999999995,
                               0.004146919000000001,
                               0.004037583,
                               0.0038016559999999996],
                              [0.004464659,
                               0.004297853,
                               0.004171732,
                               0.004120489000000001,
                               0.004304075,
                               0.004874811,
                               0.00394105,
                               0.0037009459999999997],
                              [0.004685619,
                               0.004487087,
                               0.004187128,
                               0.004008391,
                               0.004319853,
                               0.004054811,
                               0.003927613,
                               0.003682945],
                              [0.005045028,
                               0.00476198,
                               0.004082473,
                               0.00391497,
                               0.004188911,
                               0.004094674,
                               0.0038719,
                               0.003637687],
                              [0.004756372,
                               0.00420758,
                               0.003513853,
                               0.0036345999999999995,
                               0.0040866240000000005,
                               0.003953025,
                               0.003887935,
                               0.003687267],
                              [0.004738942,
                               0.004382128,
                               0.0035396390000000002,
                               0.0037460840000000002,
                               0.004284124,
                               0.004178664,
                               0.004111747,
                               0.0039354329999999995]],
                      0.01: [[0.002984954,
                              0.0039538659999999995,
                              0.004755954000000001,
                              0.004588036,
                              0.004362119,
                              0.004272296,
                              0.004196134,
                              0.003989258],
                             [0.0031880109999999997,
                              0.003945089000000001,
                              0.004943727,
                              0.004906665,
                              0.004818315,
                              0.004700895,
                              0.004601815,
                              0.0043747709999999995],
                             [0.003561375,
                              0.004047441,
                              0.0049375,
                              0.004858414,
                              0.004869699,
                              0.004679059,
                              0.004583333,
                              0.0043565470000000005],
                             [0.004127733,
                              0.0043804759999999995,
                              0.0049387829999999995,
                              0.00489396,
                              0.0049158959999999995,
                              0.00470448,
                              0.00464208,
                              0.004410273],
                             [0.00449599,
                              0.004407322,
                              0.0049185,
                              0.004873558,
                              0.004872854,
                              0.004632009,
                              0.004582213,
                              0.0043461559999999995],
                             [0.004770287,
                              0.004690436,
                              0.004808044,
                              0.004714427,
                              0.004849035,
                              0.004619092,
                              0.004508501,
                              0.004270293],
                             [0.00498722,
                              0.004801029,
                              0.0046459990000000005,
                              0.004582213,
                              0.00478553,
                              0.004533613,
                              0.004405961,
                              0.004163364],
                             [0.005212098,
                              0.004989191,
                              0.004648103,
                              0.00445119,
                              0.004802926,
                              0.0045224670000000005,
                              0.004397947,
                              0.004150541],
                             [0.005592263,
                              0.0052764859999999995,
                              0.004531587,
                              0.004353377,
                              0.0046658,
                              0.004584399,
                              0.004352054,
                              0.004114894],
                             [0.005313651,
                              0.00470147,
                              0.003928798,
                              0.004076677,
                              0.004598828,
                              0.004466528,
                              0.004407623,
                              0.004203943],
                             [0.005360131999999999,
                              0.004959512,
                              0.004013245,
                              0.0042523840000000005,
                              0.004871716,
                              0.004764989,
                              0.004701093,
                              0.004521751]]}}


def __get_data_TWD_Swaptions():
    return {'tenor': ['1y', '2y', '5y', '7y', '10y', '15y', '20y', '30y'],
            'expiry': ['1m',
                       '3m',
                       '6m',
                       '1y',
                       '2y',
                       '3y',
                       '5y',
                       '7y',
                       '10y',
                       '15y',
                       '20y'],
            'quote': {-0.01: [[0.001609555,
                               0.002056775,
                               0.0024236410000000003,
                               0.0023395770000000002,
                               0.0022597629999999997,
                               0.002247388,
                               0.002186452,
                               0.001961499],
                              [0.001688034,
                               0.002029126,
                               0.002507648,
                               0.002603959,
                               0.002493768,
                               0.002469481,
                               0.002393232,
                               0.002146372],
                              [0.001851435,
                               0.002059822,
                               0.00249476,
                               0.002468943,
                               0.002520662,
                               0.002455058,
                               0.002378257,
                               0.00213177],
                              [0.002064054,
                               0.0021966679999999997,
                               0.002485417,
                               0.0024881120000000002,
                               0.002550163,
                               0.0024657529999999998,
                               0.00240037,
                               0.002148158],
                              [0.002261019,
                               0.002219533,
                               0.002484835,
                               0.002503492,
                               0.002554367,
                               0.002430611,
                               0.002358604,
                               0.0021017279999999998],
                              [0.002405795,
                               0.002352732,
                               0.002457834,
                               0.002447037,
                               0.002557637,
                               0.002425239,
                               0.002308058,
                               0.002048673],
                              [0.002544072,
                               0.002448455,
                               0.002443325,
                               0.002444519,
                               0.002557311,
                               0.002381969,
                               0.002227574,
                               0.001962932],
                              [0.0027735209999999997,
                               0.002665411,
                               0.00252179,
                               0.002407208,
                               0.002567352,
                               0.002343119,
                               0.002185891,
                               0.00191516],
                              [0.003076174,
                               0.002912587,
                               0.002460403,
                               0.002323987,
                               0.002450421,
                               0.002282511,
                               0.002073223,
                               0.001810719],
                              [0.0027093309999999997,
                               0.002391895,
                               0.001985233,
                               0.001990655,
                               0.002162554,
                               0.001997715,
                               0.001885224,
                               0.001650199],
                              [0.002368639,
                               0.002173557,
                               0.001715116,
                               0.0017872729999999998,
                               0.001996602,
                               0.0018700479999999998,
                               0.001764129,
                               0.0015417410000000001]],
                      -0.005: [[0.002121834,
                                0.00262253,
                                0.003123736,
                                0.00301435,
                                0.0028878109999999997,
                                0.002849767,
                                0.0027860370000000003,
                                0.002576969],
                               [0.002133451,
                                0.00260278,
                                0.003239943,
                                0.003220217,
                                0.0031884229999999997,
                                0.0031334170000000003,
                                0.003052345,
                                0.0028231109999999997],
                               [0.0023610429999999997,
                                0.0026567490000000003,
                                0.0032299090000000004,
                                0.003186698,
                                0.003222595,
                                0.003117117,
                                0.003036881,
                                0.00280794],
                               [0.002686992,
                                0.0028552820000000002,
                                0.00322456,
                                0.0032107740000000004,
                                0.003256619,
                                0.003132285,
                                0.003070487,
                                0.002836592],
                               [0.00293445,
                                0.002878482,
                                0.003217176,
                                0.00321324,
                                0.00324459,
                                0.003085806,
                                0.003024217,
                                0.002786243],
                               [0.003117639,
                                0.0030576440000000004,
                                0.0031626209999999996,
                                0.0031239909999999996,
                                0.00323857,
                                0.003078085,
                                0.002967806,
                                0.002727836],
                               [0.003277185,
                                0.0031544140000000003,
                                0.003098451,
                                0.003077685,
                                0.0032169670000000003,
                                0.0030221420000000002,
                                0.002883138,
                                0.002639104],
                               [0.0034962540000000003,
                                0.0033533720000000003,
                                0.0031485190000000002,
                                0.00301025,
                                0.00322914,
                                0.002994229,
                                0.0028549490000000003,
                                0.002606456],
                               [0.0038147190000000003,
                                0.0036057959999999997,
                                0.0030707340000000003,
                                0.00292495,
                                0.003109561,
                                0.002978225,
                                0.00277105,
                                0.0025332370000000002],
                               [0.0034904890000000003,
                                0.003085205,
                                0.002569914,
                                0.002624495,
                                0.002910955,
                                0.0027674229999999998,
                                0.002682134,
                                0.002477974],
                               [0.0033037709999999996,
                                0.003046733,
                                0.002440979,
                                0.002569637,
                                0.002915643,
                                0.002807381,
                                0.002727781,
                                0.002547715]],
                      -0.0025: [[0.0021965120000000003,
                                 0.00287245,
                                 0.0034308679999999997,
                                 0.003310407,
                                 0.003164589,
                                 0.003116015,
                                 0.0030503979999999997,
                                 0.00284409],
                                [0.002330829,
                                 0.0028550409999999996,
                                 0.00356077,
                                 0.00353764,
                                 0.0034944340000000003,
                                 0.003427061,
                                 0.003343062,
                                 0.003116753],
                                [0.0025863,
                                 0.0029184959999999996,
                                 0.003551627,
                                 0.0035013970000000003,
                                 0.003531828,
                                 0.003409772,
                                 0.0033271259999999997,
                                 0.00310111],
                                [0.002958838,
                                 0.003142938,
                                 0.003547704,
                                 0.0035275999999999997,
                                 0.003568023,
                                 0.003426905,
                                 0.0033656,
                                 0.003134698],
                                [0.003228827,
                                 0.003166638,
                                 0.003537699,
                                 0.003525287,
                                 0.003549703,
                                 0.003375506,
                                 0.0033169759999999997,
                                 0.003082038],
                                [0.0034290559999999998,
                                 0.003365563,
                                 0.0034720809999999997,
                                 0.003422449,
                                 0.003540068,
                                 0.0033667859999999997,
                                 0.003257548,
                                 0.0030206440000000003],
                                [0.0035988920000000002,
                                 0.003464195,
                                 0.003388295,
                                 0.0033588690000000004,
                                 0.0035100440000000004,
                                 0.003305282,
                                 0.0031700440000000003,
                                 0.002929143],
                                [0.003817027,
                                 0.0036590140000000004,
                                 0.003428063,
                                 0.0032789990000000003,
                                 0.003523181,
                                 0.003281112,
                                 0.003146368,
                                 0.0029011059999999997],
                                [0.004145335,
                                 0.003916381,
                                 0.003343019,
                                 0.0031918790000000003,
                                 0.003401078,
                                 0.003281456,
                                 0.0030713840000000004,
                                 0.002836859],
                                [0.0038333679999999998,
                                 0.003389306,
                                 0.002825866,
                                 0.0028993390000000003,
                                 0.0032320179999999997,
                                 0.003092745,
                                 0.003014345,
                                 0.002813597],
                                [0.0036978479999999997,
                                 0.003413722,
                                 0.002743635,
                                 0.002894178,
                                 0.003293918,
                                 0.0031877859999999997,
                                 0.0031130529999999997,
                                 0.0029366979999999997]],
                      0.0: [[0.002367499,
                             0.003107705,
                             0.003719695,
                             0.003588842,
                             0.003425223,
                             0.003367283,
                             0.003299642,
                             0.003094518],
                            [0.002517065,
                             0.003092448,
                             0.003862335,
                             0.003836086,
                             0.003782592,
                             0.003703947,
                             0.0036169279999999997,
                             0.00339191],
                            [0.002798478,
                             0.003164601,
                             0.003853927,
                             0.003797252,
                             0.003823025,
                             0.003685695,
                             0.003600489,
                             0.003375767],
                            [0.0032140420000000003,
                             0.003413056,
                             0.003851242,
                             0.003825474,
                             0.0038613379999999997,
                             0.003704658,
                             0.00364347,
                             0.00341387],
                            [0.003505333,
                             0.003437434,
                             0.003838883,
                             0.00381894,
                             0.003837353,
                             0.003648645,
                             0.003592513,
                             0.003358867],
                            [0.0037217459999999997,
                             0.0036547240000000003,
                             0.003763179,
                             0.003703578,
                             0.0038244729999999997,
                             0.003639,
                             0.00353011,
                             0.003294487],
                            [0.003901452,
                             0.003755536,
                             0.0036616340000000004,
                             0.003624385,
                             0.003786833,
                             0.0035722690000000003,
                             0.0034396340000000004,
                             0.00319999],
                            [0.004119868,
                             0.003947668,
                             0.003692436,
                             0.003533085,
                             0.003800886,
                             0.003551284,
                             0.003419787,
                             0.003175764],
                            [0.0044584229999999996,
                             0.00421049,
                             0.003600447,
                             0.003443851,
                             0.0036759659999999997,
                             0.0035660170000000003,
                             0.003352134,
                             0.00311878],
                            [0.004155988,
                             0.003675279,
                             0.003066402,
                             0.0031568559999999996,
                             0.003531883,
                             0.003395313,
                             0.003322211,
                             0.003122561],
                            [0.004064115,
                             0.0037545609999999996,
                             0.003024128,
                             0.0031945709999999998,
                             0.003643405,
                             0.0035381009999999997,
                             0.003466709,
                             0.0032914859999999997]],
                      0.0025: [[0.0025306079999999997,
                                0.003331624,
                                0.003994253,
                                0.0038535320000000002,
                                0.0036732329999999997,
                                0.0036066059999999996,
                                0.003536891,
                                0.00333204],
                               [0.002694508,
                                0.003318244,
                                0.004148915,
                                0.004119754000000001,
                                0.004056771,
                                0.003967644,
                                0.003877585,
                                0.00365286],
                               [0.0030003990000000004,
                                0.0033985240000000004,
                                0.0041411420000000004,
                                0.0040784409999999995,
                                0.004100098,
                                0.0039484590000000005,
                                0.0038606359999999998,
                                0.003636194],
                               [0.00345636,
                                0.003669581,
                                0.004139566,
                                0.004108593,
                                0.004140461,
                                0.003969146,
                                0.00390784,
                                0.0036785040000000004],
                               [0.003767975,
                                0.0036944779999999997,
                                0.004125043,
                                0.004098226,
                                0.0041112729999999995,
                                0.0039087620000000005,
                                0.003854592,
                                0.003621177],
                               [0.003999615,
                                0.003929345999999999,
                                0.004039951,
                                0.003971121,
                                0.004095404,
                                0.003898242,
                                0.003789271,
                                0.003553845],
                               [0.004189089,
                                0.004032505,
                                0.003921976,
                                0.003877505,
                                0.0040507270000000005,
                                0.0038265409999999997,
                                0.00369577,
                                0.003456257],
                               [0.004408534,
                                0.0042228759999999995,
                                0.003944737,
                                0.003775517,
                                0.004065658,
                                0.0038083590000000003,
                                0.0036792870000000003,
                                0.003435315],
                               [0.004757498,
                                0.00449169,
                                0.003846332,
                                0.003684266,
                                0.003937767,
                                0.0038361479999999997,
                                0.0036179579999999997,
                                0.003384554],
                               [0.004462544000000001,
                                0.003947134000000001,
                                0.00329496,
                                0.0034010579999999998,
                                0.003815643,
                                0.003680853,
                                0.00361207,
                                0.003412285],
                               [0.004409652,
                                0.004075953,
                                0.003288255,
                                0.0034772159999999996,
                                0.003971881,
                                0.003866707,
                                0.0037978129999999997,
                                0.003622416]],
                      0.005: [[0.0026872840000000003,
                               0.0035463340000000004,
                               0.004257276,
                               0.0041071070000000005,
                               0.003910987,
                               0.0038361940000000002,
                               0.0037643909999999997,
                               0.003559213],
                              [0.002864777,
                               0.00353463,
                               0.004423395,
                               0.004391481,
                               0.004319608,
                               0.004220598,
                               0.004127505,
                               0.003902412],
                              [0.003193992,
                               0.003622602,
                               0.004416183,
                               0.004347778,
                               0.004365709000000001,
                               0.004200507,
                               0.004110043,
                               0.003885225],
                              [0.0036883040000000003,
                               0.0039151559999999995,
                               0.004415624,
                               0.0043797870000000004,
                               0.004408067,
                               0.004222834,
                               0.004161258,
                               0.003931512],
                              [0.0040194409999999995,
                               0.003940694000000001,
                               0.004399078,
                               0.004365872,
                               0.004374012,
                               0.004158271,
                               0.00410576,
                               0.0038718859999999997],
                              [0.004265792,
                               0.004192254,
                               0.004305134,
                               0.004227632,
                               0.0043553509999999995,
                               0.004146919000000001,
                               0.004037583,
                               0.0038016559999999996],
                              [0.004464659,
                               0.004297853,
                               0.004171732,
                               0.004120489000000001,
                               0.004304075,
                               0.004874811,
                               0.00394105,
                               0.0037009459999999997],
                              [0.004685619,
                               0.004487087,
                               0.004187128,
                               0.004008391,
                               0.004319853,
                               0.004054811,
                               0.003927613,
                               0.003682945],
                              [0.005045028,
                               0.00476198,
                               0.004082473,
                               0.00391497,
                               0.004188911,
                               0.004094674,
                               0.0038719,
                               0.003637687],
                              [0.004756372,
                               0.00420758,
                               0.003513853,
                               0.0036345999999999995,
                               0.0040866240000000005,
                               0.003953025,
                               0.003887935,
                               0.003687267],
                              [0.004738942,
                               0.004382128,
                               0.0035396390000000002,
                               0.0037460840000000002,
                               0.004284124,
                               0.004178664,
                               0.004111747,
                               0.0039354329999999995]],
                      0.01: [[0.002984954,
                              0.0039538659999999995,
                              0.004755954000000001,
                              0.004588036,
                              0.004362119,
                              0.004272296,
                              0.004196134,
                              0.003989258],
                             [0.0031880109999999997,
                              0.003945089000000001,
                              0.004943727,
                              0.004906665,
                              0.004818315,
                              0.004700895,
                              0.004601815,
                              0.0043747709999999995],
                             [0.003561375,
                              0.004047441,
                              0.0049375,
                              0.004858414,
                              0.004869699,
                              0.004679059,
                              0.004583333,
                              0.0043565470000000005],
                             [0.004127733,
                              0.0043804759999999995,
                              0.0049387829999999995,
                              0.00489396,
                              0.0049158959999999995,
                              0.00470448,
                              0.00464208,
                              0.004410273],
                             [0.00449599,
                              0.004407322,
                              0.0049185,
                              0.004873558,
                              0.004872854,
                              0.004632009,
                              0.004582213,
                              0.0043461559999999995],
                             [0.004770287,
                              0.004690436,
                              0.004808044,
                              0.004714427,
                              0.004849035,
                              0.004619092,
                              0.004508501,
                              0.004270293],
                             [0.00498722,
                              0.004801029,
                              0.0046459990000000005,
                              0.004582213,
                              0.00478553,
                              0.004533613,
                              0.004405961,
                              0.004163364],
                             [0.005212098,
                              0.004989191,
                              0.004648103,
                              0.00445119,
                              0.004802926,
                              0.0045224670000000005,
                              0.004397947,
                              0.004150541],
                             [0.005592263,
                              0.0052764859999999995,
                              0.004531587,
                              0.004353377,
                              0.0046658,
                              0.004584399,
                              0.004352054,
                              0.004114894],
                             [0.005313651,
                              0.00470147,
                              0.003928798,
                              0.004076677,
                              0.004598828,
                              0.004466528,
                              0.004407623,
                              0.004203943],
                             [0.005360131999999999,
                              0.004959512,
                              0.004013245,
                              0.0042523840000000005,
                              0.004871716,
                              0.004764989,
                              0.004701093,
                              0.004521751]]}}


def __get_data_NTO_Swaptions():
    return {'tenor': ['1y', '2y', '5y', '7y', '10y', '15y', '20y', '30y'],
            'expiry': ['1m',
                       '3m',
                       '6m',
                       '1y',
                       '2y',
                       '3y',
                       '5y',
                       '7y',
                       '10y',
                       '15y',
                       '20y'],
            'quote': {-0.01: [[0.001609555,
                               0.002056775,
                               0.0024236410000000003,
                               0.0023395770000000002,
                               0.0022597629999999997,
                               0.002247388,
                               0.002186452,
                               0.001961499],
                              [0.001688034,
                               0.002029126,
                               0.002507648,
                               0.002603959,
                               0.002493768,
                               0.002469481,
                               0.002393232,
                               0.002146372],
                              [0.001851435,
                               0.002059822,
                               0.00249476,
                               0.002468943,
                               0.002520662,
                               0.002455058,
                               0.002378257,
                               0.00213177],
                              [0.002064054,
                               0.0021966679999999997,
                               0.002485417,
                               0.0024881120000000002,
                               0.002550163,
                               0.0024657529999999998,
                               0.00240037,
                               0.002148158],
                              [0.002261019,
                               0.002219533,
                               0.002484835,
                               0.002503492,
                               0.002554367,
                               0.002430611,
                               0.002358604,
                               0.0021017279999999998],
                              [0.002405795,
                               0.002352732,
                               0.002457834,
                               0.002447037,
                               0.002557637,
                               0.002425239,
                               0.002308058,
                               0.002048673],
                              [0.002544072,
                               0.002448455,
                               0.002443325,
                               0.002444519,
                               0.002557311,
                               0.002381969,
                               0.002227574,
                               0.001962932],
                              [0.0027735209999999997,
                               0.002665411,
                               0.00252179,
                               0.002407208,
                               0.002567352,
                               0.002343119,
                               0.002185891,
                               0.00191516],
                              [0.003076174,
                               0.002912587,
                               0.002460403,
                               0.002323987,
                               0.002450421,
                               0.002282511,
                               0.002073223,
                               0.001810719],
                              [0.0027093309999999997,
                               0.002391895,
                               0.001985233,
                               0.001990655,
                               0.002162554,
                               0.001997715,
                               0.001885224,
                               0.001650199],
                              [0.002368639,
                               0.002173557,
                               0.001715116,
                               0.0017872729999999998,
                               0.001996602,
                               0.0018700479999999998,
                               0.001764129,
                               0.0015417410000000001]],
                      -0.005: [[0.002121834,
                                0.00262253,
                                0.003123736,
                                0.00301435,
                                0.0028878109999999997,
                                0.002849767,
                                0.0027860370000000003,
                                0.002576969],
                               [0.002133451,
                                0.00260278,
                                0.003239943,
                                0.003220217,
                                0.0031884229999999997,
                                0.0031334170000000003,
                                0.003052345,
                                0.0028231109999999997],
                               [0.0023610429999999997,
                                0.0026567490000000003,
                                0.0032299090000000004,
                                0.003186698,
                                0.003222595,
                                0.003117117,
                                0.003036881,
                                0.00280794],
                               [0.002686992,
                                0.0028552820000000002,
                                0.00322456,
                                0.0032107740000000004,
                                0.003256619,
                                0.003132285,
                                0.003070487,
                                0.002836592],
                               [0.00293445,
                                0.002878482,
                                0.003217176,
                                0.00321324,
                                0.00324459,
                                0.003085806,
                                0.003024217,
                                0.002786243],
                               [0.003117639,
                                0.0030576440000000004,
                                0.0031626209999999996,
                                0.0031239909999999996,
                                0.00323857,
                                0.003078085,
                                0.002967806,
                                0.002727836],
                               [0.003277185,
                                0.0031544140000000003,
                                0.003098451,
                                0.003077685,
                                0.0032169670000000003,
                                0.0030221420000000002,
                                0.002883138,
                                0.002639104],
                               [0.0034962540000000003,
                                0.0033533720000000003,
                                0.0031485190000000002,
                                0.00301025,
                                0.00322914,
                                0.002994229,
                                0.0028549490000000003,
                                0.002606456],
                               [0.0038147190000000003,
                                0.0036057959999999997,
                                0.0030707340000000003,
                                0.00292495,
                                0.003109561,
                                0.002978225,
                                0.00277105,
                                0.0025332370000000002],
                               [0.0034904890000000003,
                                0.003085205,
                                0.002569914,
                                0.002624495,
                                0.002910955,
                                0.0027674229999999998,
                                0.002682134,
                                0.002477974],
                               [0.0033037709999999996,
                                0.003046733,
                                0.002440979,
                                0.002569637,
                                0.002915643,
                                0.002807381,
                                0.002727781,
                                0.002547715]],
                      -0.0025: [[0.0021965120000000003,
                                 0.00287245,
                                 0.0034308679999999997,
                                 0.003310407,
                                 0.003164589,
                                 0.003116015,
                                 0.0030503979999999997,
                                 0.00284409],
                                [0.002330829,
                                 0.0028550409999999996,
                                 0.00356077,
                                 0.00353764,
                                 0.0034944340000000003,
                                 0.003427061,
                                 0.003343062,
                                 0.003116753],
                                [0.0025863,
                                 0.0029184959999999996,
                                 0.003551627,
                                 0.0035013970000000003,
                                 0.003531828,
                                 0.003409772,
                                 0.0033271259999999997,
                                 0.00310111],
                                [0.002958838,
                                 0.003142938,
                                 0.003547704,
                                 0.0035275999999999997,
                                 0.003568023,
                                 0.003426905,
                                 0.0033656,
                                 0.003134698],
                                [0.003228827,
                                 0.003166638,
                                 0.003537699,
                                 0.003525287,
                                 0.003549703,
                                 0.003375506,
                                 0.0033169759999999997,
                                 0.003082038],
                                [0.0034290559999999998,
                                 0.003365563,
                                 0.0034720809999999997,
                                 0.003422449,
                                 0.003540068,
                                 0.0033667859999999997,
                                 0.003257548,
                                 0.0030206440000000003],
                                [0.0035988920000000002,
                                 0.003464195,
                                 0.003388295,
                                 0.0033588690000000004,
                                 0.0035100440000000004,
                                 0.003305282,
                                 0.0031700440000000003,
                                 0.002929143],
                                [0.003817027,
                                 0.0036590140000000004,
                                 0.003428063,
                                 0.0032789990000000003,
                                 0.003523181,
                                 0.003281112,
                                 0.003146368,
                                 0.0029011059999999997],
                                [0.004145335,
                                 0.003916381,
                                 0.003343019,
                                 0.0031918790000000003,
                                 0.003401078,
                                 0.003281456,
                                 0.0030713840000000004,
                                 0.002836859],
                                [0.0038333679999999998,
                                 0.003389306,
                                 0.002825866,
                                 0.0028993390000000003,
                                 0.0032320179999999997,
                                 0.003092745,
                                 0.003014345,
                                 0.002813597],
                                [0.0036978479999999997,
                                 0.003413722,
                                 0.002743635,
                                 0.002894178,
                                 0.003293918,
                                 0.0031877859999999997,
                                 0.0031130529999999997,
                                 0.0029366979999999997]],
                      0.0: [[0.002367499,
                             0.003107705,
                             0.003719695,
                             0.003588842,
                             0.003425223,
                             0.003367283,
                             0.003299642,
                             0.003094518],
                            [0.002517065,
                             0.003092448,
                             0.003862335,
                             0.003836086,
                             0.003782592,
                             0.003703947,
                             0.0036169279999999997,
                             0.00339191],
                            [0.002798478,
                             0.003164601,
                             0.003853927,
                             0.003797252,
                             0.003823025,
                             0.003685695,
                             0.003600489,
                             0.003375767],
                            [0.0032140420000000003,
                             0.003413056,
                             0.003851242,
                             0.003825474,
                             0.0038613379999999997,
                             0.003704658,
                             0.00364347,
                             0.00341387],
                            [0.003505333,
                             0.003437434,
                             0.003838883,
                             0.00381894,
                             0.003837353,
                             0.003648645,
                             0.003592513,
                             0.003358867],
                            [0.0037217459999999997,
                             0.0036547240000000003,
                             0.003763179,
                             0.003703578,
                             0.0038244729999999997,
                             0.003639,
                             0.00353011,
                             0.003294487],
                            [0.003901452,
                             0.003755536,
                             0.0036616340000000004,
                             0.003624385,
                             0.003786833,
                             0.0035722690000000003,
                             0.0034396340000000004,
                             0.00319999],
                            [0.004119868,
                             0.003947668,
                             0.003692436,
                             0.003533085,
                             0.003800886,
                             0.003551284,
                             0.003419787,
                             0.003175764],
                            [0.0044584229999999996,
                             0.00421049,
                             0.003600447,
                             0.003443851,
                             0.0036759659999999997,
                             0.0035660170000000003,
                             0.003352134,
                             0.00311878],
                            [0.004155988,
                             0.003675279,
                             0.003066402,
                             0.0031568559999999996,
                             0.003531883,
                             0.003395313,
                             0.003322211,
                             0.003122561],
                            [0.004064115,
                             0.0037545609999999996,
                             0.003024128,
                             0.0031945709999999998,
                             0.003643405,
                             0.0035381009999999997,
                             0.003466709,
                             0.0032914859999999997]],
                      0.0025: [[0.0025306079999999997,
                                0.003331624,
                                0.003994253,
                                0.0038535320000000002,
                                0.0036732329999999997,
                                0.0036066059999999996,
                                0.003536891,
                                0.00333204],
                               [0.002694508,
                                0.003318244,
                                0.004148915,
                                0.004119754000000001,
                                0.004056771,
                                0.003967644,
                                0.003877585,
                                0.00365286],
                               [0.0030003990000000004,
                                0.0033985240000000004,
                                0.0041411420000000004,
                                0.0040784409999999995,
                                0.004100098,
                                0.0039484590000000005,
                                0.0038606359999999998,
                                0.003636194],
                               [0.00345636,
                                0.003669581,
                                0.004139566,
                                0.004108593,
                                0.004140461,
                                0.003969146,
                                0.00390784,
                                0.0036785040000000004],
                               [0.003767975,
                                0.0036944779999999997,
                                0.004125043,
                                0.004098226,
                                0.0041112729999999995,
                                0.0039087620000000005,
                                0.003854592,
                                0.003621177],
                               [0.003999615,
                                0.003929345999999999,
                                0.004039951,
                                0.003971121,
                                0.004095404,
                                0.003898242,
                                0.003789271,
                                0.003553845],
                               [0.004189089,
                                0.004032505,
                                0.003921976,
                                0.003877505,
                                0.0040507270000000005,
                                0.0038265409999999997,
                                0.00369577,
                                0.003456257],
                               [0.004408534,
                                0.0042228759999999995,
                                0.003944737,
                                0.003775517,
                                0.004065658,
                                0.0038083590000000003,
                                0.0036792870000000003,
                                0.003435315],
                               [0.004757498,
                                0.00449169,
                                0.003846332,
                                0.003684266,
                                0.003937767,
                                0.0038361479999999997,
                                0.0036179579999999997,
                                0.003384554],
                               [0.004462544000000001,
                                0.003947134000000001,
                                0.00329496,
                                0.0034010579999999998,
                                0.003815643,
                                0.003680853,
                                0.00361207,
                                0.003412285],
                               [0.004409652,
                                0.004075953,
                                0.003288255,
                                0.0034772159999999996,
                                0.003971881,
                                0.003866707,
                                0.0037978129999999997,
                                0.003622416]],
                      0.005: [[0.0026872840000000003,
                               0.0035463340000000004,
                               0.004257276,
                               0.0041071070000000005,
                               0.003910987,
                               0.0038361940000000002,
                               0.0037643909999999997,
                               0.003559213],
                              [0.002864777,
                               0.00353463,
                               0.004423395,
                               0.004391481,
                               0.004319608,
                               0.004220598,
                               0.004127505,
                               0.003902412],
                              [0.003193992,
                               0.003622602,
                               0.004416183,
                               0.004347778,
                               0.004365709000000001,
                               0.004200507,
                               0.004110043,
                               0.003885225],
                              [0.0036883040000000003,
                               0.0039151559999999995,
                               0.004415624,
                               0.0043797870000000004,
                               0.004408067,
                               0.004222834,
                               0.004161258,
                               0.003931512],
                              [0.0040194409999999995,
                               0.003940694000000001,
                               0.004399078,
                               0.004365872,
                               0.004374012,
                               0.004158271,
                               0.00410576,
                               0.0038718859999999997],
                              [0.004265792,
                               0.004192254,
                               0.004305134,
                               0.004227632,
                               0.0043553509999999995,
                               0.004146919000000001,
                               0.004037583,
                               0.0038016559999999996],
                              [0.004464659,
                               0.004297853,
                               0.004171732,
                               0.004120489000000001,
                               0.004304075,
                               0.004874811,
                               0.00394105,
                               0.0037009459999999997],
                              [0.004685619,
                               0.004487087,
                               0.004187128,
                               0.004008391,
                               0.004319853,
                               0.004054811,
                               0.003927613,
                               0.003682945],
                              [0.005045028,
                               0.00476198,
                               0.004082473,
                               0.00391497,
                               0.004188911,
                               0.004094674,
                               0.0038719,
                               0.003637687],
                              [0.004756372,
                               0.00420758,
                               0.003513853,
                               0.0036345999999999995,
                               0.0040866240000000005,
                               0.003953025,
                               0.003887935,
                               0.003687267],
                              [0.004738942,
                               0.004382128,
                               0.0035396390000000002,
                               0.0037460840000000002,
                               0.004284124,
                               0.004178664,
                               0.004111747,
                               0.0039354329999999995]],
                      0.01: [[0.002984954,
                              0.0039538659999999995,
                              0.004755954000000001,
                              0.004588036,
                              0.004362119,
                              0.004272296,
                              0.004196134,
                              0.003989258],
                             [0.0031880109999999997,
                              0.003945089000000001,
                              0.004943727,
                              0.004906665,
                              0.004818315,
                              0.004700895,
                              0.004601815,
                              0.0043747709999999995],
                             [0.003561375,
                              0.004047441,
                              0.0049375,
                              0.004858414,
                              0.004869699,
                              0.004679059,
                              0.004583333,
                              0.0043565470000000005],
                             [0.004127733,
                              0.0043804759999999995,
                              0.0049387829999999995,
                              0.00489396,
                              0.0049158959999999995,
                              0.00470448,
                              0.00464208,
                              0.004410273],
                             [0.00449599,
                              0.004407322,
                              0.0049185,
                              0.004873558,
                              0.004872854,
                              0.004632009,
                              0.004582213,
                              0.0043461559999999995],
                             [0.004770287,
                              0.004690436,
                              0.004808044,
                              0.004714427,
                              0.004849035,
                              0.004619092,
                              0.004508501,
                              0.004270293],
                             [0.00498722,
                              0.004801029,
                              0.0046459990000000005,
                              0.004582213,
                              0.00478553,
                              0.004533613,
                              0.004405961,
                              0.004163364],
                             [0.005212098,
                              0.004989191,
                              0.004648103,
                              0.00445119,
                              0.004802926,
                              0.0045224670000000005,
                              0.004397947,
                              0.004150541],
                             [0.005592263,
                              0.0052764859999999995,
                              0.004531587,
                              0.004353377,
                              0.0046658,
                              0.004584399,
                              0.004352054,
                              0.004114894],
                             [0.005313651,
                              0.00470147,
                              0.003928798,
                              0.004076677,
                              0.004598828,
                              0.004466528,
                              0.004407623,
                              0.004203943],
                             [0.005360131999999999,
                              0.004959512,
                              0.004013245,
                              0.0042523840000000005,
                              0.004871716,
                              0.004764989,
                              0.004701093,
                              0.004521751]]}}

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\market_data\mdobject.py
----------------------------------------
from f3sdk.f3.context import F3Object
from typing import List, Optional


class MDObjectBase:

    def __init__(self):
        pass

    async def f3_mkt_data_object_async(self) -> F3Object:
        raise NotImplementedError()


class MDObject(MDObjectBase):
    keys: Optional[List[str]]

    def __init__(self, f3object: F3Object, keys: Optional[List[str]] = None):
        super(MDObject, self).__init__()
        if not isinstance(f3object, F3Object):
            raise Exception(f"Expected F3object, got {type(f3object)} instead")
        self.__f3object = f3object
        self.keys = keys

    async def f3_mkt_data_object_async(self) -> F3Object:
        return self.__f3object

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\market_data\__init__.py
----------------------------------------

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\market_data\__pycache__\__init__.cpython-37.pyc
----------------------------------------
B

    y  d                    @   s   d S )N  r   r   r    ME:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/market_data/__init__.py <module>        
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\legacy_fragments.py
----------------------------------------
import firm_f3.mapping as f3m
import firm_f3.fincadutil as fu
import firm_f3.f3client # type:ignore
from firm_f3.evaluate import f3_evaluate_async, scalar_handler
from firm_domain import (
    Tenor, Ccy, Month, FXOption, OptionStrat, IRS, IMMFRA, TenorBasis, Rate, IMM, InflationIndex, InflationSwap
)
from firm_f3.mapping import f3instrument_strategy_async, f3discount_curve_tag_async
import firm_domain as domain
from firm_f3.model_object.util import extend_model_with_one_dimensional_calibrated_curve_async, F3Interpolation


async def extend_with_jpy_multi_curve_async(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.JPY
    ois = domain.OIS(ccy, Tenor.T_1Y)
    inst_strategy = await f3instrument_strategy_async(ois)
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ois.index_rate, inst_strategy)

    deposit = domain.Rate(ccy, Tenor.T_6M)
    inst_strategy = await f3instrument_strategy_async(
        deposit,
        domain.FRA(ccy, tenor=deposit.tenor, start=Tenor.T_6M),
        domain.IRS(ccy, tenor=Tenor.T_1Y, idx=deposit.tenor)
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, deposit, inst_strategy)

    deposit = domain.Rate(ccy, Tenor.T_3M)
    inst_strategy = await f3instrument_strategy_async(
        deposit,
        domain.TenorBasis(ccy, Tenor.T_1Y, deposit.tenor, Tenor.T_6M)
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, deposit, inst_strategy)

    inst_strategy = await f3instrument_strategy_async(
        domain.FXForward(ccy, Tenor.T_6M),
        domain.XccyBasis(ccy, Tenor.T_2Y),
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ccy.name, inst_strategy)

    model = f3.ExtendModelWithClonedCurve(
        BaseModel=model,
        CurveTag=[ccy.name, 'DiscountCurve-CollateralRate-USD O/N:1b'],
        SourceCurveTag=await f3discount_curve_tag_async(ccy.name),
    )

    return model


async def extend_with_jpy_multi_curve_async2(model, **kwargs):
    from firm_f3.model_object.instance.JPY import JPYModel
    return await JPYModel().assemble_fragment_async(model)


async def extend_with_chf_multi_curve_async(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.CHF
    ois = domain.OIS(ccy, Tenor.T_1Y)
    inst_strategy = await f3instrument_strategy_async(ois)
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ois.index_rate, inst_strategy)

    deposit = domain.Rate(ccy, Tenor.T_6M)
    inst_strategy = await f3instrument_strategy_async(
        deposit,
        domain.FRA(ccy, tenor=deposit.tenor, start=Tenor.T_6M),
        domain.IRS(ccy, tenor=Tenor.T_1Y, idx=deposit.tenor)
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, deposit, inst_strategy)

    deposit = domain.Rate(ccy, Tenor.T_3M)
    inst_strategy = await f3instrument_strategy_async(
        deposit,
        domain.FRA(ccy, deposit.tenor, Tenor.T_6M),
        domain.TenorBasis(ccy, Tenor.T_1Y, deposit.tenor, Tenor.T_6M)
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, deposit, inst_strategy)

    inst_strategy = await f3instrument_strategy_async(
        domain.FXForward(ccy, Tenor.T_6M),
        domain.XccyBasis(ccy, Tenor.T_2Y),
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ccy.name, inst_strategy)

    model = f3.ExtendModelWithClonedCurve(
        BaseModel=model,
        CurveTag=[ccy.name, 'DiscountCurve-CollateralRate-USD O/N:1b'],
        SourceCurveTag=await f3discount_curve_tag_async(ccy.name),
    )

    return model


async def extend_with_chf_multi_curve_async2(model, **kwargs):
    from firm_f3.model_object.instance.CHF import CHFModel
    return await CHFModel().assemble_fragment_async(model)


async def extend_with_nok_multi_curve_async(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.NOK
    irs_base = IRS(ccy=ccy, tenor=Tenor.T_1Y)
    fra_base_imm = IMMFRA(ccy=ccy, tenor=Tenor.T_6M, start=None)
    ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)

    overnight_rate = Rate(ccy, Tenor.T_1D)
    irs_base_rate = Rate(ccy, irs_base.idx)

    ois_tag, irs_tag = await f3m.f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    inst_strategy = await f3instrument_strategy_async(
        irs_base_rate,
        fra_base_imm,
        irs_base
    )

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            irs_tag,
            ois_tag,
        ],
        InterpolationTypes=[
            fu.get_exp_spline_interp_method(0.1),
            fu.get_exp_spline_interp_method(0.1)
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=False,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3m.f3instrument_type(irs_base_rate), None, None, *irs_tag],
            [f3m.f3instrument_type(fra_base_imm), None, None, *irs_tag],
            [f3m.f3instrument_type(irs_base), None, None, *irs_tag],
            [f3m.f3instrument_type(ois_basis), None, None, *ois_tag],
        ]
    )

    model = f3.ExtendModelWithCalibratedCurves(
        BaseModel=model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=inst_strategy,
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )

    model = f3.AddImpliedRateCurveToModel(model, 'OvernightNOK', 'OvernightNOK')
    model = f3.AddImpliedRateCurveToModel(model, 'Nibor6m', 'Nibor6m')

    deposit = domain.Rate(ccy, Tenor.T_3M)
    inst_strategy = await f3instrument_strategy_async(
        deposit,
        domain.IMMFRA(ccy=ccy, tenor=deposit.tenor, start=None),
        domain.TenorBasis(ccy, Tenor.T_1Y, deposit.tenor, Tenor.T_6M)
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, deposit, inst_strategy)

    inst_strategy = await f3instrument_strategy_async(
        domain.FXForward(ccy, Tenor.T_6M),
        domain.XccyBasis(ccy, Tenor.T_2Y),
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ccy.name, inst_strategy)

    model = f3.ExtendModelWithClonedCurve(
        BaseModel=model,
        CurveTag=[ccy.name, 'DiscountCurve-CollateralRate-USD O/N:1b'],
        SourceCurveTag=[ccy.name, 'DiscountCurve'],
    )

    return model


async def extend_with_nzd_multi_curve_async(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.NZD
    ois = domain.OIS(ccy, Tenor.T_1Y)
    inst_strategy = await f3instrument_strategy_async(ois)
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ois.index_rate, inst_strategy)

    deposit = domain.Rate(ccy, Tenor.T_3M)
    inst_strategy = await f3instrument_strategy_async(
        deposit,
        domain.FRA(ccy, tenor=deposit.tenor, start=Tenor.T_6M),
        domain.IRS(ccy, tenor=Tenor.T_1Y, idx=deposit.tenor)
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, deposit, inst_strategy)

    inst_strategy = await f3instrument_strategy_async(
        domain.FXForward(ccy, Tenor.T_6M),
        domain.XccyBasis(ccy, Tenor.T_2Y),
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ccy.name, inst_strategy)

    model = f3.ExtendModelWithClonedCurve(
        BaseModel=model,
        CurveTag=[ccy.name, 'DiscountCurve-CollateralRate-USD O/N:1b'],
        SourceCurveTag=await f3discount_curve_tag_async(ccy.name),
    )

    return model


async def extend_with_cad_multi_curve_async(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.CAD
    ois = domain.OIS(ccy, Tenor.T_1Y)
    inst_strategy = await f3instrument_strategy_async(ois)
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ois.index_rate, inst_strategy)

    deposit = domain.Rate(ccy, Tenor.T_3M)
    inst_strategy = await f3instrument_strategy_async(
        deposit,
        domain.FRA(ccy, tenor=deposit.tenor, start=Tenor.T_6M),
        domain.IRS(ccy, tenor=Tenor.T_1Y, idx=deposit.tenor)
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, deposit, inst_strategy)

    inst_strategy = await f3instrument_strategy_async(
        domain.FXForward(ccy, Tenor.T_6M),
        domain.XccyBasis(ccy, Tenor.T_2Y),
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ccy.name, inst_strategy,
                                                                           target_method=f'Default{ccy.name}',
                                                                           )

    model = f3.ExtendModelWithClonedCurve(
        BaseModel=model,
        CurveTag=[ccy.name, 'DiscountCurve-CollateralRate-USD O/N:1b'],
        SourceCurveTag=await f3discount_curve_tag_async(ccy.name),
    )

    return model


async def extend_with_sek_multi_curve_async(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.SEK
    ois = domain.OIS(ccy, Tenor.T_1Y)
    inst_strategy = await f3instrument_strategy_async(ois)
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ois.index_rate, inst_strategy)

    deposit = domain.Rate(ccy, Tenor.T_3M)
    inst_strategy = await f3instrument_strategy_async(
        deposit,
        domain.IRS(ccy, tenor=Tenor.T_1Y, idx=deposit.tenor)
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, deposit, inst_strategy)

    inst_strategy = await f3instrument_strategy_async(
        domain.FXForward(ccy, Tenor.T_6M),
        domain.XccyBasis(ccy, Tenor.T_2Y),
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ccy.name, inst_strategy)

    model = f3.ExtendModelWithClonedCurve(
        BaseModel=model,
        CurveTag=[ccy.name, 'DiscountCurve-CollateralRate-USD O/N:1b'],
        SourceCurveTag=await f3discount_curve_tag_async(ccy.name),
    )

    return model


async def extend_with_aud_multi_curve_async(model, ins_strat_aud_combined, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    aud_time_point_method = [['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
                             ['AUD-OIS', None, None, 'AUD', 'DiscountCurve-CollateralRate-AUD O/N:1b'],
                             ['AUD-BasisSwap-OIS-BBSW-3m', None, None, 'AUD',
                              'DiscountCurve-CollateralRate-AUD O/N:1b'],
                             [f3m.f3instrument_type(Rate(Ccy.AUD, Tenor.T_3M)), '0b', '2m', 'AUD',
                              'DiscountCurve-CollateralRate-BBSW:3m'],
                             [f3m.f3instrument_type(Rate(Ccy.AUD, Tenor.T_6M)), '0b', '9m', 'AUD',
                              'DiscountCurve-CollateralRate-BBSW:6m'],
                             ['AUD-FRA-BBSW-3m', '3m', '9m', 'AUD', 'DiscountCurve-CollateralRate-BBSW:3m'],
                             ['AUD-IRS-Quarterly-BBSW-3m', '1y', '3y', 'AUD', 'DiscountCurve-CollateralRate-BBSW:3m'],
                             ['AUD-BasisSwap-BBSW-3m-6m', '4y', '100y', 'AUD', 'DiscountCurve-CollateralRate-BBSW:3m'],
                             ['AUD-BasisSwap-BBSW-3m-6m', '1y', '3y', 'AUD', 'DiscountCurve-CollateralRate-BBSW:6m'],
                             ['AUD-IRS-Semi-BBSW-6m', '4y', '100y', 'AUD', 'DiscountCurve-CollateralRate-BBSW:6m']]

    aud_curve_calib_target = \
        f3.CreateOneDimensionalEntireCurveCalibrationTarget([['AUD', 'DiscountCurve-CollateralRate-BBSW:3m'],
                                                             ['AUD', 'DiscountCurve-CollateralRate-BBSW:6m'],
                                                             ['AUD', 'DiscountCurve-CollateralRate-AUD O/N:1b']],
                                                            [fu.get_exp_spline_interp_method(0.1),
                                                             fu.get_exp_spline_interp_method(0.1),
                                                             fu.get_exp_spline_interp_method(0.1)],
                                                            [[1, 'Anchored'], [1, 'Anchored'], [1, 'Anchored']],
                                                            [],
                                                            'SingleCurrencyValue',
                                                            True,
                                                            aud_time_point_method)
    model = f3.ExtendModelWithCalibratedCurves(model,
                                               aud_curve_calib_target,
                                               ins_strat_aud_combined,
                                               'NewtonRaphson_1e-3',
                                               'Par',
                                               'UseModelWideMethod'
                                               )

    model = f3.AddImpliedRateCurveToModel(model,
                                          'BBSW3m',
                                          'BBSW3m')
    model = f3.AddImpliedRateCurveToModel(model,
                                          'BBSW6m',
                                          'BBSW6m')
    model = f3.AddImpliedRateCurveToModel(model,
                                          'OvernightAUD',
                                          'OvernightAUD')
    model = f3.ExtendModelWithClonedCurve(model,
                                          ['AUD', 'DiscountCurve'],
                                          ['AUD', 'DiscountCurve-CollateralRate-AUD O/N:1b'])

    ccy = Ccy.AUD
    deposit = domain.Rate(ccy, Tenor.T_1M)
    inst_strategy = await f3instrument_strategy_async(
        deposit,
        domain.TenorBasis(ccy, Tenor.T_1Y, Tenor.T_1M, Tenor.T_3M)
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, deposit, inst_strategy)

    inst_strategy = await f3instrument_strategy_async(
        domain.FXForward(ccy, Tenor.T_6M),
        domain.XccyBasis(ccy, Tenor.T_2Y),
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ccy.name, inst_strategy,
                                                                           interpolation_types=F3Interpolation.LogLinear,
                                                                           target_method=f'Default{ccy.name}')

    model = f3.ExtendModelWithClonedCurve(
        BaseModel=model,
        CurveTag=[ccy.name, 'DiscountCurve-CollateralRate-USD O/N:1b'],
        SourceCurveTag=await f3discount_curve_tag_async(ccy.name),
    )

    return model


async def extend_with_aud_multi_curve_async2(model, **kwargs):
    from firm_f3.model_object.instance.AUD import AUDModel
    return await AUDModel().assemble_fragment_async(model)


# noinspection PyUnusedLocal
def extend_with_krw_multi_curve(model, ins_strat_krw_xccy_combined, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    krw_time_point_method = [['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
                             ['KRW-IRS-Quarterly-KRWCD-3m-Uncollat', None, None, 'KRW',
                              'DiscountCurve-CollateralRate-KRWCD:3m'],
                             [f3m.f3instrument_type(Rate(Ccy.KRW, Tenor.T_3M)), None, None, 'KRW',
                              'DiscountCurve-CollateralRate-KRWCD:3m'],
                             ['KRW_NDF_Inst_Type', None, None, 'KRW', 'DiscountCurve'],
                             ['KRWUSD-XccySwap-KRWCD3m-LiborUSD6m', None, None, 'KRW', 'DiscountCurve']]

    krw_curve_calib_target = \
        f3.CreateOneDimensionalEntireCurveCalibrationTarget([['KRW', 'DiscountCurve-CollateralRate-KRWCD:3m'],
                                                             ['KRW', 'DiscountCurve']],
                                                            [fu.get_exp_spline_interp_method(0.1),
                                                             fu.get_exp_spline_interp_method(0.1)],
                                                            [[1, 'Anchored'], [1, 'Anchored']],
                                                            [],
                                                            'SingleCurrencyNumeraireValue',
                                                            True,
                                                            krw_time_point_method)
    model = f3.ExtendModelWithCalibratedCurves(model,
                                               krw_curve_calib_target,
                                               ins_strat_krw_xccy_combined,
                                               'NewtonRaphson_1e-3',
                                               'Par',
                                               'DefaultUSD'
                                               )

    model = f3.AddImpliedRateCurveToModel(model,
                                          'KRWCD3m',
                                          'KRWCD3m')
    model = f3.ExtendModelWithClonedCurve(model,
                                          f3.DiscountCurveTag('KRW', 'OvernightUSD'),
                                          f3.DiscountCurveTag('KRW'))

    return model


async def extend_with_cnh_multi_curve_async(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.CNH
    inst_strategy = await f3instrument_strategy_async(
        domain.FXForward(ccy, Tenor.T_6M),
        domain.CrossCurrencySwap(ccy, Tenor.T_2Y),
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ccy.name, inst_strategy)

    model = f3.ExtendModelWithClonedCurve(
        BaseModel=model,
        CurveTag=[ccy.name, 'DiscountCurve-CollateralRate-USD O/N:1b'],
        SourceCurveTag=await f3discount_curve_tag_async(ccy.name),
    )

    return model


async def extend_with_cny_multi_curve_async(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.CNY
    irs = domain.IRS(ccy, Tenor.T_1Y)
    inst_strategy = await f3instrument_strategy_async(irs)
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, irs.index_rate, inst_strategy,
                                                                           target_method='DefaultUSD')

    inst_strategy = await f3instrument_strategy_async(domain.FXForward(ccy, Tenor.T_6M))
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ccy.name, inst_strategy,
                                                                           target_method=fu.ccy_to_val_spec(ccy))

    model = f3.ExtendModelWithClonedCurve(
        BaseModel=model,
        CurveTag=[ccy.name, 'DiscountCurve-CollateralRate-USD O/N:1b'],
        SourceCurveTag=await f3discount_curve_tag_async(ccy.name),
    )

    return model


async def extend_with_myr_multi_curve_async(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.MYR
    deposit = domain.Rate(ccy, Tenor.T_3M)
    inst_strategy = await f3instrument_strategy_async(
        deposit,
        domain.IRS(ccy, tenor=Tenor.T_1Y, idx=deposit.tenor)
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, deposit, inst_strategy,
                                                                           target_method='DefaultUSD')

    inst_strategy = await f3instrument_strategy_async(domain.FXForward(ccy, Tenor.T_6M))
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ccy.name, inst_strategy,
                                                                           target_method=fu.ccy_to_val_spec(ccy))

    model = f3.ExtendModelWithClonedCurve(
        BaseModel=model,
        CurveTag=[ccy.name, 'DiscountCurve-CollateralRate-USD O/N:1b'],
        SourceCurveTag=await f3discount_curve_tag_async(ccy.name),
    )

    return model


async def extend_with_twd_multi_curve_async(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.TWD
    deposit = domain.Rate(ccy, Tenor.T_3M)
    inst_strategy = await f3instrument_strategy_async(
        deposit,
        domain.IRS(ccy, tenor=Tenor.T_1Y, idx=deposit.tenor)
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, deposit, inst_strategy,
                                                                           target_method='DefaultUSD')

    inst_strategy = await f3instrument_strategy_async(domain.FXForward(ccy, Tenor.T_6M))
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ccy.name, inst_strategy,
                                                                           target_method=fu.ccy_to_val_spec(ccy))

    model = f3.ExtendModelWithClonedCurve(
        BaseModel=model,
        CurveTag=[ccy.name, 'DiscountCurve-CollateralRate-USD O/N:1b'],
        SourceCurveTag=await f3discount_curve_tag_async(ccy.name),
    )

    return model


async def extend_with_nto_multi_curve_async(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.NTO
    deposit = domain.Rate(ccy, Tenor.T_3M)
    inst_strategy = await f3instrument_strategy_async(
        deposit,
        domain.IRS(ccy, tenor=Tenor.T_1Y, idx=deposit.tenor)
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, deposit, inst_strategy,
                                                                           target_method='DefaultUSD')

    inst_strategy = await f3instrument_strategy_async(domain.FXForward(ccy, Tenor.T_6M))
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ccy.name, inst_strategy,
                                                                           target_method=fu.ccy_to_val_spec(ccy))

    model = f3.ExtendModelWithClonedCurve(
        BaseModel=model,
        CurveTag=[ccy.name, 'DiscountCurve-CollateralRate-USD O/N:1b'],
        SourceCurveTag=await f3discount_curve_tag_async(ccy.name),
    )

    return model


async def extend_with_thb_multi_curve_async(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.THB
    deposit = domain.Rate(ccy, Tenor.T_6M)
    inst_strategy = await f3instrument_strategy_async(
        deposit,
        domain.IRS(ccy, tenor=Tenor.T_1Y, idx=deposit.tenor)
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, deposit, inst_strategy,
                                                                           target_method='DefaultUSD')

    inst_strategy = await f3instrument_strategy_async(domain.FXForward(ccy, Tenor.T_6M))
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ccy.name, inst_strategy,
                                                                           target_method=fu.ccy_to_val_spec(ccy))

    model = f3.ExtendModelWithClonedCurve(
        BaseModel=model,
        CurveTag=[ccy.name, 'DiscountCurve-CollateralRate-USD O/N:1b'],
        SourceCurveTag=await f3discount_curve_tag_async(ccy.name),
    )

    return model


async def extend_with_inr_multi_curve_async(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.INR
    inst_strategy = await f3instrument_strategy_async(
        domain.FXForward(ccy, Tenor.T_6M),
        domain.CrossCurrencySwap(ccy, Tenor.T_2Y),
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ccy.name, inst_strategy,
                                                                           bound_constraints='GreaterThanZero')

    model = f3.ExtendModelWithClonedCurve(
        BaseModel=model,
        CurveTag=[ccy.name, 'DiscountCurve-CollateralRate-USD O/N:1b'],
        SourceCurveTag=await f3discount_curve_tag_async(ccy.name),
    )

    ois_ann = domain.OIS(ccy, Tenor.T_1Y, fixed_freq=Tenor.T_1Y)
    ois_semi = domain.OIS(ccy, Tenor.T_1Y, fixed_freq=Tenor.T_6M)
    inst_strategy = await f3instrument_strategy_async(ois_ann, ois_semi)
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ois_ann.index_rate, inst_strategy,
                                                                           target_method='DefaultUSD')

    return model


async def extend_with_ino_multi_curve_async(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.INO
    inst_strategy = await f3instrument_strategy_async(
        domain.FXForward(ccy, Tenor.T_6M),
        domain.CrossCurrencySwap(ccy, Tenor.T_2Y),
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ccy.name, inst_strategy,
                                                                           bound_constraints='GreaterThanZero')

    model = f3.ExtendModelWithClonedCurve(
        BaseModel=model,
        CurveTag=[ccy.name, 'DiscountCurve-CollateralRate-USD O/N:1b'],
        SourceCurveTag=await f3discount_curve_tag_async(ccy.name),
    )

    ois_ann = domain.OIS(ccy, Tenor.T_1Y, fixed_freq=Tenor.T_1Y)
    ois_semi = domain.OIS(ccy, Tenor.T_1Y, fixed_freq=Tenor.T_6M)
    inst_strategy = await f3instrument_strategy_async(ois_ann, ois_semi)
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ois_ann.index_rate, inst_strategy,
                                                                           target_method='DefaultUSD')

    return model


async def extend_with_rub_multi_curve_async(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ccy = Ccy.RUB
    inst_strategy = await f3instrument_strategy_async(
        domain.FXForward(ccy, Tenor.T_6M),
        domain.CrossCurrencySwap(ccy, Tenor.T_2Y),
    )
    model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ccy.name, inst_strategy,
                                                                           bound_constraints='GreaterThanZero',
                                                                           target_method=f'Default{ccy.name}')

    model = f3.ExtendModelWithClonedCurve(
        BaseModel=model,
        CurveTag=[ccy.name, 'DiscountCurve-CollateralRate-USD O/N:1b'],
        SourceCurveTag=await f3discount_curve_tag_async(ccy.name),
    )

    return model


async def extend_with_fx_fwds_async(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    for ccy in (Ccy.PHP, Ccy.IDR, Ccy.MXN):
        inst_strategy = await f3instrument_strategy_async(domain.FXForward(ccy, Tenor.T_6M))
        model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ccy.name, inst_strategy)

        model = f3.ExtendModelWithClonedCurve(
            BaseModel=model,
            CurveTag=[ccy.name, 'DiscountCurve-CollateralRate-USD O/N:1b'],
            SourceCurveTag=[ccy.name, 'DiscountCurve'],
        )

    return model


# noinspection PyUnusedLocal
def extend_with_eur_swaptions(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    eur_swaption_tag_suffix = 'ParYieldCashSettledSwaption:FullCashSingleCurrencyCollateralInEUR'
    eur_swaption_tag_prefix = 'ParYieldCashSettledSwaption:IRS:12m:Euribor:6m:Relative:'
    eur_swaption_tags = {0: eur_swaption_tag_prefix + '0',
                         0.0025: eur_swaption_tag_prefix + '0.0025',
                         -0.0025: eur_swaption_tag_prefix + '-0.0025',
                         0.005: eur_swaption_tag_prefix + '0.005',
                         -.005: eur_swaption_tag_prefix + '-0.005',
                         0.01: eur_swaption_tag_prefix + '0.01',
                         -0.01: eur_swaption_tag_prefix + '-0.01'}
    model = f3.ExtendModelWithInterpolatedVolatilityCube(model,
                                                         ['IRS:12m:Euribor:6m', 'NormalVolatility'],
                                                         [[eur_swaption_tags[0], eur_swaption_tag_suffix],
                                                          [eur_swaption_tags[0.0025], eur_swaption_tag_suffix],
                                                          [eur_swaption_tags[-0.0025], eur_swaption_tag_suffix],
                                                          [eur_swaption_tags[0.005], eur_swaption_tag_suffix],
                                                          [eur_swaption_tags[-0.005], eur_swaption_tag_suffix],
                                                          [eur_swaption_tags[0.01], eur_swaption_tag_suffix],
                                                          [eur_swaption_tags[-0.01], eur_swaption_tag_suffix]],
                                                         'Linear',
                                                         'Normal',
                                                         ['UnderlyingMaturity', 'OptionExpiry', 'Strike'])

    model = f3.ExtendModelWithClonedCurve(model,
                                          ['IRS:12m:Euribor:6m', 'Volatility'],
                                          ['IRS:12m:Euribor:6m', 'NormalVolatility'])

    return model


def extend_with_pln_swaptions(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    pln_swaption_tag_suffix = 'VanillaSwaption:FullCashSingleCurrencyCollateralInUSD'
    pln_swaption_tag_prefix = 'VanillaSwaption:IRS:12m:Wibor:6m:Relative:'
    pln_swaption_tags = {0: pln_swaption_tag_prefix + '0',
                         0.0025: pln_swaption_tag_prefix + '0.0025',
                         -0.0025: pln_swaption_tag_prefix + '-0.0025',
                         0.005: pln_swaption_tag_prefix + '0.005',
                         -.005: pln_swaption_tag_prefix + '-0.005',
                         0.01: pln_swaption_tag_prefix + '0.01',
                         -0.01: pln_swaption_tag_prefix + '-0.01'}
    model = f3.ExtendModelWithInterpolatedVolatilityCube(model,
                                                         ['IRS:12m:Wibor:6m', 'NormalVolatility'],
                                                         [[pln_swaption_tags[0], pln_swaption_tag_suffix],
                                                          [pln_swaption_tags[0.0025], pln_swaption_tag_suffix],
                                                          [pln_swaption_tags[-0.0025], pln_swaption_tag_suffix],
                                                          [pln_swaption_tags[0.005], pln_swaption_tag_suffix],
                                                          [pln_swaption_tags[-0.005], pln_swaption_tag_suffix],
                                                          [pln_swaption_tags[0.01], pln_swaption_tag_suffix],
                                                          [pln_swaption_tags[-0.01], pln_swaption_tag_suffix]],
                                                         'Linear',
                                                         'Normal',
                                                         ['UnderlyingMaturity', 'OptionExpiry', 'Strike'])

    model = f3.ExtendModelWithClonedCurve(model,
                                          ['IRS:12m:Wibor:6m', 'Volatility'],
                                          ['IRS:12m:Wibor:6m', 'NormalVolatility'])

    return model


def extend_with_twd_swaptions(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    twd_swaption_tag_suffix = 'ParYieldCashSettledSwaption:FullCashSingleCurrencyCollateralInUSD'
    twd_swaption_tag_prefix = 'ParYieldCashSettledSwaption:IRS:3m:Taibor:3m:Relative:'
    twd_swaption_tags = {0: twd_swaption_tag_prefix + '0',
                         0.0025: twd_swaption_tag_prefix + '0.0025',
                         -0.0025: twd_swaption_tag_prefix + '-0.0025',
                         0.005: twd_swaption_tag_prefix + '0.005',
                         -.005: twd_swaption_tag_prefix + '-0.005',
                         0.01: twd_swaption_tag_prefix + '0.01',
                         -0.01: twd_swaption_tag_prefix + '-0.01'}
    model = f3.ExtendModelWithInterpolatedVolatilityCube(model,
                                                         ['IRS:3m:Taibor:3m', 'NormalVolatility'],
                                                         [[twd_swaption_tags[0], twd_swaption_tag_suffix],
                                                          [twd_swaption_tags[0.0025], twd_swaption_tag_suffix],
                                                          [twd_swaption_tags[-0.0025], twd_swaption_tag_suffix],
                                                          [twd_swaption_tags[0.005], twd_swaption_tag_suffix],
                                                          [twd_swaption_tags[-0.005], twd_swaption_tag_suffix],
                                                          [twd_swaption_tags[0.01], twd_swaption_tag_suffix],
                                                          [twd_swaption_tags[-0.01], twd_swaption_tag_suffix]],
                                                         'Linear',
                                                         'Normal',
                                                         ['UnderlyingMaturity', 'OptionExpiry', 'Strike'])

    model = f3.ExtendModelWithClonedCurve(model,
                                          ['IRS:3m:Taibor:3m', 'Volatility'],
                                          ['IRS:3m:Taibro:3m', 'NormalVolatility'])

    return model


def extend_with_nto_swaptions(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    nto_swaption_tag_suffix = 'ParYieldCashSettledSwaption:FullCashSingleCurrencyCollateralInUSD'
    nto_swaption_tag_prefix = 'ParYieldCashSettledSwaption:IRS:3m:NTO LIBOR:3m:Relative:'
    nto_swaption_tags = {0: nto_swaption_tag_prefix + '0',
                         0.0025: nto_swaption_tag_prefix + '0.0025',
                         -0.0025: nto_swaption_tag_prefix + '-0.0025',
                         0.005: nto_swaption_tag_prefix + '0.005',
                         -.005: nto_swaption_tag_prefix + '-0.005',
                         0.01: nto_swaption_tag_prefix + '0.01',
                         -0.01: nto_swaption_tag_prefix + '-0.01'}
    model = f3.ExtendModelWithInterpolatedVolatilityCube(model,
                                                         ['IRS:3m:NTO LIBOR:3m', 'NormalVolatility'],
                                                         [[nto_swaption_tags[0], nto_swaption_tag_suffix],
                                                          [nto_swaption_tags[0.0025], nto_swaption_tag_suffix],
                                                          [nto_swaption_tags[-0.0025], nto_swaption_tag_suffix],
                                                          [nto_swaption_tags[0.005], nto_swaption_tag_suffix],
                                                          [nto_swaption_tags[-0.005], nto_swaption_tag_suffix],
                                                          [nto_swaption_tags[0.01], nto_swaption_tag_suffix],
                                                          [nto_swaption_tags[-0.01], nto_swaption_tag_suffix]],
                                                         'Linear',
                                                         'Normal',
                                                         ['UnderlyingMaturity', 'OptionExpiry', 'Strike'])

    model = f3.ExtendModelWithClonedCurve(model,
                                          ['IRS:3m:NTO LIBOR:3m', 'Volatility'],
                                          ['IRS:3m:NTO LIBOR:3m', 'NormalVolatility'])

    return model


async def extend_with_eur_swaptions_sabr_async(model, **kwargs):
    from firm_f3.model_object.swaption_model import SabrSwaptionMixIn
    return await SabrSwaptionMixIn(currency=Ccy.EUR).assemble_fragment_async(model)


# noinspection PyUnusedLocal
def extend_with_usd_swaptions(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    usd_swaption_tag_suffix = 'VanillaSwaption:FullCashSingleCurrencyCollateralInUSD'
    usd_swaption_tag_prefix = 'VanillaSwaption:IRS:6m:USD LIBOR:3m:Relative:'
    usd_swaption_tags = {0: usd_swaption_tag_prefix + '0',
                         0.0025: usd_swaption_tag_prefix + '0.0025',
                         -0.0025: usd_swaption_tag_prefix + '-0.0025',
                         0.005: usd_swaption_tag_prefix + '0.005',
                         -.005: usd_swaption_tag_prefix + '-0.005',
                         0.01: usd_swaption_tag_prefix + '0.01',
                         -0.01: usd_swaption_tag_prefix + '-0.01'}

    model = f3.ExtendModelWithInterpolatedVolatilityCube(
        BaseModel=model,
        CurveTag=['IRS:6m:USD LIBOR:3m', 'NormalVolatility'],
        MarketDataTags=[[usd_swaption_tags[0], usd_swaption_tag_suffix],
                        [usd_swaption_tags[0.0025], usd_swaption_tag_suffix],
                        [usd_swaption_tags[-0.0025], usd_swaption_tag_suffix],
                        [usd_swaption_tags[0.005], usd_swaption_tag_suffix],
                        [usd_swaption_tags[-0.005], usd_swaption_tag_suffix],
                        [usd_swaption_tags[0.01], usd_swaption_tag_suffix],
                        [usd_swaption_tags[-0.01], usd_swaption_tag_suffix]],
        ThreeDimInterpolationMethod='Linear',
        VolatilityConvention='Normal',
        Axes=['UnderlyingMaturity', 'OptionExpiry', 'Strike']
    )

    model = f3.ExtendModelWithClonedCurve(
        BaseModel=model,
        CurveTag=['IRS:6m:USD LIBOR:3m', 'Volatility'],
        SourceCurveTag=['IRS:6m:USD LIBOR:3m', 'NormalVolatility']
    )

    return model


async def extend_with_usd_swaptions_sabr_async(model, **kwargs):
    from firm_f3.model_object.swaption_model import SabrSwaptionMixIn
    return await SabrSwaptionMixIn(currency=Ccy.USD).assemble_fragment_async(model)


# noinspection PyUnusedLocal
def extend_with_sar_swaptions(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    sar_swaption_tag_suffix = 'VanillaSwaption:FullCashSingleCurrencyCollateralInUSD'
    sar_swaption_tag_prefix = 'VanillaSwaption:IRS:12m:SAIBOR:3m:FullCashSingleCurrencyCollateralInSAR:Relative:'
    sar_swaption_tags = {0: sar_swaption_tag_prefix + '0',
                         0.0025: sar_swaption_tag_prefix + '0.0025',
                         -0.0025: sar_swaption_tag_prefix + '-0.0025',
                         0.005: sar_swaption_tag_prefix + '0.005',
                         -.005: sar_swaption_tag_prefix + '-0.005',
                         0.01: sar_swaption_tag_prefix + '0.01',
                         -0.01: sar_swaption_tag_prefix + '-0.01'}

    model = f3.ExtendModelWithInterpolatedVolatilityCube(
        BaseModel=model,
        CurveTag=['IRS:12m:SAIBOR:3m', 'NormalVolatility'],
        MarketDataTags=[[sar_swaption_tags[0], sar_swaption_tag_suffix],
                        [sar_swaption_tags[0.0025], sar_swaption_tag_suffix],
                        [sar_swaption_tags[-0.0025], sar_swaption_tag_suffix],
                        [sar_swaption_tags[0.005], sar_swaption_tag_suffix],
                        [sar_swaption_tags[-0.005], sar_swaption_tag_suffix],
                        [sar_swaption_tags[0.01], sar_swaption_tag_suffix],
                        [sar_swaption_tags[-0.01], sar_swaption_tag_suffix]],
        ThreeDimInterpolationMethod='Linear',
        VolatilityConvention='Normal',
        Axes=['UnderlyingMaturity', 'OptionExpiry', 'Strike']
    )

    model = f3.ExtendModelWithClonedCurve(
        BaseModel=model,
        CurveTag=['IRS:12m:SAIBOR:3m', 'Volatility'],
        SourceCurveTag=['IRS:12m:SAIBOR:3m', 'NormalVolatility']
    )

    return model


# noinspection PyUnusedLocal
def extend_with_jpy_swaptions(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    jpy_swaption_tag_suffix = 'VanillaSwaption:FullCashSingleCurrencyCollateralInJPY'
    jpy_swaption_tag_prefix = 'VanillaSwaption:IRS:6m:JPY LIBOR:6m:Relative:'
    jpy_swaption_tags = {0: jpy_swaption_tag_prefix + '0',
                         0.0025: jpy_swaption_tag_prefix + '0.0025',
                         -0.0025: jpy_swaption_tag_prefix + '-0.0025',
                         0.005: jpy_swaption_tag_prefix + '0.005',
                         -.005: jpy_swaption_tag_prefix + '-0.005',
                         0.01: jpy_swaption_tag_prefix + '0.01',
                         -0.01: jpy_swaption_tag_prefix + '-0.01'}

    model = f3.ExtendModelWithInterpolatedVolatilityCube(model,
                                                         ['IRS:6m:JPY LIBOR:6m', 'NormalVolatility'],
                                                         [[jpy_swaption_tags[0], jpy_swaption_tag_suffix],
                                                          [jpy_swaption_tags[0.0025], jpy_swaption_tag_suffix],
                                                          [jpy_swaption_tags[-0.0025], jpy_swaption_tag_suffix],
                                                          [jpy_swaption_tags[0.005], jpy_swaption_tag_suffix],
                                                          [jpy_swaption_tags[-0.005], jpy_swaption_tag_suffix],
                                                          [jpy_swaption_tags[0.01], jpy_swaption_tag_suffix],
                                                          [jpy_swaption_tags[-0.01], jpy_swaption_tag_suffix]],
                                                         'Linear',
                                                         'Normal',
                                                         ['UnderlyingMaturity', 'OptionExpiry', 'Strike'])

    model = f3.ExtendModelWithClonedCurve(model,
                                          ['IRS:6m:JPY LIBOR:6m', 'Volatility'],
                                          ['IRS:6m:JPY LIBOR:6m', 'NormalVolatility'])

    return model


async def extend_with_jpy_swaptions_sabr_async(model, **kwargs):
    from firm_f3.model_object.swaption_model import SabrSwaptionMixIn
    return await SabrSwaptionMixIn(currency=Ccy.JPY).assemble_fragment_async(model)


# noinspection PyUnusedLocal
def extend_with_aud_swaptions(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    aud_swaption_tag_suffix_6m = 'VanillaPhysicallySettledSwaption'
    aud_swaption_tag_prefix_6m = 'SwaptionInstrument:SwapBBSWSemi:BBSW6m:SwapBBSW6m:'
    aud_swaption_tag_suffix_3m = 'VanillaPhysicallySettledSwaption'
    aud_swaption_tag_prefix_3m = 'SwaptionInstrument:SwapBBSWQuarterly:BBSW3m:SwapBBSW3m:'

    aud_swaption_tags_6m = {0: aud_swaption_tag_prefix_6m + '0.0',
                            0.0025: aud_swaption_tag_prefix_6m + '0.0025',
                            -0.0025: aud_swaption_tag_prefix_6m + '-0.0025',
                            0.005: aud_swaption_tag_prefix_6m + '0.005',
                            -.005: aud_swaption_tag_prefix_6m + '-0.005',
                            0.01: aud_swaption_tag_prefix_6m + '0.01',
                            -0.01: aud_swaption_tag_prefix_6m + '-0.01'}

    model = f3.ExtendModelWithInterpolatedVolatilityCube(model,
                                                         ['IRS:6m:BBSW:6m', 'NormalVolatility'],
                                                         [[aud_swaption_tags_6m[0], aud_swaption_tag_suffix_6m],
                                                          [aud_swaption_tags_6m[0.0025], aud_swaption_tag_suffix_6m],
                                                          [aud_swaption_tags_6m[-0.0025], aud_swaption_tag_suffix_6m],
                                                          [aud_swaption_tags_6m[0.005], aud_swaption_tag_suffix_6m],
                                                          [aud_swaption_tags_6m[-0.005], aud_swaption_tag_suffix_6m],
                                                          [aud_swaption_tags_6m[0.01], aud_swaption_tag_suffix_6m],
                                                          [aud_swaption_tags_6m[-0.01], aud_swaption_tag_suffix_6m]],
                                                         'Linear',
                                                         'Normal',
                                                         ['UnderlyingMaturity', 'OptionExpiry', 'Strike'])

    model = f3.ExtendModelWithClonedCurve(model,
                                          ['IRS:6m:BBSW:6m', 'Volatility'],
                                          ['IRS:6m:BBSW:6m', 'NormalVolatility'])

    aud_swaption_tags_3m = {0: aud_swaption_tag_prefix_3m + '0.0',
                            0.0025: aud_swaption_tag_prefix_3m + '0.0025',
                            -0.0025: aud_swaption_tag_prefix_3m + '-0.0025',
                            0.005: aud_swaption_tag_prefix_3m + '0.005',
                            -.005: aud_swaption_tag_prefix_3m + '-0.005',
                            0.01: aud_swaption_tag_prefix_3m + '0.01',
                            -0.01: aud_swaption_tag_prefix_3m + '-0.01'}

    model = f3.ExtendModelWithInterpolatedVolatilityCube(model,
                                                         ['IRS:3m:BBSW:3m', 'NormalVolatility'],
                                                         [[aud_swaption_tags_3m[0], aud_swaption_tag_suffix_3m],
                                                          [aud_swaption_tags_3m[0.0025], aud_swaption_tag_suffix_3m],
                                                          [aud_swaption_tags_3m[-0.0025], aud_swaption_tag_suffix_3m],
                                                          [aud_swaption_tags_3m[0.005], aud_swaption_tag_suffix_3m],
                                                          [aud_swaption_tags_3m[-0.005], aud_swaption_tag_suffix_3m],
                                                          [aud_swaption_tags_3m[0.01], aud_swaption_tag_suffix_3m],
                                                          [aud_swaption_tags_3m[-0.01], aud_swaption_tag_suffix_3m]],
                                                         'Linear',
                                                         'Normal',
                                                         ['UnderlyingMaturity', 'OptionExpiry', 'Strike'])

    model = f3.ExtendModelWithClonedCurve(model,
                                          ['IRS:3m:BBSW:3m', 'Volatility'],
                                          ['IRS:3m:BBSW:3m', 'NormalVolatility'])

    return model


async def extend_with_aud_swaptions_sabr_async(model, **kwargs):
    from firm_f3.model_object.swaption_model import SabrSwaptionMixIn
    helper = SabrSwaptionMixIn(currency=Ccy.AUD)
    helper.swaption_data_instrument = domain.Swaption(Ccy.AUD, None, None, idx=Tenor.T_3M)
    model = await helper.assemble_fragment_async(model)

    helper = SabrSwaptionMixIn(currency=Ccy.AUD)
    helper.swaption_data_instrument = domain.Swaption(Ccy.AUD, None, None, idx=Tenor.T_6M)
    model = await helper.assemble_fragment_async(model)
    return model


# noinspection PyUnusedLocal
def extend_with_krw_swaptions(model, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    krw_swaption_tag_suffix = 'VanillaSwaption'
    krw_swaption_tag_prefix = 'VanillaSwaption:IRS:3m:KRWCD:3m:Relative:'
    krw_swaption_tags = {0: krw_swaption_tag_prefix + '0',
                         0.0025: krw_swaption_tag_prefix + '0.0025',
                         -0.0025: krw_swaption_tag_prefix + '-0.0025',
                         0.005: krw_swaption_tag_prefix + '0.005',
                         -.005: krw_swaption_tag_prefix + '-0.005',
                         0.01: krw_swaption_tag_prefix + '0.01',
                         -0.01: krw_swaption_tag_prefix + '-0.01'}

    model = f3.ExtendModelWithInterpolatedVolatilityCube(model,
                                                         ['IRS:3m:KRWCD:3m', 'NormalVolatility'],
                                                         [[krw_swaption_tags[0], krw_swaption_tag_suffix],
                                                          [krw_swaption_tags[0.0025], krw_swaption_tag_suffix],
                                                          [krw_swaption_tags[-0.0025], krw_swaption_tag_suffix],
                                                          [krw_swaption_tags[0.005], krw_swaption_tag_suffix],
                                                          [krw_swaption_tags[-0.005], krw_swaption_tag_suffix],
                                                          [krw_swaption_tags[0.01], krw_swaption_tag_suffix],
                                                          [krw_swaption_tags[-0.01], krw_swaption_tag_suffix]],
                                                         'Linear',
                                                         'Normal',
                                                         ['UnderlyingMaturity', 'OptionExpiry', 'Strike'])

    model = f3.ExtendModelWithClonedCurve(model,
                                          ['IRS:3m:KRWCD:3m', 'Volatility'],
                                          ['IRS:3m:KRWCD:3m', 'NormalVolatility'])

    return model


async def extend_with_krw_swaptions_sabr_async(model, **kwargs):
    from firm_f3.model_object.swaption_model import SabrSwaptionMixIn
    return await SabrSwaptionMixIn(currency=Ccy.KRW).assemble_fragment_async(model)


async def extend_with_fx_vols_async(model, ccy: Ccy, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ccy_pair = f3m.ccy_to_f3pair(ccy)
    ccy_pair_inv = f3m.ccy_to_f3pair(ccy, True)
    ins_types = [FXOption(ccy, Tenor.T_3M, OptionStrat.STRAD),
                 FXOption(ccy, Tenor.T_3M, OptionStrat.RR),
                 FXOption(ccy, Tenor.T_3M, OptionStrat.FLY)]

    strad_ins_type, rr_ins_type, fly_ins_type = fu.get_instrument_type(*ins_types)
    strad_curve_tag, rr_curve_tag, fly_curve_tag = await f3_evaluate_async(
        [f3.StraddleCurveTag(ccy_pair), f3.RiskReversalCurveTag(ccy_pair), f3.ButterflyCurveTag(ccy_pair)],
        callback=scalar_handler)

    model = f3.ExtendModelWithInterpolationCurve(
        BaseModel=model,
        CurveTag=strad_curve_tag,
        MarketDataTag=strad_ins_type,
        InterpolationMethod='Linear'
    )

    model = f3.ExtendModelWithTwoDimInterpolationCurve(
        BaseModel=model,
        CurveTag=rr_curve_tag,
        MarketDataTag=rr_ins_type,
        TwoDimInterpolationMethod=['Linear', 'Linear'],
        Axes=['OptionExpiry', 'Delta']
    )

    model = f3.ExtendModelWithTwoDimInterpolationCurve(
        BaseModel=model,
        CurveTag=fly_curve_tag,
        MarketDataTag=fly_ins_type,
        TwoDimInterpolationMethod=['Linear', 'Linear'],
        Axes=['OptionExpiry', 'Delta']
    )

    model = f3.ExtendModelWithParameterizedCurves(
        BaseModel=model,
        Expressions='; '.join([
            'sigma_bar(t) = sigma_straddle(t) + 0.5* sigma_BF(t,0.25)',
            'z(t) = -sigma_bar(t) * sqrt(max(t, 7/365)) * norminv(0.25)',
        ]),
        TargetCurves=[
            ['sigma_bar', ccy_pair, 'Sigma_bar'],
            ['z', ccy_pair, 'Moneyness_25D']
        ],
        Parameters=None,
        Functions=[
            ['sigma_straddle', *strad_curve_tag],
            ['sigma_BF', *fly_curve_tag]
        ],
    )

    model = f3.ExtendModelWithParameterizedCurves(
        BaseModel=model,
        Expressions='; '.join([
            'rho_nu_over_alpha(t) = sigma_RR(t,0.25)/sigma_ATM(t)/z(t)',
            'nu_over_alpha(t) = (6*(sigma_BF(t,0.25)/sigma_ATM(t)/z(t)/z(t)+ (rho_nu_over_alpha(t))^2/4))^0.5',
            'rho(t) = rho_nu_over_alpha(t)/ nu_over_alpha(t)'
        ]),
        TargetCurves=[
            ['rho_nu_over_alpha', ccy_pair, 'Rho_nu_over_alpha_guess'],
            ['nu_over_alpha', ccy_pair, 'Nu_over_alpha_guess'],
            ['rho', ccy_pair, 'Rho_guess']
        ],
        Parameters=None,
        Functions=[
            ['sigma_BF', *fly_curve_tag],
            ['sigma_RR', *rr_curve_tag],
            ['sigma_ATM', *strad_curve_tag],
            ['z', ccy_pair, 'Moneyness_25D']
        ]
    )

    model = f3.ExtendModelWithParameterizedCurves(
        BaseModel=model,
        Expressions='; '.join([
            'a_3(t) = (rho_nu_over_alpha(t)/4-(rho_nu_over_alpha(t))^2/8+(nu_over_alpha(t))^2/12)*max(t,7/365)',
            'p(t) = 1/a_3(t)',
            'q(t) = -sigma_ATM(t)/a_3(t)'
        ]),
        TargetCurves=[
            ['a_3', ccy_pair, 'a_3_guess'],
            ['p', ccy_pair, 'p_guess'],
            ['q', ccy_pair, 'q_guess']
        ],
        Parameters=None,
        Functions=[
            ['rho_nu_over_alpha', ccy_pair, 'Rho_nu_over_alpha_guess'],
            ['nu_over_alpha', ccy_pair, 'Nu_over_alpha_guess'],
            ['sigma_ATM', *strad_curve_tag]
        ]
    )

    model = f3.ExtendModelWithParameterizedCurves(
        BaseModel=model,
        Expressions='; '.join([
            'alpha(t) = (-q(t)/2+((q(t)/2)^2+(p(t)/3)^3)^0.5)^(1/3) - (q(t)/2+((q(t)/2)^2+(p(t)/3)^3)^0.5)^(1/3)',
            'nu(t) = nu_over_alpha(t) * alpha(t)'
        ]),
        TargetCurves=[
            ['alpha', ccy_pair, 'Alpha_guess'],
            ['nu', ccy_pair, 'Nu_guess']
        ],
        Parameters=None,
        Functions=[
            ['p', ccy_pair, 'p_guess'],
            ['q', ccy_pair, 'q_guess'],
            ['nu_over_alpha', ccy_pair, 'Nu_over_alpha_guess']
        ]
    )

    val_spec_builder = f3.CreateClosedFormVolatilityValuationSpecificationBuilder(
        VolatileIndex=ccy_pair,
        VolatilityType='SABR'
    )

    model = f3.ExtendModelWithVolatilitySurface(
        BaseModel=model,
        CurveTag=f3.VolatilityCurveTag(val_spec_builder),
        UnderlyingCurveTags=[
            [ccy_pair, 'SABRAlpha'],
            [ccy_pair, 'SABRBeta'],
            [ccy_pair, 'SABRRho'],
            [ccy_pair, 'SABRNu']
        ],
        VolatilityType='SABR'
    )

    fixed_beta = f3.CreateDateValueMarketData(
        DateValueName='SABR',
        DateValueType='Beta',
        Maturities='1y',
        Values=1,
        MarketConventions='NoScheduleNoHolidays'
    )

    model = f3.ExtendModelWithMarketData(
        BaseModel=model,
        MarketData=fixed_beta
    )

    model = f3.ExtendModelWithInterpolationCurve(
        BaseModel=model,
        CurveTag=[ccy_pair, 'SABRBeta'],
        MarketDataTag=['SABR', 'Beta'],
        InterpolationMethod='Linear'
    )

    sabr_calib_target = f3.CreateOneDimensionalCalibrationTarget(
        CurveTags=[
            [ccy_pair, 'SABRAlpha'],
            [ccy_pair, 'SABRRho'],
            [ccy_pair, 'SABRNu']
        ],
        InterpolationTypes=['Linear', 'Linear', 'Linear'],
        InitialValueCurves=[
            [ccy_pair, 'Alpha_guess', 'Unanchored'],
            [ccy_pair, 'Rho_guess', 'Unanchored'],
            [ccy_pair, 'Nu_guess', 'Unanchored']
        ],
        BoundConstraints=[
            'GreaterThanZero',
            'BetweenMinusOneAndOne',
            'GreaterThanZero'
        ],
        OptimizationObjective='OptionStrategyParValue',
        EliminateIndices=None,
        TimePointMethod='DropIfNotIncreasing',
        UseHints=False
    )

    model = f3.ExtendModelWithCalibratedCurves(
        BaseModel=model,
        CalibrationTarget=sabr_calib_target,
        InstrumentStrategy=f3.CreateElementInstrumentStrategyCollection(
            MarketDataTags=[[strad_ins_type], [rr_ins_type], [fly_ins_type]],
            Sort=True
        ),
        Optimizer=fu.get_root_finder(ccy),
        SourceMethod='ValueToPar',
        TargetMethod=val_spec_builder
    )

    model = f3.ExtendModelWithClonedCurve(
        BaseModel=model,
        CurveTag=f3.VolatilityCurveTag(ccy_pair),
        SourceCurveTag=f3.VolatilityCurveTag(val_spec_builder)
    )

    return model


# noinspection PyUnusedLocal
async def extend_with_inflation_swap_async(model, idx: InflationIndex, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3_idx = fu.f3index_by_inflation_index(idx)
    ins_type = fu.get_instrument_type(InflationSwap(idx, Tenor.T_1Y))
    swap_ins_strat = f3.CreateElementInstrumentStrategy(ins_type)
    seasonality_ins, seasonality_labels = fu.f3_seasonality_ins_type_by_inf_index(idx)
    seasonality_mkt_data = f3.CreateLabelledValuesMarketData(seasonality_ins,
                                                             [0] * len(seasonality_labels))
    seasonality_tag = (await fu.get_market_data_tag_async(seasonality_mkt_data))[0]

    model = f3.ExtendModelWithBootstrappedCurves(model,
                                                 f3.InflationCurveTag(f3_idx),
                                                 swap_ins_strat,
                                                 'LogLinear',
                                                 [1, 'Anchored'])

    model = f3.ExtendModelWithZeroDimensionalCurve(model,
                                                   [f3_idx, 'SeasonalAdjustments'],
                                                   seasonality_tag)

    model = f3.ExtendModelWith1dFunctionCurve(model,
                                              [f3_idx, 'SeasonalityConverter'],
                                              'Exponential')

    model = f3.ExtendModelWithMonthlyInflationSeasonalityCurve(model,
                                                               f3.InflationSeasonalityCurveTag(f3_idx),
                                                               [f3_idx, 'SeasonalAdjustments'],
                                                               [f3_idx, 'SeasonalityConverter'],
                                                               True)

    return model

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\legacy_strategies.py
----------------------------------------
from typing import Dict
from f3sdk.f3.f3object import F3Object  # type:ignore

import firm_f3.fincadutil as fu
from firm_f3.fincadutil import get_market_data_tag_async

import firm_f3.f3client # type:ignore
from firm_domain import Tenor, Ccy, FRA, IRS, OIS, TenorBasis, FXForward, XccyBasis, CrossCurrencySwap, Rate
from firm_f3.mapping import f3instrument_strategy_async
from firm_f3.market_data.mdobject import MDObjectBase


async def get_instrument_strategies_async(mkt_data_input: Dict[str, MDObjectBase]) -> Dict[str, object]:
    f3 = firm_f3.f3client.get_platform_client()
    mkt_data = {k: await v.f3_mkt_data_object_async() for k, v in mkt_data_input.items()}

    jpy_ois_md = mkt_data[fu.get_instrument_type(OIS(Ccy.JPY, Tenor.T_1Y))]
    ins_strat_jpy_ois = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(jpy_ois_md))
    jpy_irs_md = mkt_data[fu.get_instrument_type(IRS(Ccy.JPY, Tenor.T_1Y))]
    ins_strat_jpy_irs_6m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(jpy_irs_md))
    jpy_cash_depo_6m_md = mkt_data[fu.get_instrument_type(Rate(Ccy.JPY, Tenor.T_6M))]
    ins_strat_jpy_cash_depo_6m = f3.CreateElementInstrumentStrategy(
        await get_market_data_tag_async(jpy_cash_depo_6m_md))
    jpy_fra_6m_md = mkt_data[fu.get_instrument_type(FRA(Ccy.JPY, Tenor.T_6M, Tenor.T_6M))]
    ins_strat_jpy_fra_6m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(jpy_fra_6m_md))
    ins_strat_jpy_irs_combined = f3.CreateConcatenatedInstrumentStrategy(
        f3.ArrayStack(
            ins_strat_jpy_cash_depo_6m,
            ins_strat_jpy_fra_6m,
            ins_strat_jpy_irs_6m))

    jpy_cash_depo_3m_md = mkt_data[fu.get_instrument_type(Rate(Ccy.JPY, Tenor.T_3M))]
    ins_strat_jpy_cash_depo_3m = f3.CreateElementInstrumentStrategy(
        await get_market_data_tag_async(jpy_cash_depo_3m_md))
    jpy_basis_3m_6m_md = mkt_data[fu.get_instrument_type(TenorBasis(Ccy.JPY, Tenor.T_1Y, Tenor.T_3M, Tenor.T_6M))]
    ins_strat_jpy_tb_3m_6m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(jpy_basis_3m_6m_md))
    ins_strat_jpy_3m_combined = f3.CreateConcatenatedInstrumentStrategy(
        f3.ArrayStack(
            ins_strat_jpy_cash_depo_3m,
            ins_strat_jpy_tb_3m_6m))

    jpy_fwd_md = mkt_data[fu.get_instrument_type(FXForward(Ccy.JPY, Tenor.T_6M))]
    ins_strat_jpy_fwd = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(jpy_fwd_md))
    jpy_xccy_md = mkt_data[fu.get_instrument_type(XccyBasis(Ccy.JPY, Tenor.T_2Y))]
    ins_strat_jpy_xccy = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(jpy_xccy_md))
    ins_strat_jpy_xccy_combined = f3.CreateConcatenatedInstrumentStrategy(
        f3.ArrayStack(
            ins_strat_jpy_fwd,
            ins_strat_jpy_xccy))

    nzd_ois_md = mkt_data[fu.get_instrument_type(OIS(Ccy.NZD, Tenor.T_1Y))]
    ins_strat_nzd_ois = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(nzd_ois_md))
    nzd_irs_md = mkt_data[fu.get_instrument_type(IRS(Ccy.NZD, Tenor.T_1Y))]
    ins_strat_nzd_irs_3m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(nzd_irs_md))
    nzd_cash_depo_md = mkt_data[fu.get_instrument_type(Rate(Ccy.NZD, Tenor.T_3M))]
    ins_strat_nzd_cash_depo_3m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(nzd_cash_depo_md))
    nzd_fra_md = mkt_data[fu.get_instrument_type(FRA(Ccy.NZD, Tenor.T_3M, Tenor.T_6M))]
    ins_strat_nzd_fra_3m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(nzd_fra_md))
    ins_strat_nzd_irs_combined = f3.CreateConcatenatedInstrumentStrategy(
        f3.ArrayStack(
            ins_strat_nzd_cash_depo_3m,
            ins_strat_nzd_fra_3m,
            ins_strat_nzd_irs_3m))

    nzd_fwd_md = mkt_data[fu.get_instrument_type(FXForward(Ccy.NZD, Tenor.T_6M))]
    ins_strat_nzd_fwd = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(nzd_fwd_md))
    nzd_xccy_md = mkt_data[fu.get_instrument_type(XccyBasis(Ccy.NZD, Tenor.T_2Y))]
    ins_strat_nzd_xccy = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(nzd_xccy_md))
    ins_strat_nzd_xccy_combined = f3.CreateConcatenatedInstrumentStrategy(
        f3.ArrayStack(
            ins_strat_nzd_fwd,
            ins_strat_nzd_xccy))

    cad_ois_md = mkt_data[fu.get_instrument_type(OIS(Ccy.CAD, Tenor.T_1Y))]
    ins_strat_cad_ois = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(cad_ois_md))
    cad_irs_md = mkt_data[fu.get_instrument_type(IRS(Ccy.CAD, Tenor.T_1Y))]
    ins_strat_cad_irs_3m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(cad_irs_md))
    cad_cash_depo_md = mkt_data[fu.get_instrument_type(Rate(Ccy.CAD, Tenor.T_3M))]
    ins_strat_cad_cash_depo_3m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(cad_cash_depo_md))
    cad_fra_md = mkt_data[fu.get_instrument_type(FRA(Ccy.CAD, Tenor.T_3M, Tenor.T_6M))]
    ins_strat_cad_fra_3m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(cad_fra_md))
    ins_strat_cad_irs_combined = f3.CreateConcatenatedInstrumentStrategy(
        f3.ArrayStack(
            ins_strat_cad_cash_depo_3m,
            ins_strat_cad_fra_3m,
            ins_strat_cad_irs_3m))

    cad_fwd_md = mkt_data[fu.get_instrument_type(FXForward(Ccy.CAD, Tenor.T_6M))]
    ins_strat_cad_fwd = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(cad_fwd_md))
    cad_xccy_md = mkt_data[fu.get_instrument_type(XccyBasis(Ccy.CAD, Tenor.T_2Y))]
    ins_strat_cad_xccy = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(cad_xccy_md))
    ins_strat_cad_xccy_combined = f3.CreateConcatenatedInstrumentStrategy(
        f3.ArrayStack(
            ins_strat_cad_fwd,
            ins_strat_cad_xccy))

    sek_ois_md = mkt_data[fu.get_instrument_type(OIS(Ccy.SEK, Tenor.T_1Y))]
    ins_strat_sek_ois = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(sek_ois_md))
    sek_cash_depo_md = mkt_data[fu.get_instrument_type(Rate(Ccy.SEK, Tenor.T_3M))]
    ins_strat_sek_cash_depo_3m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(sek_cash_depo_md))
    sek_irs_md = mkt_data[fu.get_instrument_type(IRS(Ccy.SEK, Tenor.T_1Y))]
    ins_strat_sek_irs_3m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(sek_irs_md))
    ins_strat_sek_irs_combined = f3.CreateConcatenatedInstrumentStrategy(
        f3.ArrayStack(
            ins_strat_sek_cash_depo_3m,
            ins_strat_sek_irs_3m))

    sek_fwd_md = mkt_data[fu.get_instrument_type(FXForward(Ccy.SEK, Tenor.T_6M))]
    ins_strat_sek_fwd = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(sek_fwd_md))
    sek_xccy_md = mkt_data[fu.get_instrument_type(XccyBasis(Ccy.SEK, Tenor.T_2Y))]
    ins_strat_sek_xccy = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(sek_xccy_md))
    ins_strat_sek_xccy_combined = f3.CreateConcatenatedInstrumentStrategy(
        f3.ArrayStack(
            ins_strat_sek_fwd,
            ins_strat_sek_xccy))

    chf_ois_md = mkt_data[fu.get_instrument_type(OIS(Ccy.CHF, Tenor.T_1Y))]
    ins_strat_chf_ois = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(chf_ois_md))
    chf_cash_depo_6m_md = mkt_data[fu.get_instrument_type(Rate(Ccy.CHF, Tenor.T_6M))]
    ins_strat_chf_cash_depo_6m = f3.CreateElementInstrumentStrategy(
        await get_market_data_tag_async(chf_cash_depo_6m_md))
    chf_fra_md = mkt_data[fu.get_instrument_type(FRA(Ccy.CHF, Tenor.T_6M, Tenor.T_6M))]
    ins_strat_chf_fra_6m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(chf_fra_md))
    chf_irs_md = mkt_data[fu.get_instrument_type(IRS(Ccy.CHF, Tenor.T_1Y))]
    ins_strat_chf_irs_6m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(chf_irs_md))
    ins_strat_chf_irs_combined_6m = f3.CreateConcatenatedInstrumentStrategy(
        f3.ArrayStack(
            ins_strat_chf_cash_depo_6m,
            ins_strat_chf_fra_6m,
            ins_strat_chf_irs_6m))

    chf_cash_depo_3m_md = mkt_data[fu.get_instrument_type(Rate(Ccy.CHF, Tenor.T_3M))]
    ins_strat_chf_cash_depo_3m = f3.CreateElementInstrumentStrategy(
        await get_market_data_tag_async(chf_cash_depo_3m_md))
    chf_fra_3m_md = mkt_data[fu.get_instrument_type(FRA(Ccy.CHF, Tenor.T_3M, Tenor.T_6M))]
    ins_strat_chf_fra_3m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(chf_fra_3m_md))
    chf_basis_3m_6m_md = mkt_data[fu.get_instrument_type(TenorBasis(Ccy.CHF, Tenor.T_1Y, Tenor.T_3M, Tenor.T_6M))]
    ins_strat_chf_tb_3m_6m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(chf_basis_3m_6m_md))
    ins_strat_chf_irs_combined_3m = f3.CreateConcatenatedInstrumentStrategy(
        f3.ArrayStack(
            ins_strat_chf_cash_depo_3m,
            ins_strat_chf_fra_3m,
            ins_strat_chf_tb_3m_6m))

    chf_fwd_md = mkt_data[fu.get_instrument_type(FXForward(Ccy.CHF, Tenor.T_6M))]
    ins_strat_chf_fwd = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(chf_fwd_md))
    chf_xccy_md = mkt_data[fu.get_instrument_type(XccyBasis(Ccy.CHF, Tenor.T_2Y))]
    ins_strat_chf_xccy = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(chf_xccy_md))
    ins_strat_chf_xccy_combined = f3.CreateConcatenatedInstrumentStrategy(
        f3.ArrayStack(
            ins_strat_chf_fwd,
            ins_strat_chf_xccy))

    aud_ois_md = mkt_data[fu.get_instrument_type(OIS(Ccy.AUD, Tenor.T_1Y))]
    ins_strat_aud_ois = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(aud_ois_md))
    aud_fra_md = mkt_data[fu.get_instrument_type(FRA(Ccy.AUD, Tenor.T_3M, Tenor.T_6M))]
    ins_strat_aud_fra_3m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(aud_fra_md))
    aud_cash_depo_3m_md = mkt_data[fu.get_instrument_type(Rate(Ccy.AUD, Tenor.T_3M))]
    ins_strat_aud_cash_depo_3m = f3.CreateElementInstrumentStrategy(
        await get_market_data_tag_async(aud_cash_depo_3m_md))
    aud_cash_depo_6m_md = mkt_data[fu.get_instrument_type(Rate(Ccy.AUD, Tenor.T_6M))]
    ins_strat_aud_cash_depo_6m = f3.CreateElementInstrumentStrategy(
        await get_market_data_tag_async(aud_cash_depo_6m_md))
    aud_irs_3m_md = mkt_data[fu.get_instrument_type(IRS(Ccy.AUD, Tenor.T_1Y))]
    ins_strat_aud_irs_3m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(aud_irs_3m_md))
    aud_irs_6m_md = mkt_data[fu.get_instrument_type(IRS(Ccy.AUD, Tenor.T_5Y))]
    ins_strat_aud_irs_6m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(aud_irs_6m_md))
    aud_basis_on_3m_md = mkt_data[fu.get_instrument_type(TenorBasis(Ccy.AUD, Tenor.T_1Y, Tenor.T_1D, Tenor.T_3M))]
    ins_strat_aud_tb_on_3m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(aud_basis_on_3m_md))
    aud_basis_3m_6m_md = mkt_data[fu.get_instrument_type(TenorBasis(Ccy.AUD, Tenor.T_1Y, Tenor.T_3M, Tenor.T_6M))]
    ins_strat_aud_tb_3m_6m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(aud_basis_3m_6m_md))
    ins_strat_aud_combined = f3.CreateConcatenatedInstrumentStrategy(
        f3.ArrayStack(
            ins_strat_aud_ois,
            ins_strat_aud_cash_depo_3m,
            ins_strat_aud_cash_depo_6m,
            ins_strat_aud_fra_3m,
            ins_strat_aud_irs_3m,
            ins_strat_aud_irs_6m,
            ins_strat_aud_tb_on_3m,
            ins_strat_aud_tb_3m_6m,
        ))

    aud_cash_depo_1m_md = mkt_data[fu.get_instrument_type(Rate(Ccy.AUD, Tenor.T_1M))]
    ins_strat_aud_cash_depo_1m = f3.CreateElementInstrumentStrategy(
        await get_market_data_tag_async(aud_cash_depo_1m_md))
    aud_basis_1m_3m_md = mkt_data[fu.get_instrument_type(TenorBasis(Ccy.AUD, Tenor.T_1Y, Tenor.T_1M, Tenor.T_3M))]
    ins_strat_aud_tb_1m_3m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(aud_basis_1m_3m_md))
    ins_strat_aud_1m_combined = f3.CreateConcatenatedInstrumentStrategy(
        f3.ArrayStack(
            ins_strat_aud_cash_depo_1m,
            ins_strat_aud_tb_1m_3m,
        ))

    aud_fwd_md = mkt_data[fu.get_instrument_type(FXForward(Ccy.AUD, Tenor.T_6M))]
    ins_strat_aud_fwd = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(aud_fwd_md))
    aud_xccy_md = mkt_data[fu.get_instrument_type(XccyBasis(Ccy.AUD, Tenor.T_2Y))]
    ins_strat_aud_xccy = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(aud_xccy_md))
    ins_strat_aud_xccy_combined = f3.CreateConcatenatedInstrumentStrategy(
        f3.ArrayStack(
            ins_strat_aud_fwd,
            ins_strat_aud_xccy))

    krw_cash_depo_3m_md = mkt_data[fu.get_instrument_type(Rate(Ccy.KRW, Tenor.T_3M))]
    ins_strat_krw_cash_depo_3m = f3.CreateElementInstrumentStrategy(
        await get_market_data_tag_async(krw_cash_depo_3m_md))
    krw_irs_3m_md = mkt_data[fu.get_instrument_type(IRS(Ccy.KRW, Tenor.T_1Y))]
    ins_strat_krw_irs_3m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(krw_irs_3m_md))
    krw_fwd_md = mkt_data[fu.get_instrument_type(FXForward(Ccy.KRW, Tenor.T_6M))]
    ins_strat_krw_fwd = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(krw_fwd_md))
    krw_xccy_md = mkt_data[fu.get_instrument_type(XccyBasis(Ccy.KRW, Tenor.T_2Y))]
    ins_strat_krw_xccy = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(krw_xccy_md))
    ins_strat_krw_xccy_combined = f3.CreateConcatenatedInstrumentStrategy(
        f3.ArrayStack(
            ins_strat_krw_cash_depo_3m,
            ins_strat_krw_irs_3m,
            ins_strat_krw_fwd,
            ins_strat_krw_xccy))

    myr_cash_depo_3m_md = mkt_data[fu.get_instrument_type(Rate(Ccy.MYR, Tenor.T_3M))]
    ins_strat_myr_cash_depo_3m = f3.CreateElementInstrumentStrategy(
        await get_market_data_tag_async(myr_cash_depo_3m_md))
    myr_irs_3m_md = mkt_data[fu.get_instrument_type(IRS(Ccy.MYR, Tenor.T_1Y))]
    ins_strat_myr_irs_3m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(myr_irs_3m_md))
    ins_strat_myr_irs_3m_combined = f3.CreateConcatenatedInstrumentStrategy(
        f3.ArrayStack(
            ins_strat_myr_cash_depo_3m,
            ins_strat_myr_irs_3m))
    myr_fwd_md = mkt_data[fu.get_instrument_type(FXForward(Ccy.MYR, Tenor.T_6M))]
    ins_strat_myr_fwd = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(myr_fwd_md))

    thb_cash_depo_6m_md = mkt_data[fu.get_instrument_type(Rate(Ccy.THB, Tenor.T_6M))]
    ins_strat_thb_cash_depo_6m = f3.CreateElementInstrumentStrategy(
        await get_market_data_tag_async(thb_cash_depo_6m_md))
    thb_irs_6m_md = mkt_data[fu.get_instrument_type(IRS(Ccy.THB, Tenor.T_1Y))]
    ins_strat_thb_irs_6m = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(thb_irs_6m_md))
    ins_strat_thb_irs_6m_combined = f3.CreateConcatenatedInstrumentStrategy(
        f3.ArrayStack(
            ins_strat_thb_cash_depo_6m,
            ins_strat_thb_irs_6m))
    thb_fwd_md = mkt_data[fu.get_instrument_type(FXForward(Ccy.THB, Tenor.T_6M))]
    ins_strat_thb_fwd = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(thb_fwd_md))

    cny_irs_7d_md = mkt_data[fu.get_instrument_type(IRS(Ccy.CNY, Tenor.T_1Y))]
    ins_strat_cny_irs_7d = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(cny_irs_7d_md))
    cny_fwd_md = mkt_data[fu.get_instrument_type(FXForward(Ccy.CNY, Tenor.T_6M))]
    ins_strat_cny_fwd = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(cny_fwd_md))

    rub_fwd_md = mkt_data[fu.get_instrument_type(FXForward(Ccy.RUB, Tenor.T_6M))]
    ins_strat_rub_fwd = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(rub_fwd_md))
    rub_ccs_md = mkt_data[fu.get_instrument_type(CrossCurrencySwap(Ccy.RUB, Tenor.T_2Y))]
    ins_strat_rub_ccs = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(rub_ccs_md))
    ins_strat_rub_xccy_combined = f3.CreateConcatenatedInstrumentStrategy(
        f3.ArrayStack(
            ins_strat_rub_fwd,
            ins_strat_rub_ccs))

    inr_ois_md = mkt_data[fu.get_instrument_type(OIS(Ccy.INR, Tenor.T_1Y))]
    ins_strat_inr_ois = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(inr_ois_md))
    inr_fwd_md = mkt_data[fu.get_instrument_type(FXForward(Ccy.INR, Tenor.T_6M))]
    ins_strat_inr_fwd = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(inr_fwd_md))
    inr_ccs_md = mkt_data[fu.get_instrument_type(CrossCurrencySwap(Ccy.INR, Tenor.T_2Y))]
    ins_strat_inr_ccs = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(inr_ccs_md))
    ins_strat_inr_xccy_combined = f3.CreateConcatenatedInstrumentStrategy(
        f3.ArrayStack(
            ins_strat_inr_fwd,
            ins_strat_inr_ccs))

    ino_ois_md = mkt_data[fu.get_instrument_type(OIS(Ccy.INO, Tenor.T_1Y))]
    ins_strat_ino_ois = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(ino_ois_md))
    ino_fwd_md = mkt_data[fu.get_instrument_type(FXForward(Ccy.INO, Tenor.T_6M))]
    ins_strat_ino_fwd = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(ino_fwd_md))
    ino_ccs_md = mkt_data[fu.get_instrument_type(CrossCurrencySwap(Ccy.INO, Tenor.T_2Y))]
    ins_strat_ino_ccs = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(ino_ccs_md))
    ins_strat_ino_xccy_combined = f3.CreateConcatenatedInstrumentStrategy(
        f3.ArrayStack(
            ins_strat_ino_fwd,
            ins_strat_ino_ccs))

    ins_strat_cnh_xccy_combined = await f3instrument_strategy_async(FXForward(Ccy.CNH, Tenor.T_6M),
                                                                    CrossCurrencySwap(Ccy.CNH, Tenor.T_2Y))

    php_fwd_md = mkt_data[fu.get_instrument_type(FXForward(Ccy.PHP, Tenor.T_6M))]
    ins_strat_php_fwd = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(php_fwd_md))
    idr_fwd_md = mkt_data[fu.get_instrument_type(FXForward(Ccy.IDR, Tenor.T_6M))]
    ins_strat_idr_fwd = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(idr_fwd_md))
    twd_fwd_md = mkt_data[fu.get_instrument_type(FXForward(Ccy.TWD, Tenor.T_6M))]
    ins_strat_twd_fwd = f3.CreateElementInstrumentStrategy(await get_market_data_tag_async(twd_fwd_md))

    return {
        'ins_strat_jpy_ois': ins_strat_jpy_ois,
        'ins_strat_jpy_irs_combined': ins_strat_jpy_irs_combined,
        'ins_strat_jpy_3m_combined': ins_strat_jpy_3m_combined,
        'ins_strat_jpy_xccy_combined': ins_strat_jpy_xccy_combined,
        'ins_strat_aud_combined': ins_strat_aud_combined,
        'ins_strat_aud_1m_combined': ins_strat_aud_1m_combined,
        'ins_strat_aud_xccy_combined': ins_strat_aud_xccy_combined,
        'ins_strat_nzd_ois': ins_strat_nzd_ois,
        'ins_strat_nzd_irs_combined': ins_strat_nzd_irs_combined,
        'ins_strat_nzd_xccy_combined': ins_strat_nzd_xccy_combined,
        'ins_strat_cad_ois': ins_strat_cad_ois,
        'ins_strat_cad_irs_combined': ins_strat_cad_irs_combined,
        'ins_strat_cad_xccy_combined': ins_strat_cad_xccy_combined,
        'ins_strat_myr_irs_3m_combined': ins_strat_myr_irs_3m_combined,
        'ins_strat_myr_fwd': ins_strat_myr_fwd,
        'ins_strat_sek_ois': ins_strat_sek_ois,
        'ins_strat_sek_irs_combined': ins_strat_sek_irs_combined,
        'ins_strat_sek_xccy_combined': ins_strat_sek_xccy_combined,
        'ins_strat_chf_ois': ins_strat_chf_ois,
        'ins_strat_chf_irs_combined_6m': ins_strat_chf_irs_combined_6m,
        'ins_strat_chf_irs_combined_3m': ins_strat_chf_irs_combined_3m,
        'ins_strat_chf_xccy_combined': ins_strat_chf_xccy_combined,
        'ins_strat_krw_xccy_combined': ins_strat_krw_xccy_combined,
        'ins_strat_inr_xccy_combined': ins_strat_inr_xccy_combined,
        'ins_strat_ino_xccy_combined': ins_strat_ino_xccy_combined,
        'ins_strat_inr_ois': ins_strat_inr_ois,
        'ins_strat_ino_ois': ins_strat_ino_ois,
        'ins_strat_rub_xccy_combined': ins_strat_rub_xccy_combined,
        'ins_strat_cny_irs_7d': ins_strat_cny_irs_7d,
        'ins_strat_php_fwd': ins_strat_php_fwd,
        'ins_strat_cnh_xccy_combined': ins_strat_cnh_xccy_combined,
        'ins_strat_cny_fwd': ins_strat_cny_fwd,
        'ins_strat_idr_fwd': ins_strat_idr_fwd,
        'ins_strat_twd_fwd': ins_strat_twd_fwd,
        'ins_strat_thb_irs_6m_combined': ins_strat_thb_irs_6m_combined,
        'ins_strat_thb_fwd': ins_strat_thb_fwd,
    }

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\model_ccs_swaption.py
----------------------------------------
import asyncio
from f3sdk.f3 import F3Object  # type:ignore
from typing import Dict, List

from firm_domain import CCSSwaption
import firm_f3.f3client  # type:ignore
from firm_domain.core import Ccy, Tenor
from firm_f3.mapping import get_ccs_index_name, f3instrument_type, f3quote_spec_by_tenor
from firm_f3.evaluate import f3_evaluate_async
from firm_f3.modelconfig import CCS_SWAPTION_TENORS, CCS_SWAPTION_CCY
from firm_f3.market_data.marketdata import CCS_VOL_DATA_OVERRIDES


async def extend_with_ccs_vol_surface_single_ccy(ccy: Ccy, f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()

    for t in CCS_SWAPTION_TENORS:
        index_name = get_ccs_index_name(ccy, t)
        ins_type_name = f3instrument_type(CCSSwaption(ccy, Tenor.T_1Y, t))
        vol_curve_tag = await f3_evaluate_async(f3.VolatilityCurveTag(index_name))
        und_curve_tag = [index_name, 'InterpolatedVol']

        f3model = f3.ExtendModelWithTwoDimInterpolationCurve(
            BaseModel=f3model,
            CurveTag=und_curve_tag,
            MarketDataTag=[ins_type_name, 'ForceUnique'],
            TwoDimInterpolationMethod=['Linear', 'Linear', False],
            Axes=['OptionExpiry', 'Strike']
        )

        f3model = f3.ExtendModelWithVolatilitySurface(
            BaseModel=f3model,
            CurveTag=vol_curve_tag[0],
            UnderlyingCurveTags=und_curve_tag,
            VolatilityType=['NormalSurface', 'Relative']
        )

    return f3model


async def extend_with_ccs_state_variables_single_ccy(ccy: Ccy, f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()

    curve_points = [Tenor.T_1M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M, Tenor.T_1Y, Tenor.T_18M, Tenor.T_2Y, Tenor.T_3Y,
                    Tenor.T_4Y, Tenor.T_5Y, Tenor.T_6Y, Tenor.T_7Y, Tenor.T_8Y, Tenor.T_9Y, Tenor.T_10Y, Tenor.T_12Y,
                    Tenor.T_15Y, Tenor.T_20Y]
    curve_points_f3 = [f3quote_spec_by_tenor(t) for t in curve_points]

    for t in CCS_SWAPTION_TENORS:
        index_name = get_ccs_index_name(ccy, t)
        fra_ins_type = f3.CreateFRAInstrumentType(MarketConventions='NoSchedule',
                                                  FloatingIndex=get_ccs_index_name(ccy, t))
        md = f3.CreateCurveMarketData(InstrumentType=fra_ins_type,
                                      Maturities=curve_points_f3,
                                      Quotes=([0] * len(curve_points_f3)))

        ins_strat = f3.CreateElementInstrumentStrategy(MarketDataTag=fra_ins_type)
        state_variable_curve_tag = await f3_evaluate_async(f3.StateVariableForwardCurveTag(index_name))
        calib_target = f3.CreateOneDimensionalCalibrationTarget(CurveTags=state_variable_curve_tag[0],
                                                                InterpolationTypes='Linear',
                                                                InitialValueCurves=[0.01, 'Unanchored'],
                                                                OptimizationObjective='SingleCurrencyValue',
                                                                TimePointMethod='DropIfNotIncreasing',
                                                                UseHints=True)

        val_spec = f3.CreateClosedFormStateVariableValuationSpecification(UnderlyingValuationMethod='DefaultCNH',
                                                                          StateVariables=index_name)

        f3model = f3.ExtendModelWithCalibratedCurves(BaseModel=f3model,
                                                     CalibrationTarget=calib_target,
                                                     InstrumentStrategy=ins_strat,
                                                     Optimizer='NewtonRaphson',
                                                     SourceMethod='DefaultCNH',
                                                     TargetMethod=val_spec)
        f3model = f3.ExtendModelWithMarketData(BaseModel=f3model,
                                               MarketData=md)

        return f3model


def extend_with_ccs_vol_market_data_single_ccy(ccy: Ccy, f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()

    for t in CCS_SWAPTION_TENORS:
        vol_levels = CCS_VOL_DATA_OVERRIDES[ccy].get(t, CCS_VOL_DATA_OVERRIDES[ccy]['Default'])
        ccs_swaption_ins_type = f3instrument_type(CCSSwaption(ccy, Tenor.T_1Y, tenor=t))
        md = f3.CreateOptionMarketData(
            InstrumentType=ccs_swaption_ins_type,
            Expiries=vol_levels['Expiries'],
            Strikes=vol_levels['Strikes'],
            Quotes=vol_levels['Quotes'],
            Payoffs='Call',
            MarketDataTagMethod='ForceUnique'
        )
        f3model = f3.ExtendModelWithMarketData(
            BaseModel=f3model,
            MarketData=md,
        )

    return f3model


async def extend_with_ccs_vol_surface(f3model: F3Object, **kwargs):
    for ccy in CCS_SWAPTION_CCY:
        f3model = await extend_with_ccs_vol_surface_single_ccy(ccy, f3model)
    return f3model


async def extend_with_ccs_state_variables(f3model: F3Object, **kwargs):
    for ccy in CCS_SWAPTION_CCY:
        f3model = await extend_with_ccs_state_variables_single_ccy(ccy, f3model)
    return f3model


def extend_with_ccs_vol_market_data(f3model: F3Object, **kwargs):
    for ccy in CCS_SWAPTION_CCY:
        f3model = extend_with_ccs_vol_market_data_single_ccy(ccy, f3model)
    return f3model


extensions = (
    extend_with_ccs_vol_surface,
    extend_with_ccs_state_variables,
    extend_with_ccs_vol_market_data
)


async def assemble_model_fragment_async(f3model: F3Object = '${-1}', **kwargs):
    for func in extensions:
        if asyncio.iscoroutinefunction(func):
            f3model = await func(f3model, **kwargs)
        else:
            f3model = func(f3model, **kwargs)
    return f3model


def cnh_ccs_vol_override(f3model: F3Object, override: float) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    vol_levels: Dict[str, List] = {
        'Expiries': ['1y', '2y', '3y', '4y', '5y'],
        'Strikes': [['ATM', 0]],
        'Quotes': [[override, override, override, override, override]]
    }
    for t in CCS_SWAPTION_TENORS:
        ccs_swaption_ins_type = f3instrument_type(CCSSwaption(Ccy.CNH, Tenor.T_1Y, tenor=t))
        md = f3.CreateOptionMarketData(
            InstrumentType=ccs_swaption_ins_type,
            Expiries=vol_levels['Expiries'],
            Strikes=vol_levels['Strikes'],
            Quotes=vol_levels['Quotes'],
            Payoffs='Call',
            MarketDataTagMethod='ForceUnique'
        )
        f3model = f3.ExtendModelWithMarketData(
            BaseModel=f3model,
            MarketData=md,
        )

    return f3model


def cnh_ccs_override(f3model: F3Object, override: Dict[str, float]) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithMarketData(
        BaseModel=f3model,
        MarketData=f3.CreateMarketData(
            InstrumentType=[['CNH_CCS_Inst_Type']],
            QuoteSpecifications=[[i] for i in override.keys()],
            Quotes=[[i] for i in override.values()],
        ),
    )


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\model_eur.py
----------------------------------------
from typing import Dict, Optional, List, Mapping, Union, Tuple

from firm_f3.core.modelutils import create_collapsed_compounding_valspec
from colorama import Fore
from f3sdk.f3.f3object import F3Object  # type:ignore

import firm_f3.f3client  # type:ignore
from firm_f3.f3definitions import CurveTag
import firm_domain as domain
from firm_domain import Ccy, Tenor
from firm_f3.mapping import f3instrument_strategy_async, f3instrument_type
from firm_f3.market_data.mdobject import MDObjectBase
from firm_f3.model_fragments.model_fragment import FragmentBase, RequiredMktData

from firm_f3.model_object.util import extend_model_with_one_dimensional_calibrated_curve_async


def tag_discount_eur_overnightUsd() -> F3Object:
    return firm_f3.f3client.get_platform_client().DiscountCurveTag('EUR', 'OvernightUSD')


def tag_discount_eur_overnightEur() -> F3Object:
    return firm_f3.f3client.get_platform_client().DiscountCurveTag('EUR', 'OvernightEUR')


def tag_discount_eur_euribor3m() -> F3Object:
    return firm_f3.f3client.get_platform_client().DiscountCurveTag('EUR', 'Euribor3m')


def tag_discount_eur_euribor6m() -> F3Object:
    return firm_f3.f3client.get_platform_client().DiscountCurveTag('EUR', 'Euribor6m')


class MultiCurveFragmentEur(FragmentBase):

    @property
    def fragment_name(self) -> str:
        return "eur_multi_curve_ModelFragment"

    def create_static_data(self) -> List[F3Object]:
        f3 = firm_f3.f3client.get_platform_client()
        o: List[F3Object] = []
        for discountCurveTag in [tag_discount_eur_overnightUsd(),
                                 tag_discount_eur_overnightEur(),
                                 tag_discount_eur_euribor3m(),
                                 tag_discount_eur_euribor6m()]:
            curvetag: CurveTag = CurveTag.from_discount_curve_tag(discountCurveTag)
            name = curvetag.zspread_convention_name
            zspread_conv = f3.CreateZSpreadConvention(
                UnderlyingCurveTag=curvetag.to_list(),
                CompoundingFrequency='Continuous',
                BaseDateConvention='SettlementDate').named(name)
            o.append(zspread_conv)
        return o

    async def assemble_async(self,
                             base_model: Optional[F3Object],
                             market_data: Optional[Mapping[str, MDObjectBase]]) -> Tuple[F3Object, RequiredMktData]:
        f3 = firm_f3.f3client.get_platform_client()
        model = f3.ExtendModelWithValuationSpecification(base_model or "${-1}", create_collapsed_compounding_valspec())

        all_instruments = []

        ccy = Ccy.EUR
        ois = domain.OIS(ccy, Tenor.T_1Y)
        instruments = [ois]
        all_instruments += instruments
        inst_strategy = await f3instrument_strategy_async(*instruments)
        model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ois.index_rate, inst_strategy)

        deposit = domain.Rate(ccy, Tenor.T_6M)
        instruments = [deposit,
                       domain.FRA(ccy, tenor=deposit.tenor, start=Tenor.T_6M),
                       domain.IRS(ccy, tenor=Tenor.T_1Y, idx=deposit.tenor)]
        all_instruments += instruments
        inst_strategy = await f3instrument_strategy_async(*instruments)

        model = await extend_model_with_one_dimensional_calibrated_curve_async(model, deposit, inst_strategy)

        deposit = domain.Rate(ccy, Tenor.T_3M)
        instruments = [deposit,
                       domain.TenorBasis(ccy, Tenor.T_1Y, deposit.tenor, Tenor.T_6M)]
        all_instruments += instruments
        inst_strategy = await f3instrument_strategy_async(*instruments)

        model = await extend_model_with_one_dimensional_calibrated_curve_async(model, deposit, inst_strategy)

        deposit = domain.Rate(ccy, Tenor.T_1M)
        instruments = [deposit,
                       domain.IRS(ccy, tenor=Tenor.T_2M, idx=deposit.tenor)]
        all_instruments += instruments
        inst_strategy = await f3instrument_strategy_async(*instruments)

        model = await extend_model_with_one_dimensional_calibrated_curve_async(model, deposit, inst_strategy)

        instruments = [domain.FXForward(ccy, Tenor.T_6M),
                       domain.XccyBasis(ccy, Tenor.T_2Y)]
        all_instruments += instruments
        inst_strategy = await f3instrument_strategy_async(*instruments)

        model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ccy.name, inst_strategy,
                                                                               target_method=f'Default{ccy.name}')

        model = f3.ExtendModelWithClonedCurve(
            BaseModel=model,
            CurveTag=[ccy.name, 'DiscountCurve-CollateralRate-USD O/N:1b'],
            SourceCurveTag=[ccy.name, 'DiscountCurve'],
        )

        req_mkt_data = RequiredMktData(set(f3instrument_type(*all_instruments)))

        return model, req_mkt_data

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\model_fragment.py
----------------------------------------
from firm_f3.core.crud import update_or_create_async
from typing import List, Dict, Optional, Any, Mapping, Union, Tuple, Set
from f3sdk.f3.f3object import F3Object  # type:ignore
from f3sdk.lib.coroutine import wait  # type:ignore

from firm_f3.market_data.mdobject import MDObjectBase


class RequiredMktData:
    data_set: Set[str]

    def __init__(self, data_set: Set[str]):
        self.data_set = data_set


class FragmentBase:
    def __init__(self):
        pass

    def create_static_data(self) -> List[F3Object]:
        raise NotImplementedError()

    def __str__(self):
        return self.fragment_name

    def __eq__(self, other):
        return self.fragment_name == other.fragment_name

    def __lt__(self, other):
        return self.fragment_name < other.fragment_name

    def __hash__(self):
        return hash(self.fragment_name)

    @property
    def fragment_name(self) -> str:
        raise NotImplementedError()

    async def assemble_async(self,
                             base_model: Optional[F3Object],
                             market_data: Optional[Mapping[str, MDObjectBase]]) -> Tuple[F3Object, RequiredMktData]:
        raise NotImplementedError()

    async def assemble_and_update_async(self,
                                        tail: str,
                                        market_data: Dict[str, MDObjectBase]) -> Dict[str, Any]:
        model, _ = await self.assemble_async(None, market_data)
        model_fragment: Dict[str, Any] = await update_model_fragment_async(f"{self.fragment_name}_{tail}", model)
        return model_fragment


def update_model_fragment(fragment_name: str, model: F3Object) -> Dict[str, Any]:
    return wait(update_model_fragment_async(fragment_name, model))


async def update_model_fragment_async(fragment_name: str, model: F3Object) -> Dict[str, Any]:
    f3ml = ''.join(model.form_f3ml())
    return await update_or_create_async(object_type="model_fragment", name=fragment_name, f3ml=f3ml)

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\model_gbp.py
----------------------------------------
from typing import Dict, Optional, List, Mapping, Union, Tuple

from firm_f3.core.modelutils import create_collapsed_compounding_valspec
from f3sdk.f3.f3object import F3Object  # type:ignore

import firm_f3.f3client  # type:ignore
from firm_f3.f3definitions import CurveTag
import firm_domain as domain
from firm_domain import Ccy, Tenor
from firm_f3.mapping import f3instrument_strategy_async, f3instrument_type
from firm_f3.market_data.mdobject import MDObjectBase
from firm_f3.model_fragments.model_fragment import FragmentBase, RequiredMktData

from firm_f3.model_object.util import extend_model_with_one_dimensional_calibrated_curve_async


def tag_discount_gbp_overnightUsd() -> F3Object:
    return firm_f3.f3client.get_platform_client().DiscountCurveTag('GBP', 'OvernightUSD')


def tag_discount_gbp_overnightGbp() -> F3Object:
    return firm_f3.f3client.get_platform_client().DiscountCurveTag('GBP', 'OvernightGBP')


def tag_discount_gbp_liborGbp3m() -> F3Object:
    return firm_f3.f3client.get_platform_client().DiscountCurveTag('GBP', 'LiborGBP3m')


def tag_discount_gbp_liborGbp6m() -> F3Object:
    return firm_f3.f3client.get_platform_client().DiscountCurveTag('GBP', 'LiborGBP6m')


class MultiCurveFragmentGbp(FragmentBase):

    @property
    def fragment_name(self) -> str:
        return "gbp_multi_curve_ModelFragment"

    def create_static_data(self) -> List[F3Object]:
        f3 = firm_f3.f3client.get_platform_client()
        o: List[F3Object] = []
        for discountCurveTag in [tag_discount_gbp_overnightUsd(),
                                 tag_discount_gbp_overnightGbp(),
                                 tag_discount_gbp_liborGbp3m(),
                                 tag_discount_gbp_liborGbp6m()]:
            curvetag: CurveTag = CurveTag.from_discount_curve_tag(discountCurveTag)
            name = curvetag.zspread_convention_name
            zspread_conv = f3.CreateZSpreadConvention(
                UnderlyingCurveTag=curvetag.to_list(),
                CompoundingFrequency='Continuous',
                BaseDateConvention='SettlementDate').named(name)
            o.append(zspread_conv)
        return o

    async def assemble_async(self,
                             base_model: Optional[F3Object],
                             market_data: Optional[Mapping[str, MDObjectBase]]) -> Tuple[F3Object, RequiredMktData]:
        f3 = firm_f3.f3client.get_platform_client()
        model = f3.ExtendModelWithValuationSpecification(base_model or "${-1}", create_collapsed_compounding_valspec())

        all_instruments = []

        ccy = Ccy.GBP
        ois = domain.OIS(ccy, Tenor.T_1Y)
        instruments = [ois]
        all_instruments += instruments
        inst_strategy = await f3instrument_strategy_async(*instruments)
        model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ois.index_rate, inst_strategy)

        deposit = domain.Rate(ccy, Tenor.T_6M)
        instruments = [deposit,
                       domain.FRA(ccy, tenor=deposit.tenor, start=Tenor.T_6M),
                       domain.IRS(ccy, tenor=Tenor.T_1Y, idx=deposit.tenor)]
        all_instruments += instruments
        inst_strategy = await f3instrument_strategy_async(*instruments)
        model = await extend_model_with_one_dimensional_calibrated_curve_async(model, deposit, inst_strategy)

        deposit = domain.Rate(ccy, Tenor.T_3M)
        instruments = [deposit,
                       domain.TenorBasis(ccy, Tenor.T_1Y, deposit.tenor, Tenor.T_6M)]
        all_instruments += instruments
        inst_strategy = await f3instrument_strategy_async(*instruments)
        model = await extend_model_with_one_dimensional_calibrated_curve_async(model, deposit, inst_strategy)

        instruments = [domain.FXForward(ccy, Tenor.T_6M),
                       domain.XccyBasis(ccy, Tenor.T_2Y)]
        all_instruments += instruments
        inst_strategy = await f3instrument_strategy_async(*instruments)
        model = await extend_model_with_one_dimensional_calibrated_curve_async(model, ccy.name, inst_strategy,
                                                                               target_method=f'Default{ccy.name}')

        model = f3.ExtendModelWithClonedCurve(
            BaseModel=model,
            CurveTag=[ccy.name, 'DiscountCurve-CollateralRate-USD O/N:1b'],
            SourceCurveTag=[ccy.name, 'DiscountCurve'],
        )

        return model, RequiredMktData(set(f3instrument_type(*all_instruments)))

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\model_hkd.py
----------------------------------------
import asyncio
from f3sdk.f3 import F3Object  # type:ignore
from firm_domain import IRS, FRA, FXForward, XccyBasis, Rate, TenorBasis
from firm_domain.core import Ccy, Tenor
from firm_f3.mapping import f3instrument_type, f3discount_curve_tag_async, f3instrument_strategy_async, \
    OvernightUSD, f3index
from firm_f3.model_fragments import EXP_SPLINE_INTERP_METHOD
import firm_f3.f3client # type:ignore
from firm_f3.model_object.util import extend_model_with_one_dimensional_calibrated_curve_async

INTERP_METHOD = EXP_SPLINE_INTERP_METHOD

ccy = Ccy.HKD
irs_base = IRS(ccy=ccy, tenor=Tenor.T_1Y)
fra_base = FRA(ccy=ccy, tenor=Tenor.T_3M, start=Tenor.T_6M)

ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
s1s3 = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1M, idx_2=irs_base.idx)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_2Y)
fwd = FXForward(ccy=ccy, tenor=Tenor.T_6M)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
rate_1m = Rate(ccy, Tenor.T_1M)
rate_3m = Rate(ccy, Tenor.T_3M)

assert irs_base_rate == rate_3m


async def extend_with_base_curves(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            irs_tag,
            ois_tag,
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=False,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(irs_base_rate), None, None, *irs_tag],
            [f3instrument_type(fra_base), None, None, *irs_tag],
            [f3instrument_type(irs_base), None, None, *irs_tag],
            [f3instrument_type(ois_basis), None, None, *ois_tag],
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base_rate, fra_base, irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def extend_with_irs_1m_curve(f3model: F3Object, **kwargs):
    return await extend_model_with_one_dimensional_calibrated_curve_async(
        f3model=f3model,
        target=rate_1m,
        inst_strategies=await f3instrument_strategy_async(rate_1m, s1s3),
    )


async def extend_with_xccy_curve(f3model: F3Object, **kwargs):
    return await extend_model_with_one_dimensional_calibrated_curve_async(
        f3model=f3model,
        target=ccy.name,
        inst_strategies=await f3instrument_strategy_async(fwd, xccy),
        target_method=f'Default{ccy.name}'
    )


async def add_usd_collateral_discount_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    extend_with_base_curves,
    add_irs_base_curve,
    add_ois_curve,
    extend_with_irs_1m_curve,
    extend_with_xccy_curve,
    add_usd_collateral_discount_curve,
)


async def assemble_model_fragment_async(f3model: F3Object = '${-1}', **kwargs):
    for func in extensions:
        if asyncio.iscoroutinefunction(func):
            f3model = await func(f3model, **kwargs)
        else:
            f3model = func(f3model, **kwargs)
    return f3model


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\model_huf.py
----------------------------------------
import asyncio
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client # type:ignore
from firm_domain import IRS, FRA, FXForward, XccyBasis, Rate, TenorBasis
from firm_domain.core import Ccy, Tenor
from firm_f3.mapping import f3instrument_type, f3discount_curve_tag_async, f3instrument_strategy_async, \
    OvernightUSD, f3index
from firm_f3.model_fragments import EXP_SPLINE_INTERP_METHOD
from firm_f3.model_object.util import extend_model_with_one_dimensional_calibrated_curve_async

INTERP_METHOD = EXP_SPLINE_INTERP_METHOD

ccy = Ccy.HUF
irs_base = IRS(ccy=ccy, tenor=Tenor.T_1Y)
fra_base = FRA(ccy=ccy, tenor=Tenor.T_6M, start=Tenor.T_6M)
fra_3m = FRA(ccy=ccy, tenor=Tenor.T_3M, start=Tenor.T_6M)

ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
s3s6 = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_3M, idx_2=irs_base.idx)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_2Y)
fwd = FXForward(ccy=ccy, tenor=Tenor.T_6M)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
rate_3m = Rate(ccy, Tenor.T_3M)
rate_6m = Rate(ccy, Tenor.T_6M)

assert irs_base_rate == rate_6m


async def extend_with_base_curves(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            irs_tag,
            ois_tag,
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=False,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(irs_base_rate), None, None, *irs_tag],
            [f3instrument_type(fra_base), None, None, *irs_tag],
            [f3instrument_type(irs_base), None, None, *irs_tag],
            [f3instrument_type(ois_basis), None, None, *ois_tag],
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base_rate, fra_base, irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def extend_with_irs_3m_curve(f3model: F3Object, **kwargs):
    return await extend_model_with_one_dimensional_calibrated_curve_async(
        f3model=f3model,
        target=rate_3m,
        inst_strategies=await f3instrument_strategy_async(rate_3m, fra_3m, s3s6),
    )


async def extend_with_xccy_curve(f3model: F3Object, **kwargs):
    return await extend_model_with_one_dimensional_calibrated_curve_async(
        f3model=f3model,
        target=ccy.name,
        inst_strategies=await f3instrument_strategy_async(fwd, xccy),
    )


async def add_usd_collateral_discount_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    extend_with_base_curves,
    add_irs_base_curve,
    add_ois_curve,
    extend_with_irs_3m_curve,
    extend_with_xccy_curve,
    add_usd_collateral_discount_curve,
)


async def assemble_model_fragment_async(f3model: F3Object = '${-1}', **kwargs):
    for func in extensions:
        if asyncio.iscoroutinefunction(func):
            f3model = await func(f3model, **kwargs)
        else:
            f3model = func(f3model, **kwargs)
    return f3model


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\model_ils.py
----------------------------------------
import asyncio
from firm_domain.core import Ccy, Tenor
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client # type:ignore
from firm_domain import IRS, FRA, FXForward, XccyBasis, Rate, TenorBasis
from firm_f3.mapping import f3instrument_type, f3discount_curve_tag_async, f3instrument_strategy_async, \
    OvernightUSD, f3index
from firm_f3.model_fragments import EXP_SPLINE_INTERP_METHOD
from firm_f3.model_object.util import extend_model_with_one_dimensional_calibrated_curve_async

INTERP_METHOD = EXP_SPLINE_INTERP_METHOD

ccy = Ccy.ILS
irs_base = IRS(ccy=ccy, tenor=Tenor.T_1Y)
fra_base = FRA(ccy=ccy, tenor=Tenor.T_3M, start=Tenor.T_6M)

ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_2Y)
fwd = FXForward(ccy=ccy, tenor=Tenor.T_6M)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
rate_3m = Rate(ccy, Tenor.T_3M)

assert irs_base_rate == rate_3m


async def extend_with_base_curves(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            irs_tag,
            ois_tag,
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=False,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(irs_base_rate), None, None, *irs_tag],
            [f3instrument_type(fra_base), None, None, *irs_tag],
            [f3instrument_type(irs_base), None, None, *irs_tag],
            [f3instrument_type(ois_basis), None, None, *ois_tag],
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base_rate, fra_base, irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def extend_with_xccy_curve(f3model: F3Object, **kwargs):
    return await extend_model_with_one_dimensional_calibrated_curve_async(
        f3model=f3model,
        target=ccy.name,
        inst_strategies=await f3instrument_strategy_async(fwd, xccy),
    )


async def add_usd_collateral_discount_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    extend_with_base_curves,
    add_irs_base_curve,
    add_ois_curve,
    extend_with_xccy_curve,
    add_usd_collateral_discount_curve,
)


async def assemble_model_fragment_async(f3model: F3Object = '${-1}', **kwargs):
    for func in extensions:
        if asyncio.iscoroutinefunction(func):
            f3model = await func(f3model, **kwargs)
        else:
            f3model = func(f3model, **kwargs)
    return f3model


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\model_pln.py
----------------------------------------
import asyncio
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client # type:ignore
from firm_domain.core import Ccy, Tenor
from firm_domain import IRS, FRA, FXForward, XccyBasis, Rate, TenorBasis
from firm_f3.mapping import f3instrument_type, f3discount_curve_tag_async, f3instrument_strategy_async, \
    OvernightUSD, f3index
from firm_f3.model_fragments import EXP_SPLINE_INTERP_METHOD
from firm_f3.model_object.util import extend_model_with_one_dimensional_calibrated_curve_async

INTERP_METHOD = EXP_SPLINE_INTERP_METHOD

ccy = Ccy.PLN
irs_base = IRS(ccy=ccy, tenor=Tenor.T_1Y)
fra_base = FRA(ccy=ccy, tenor=Tenor.T_6M, start=Tenor.T_6M)
fra_3m = FRA(ccy=ccy, tenor=Tenor.T_3M, start=Tenor.T_6M)

ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
s3s6 = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_3M, idx_2=irs_base.idx)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_2Y)
fwd = FXForward(ccy=ccy, tenor=Tenor.T_6M)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
rate_3m = Rate(ccy, Tenor.T_3M)
rate_6m = Rate(ccy, Tenor.T_6M)

assert irs_base_rate == rate_6m


async def extend_with_base_curves(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            irs_tag,
            ois_tag,
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=False,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(irs_base_rate), None, None, *irs_tag],
            [f3instrument_type(fra_base), None, None, *irs_tag],
            [f3instrument_type(irs_base), None, None, *irs_tag],
            [f3instrument_type(ois_basis), None, None, *ois_tag],
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base_rate, fra_base, irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def extend_with_irs_3m_curve(f3model: F3Object, **kwargs):
    return await extend_model_with_one_dimensional_calibrated_curve_async(
        f3model=f3model,
        target=rate_3m,
        inst_strategies=await f3instrument_strategy_async(rate_3m, fra_3m, s3s6),
    )


async def extend_with_xccy_curve(f3model: F3Object, **kwargs):
    return await extend_model_with_one_dimensional_calibrated_curve_async(
        f3model=f3model,
        target=ccy.name,
        inst_strategies=await f3instrument_strategy_async(fwd, xccy),
    )


async def add_usd_collateral_discount_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    extend_with_base_curves,
    add_irs_base_curve,
    add_ois_curve,
    extend_with_irs_3m_curve,
    extend_with_xccy_curve,
    add_usd_collateral_discount_curve,
)


async def assemble_model_fragment_async(f3model: F3Object = '${-1}', **kwargs):
    for func in extensions:
        if asyncio.iscoroutinefunction(func):
            f3model = await func(f3model, **kwargs)
        else:
            f3model = func(f3model, **kwargs)
    return f3model


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\model_sar.py
----------------------------------------
import asyncio
from firm_domain.core import Tenor, Ccy
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client # type:ignore
from firm_domain import IRS, FRA, FXForward, XccyBasis, Rate, TenorBasis
from firm_f3.mapping import f3instrument_type, f3discount_curve_tag_async, f3instrument_strategy_async, \
    OvernightUSD, f3index
from firm_f3.model_fragments import EXP_SPLINE_INTERP_METHOD
from firm_f3.model_object.util import extend_model_with_one_dimensional_calibrated_curve_async

INTERP_METHOD = EXP_SPLINE_INTERP_METHOD

ccy = Ccy.SAR
irs_base = IRS(ccy=ccy, tenor=Tenor.T_1Y)
fra_base = FRA(ccy=ccy, tenor=Tenor.T_3M, start=Tenor.T_6M)

ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_2Y)
fwd = FXForward(ccy=ccy, tenor=Tenor.T_6M)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
rate_3m = Rate(ccy, Tenor.T_3M)

assert irs_base_rate == rate_3m


async def extend_with_base_curves(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            irs_tag,
            ois_tag,
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=False,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(irs_base_rate), None, None, *irs_tag],
            [f3instrument_type(fra_base), None, None, *irs_tag],
            [f3instrument_type(irs_base), None, None, *irs_tag],
            [f3instrument_type(ois_basis), None, None, *ois_tag],
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base_rate, fra_base, irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def extend_with_xccy_curve(f3model: F3Object, **kwargs):
    return await extend_model_with_one_dimensional_calibrated_curve_async(
        f3model=f3model,
        target=ccy.name,
        inst_strategies=await f3instrument_strategy_async(fwd, xccy),
        target_method=f'Default{ccy.name}'
    )


async def add_usd_collateral_discount_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    extend_with_base_curves,
    add_irs_base_curve,
    add_ois_curve,
    extend_with_xccy_curve,
    add_usd_collateral_discount_curve,
)


async def assemble_model_fragment_async(f3model: F3Object = '${-1}', **kwargs):
    for func in extensions:
        if asyncio.iscoroutinefunction(func):
            f3model = await func(f3model, **kwargs)
        else:
            f3model = func(f3model, **kwargs)
    return f3model


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\model_securities.py
----------------------------------------
import asyncio
from firm_domain.core import Tenor, Ccy
from firm_domain import Security
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore
from firm_f3.mapping import f3_security_entity
from firm_f3.evaluate import f3_asset_curve_tag_async


funding_curve_tag = ['Security', 'FundingCurve']


def extend_with_security_funding_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWith1dFunctionCurve(BaseModel=f3model,
                                             CurveTag=funding_curve_tag,
                                             OneDimensionalFunction=1)


async def extend_with_asset_price_curves(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()

    for sec in Security:
        asset_curve_tag = await f3_asset_curve_tag_async(sec)
        f3model = f3.ExtendModelWithAssetPriceCurve(
            BaseModel=f3model,
            CurveTag=asset_curve_tag,
            AssetMarketDataTag=f3_security_entity(sec),
            FundingCurveTag=funding_curve_tag)

    return f3model

extensions = (
    extend_with_security_funding_curve,
    extend_with_asset_price_curves
)


async def assemble_model_fragment_async(f3model: F3Object = '${-1}', **kwargs):
    for func in extensions:
        if asyncio.iscoroutinefunction(func):
            f3model = await func(f3model, **kwargs)
        else:
            f3model = func(f3model, **kwargs)
    return f3model


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\model_sgd.py
----------------------------------------
import asyncio
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client # type:ignore
from firm_domain.core import Ccy, Tenor
from firm_domain import IRS, FXForward, XccyBasis, Rate, TenorBasis
from firm_f3.mapping import f3instrument_type, f3discount_curve_tag_async, f3instrument_strategy_async, \
    OvernightUSD, f3index
from firm_f3.model_fragments import EXP_SPLINE_INTERP_METHOD
from firm_f3.model_object.util import extend_model_with_one_dimensional_calibrated_curve_async

INTERP_METHOD = EXP_SPLINE_INTERP_METHOD

ccy = Ccy.SGD
irs_base = IRS(ccy=ccy, tenor=Tenor.T_1Y)
irs_3m = IRS(ccy=ccy, tenor=Tenor.T_1Y, idx=Tenor.T_3M)

ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
s3s6 = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_3M, idx_2=irs_base.idx)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_2Y)
fwd = FXForward(ccy=ccy, tenor=Tenor.T_6M)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
rate_3m = Rate(ccy, Tenor.T_3M)
rate_6m = Rate(ccy, Tenor.T_6M)

assert irs_base_rate == rate_6m


async def extend_with_base_curves(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            irs_tag,
            ois_tag,
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=False,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(irs_base_rate), None, None, *irs_tag],
            [f3instrument_type(irs_base), None, None, *irs_tag],
            [f3instrument_type(ois_basis), None, None, *ois_tag],
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base_rate, irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def extend_with_irs_3m_curve(f3model: F3Object, **kwargs):
    return await extend_model_with_one_dimensional_calibrated_curve_async(
        f3model=f3model,
        target=rate_3m,
        inst_strategies=await f3instrument_strategy_async(rate_3m, irs_3m, s3s6),
    )


async def extend_with_xccy_curve(f3model: F3Object, **kwargs):
    return await extend_model_with_one_dimensional_calibrated_curve_async(
        f3model=f3model,
        target=ccy.name,
        inst_strategies=await f3instrument_strategy_async(fwd, xccy),
        target_method=f'Default{ccy.name}'
    )


async def add_usd_collateral_discount_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    extend_with_base_curves,
    add_irs_base_curve,
    add_ois_curve,
    extend_with_irs_3m_curve,
    extend_with_xccy_curve,
    add_usd_collateral_discount_curve,
)


async def assemble_model_fragment_async(f3model: F3Object = '${-1}', **kwargs):
    for func in extensions:
        if asyncio.iscoroutinefunction(func):
            f3model = await func(f3model, **kwargs)
        else:
            f3model = func(f3model, **kwargs)
    return f3model


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\model_step_curve.py
----------------------------------------
from typing import Dict, Any, Optional

from firm_domain.market_date import MarketDate
from f3sdk.f3.f3object import F3Object

import firm_f3.f3client
from firm_f3.datalayer import get_market_data_snapshot_async, MarketDataProvider, MarketDataProviderBpipe
from firm_f3.evaluate.core import af3v
from firm_f3.evaluate.handlers import scalar_handler
from firm_f3.market_data.marketdata import get_curve_mkt_data_async
from firm_f3.model_fragments.model_fragment import FragmentBase


class StepCurveFragment(FragmentBase):

    async def assemble_async(self, base_model: Optional[F3Object],
                             market_data: Optional[Dict[str, Any]]) -> F3Object:
        f3 = firm_f3.f3client.get_platform_client()
        # Reference data
        f3_2dlog_function = f3.Create2dFunctions(
            Expressions='f(t,y)=log(y)',
            TargetFunctions=['f', 'TwoDLog']
        )
        f3_exp_tension_spline_interp_method_flat = f3.CreateExponentialTensionSplineInterpolationMethod(
            TensionFunction=1,
            ExponentialExtrapolationSettings='Flat'
        )
        f3_tension_spline_1 = f3.CreateFunctionMappingInterpolationMethod(
            Function=f3_2dlog_function,
            InverseFunction='Exponential',
            UnderlyingInterpolationMethod=f3_exp_tension_spline_interp_method_flat
        )
        f3_nr_optimizer = f3.CreateNewtonRaphsonRootSearchOptimizer(
            Tolerance=.00001,
            MaxIterations=25,
            Bisection=True,
            CollectDiagnostics=True
        )

        # Initial model
        f3_model = f3.ExtendModelWithValuationSpecification(
            SourceModel=base_model,
            ValuationMethod="CollapsedCompounding"
        )

        # Fixings
        f3_fixings = f3.CreateIndexFixingsMarketData(market_data['fixings'], 'OvernightUSD')
        f3_market_data_sets = f3.CombineMarketDataSets(InputMarketDataSets=[f3_fixings])
        f3_model = f3.ExtendModelWithFixingsCurve(
            BaseModel=f3_model,
            # f3.FixingsCurveTag('OvernightUSD') ['USD O/N:1b', 'Fixings']
            CurveTag=f3.FixingsCurveTag('OvernightUSD'),
            FixingsMarketDataTag='OvernightUSD'
        )

        # USD 0 - 1y
        meeting_times = await af3v(
            [f3.ModelTime(Model=f3_model, Date=x) for x in market_data['meeting_dates'][:13]],
            callback=scalar_handler
        )

        ## instrument types
        f3_usd_ois_meeting_times_inst_type = f3.CreateParameterInstrumentType(
            ParameterName='USDOIS',
            ParameterType='MeetingTimes'
        )
        f3_usd_ois_turn_smoothing_inst_type = f3.CreateParameterInstrumentType(
            ParameterName='USDOIS',
            ParameterType='TurnSmoothing'
        )
        f3_overnight_usd_short_end_turn_pressure_inst_type = f3.CreateDateValueInstrumentType(
            MarketConventions='OvernightUSD',
            DateValueName='OvernightUSDShortEnd',
            DateValueType='TurnPressure'
        )

        ## market data
        f3_usd_ois_meeting_times = f3.CreateLabelledValuesMarketData(
            InstrumentType=f3_usd_ois_meeting_times_inst_type,
            Values=meeting_times
        )
        f3_usd_ois_turn_smoothing = f3.CreateLabelledValuesMarketData(
            InstrumentType=f3_usd_ois_turn_smoothing_inst_type,
            Values=10000
        )
        f3_overnight_usd_short_end_turn_pressure = f3.CreateCurveMarketData(
            InstrumentType=f3_overnight_usd_short_end_turn_pressure_inst_type,
            Maturities=market_data['turn_pressure']['turn_dates'],
            Quotes=market_data['turn_pressure']['turn_quotes'],
        )
        f3_usd_futures_fed_funds = f3.CreateCurveMarketData(
            InstrumentType='USD-Futures-FedFunds',
            Maturities=market_data['usd_fed_funds_futures']['maturities'],
            Quotes=market_data['usd_fed_funds_futures']['quotes']
        )
        f3_usd_ois = f3.CreateCurveMarketData(
            InstrumentType='USD-OIS',
            Maturities=market_data['usd_ois']['maturities'],
            Quotes=market_data['usd_ois']['quotes']
        )
        f3_market_data_sets = f3.CombineMarketDataSets([
            f3_market_data_sets,
            f3_usd_ois_meeting_times,
            f3_usd_ois_turn_smoothing,
            f3_overnight_usd_short_end_turn_pressure,
            f3_usd_futures_fed_funds,
            f3_usd_ois
        ])

        ## modelling
        market_data['strategy_0y_1y'].insert(0, ["InstrumentType", "Maturity", "UseQuote"])
        f3_instrument_strategy_0y_1y = f3.CreateInstrumentStrategy(market_data['strategy_0y_1y'])
        f3_zero_dimensional_calibration_target = f3.CreateZeroDimensionalCalibrationTarget(
            CurveTag=['USDOIS', 'YValues'],
            InitialValues=[1] * len(market_data['meeting_dates']),
            FixedIndices=1,
            OptimizationObjective='SingleCurrencyValue',
            UseHints=True
        )
        f3_tag_replacement_discount_short_end = f3.CreateCurveTagReplacementValuationSpecificationBuilder(
            SourceCurveTag=f3.DiscountCurveTag(Currency='USD', CollateralAgreement='OvernightUSD'),
            ReplacementCurveTag=['USD', 'DiscountShortEnd']
        )
        f3_tag_replacement_projected_short_end = f3.CreateCurveTagReplacementValuationSpecificationBuilder(
            SourceCurveTag=f3.InterestRateCurveTag('OvernightUSD'),
            ReplacementCurveTag=['USD', 'ProjectedShortEnd']
        )
        f3_composite_specification = f3.CreateCompositeValuationSpecificationBuilder(
            CalculationStrategies=[f3_tag_replacement_discount_short_end, f3_tag_replacement_projected_short_end]
        )

        f3_model = f3.ExtendModelWithZeroDimensionalCurve(
            BaseModel=f3_model,
            CurveTag=['USDOIS', 'MeetingTimes'],
            MarketDataTag=f3_usd_ois_meeting_times_inst_type
        )
        f3_model = f3.ExtendModelWithCalibratedCurves(
            BaseModel=f3_model,
            CalibrationTarget=f3_zero_dimensional_calibration_target,
            InstrumentStrategy=f3_instrument_strategy_0y_1y,
            Optimizer='DefaultLeastSquares',
            SourceMethod='Par',
            TargetMethod=f3_composite_specification
        )
        f3_model = f3.ExtendModelWithInterpolatedParametersCurve(
            BaseModel=f3_model,
            CurveTag=['USD', 'DiscountShortEnd'],
            XParameters=['USDOIS', 'MeetingTimes'],
            YParameters=['USDOIS', 'YValues'],
            InterpolationMethod='LogLinear'
        )
        f3_model = f3.ExtendModelWithTurnPressureDiscountCurve(
            BaseModel=f3_model,
            CurveTag=['USD', 'DiscountShortEnd-WithTurn'],
            UnderlyingCurveTag=['USD', 'DiscountShortEnd'],
            TurnPressureMarketDataTag=f3_overnight_usd_short_end_turn_pressure_inst_type,
            SmoothingParameterTag=f3_usd_ois_turn_smoothing_inst_type
        )
        f3_model = f3.ExtendModelWithSimpleConvexityAdjustmentCurve(
            BaseModel=f3_model,
            CurveTag=f3.ConvexityAdjustmentCurveTag('USD-Futures-FedFunds'),
            ConvexityFunction='NoConvexityAdjustment'
        )
        f3_model = f3.ExtendModelWithImpliedRateCurve(
            BaseModel=f3_model,
            CurveTag=['USD', 'ProjectedShortEnd'],
            UnderlyingCurveTag=['USD', 'DiscountShortEnd-WithTurn'],
            RateMarketConventions='OvernightUSD'
        )

        # USD 1y - 2y

        ## market data
        f3_overnight_usd_transition_point_md = f3.CreateParameterMarketData(
            Values=1,
            ParameterName='USDOIS',
            ParameterType='TransitionPoint'
        )
        f3_overnight_usd_transition_smoothing_md = f3.CreateParameterMarketData(
            Values=10000,
            ParameterName='USDOIS',
            ParameterType='TransitionSmoothing'
        )
        f3_market_data_sets = f3.CombineMarketDataSets([
            f3_market_data_sets,
            f3_overnight_usd_transition_point_md,
            f3_overnight_usd_transition_smoothing_md
        ])

        f3_tag_replacement_discounted_long_end = f3.CreateCurveTagReplacementValuationSpecificationBuilder(
            SourceCurveTag=['USD', 'DiscountCurve-CollateralRate-USD O/N:1b'],
            ReplacementCurveTag=['USD', 'DiscountCurve-CollateralRate-USD O/N:1b-LongEnd']
        )

        f3_tag_replacement_projected_long_end = f3.CreateCurveTagReplacementValuationSpecificationBuilder(
            SourceCurveTag=['USD O/N:1b', 'OvernightRateCurve'],
            ReplacementCurveTag=['USD', 'Overnight-CollateralRate-USD O/N:1b-LongEnd']
        )
        f3_composite_specification_long_end = f3.CreateCompositeValuationSpecificationBuilder(
            CalculationStrategies=[f3_tag_replacement_discounted_long_end, f3_tag_replacement_projected_long_end]
        )

        f3_model = f3.ExtendModelWithImpliedRateCurve(
            BaseModel=f3_model,
            CurveTag=['USD', 'Overnight-CollateralRate-USD O/N:1b-LongEnd'],
            UnderlyingCurveTag=['USD', 'DiscountCurve-CollateralRate-USD O/N:1b-LongEnd'],
            RateMarketConventions='OvernightUSD'
        )

        ## modelling
        f3_one_dimensional_entire_curve_calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
            CurveTags=['USD', 'DiscountCurve-CollateralRate-USD O/N:1b-LongEnd'],
            InterpolationTypes=f3_tension_spline_1,
            InitialValueCurves=['USD', 'DiscountShortEnd-WithTurn'],
            BoundConstraints='GreaterThanZero',
            OptimizationObjective='SingleCurrencyValue',
            UseHints=True,
            TimePointMethod='DropIfNotIncreasing'
        )

        market_data['strategy_1y_2y'].insert(0, ["InstrumentType", "Maturity", "UseQuote"])
        f3_instrument_strategy_1y_2y = f3.CreateInstrumentStrategy(market_data['strategy_1y_2y'])
        f3_model = f3.ExtendModelWithCalibratedCurves(
            BaseModel=f3_model,
            CalibrationTarget=f3_one_dimensional_entire_curve_calibration_target,
            InstrumentStrategy=f3_instrument_strategy_1y_2y,
            Optimizer=f3_nr_optimizer,
            SourceMethod='ValueToPar',
            TargetMethod=f3_composite_specification_long_end
        )

        f3_model = f3.ExtendModelWithImpliedRateCurve(
            BaseModel=f3_model,
            CurveTag=['USD', 'OvernightRateCurve-Concatenated'],
            UnderlyingCurveTag=['USD', 'DiscountCurveShortEnd-Concatenated'],
            RateMarketConventions='OvernightUSD'
        )

        f3_model = f3.ExtendModelWithLastRelevantPointCurve(
            BaseModel=f3_model,
            CurveTag=['USDDiscountShortEnd-WithTurn', 'LastPoint'],
            UnderlyingCurveTag=['USD', 'DiscountShortEnd-WithTurn']
        )
        f3_model = f3.ExtendModelWithZeroDimensionalCurve(
            BaseModel=f3_model,
            CurveTag=['USDOIS', 'TransitionSmoothing'],
            MarketDataTag=['USDOIS', 'TransitionSmoothing']
        )
        f3_model = f3.ExtendModelWithZeroDimensionalCurve(
            BaseModel=f3_model,
            CurveTag=['USDOIS', 'TransitionPoint'],
            MarketDataTag=['USDOIS', 'TransitionPoint']
        )
        f3_model = f3.ExtendModelWithConcatenationCurve(
            BaseModel=f3_model,
            CurveTag=['USD', 'DiscountCurveShortEnd-Concatenated'],
            FirstCurveTag=['USD', 'DiscountShortEnd-WithTurn'],
            SecondCurveTag=['USD', 'DiscountCurve-CollateralRate-USD O/N:1b-LongEnd'],
            TransitionPointCurveTag=['USDOIS', 'TransitionPoint'],
            SmoothingParameter=['USDOIS', 'TransitionSmoothing']
        )

        # t0, t1 = 1, 1
        # weight_func = f'(max(0,min(1,(t-{t0})/({t1}-{t0}))))'
        #
        # f3_model = f3.ExtendModelWithParameterizedCurves(BaseModel=f3_model,
        #                                                  Expressions=[
        #                                                      f'y(t)=(1-{weight_func})*y0(t)+({weight_func})*y1(t)'],
        #                                                  TargetCurves=['y',
        #                                                                *['USD', 'DiscountCurveShortEnd-Concatenated']],
        #                                                  Parameters=None,
        #                                                  Functions=[
        #                                                      ['y0', *['USD', 'DiscountShortEnd-WithTurn']],
        #                                                      ['y1', *['USD',
        #                                                               'DiscountCurve-CollateralRate-USD O/N:1b-LongEnd']]
        #                                                  ])

        model_with_market_data = f3.ExtendModelWithMarketData(
            BaseModel=f3_model,
            MarketData=f3_market_data_sets
        )

        def filter_function(sth: str):
            return True

        await get_curve_mkt_data_async(MarketDate(), MarketDataProviderBpipe('prd'), filter_function, filter_function)

        return model_with_market_data


# TODO use get_curve_mkt_data_async in marketdata.py
async def get_usd_ois_market_data_async(eval_date: MarketDate, data_provider: MarketDataProvider) -> Dict[str, Any]:
    mat_to_ticker = {
        "1w": "USSO1Z Curncy",
        "2w": "USSO2Z Curncy",
        "3w": "USSO3Z Curncy",
        "1m": "USSOA Curncy",
        "2m": "USSOB Curncy",
        "3m": "USSOC Curncy",
        "4m": "USSOD Curncy",
        "5m": "USSOE Curncy",
        "6m": "USSOF Curncy",
        "7m": "USSOG Curncy",
        "8m": "USSOH Curncy",
        "9m": "USSOI Curncy",
        "10m": "USSOJ Curncy",
        "11m": "USSOK Curncy",
        "1y": "USSO1 Curncy",
        "15m": "USSO1C Curncy",
        "18m": "USSO1F Curncy",
        "21m": "USSO1I Curncy",
        "2y": "USSO2 Curncy"
    }

    data = await get_market_data_snapshot_async(list(mat_to_ticker.values()), eval_date, data_provider, 'LAST_PRICE')
    quotes = [data[ticker] * 0.01 for ticker in list(mat_to_ticker.values())]

    return {'maturities': list(mat_to_ticker.keys()), 'quotes': quotes, 'tickers': list(mat_to_ticker.values())}

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\model_step_curve_new.py
----------------------------------------
from typing import Dict, Any, Optional

from firm_domain.market_date import MarketDate
from f3sdk.f3.f3object import F3Object
from f3sdk.f3.platform import F3

import firm_f3.f3client
from firm_f3.datalayer import get_market_data_snapshot_async, MarketDataProvider
from firm_f3.model_fragments.model_fragment import FragmentBase


class NewStepCurveFragment(FragmentBase):

    async def assemble_async(self, base_model: Optional[F3Object],
                             market_data: Optional[Dict[str, Any]]) -> F3Object:
        f3: F3 = firm_f3.f3client.get_platform_client()

        # Market Data
        hull_white_mean_reversion = f3.CreateLabelledValuesMarketData(
            InstrumentType='LiborUSD3m-HullWhiteMeanReversion',
            Values=0.03
        )

        hull_white_volatility = f3.CreateCurveMarketData(
            InstrumentType='LiborUSD3m-HullWhiteVolatility',
            Maturities='1y',
            Quotes=0.0097
        )

        f3_market_data_set = f3.CombineMarketDataSets(
            InputMarketDataSets=[hull_white_mean_reversion, hull_white_volatility]
        )

        f3_usd_meeting_date_inst_type = f3.CreateMeetingDateTargetRateInstrumentType(Currency='USD')

        f3_turn_pressure_inst_type = f3.CreateTurnPressureInstrumentType(
            RateIndex='OvernightUSD'
        )

        f3_turn_pressure = f3.CreateCurveMarketData(
            InstrumentType=f3_turn_pressure_inst_type,
            Maturities=market_data['turn_pressure']['turn_dates'],
            Quotes=market_data['turn_pressure']['turn_quotes'],
        )

        f3_meeting_date_market_data = f3.CreateCurveMarketData(
            InstrumentType=f3_usd_meeting_date_inst_type,
            Maturities=market_data['meeting_dates'],
            Quotes=['n/a' for _ in market_data['meeting_dates']]
        )

        f3_ois_market_data = f3.CreateCurveMarketData(
            InstrumentType='USD-OIS',
            Maturities=market_data['ois']['maturities'],
            Quotes=market_data['ois']['quotes']
        )

        f3_basis_swap_market_data = f3.CreateCurveMarketData(
            InstrumentType='USD-BasisSwap-OIS-Libor-3m',
            Maturities=market_data['basis']['maturities'],
            Quotes=market_data['basis']['quotes']
        )

        f3_fra_market_data = f3.CreateCurveMarketData(
            InstrumentType='USD-FRA-Libor-3m',
            Maturities=market_data['fra']['maturities'],
            Quotes=market_data['fra']['quotes']
        )

        f3_irs_market_data = f3.CreateCurveMarketData(
            InstrumentType='USD-IRS-Semi-Libor-3m',
            Maturities=market_data['irs']['maturities'],
            Quotes=market_data['irs']['quotes']
        )

        f3_future_market_data = f3.CreateCurveMarketData(
            InstrumentType='USD-Futures-Libor-3m',
            Maturities=market_data['futures']['maturities'],
            Quotes=market_data['futures']['quotes']
        )

        f3_fff_market_data = f3.CreateCurveMarketData(
            InstrumentType='USD-Futures-FedFunds',
            Maturities=market_data['fff']['maturities'],
            Quotes=market_data['fff']['quotes']
        )

        f3_fixings_market_data = f3.CreateIndexFixingsMarketData(
            Fixings=market_data['fixings'],
            FixingsIndex='OvernightUSD'
        )

        f3_market_data_set = f3.CombineMarketDataSets(
            InputMarketDataSets=[
                f3_market_data_set,
                f3_meeting_date_market_data,
                f3_ois_market_data,
                f3_basis_swap_market_data,
                f3_fra_market_data,
                f3_irs_market_data,
                f3_turn_pressure,
                f3_future_market_data,
                f3_fff_market_data,
                f3_fixings_market_data
            ]
        )

        # Strategy
        market_data['strategy'].insert(0, ['InstrumentType', 'Maturity', 'UseQuote'])
        f3_instrument_strategy = f3.CreateInstrumentStrategy(InstrumentStrategy=market_data['strategy'])

        # Modelling
        model = f3.ExtendModelWithInterpolationCurve(
            BaseModel=base_model,
            CurveTag=['USD', 'HWFuturesVolCurve'],
            MarketDataTag=['LiborUSD3m', 'HullWhiteVolatility'],
            InterpolationMethod='Linear'
        )
        model = f3.ExtendModelWithZeroDimensionalCurve(
            BaseModel=model,
            CurveTag=['USD', 'HWFuturesMeanRevCurve'],
            MarketDataTag=['LiborUSD3m', 'HullWhiteMeanReversion']
        )
        model = f3.ExtendModelWithSingleFactorHullWhiteConvexityAdjustmentCurve(
            BaseModel=model,
            CurveTag=f3.ConvexityAdjustmentCurveTag(ConvexityCurveIdentifier='LiborUSD3m'),
            Index='LiborUSD3m',
            CompoundingFrequency='Continuous',
            VolatilityCurveTag=['USD', 'HWFuturesVolCurve'],
            MeanReversionCurveTag=['USD', 'HWFuturesMeanRevCurve']
        )
        model = f3.ExtendModelWithSimpleConvexityAdjustmentCurve(
            BaseModel=model,
            CurveTag=f3.ConvexityAdjustmentCurveTag(ConvexityCurveIdentifier='USD-Futures-FedFunds'),
            ConvexityFunction='NoConvexityAdjustment'
        )

        f3_instrument_type_target_curve_map = [
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag'],

            ['USD-BasisSwap-OIS-Libor-3m', None, None, 'USD', 'DiscountCurve-CollateralRate-USD O/N:1b'],
            ['USD-Futures-FedFunds', None, None, 'USD', 'DiscountCurve-CollateralRate-USD O/N:1b'],
            ['USD-OIS', None, None, 'USD', 'DiscountCurve-CollateralRate-USD O/N:1b'],

            ['USD-Futures-Libor-3m', None, None, 'USD LIBOR:3m', 'SpreadDiscountCurve'],
            ['USD-FRA-Libor-3m', None, None, 'USD LIBOR:3m', 'SpreadDiscountCurve'],
            ['USD-IRS-Semi-Libor-3m', None, None, 'USD LIBOR:3m', 'SpreadDiscountCurve']
        ]

        f3_meeting_dates_calibration = f3.CreateMeetingDatesDiscountCurveCalibrationTarget(
            TargetCurves=f3.DiscountCurveTag('USD', 'OvernightUSD'),
            InitialValueCurves=[1, 'Anchored'],
            BoundConstraints='GreaterThanZero',
            MeetingDatesTag=f3_usd_meeting_date_inst_type,
            TurnPressureTag=f3_turn_pressure_inst_type,
            ExtraTargetCurves=['USD LIBOR:3m', 'SpreadDiscountCurve'],
            ExtraInterpolationTypes='MonotoneConvexExponentialDecay',
            ExtraInitialValueCurves=[1, 'Anchored'],
            ExtraBoundConstraints='GreaterThanZero',
            InstrumentTypeTargetCurveMap=f3_instrument_type_target_curve_map,
            AdvancedConfiguration=['UseHints', True]
        )

        f3_curve_replacement = f3.CreateCurveTagReplacementValuationSpecificationBuilder(
            SourceCurveTag=f3.DiscountCurveTag('USD'),
            ReplacementCurveTag=f3.DiscountCurveTag('USD', 'OvernightUSD')
        )

        model = f3.ExtendModelWithCalibratedCurves(
            BaseModel=model,
            CalibrationTarget=f3_meeting_dates_calibration,
            InstrumentStrategy=f3_instrument_strategy,
            Optimizer='NewtonRaphson',
            SourceMethod='Par',
            TargetMethod=f3_curve_replacement
        )

        model = f3.ExtendModelWithImpliedRateCurve(
            BaseModel=model,
            CurveTag=f3.InterestRateCurveTag('OvernightUSD'),
            UnderlyingCurveTag=f3.DiscountCurveTag('USD', 'OvernightUSD'),
            RateMarketConventions='OvernightUSD'
        )

        model = f3.ExtendModelWithImpliedRateCurve(
            BaseModel=model,
            CurveTag=['USD LIBOR:3m', 'SpreadRateCurve'],
            UnderlyingCurveTag=['USD LIBOR:3m', 'SpreadDiscountCurve'],
            RateMarketConventions='LiborUSD3m'
        )

        model = f3.ExtendModelWithImpliedRateCurve(
            BaseModel=model,
            CurveTag=['USD LIBOR:3m', 'LiborRateCurve'],
            UnderlyingCurveTag=['USD', 'DiscountCurve-CollateralRate-USD LIBOR:3m'],
            RateMarketConventions='LiborUSD3m'
        )

        model = f3.ExtendModelWithParameterizedCurves(
            BaseModel=model,
            Expressions=[f'Libor3mDiscount(t) = Libor3mSpreadOverOISDiscount(t) * OISDiscount(t)'],
            TargetCurves=['Libor3mDiscount', 'USD', 'DiscountCurve-CollateralRate-USD LIBOR:3m'],
            Functions=[
                ['Libor3mSpreadOverOISDiscount', 'USD LIBOR:3m', 'SpreadDiscountCurve'],
                ['OISDiscount', 'USD', 'DiscountCurve-CollateralRate-USD O/N:1b']
            ]
        )

        model = f3.ExtendModelWithFixingsCurve(
            BaseModel=model,
            CurveTag=f3.FixingsCurveTag("OvernightUSD"),
            FixingsMarketDataTag='OvernightUSD'
        )

        model_with_market_data = f3.ExtendModelWithMarketData(
            BaseModel=model,
            MarketData=f3_market_data_set
        )

        return model_with_market_data

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\model_try.py
----------------------------------------
import asyncio
from firm_domain.core import Tenor, Ccy
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client # type:ignore
from firm_domain import FXForward, CrossCurrencySwap
from firm_f3.mapping import f3discount_curve_tag_async, f3instrument_strategy_async, \
    OvernightUSD
from firm_f3.model_object.util import extend_model_with_one_dimensional_calibrated_curve_async

ccy = Ccy.TRY

fwd = FXForward(ccy=ccy, tenor=Tenor.T_6M)
ccs = CrossCurrencySwap(ccy=ccy, tenor=Tenor.T_2Y)


async def extend_with_ccs_curve(f3model: F3Object, **kwargs):
    return await extend_model_with_one_dimensional_calibrated_curve_async(
        f3model=f3model,
        target=ccy.name,
        inst_strategies=await f3instrument_strategy_async(fwd, ccs)
    )


async def add_usd_collateral_discount_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    extend_with_ccs_curve,
    add_usd_collateral_discount_curve,
)


async def assemble_model_fragment_async(f3model: F3Object = '${-1}', **kwargs):
    for func in extensions:
        if asyncio.iscoroutinefunction(func):
            f3model = await func(f3model, **kwargs)
        else:
            f3model = func(f3model, **kwargs)
    return f3model


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\model_usd.py
----------------------------------------
from typing import Dict, Optional, List, Mapping, Union, Tuple

from firm_f3.core.modelutils import create_collapsed_compounding_valspec
from firm_f3.market_data.marketdata import fx_spot_market_data_key
from f3sdk.f3.f3object import F3Object  # type:ignore

import firm_f3.f3client  # type:ignore
from firm_f3.f3definitions import CurveTag
from firm_domain import Ccy, Tenor, OIS, TenorBasis, IRS, Rate, FRA
from firm_f3.mapping import f3instrument_type, f3instrument_strategy_async
from firm_f3.market_data.mdobject import MDObjectBase

from firm_f3.model_fragments import EXP_SPLINE_INTERP_METHOD
from firm_f3.model_fragments.model_fragment import FragmentBase, RequiredMktData
from firm_f3.fincadutil import get_market_data_tag_async

import firm_domain as domain
from firm_f3.model_object.util import extend_model_with_one_dimensional_calibrated_curve_async

INTERP_METHOD = EXP_SPLINE_INTERP_METHOD


def tag_discount_usd_overnightUsd() -> F3Object:
    return firm_f3.f3client.get_platform_client().DiscountCurveTag('USD', 'OvernightUSD')


def tag_discount_usd_liborUsd1m() -> F3Object:
    return firm_f3.f3client.get_platform_client().DiscountCurveTag('USD', 'LiborUSD1m')


def tag_discount_usd_liborUsd3m() -> F3Object:
    return firm_f3.f3client.get_platform_client().DiscountCurveTag('USD', 'LiborUSD3m')


def tag_discount_usd_liborUsd6m() -> F3Object:
    return firm_f3.f3client.get_platform_client().DiscountCurveTag('USD', 'LiborUSD6m')


class MultiCurveFragmentUsd(FragmentBase):

    @property
    def fragment_name(self) -> str:
        return "usd_multi_curve_ModelFragment"

    @staticmethod
    def hw_param_mean() -> F3Object:
        f3 = firm_f3.f3client.get_platform_client()
        return f3.CreateLabelledValuesMarketData("LiborUSD3m-HullWhiteMeanReversion", 0.03)

    @staticmethod
    def hw_param_vol() -> F3Object:
        f3 = firm_f3.f3client.get_platform_client()
        return f3.CreateCurveMarketData("LiborUSD3m-HullWhiteVolatility", "1y", 0.0097)

    def create_static_data(self) -> List[F3Object]:
        f3 = firm_f3.f3client.get_platform_client()
        o: List[F3Object] = []
        for discountCurveTag in [tag_discount_usd_overnightUsd(),
                                 tag_discount_usd_liborUsd1m(),
                                 tag_discount_usd_liborUsd3m(),
                                 tag_discount_usd_liborUsd6m()]:
            curvetag: CurveTag = CurveTag.from_discount_curve_tag(discountCurveTag)
            name = curvetag.zspread_convention_name
            zspread_conv = f3.CreateZSpreadConvention(
                UnderlyingCurveTag=curvetag.to_list(),
                CompoundingFrequency='Continuous',
                BaseDateConvention='SettlementDate').named(name)
            o.append(zspread_conv)
        return o

    def __init__(self, additional_discounting_curves: bool = False):
        super().__init__()
        self.additional_discounting_curves = additional_discounting_curves

    async def assemble_async(self,
                             base_model: Optional[F3Object],
                             market_data: Optional[Mapping[str, MDObjectBase]] = None) \
            -> Tuple[F3Object, RequiredMktData]:
        f3 = firm_f3.f3client.get_platform_client()
        model = f3.ExtendModelWithValuationSpecification(base_model or "${-1}", create_collapsed_compounding_valspec())

        all_instruments = []

        instruments = [OIS(Ccy.USD, Tenor.T_1Y),
                       FRA(Ccy.USD, Tenor.T_3M, Tenor.T_1D),
                       IRS(Ccy.USD, Tenor.T_1Y),
                       TenorBasis(Ccy.USD, Tenor.T_1Y, Tenor.T_1D, Tenor.T_3M),
                       'USD-Futures-Libor-3m']
        all_instruments += instruments
        ins_strat_usd_combined = await f3instrument_strategy_async(*instruments)

        usd_future_conv_adj_mr = MultiCurveFragmentUsd.hw_param_mean()
        usd_future_conv_adj_vol = MultiCurveFragmentUsd.hw_param_vol()

        md_tag_usd_future_conv_adj_mr = await get_market_data_tag_async(usd_future_conv_adj_mr)
        md_tag_usd_future_conv_adj_vol = await get_market_data_tag_async(usd_future_conv_adj_vol)

        model = f3.ExtendModelWithMarketData(BaseModel=model, MarketData=usd_future_conv_adj_mr)
        model = f3.ExtendModelWithMarketData(BaseModel=model, MarketData=usd_future_conv_adj_vol)

        usd_3m_rate_curve_tag = ['USD LIBOR:3m', 'LiborRateCurve']

        calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
            CurveTags=[
                usd_3m_rate_curve_tag,
                ['USD', 'DiscountCurve-CollateralRate-USD O/N:1b']
            ],
            InterpolationTypes=[
                'Linear',
                INTERP_METHOD
            ],
            InitialValueCurves=[
                [0.01, 'Unanchored'],
                [1, 'Anchored']
            ],
            BoundConstraints=[],
            OptimizationObjective='SingleCurrencyValue',
            UseHints=False,
            TimePointMethod=[
                ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
                ['USD-OIS', None, None, 'USD', 'DiscountCurve-CollateralRate-USD O/N:1b'],
                ['USD-BasisSwap-OIS-Libor-3m', None, None, 'USD', 'DiscountCurve-CollateralRate-USD O/N:1b'],
                ['USD-Futures-Libor-3m', None, None, *usd_3m_rate_curve_tag],
                [f3instrument_type(FRA(Ccy.USD, Tenor.T_3M, Tenor.T_1D)), None, None, *usd_3m_rate_curve_tag],
                ['USD-IRS-Semi-Libor-3m', None, None, *usd_3m_rate_curve_tag]
            ]
        )

        model = f3.ExtendModelWithCalibratedCurves(
            BaseModel=model,
            CalibrationTarget=calibration_target,
            InstrumentStrategy=ins_strat_usd_combined,
            Optimizer='NewtonRaphson_1e-3',
            SourceMethod='Par',
            TargetMethod='UseModelWideMethod'
        )

        hullwhite_vol_conv_adj = [['USD', "HWFuturesVolCurve"]]
        model = f3.ExtendModelWithInterpolationCurve(model,
                                                     hullwhite_vol_conv_adj,
                                                     md_tag_usd_future_conv_adj_vol,
                                                     "Linear")
        hullwhite_mr_conv_adj = [['USD', "HWFuturesMeanRevCurve"]]
        model = f3.ExtendModelWithZeroDimensionalCurve(model,
                                                       hullwhite_mr_conv_adj,
                                                       md_tag_usd_future_conv_adj_mr)

        future_conv_adj_curve = f3.ConvexityAdjustmentCurveTag("LiborUSD3m")
        model = f3.ExtendModelWithSingleFactorHullWhiteConvexityAdjustmentCurve(model,
                                                                                future_conv_adj_curve,
                                                                                "LiborUSD3m",
                                                                                "Continuous",
                                                                                hullwhite_vol_conv_adj,
                                                                                hullwhite_mr_conv_adj)
        model = f3.AddImpliedRateCurveToModel(model,
                                              'OvernightUSD',
                                              'OvernightUSD')

        ccy = Ccy.USD
        instruments = [FRA(Ccy.USD, Tenor.T_1M, Tenor.T_1D),
                       domain.TenorBasis(ccy, Tenor.T_1Y, Tenor.T_1M, Tenor.T_3M)]
        all_instruments += instruments
        inst_strategy = await f3instrument_strategy_async(*instruments)

        model = f3.ExtendModelWithBootstrappedCurves(model,
                                                     ['USD LIBOR:1m', 'LiborRateCurve'],
                                                     inst_strategy,
                                                     'Linear',
                                                     [0.01, 'Unanchored'])

        instruments = [FRA(Ccy.USD, Tenor.T_6M, Tenor.T_1D),
                       domain.TenorBasis(ccy, Tenor.T_1Y, Tenor.T_3M, Tenor.T_6M)]
        all_instruments += instruments
        inst_strategy = await f3instrument_strategy_async(*instruments)

        model = f3.ExtendModelWithBootstrappedCurves(model,
                                                     ['USD LIBOR:6m', 'LiborRateCurve'],
                                                     inst_strategy,
                                                     'Linear',
                                                     [0.01, 'Unanchored'])

        model = f3.ExtendModelWithClonedCurve(model,
                                              ['USD', 'DiscountCurve'],
                                              ['USD', 'DiscountCurve-CollateralRate-USD O/N:1b'])

        model = f3.ExtendModelWithFXRatesCurve(model,
                                               ['UniqueFXRatesCurve', 'FXRates'],
                                               ['UniqueFXRates', 'FXSpotQuotes'])

        model = f3.ExtendModelWithBootstrappedImpliedDiscountCurve(BaseModel=model,
                                                                   CurveTag=tag_discount_usd_liborUsd3m(),
                                                                   RateIndex='LiborUSD3m',
                                                                   SamplingSchedule=['40y', 'SwapUSD3m'])

        if self.additional_discounting_curves:
            # beware of https://firm-jira/browse/BI-5410 USD libor model exhibits unexpected behaviour with implied libor discounting curves
            model = f3.ExtendModelWithBootstrappedImpliedDiscountCurve(BaseModel=model,
                                                                       CurveTag=tag_discount_usd_liborUsd1m(),
                                                                       RateIndex='LiborUSD1m',
                                                                       SamplingSchedule=['40y', 'SwapUSD1m'])

            model = f3.ExtendModelWithBootstrappedImpliedDiscountCurve(BaseModel=model,
                                                                       CurveTag=tag_discount_usd_liborUsd6m(),
                                                                       RateIndex='LiborUSD6m',
                                                                       SamplingSchedule=['40y', 'SwapUSD6m'])

        req = RequiredMktData(set(f3instrument_type(*all_instruments)) | {fx_spot_market_data_key})

        return model, req

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\model_zar.py
----------------------------------------
import asyncio
from firm_domain.core import Tenor, Ccy
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client # type:ignore
from firm_domain import IRS, FRA, FXForward, XccyBasis, Rate, TenorBasis
from firm_f3.mapping import f3instrument_type, f3discount_curve_tag_async, f3instrument_strategy_async, \
    OvernightUSD, f3index
from firm_f3.model_fragments import EXP_SPLINE_INTERP_METHOD
from firm_f3.model_object.util import extend_model_with_one_dimensional_calibrated_curve_async

INTERP_METHOD = EXP_SPLINE_INTERP_METHOD

ccy = Ccy.ZAR
irs_base = IRS(ccy=ccy, tenor=Tenor.T_1Y)
fra_base = FRA(ccy=ccy, tenor=Tenor.T_3M, start=Tenor.T_6M)

ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_2Y)
fwd = FXForward(ccy=ccy, tenor=Tenor.T_6M)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
rate_3m = Rate(ccy, Tenor.T_3M)

assert irs_base_rate == rate_3m


async def extend_with_base_curves(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            irs_tag,
            ois_tag,
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=False,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(irs_base_rate), None, None, *irs_tag],
            [f3instrument_type(fra_base), None, None, *irs_tag],
            [f3instrument_type(irs_base), None, None, *irs_tag],
            [f3instrument_type(ois_basis), None, None, *ois_tag],
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base_rate, fra_base, irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def extend_with_xccy_curve(f3model: F3Object, **kwargs):
    return await extend_model_with_one_dimensional_calibrated_curve_async(
        f3model=f3model,
        target=ccy.name,
        inst_strategies=await f3instrument_strategy_async(fwd, xccy),
        target_method=f'Default{ccy.name}'
    )


async def add_usd_collateral_discount_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    extend_with_base_curves,
    add_irs_base_curve,
    add_ois_curve,
    extend_with_xccy_curve,
    add_usd_collateral_discount_curve,
)


async def assemble_model_fragment_async(f3model: F3Object = '${-1}', **kwargs):
    for func in extensions:
        if asyncio.iscoroutinefunction(func):
            f3model = await func(f3model, **kwargs)
        else:
            f3model = func(f3model, **kwargs)
    return f3model


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_aud.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client # type:ignore

from firm_domain import IRS, TenorBasis, XccyBasis, Rate, FXForward
from firm_domain.core import Ccy, Tenor
from firm_f3.mapping import f3instrument_type, f3instrument_strategy_async, f3discount_curve_tag_async, \
    OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.AUD
irs_base = IRS(ccy=ccy, tenor=Tenor.T_1Y)
ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
s1s3 = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1M, idx_2=Tenor.T_3M)
s3s6 = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_5Y)
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
irs_1m = Rate(ccy, Tenor.T_1M)
irs_3m = Rate(ccy, Tenor.T_3M)
irs_6m = Rate(ccy, Tenor.T_6M)

assert irs_base_rate == irs_3m


async def bootstrap_base_ois_dual_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            ois_tag,
            irs_tag
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=True,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(ois_basis), None, None] + ois_tag,
            [f3instrument_type(irs_base), None, None] + irs_tag,
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_irs_6m_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(irs_6m),
        Instruments=await f3instrument_strategy_async(s3s6),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored']
    )


def add_irs_6m_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_6m)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_irs_1m_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(irs_1m),
        Instruments=await f3instrument_strategy_async(s1s3),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored']
    )


def add_irs_1m_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_1m)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_xccy_discount_curve_async(f3model: F3Object, fx_points_model: bool = False, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    inst = fx_fwd if fx_points_model else xccy
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(inst),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', f'Default{ccy.name}']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


def bootstrap_6m_vol_cube(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    aud_swaption_tag_suffix_6m = 'VanillaPhysicallySettledSwaption'
    aud_swaption_tag_prefix_6m = 'SwaptionInstrument:SwapBBSWSemi:BBSW6m:SwapBBSW6m:'

    aud_swaption_tags_6m = {0: aud_swaption_tag_prefix_6m + '0.0',
                            0.0025: aud_swaption_tag_prefix_6m + '0.0025',
                            -0.0025: aud_swaption_tag_prefix_6m + '-0.0025',
                            0.005: aud_swaption_tag_prefix_6m + '0.005',
                            -.005: aud_swaption_tag_prefix_6m + '-0.005',
                            0.01: aud_swaption_tag_prefix_6m + '0.01',
                            -0.01: aud_swaption_tag_prefix_6m + '-0.01'}

    return f3.ExtendModelWithInterpolatedVolatilityCube(
        BaseModel=f3model,
        CurveTag=['IRS:6m:BBSW:6m', 'NormalVolatility'],
        MarketDataTags=[
            [aud_swaption_tags_6m[0], aud_swaption_tag_suffix_6m],
            [aud_swaption_tags_6m[0.0025], aud_swaption_tag_suffix_6m],
            [aud_swaption_tags_6m[-0.0025], aud_swaption_tag_suffix_6m],
            [aud_swaption_tags_6m[0.005], aud_swaption_tag_suffix_6m],
            [aud_swaption_tags_6m[-0.005], aud_swaption_tag_suffix_6m],
            [aud_swaption_tags_6m[0.01], aud_swaption_tag_suffix_6m],
            [aud_swaption_tags_6m[-0.01], aud_swaption_tag_suffix_6m]
        ],
        ThreeDimInterpolationMethod='Linear',
        VolatilityConvention='Normal',
        Axes=['UnderlyingMaturity', 'OptionExpiry', 'Strike']
    )


def add_6m_vol_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = ['IRS:6m:BBSW:6m', 'Volatility']
    source_tag = ['IRS:6m:BBSW:6m', 'NormalVolatility']
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


def bootstrap_3m_vol_cube(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    aud_swaption_tag_suffix_3m = 'VanillaPhysicallySettledSwaption'
    aud_swaption_tag_prefix_3m = 'SwaptionInstrument:SwapBBSWQuarterly:BBSW3m:SwapBBSW3m:'

    aud_swaption_tags_3m = {0: aud_swaption_tag_prefix_3m + '0.0',
                            0.0025: aud_swaption_tag_prefix_3m + '0.0025',
                            -0.0025: aud_swaption_tag_prefix_3m + '-0.0025',
                            0.005: aud_swaption_tag_prefix_3m + '0.005',
                            -.005: aud_swaption_tag_prefix_3m + '-0.005',
                            0.01: aud_swaption_tag_prefix_3m + '0.01',
                            -0.01: aud_swaption_tag_prefix_3m + '-0.01'}

    return f3.ExtendModelWithInterpolatedVolatilityCube(
        BaseModel=f3model,
        CurveTag=['IRS:3m:BBSW:3m', 'NormalVolatility'],
        MarketDataTags=[
            [aud_swaption_tags_3m[0], aud_swaption_tag_suffix_3m],
            [aud_swaption_tags_3m[0.0025], aud_swaption_tag_suffix_3m],
            [aud_swaption_tags_3m[-0.0025], aud_swaption_tag_suffix_3m],
            [aud_swaption_tags_3m[0.005], aud_swaption_tag_suffix_3m],
            [aud_swaption_tags_3m[-0.005], aud_swaption_tag_suffix_3m],
            [aud_swaption_tags_3m[0.01], aud_swaption_tag_suffix_3m],
            [aud_swaption_tags_3m[-0.01], aud_swaption_tag_suffix_3m]
        ],
        ThreeDimInterpolationMethod='Linear',
        VolatilityConvention='Normal',
        Axes=['UnderlyingMaturity', 'OptionExpiry', 'Strike']
    )


def add_3m_vol_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = ['IRS:3m:BBSW:3m', 'Volatility']
    source_tag = ['IRS:3m:BBSW:3m', 'NormalVolatility']
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_base_ois_dual_curve_async,
    add_ois_curve,
    add_irs_base_curve,
    bootstrap_irs_6m_curve_async,
    add_irs_6m_curve,
    bootstrap_irs_1m_curve_async,
    add_irs_1m_curve,
    bootstrap_xccy_discount_curve_async,
    add_usd_collateral_discount_curve_async,
    bootstrap_6m_vol_cube,
    add_6m_vol_curve,
    bootstrap_3m_vol_cube,
    add_3m_vol_curve,
)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_cad.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain.core import Ccy, Tenor
from firm_domain import IRS, TenorBasis, XccyBasis, Rate, FXForward
from firm_f3.mapping import f3instrument_type, f3instrument_strategy_async, f3discount_curve_tag_async, \
    OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.CAD
irs_base = IRS(ccy=ccy, tenor=Tenor.T_5Y)
ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_5Y)
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
irs_3m = Rate(ccy, Tenor.T_3M)

assert irs_base_rate == irs_3m


async def bootstrap_base_ois_dual_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            ois_tag,
            irs_tag
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=True,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(ois_basis), None, None, *ois_tag],
            [f3instrument_type(irs_base), None, None, *irs_tag],
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_xccy_discount_curve_async(f3model: F3Object, fx_points_model: bool = False, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    inst = fx_fwd if fx_points_model else xccy
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(inst),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', f'Default{ccy.name}']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_base_ois_dual_curve_async,
    add_ois_curve,
    add_irs_base_curve,
    bootstrap_xccy_discount_curve_async,
    add_usd_collateral_discount_curve_async,
)

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_chf.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain.core import Ccy, Tenor
from firm_domain import IRS, TenorBasis, XccyBasis, Rate, FXForward
from firm_f3.mapping import f3instrument_type, f3instrument_strategy_async, f3discount_curve_tag_async, \
    OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.CHF
irs_base = IRS(ccy=ccy, tenor=Tenor.T_5Y)
ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
s3s6 = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_5Y)
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
irs_3m = Rate(ccy, Tenor.T_3M)
irs_6m = Rate(ccy, Tenor.T_6M)

assert irs_base_rate == irs_6m


async def bootstrap_base_ois_dual_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            ois_tag,
            irs_tag
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=True,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(irs_base), None, None, *irs_tag],
            [f3instrument_type(ois_basis), None, None, *ois_tag],
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_xccy_discount_curve_async(f3model: F3Object, fx_points_model: bool = False, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    inst = fx_fwd if fx_points_model else xccy
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(inst),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', 'DefaultUSD']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


async def bootstrap_irs_3m_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(irs_3m),
        Instruments=await f3instrument_strategy_async(s3s6),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored']
    )


def add_irs_3m_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_3m)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


extensions = (
    bootstrap_base_ois_dual_curve_async,
    add_ois_curve,
    add_irs_base_curve,
    bootstrap_xccy_discount_curve_async,
    add_usd_collateral_discount_curve_async,
    bootstrap_irs_3m_curve_async,
    add_irs_3m_curve,
)

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_cnh.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain import CrossCurrencySwap, FXForward
from firm_domain.core import Ccy, Tenor
from firm_f3.mapping import f3instrument_strategy_async, f3discount_curve_tag_async, OvernightUSD

INTERP_METHOD = 'LogLinear'

ccy = Ccy.CNH
ccs = CrossCurrencySwap(ccy=ccy, tenor=Tenor.T_1Y)
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)


async def bootstrap_ccs_discount_curve_async(f3model: F3Object, fx_points_model: bool = False, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    inst = fx_fwd if fx_points_model else ccs
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(inst),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['BoundConstraints', 'GreaterThanZero'],
            ['TargetMethod', 'DefaultUSD']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_ccs_discount_curve_async,
    add_usd_collateral_discount_curve_async,
)

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_cny.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain import IRS, Rate, FXForward
from firm_domain.core import Ccy, Tenor
from firm_f3.mapping import f3instrument_strategy_async, f3discount_curve_tag_async, OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.CNY
irs_base = IRS(ccy=ccy, tenor=Tenor.T_5Y)
irs_base_rate = Rate(ccy, irs_base.idx)
irs_1w = Rate(ccy, Tenor.T_1W)

assert irs_base_rate == irs_1w

fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)


async def bootstrap_base_irs_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(irs_base_rate),
        Instruments=await f3instrument_strategy_async(irs_base),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, "Anchored"],
        AdvancedConfiguration=['TargetMethod', 'DefaultUSD']
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_fx_fwd_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(fx_fwd),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', f'Default{ccy.name}']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_base_irs_curve_async,
    add_irs_base_curve,
    bootstrap_fx_fwd_discount_curve_async,
    add_usd_collateral_discount_curve_async,
)

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_eur.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client # type:ignore
from firm_domain.core import Ccy, Tenor

from firm_domain import IRS, TenorBasis, XccyBasis, Rate, FXForward
from firm_f3.mapping import f3instrument_type, f3instrument_strategy_async, f3discount_curve_tag_async, \
    OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.EUR
irs_base = IRS(ccy=ccy, tenor=Tenor.T_5Y)
ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
s3s6 = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_5Y)
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
irs_3m = Rate(ccy, Tenor.T_3M)
irs_6m = Rate(ccy, Tenor.T_6M)

assert irs_base_rate == irs_6m


async def bootstrap_discount_ois_euribor_6m_dual_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            ois_tag,
            irs_tag
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=True,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(irs_base), None, None] + irs_tag,
            [f3instrument_type(ois_basis), None, None] + ois_tag
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_euribor_6m_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_discount_euribor_3m_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(irs_3m),
        Instruments=await f3instrument_strategy_async(s3s6),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored']
    )


def add_euribor_3m_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_3m)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_xccy_discount_curve_async(f3model: F3Object, fx_points_model: bool = False, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    inst = fx_fwd if fx_points_model else xccy
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(inst),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', f'Default{ccy.name}']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


def bootstrap_6m_vol_cube(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    eur_swaption_tag_suffix = 'ParYieldCashSettledSwaption:FullCashSingleCurrencyCollateralInEUR'
    eur_swaption_tag_prefix = 'ParYieldCashSettledSwaption:IRS:12m:Euribor:6m:Relative:'

    eur_swaption_tags = {0: eur_swaption_tag_prefix + '0',
                         0.0025: eur_swaption_tag_prefix + '0.0025',
                         -0.0025: eur_swaption_tag_prefix + '-0.0025',
                         0.005: eur_swaption_tag_prefix + '0.005',
                         -.005: eur_swaption_tag_prefix + '-0.005',
                         0.01: eur_swaption_tag_prefix + '0.01',
                         -0.01: eur_swaption_tag_prefix + '-0.01'}

    return f3.ExtendModelWithInterpolatedVolatilityCube(
        BaseModel=f3model,
        CurveTag=['IRS:12m:Euribor:6m', 'NormalVolatility'],
        MarketDataTags=[
            [eur_swaption_tags[0], eur_swaption_tag_suffix],
            [eur_swaption_tags[0.0025], eur_swaption_tag_suffix],
            [eur_swaption_tags[-0.0025], eur_swaption_tag_suffix],
            [eur_swaption_tags[0.005], eur_swaption_tag_suffix],
            [eur_swaption_tags[-0.005], eur_swaption_tag_suffix],
            [eur_swaption_tags[0.01], eur_swaption_tag_suffix],
            [eur_swaption_tags[-0.01], eur_swaption_tag_suffix]
        ],
        ThreeDimInterpolationMethod='Linear',
        VolatilityConvention='Normal',
        Axes=['UnderlyingMaturity', 'OptionExpiry', 'Strike']
    )


def add_6m_vol_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = ['IRS:12m:Euribor:6m', 'Volatility']
    source_tag = ['IRS:12m:Euribor:6m', 'NormalVolatility']
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_discount_ois_euribor_6m_dual_curve_async,
    add_ois_curve,
    add_euribor_6m_curve,
    bootstrap_discount_euribor_3m_curve_async,
    add_euribor_3m_curve,
    bootstrap_xccy_discount_curve_async,
    add_usd_collateral_discount_curve_async,
    bootstrap_6m_vol_cube,
    add_6m_vol_curve,
)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_fragment.py
----------------------------------------
import asyncio
from f3sdk.f3 import F3Object  # type:ignore
from f3sdk.lib.coroutine import wait  # type: ignore
import firm_f3.f3client  # type:ignore
from firm_f3.core.orm import ModelFragment
from firm_f3.model_fragments import (
    risk_model_eur, risk_model_jpy, risk_model_sek, risk_model_hkd, risk_model_cnh, risk_model_sgd, risk_model_idr,
    risk_model_nzd, risk_model_krw, risk_model_gbp, risk_model_rub, risk_model_ino, risk_model_myr, risk_model_cny,
    risk_model_twd, risk_model_pln, risk_model_thb, risk_model_zar, risk_model_sar, risk_model_ils, risk_model_cad,
    risk_model_aud, risk_model_huf, risk_model_inr, risk_model_php, risk_model_usd, risk_model_nok, risk_model_chf,
    risk_model_try, risk_model_fx_vol, model_ccs_swaption, risk_model_mxn, risk_model_nto, model_securities
)
from firm_f3.model_object.instance.USD import USDModelInflationSwap

model_fragments = (
    risk_model_usd,
    risk_model_eur,
    risk_model_aud,
    risk_model_krw,
    risk_model_gbp,
    risk_model_jpy,
    risk_model_nzd,
    risk_model_sek,
    risk_model_hkd,
    risk_model_sgd,
    risk_model_zar,
    risk_model_sar,
    risk_model_huf,
    risk_model_pln,
    risk_model_ils,
    risk_model_cad,
    risk_model_cny,
    risk_model_cnh,
    risk_model_myr,
    risk_model_mxn,
    risk_model_nto,
    risk_model_thb,
    risk_model_rub,
    risk_model_inr,
    risk_model_ino,
    risk_model_twd,
    risk_model_php,
    risk_model_idr,
    risk_model_nok,
    risk_model_chf,
    risk_model_try,
    risk_model_fx_vol,
    model_ccs_swaption,
    model_securities
)


async def assemble_risk_model_fragments_async(f3model: F3Object = '${-1}', **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3model = f3.ExtendModelWithValuationSpecification(f3model, "CollapsedCompounding")
    f3model = f3.ExtendModelWithFXRatesCurve(
        BaseModel=f3model,
        CurveTag=['UniqueFXRatesCurve', 'FXRates'],
        FXMarketDataTag=['UniqueFXRates', 'FXSpotQuotes']
    )

    for fragment in model_fragments:
        for func in fragment.extensions:
            if asyncio.iscoroutinefunction(func):
                f3model = await func(f3model, **kwargs)
            else:
                f3model = func(f3model, **kwargs)
            assert f3model is not None

    # inflation swap fragment
    f3model = await USDModelInflationSwap().assemble_fragment_async(f3model)

    return f3model


async def update_risk_model_fragment_async(tail: str):
    model = await assemble_risk_model_fragments_async()
    name = f'risk_model_ModelFragment_{tail}'
    model_fragment = ModelFragment(name=name, definition=model)
    return await model_fragment.save_async()


def update_risk_model_fragment(tail: str):
    return wait(update_risk_model_fragment_async(tail=tail))


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_fx_vol.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client # type:ignore
from firm_f3.mapping import ccy_to_f3pair
from firm_f3.modelconfig import FX_OPTION_CCY


def extend_model_with_fx_vol_sabr_fragment(f3model: F3Object, ccy_pair: str, **kwargs) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    ccy_pair_inv = ccy_pair[-3:] + ccy_pair[:3]
    val_spec_builder = f3.CreateClosedFormVolatilityValuationSpecificationBuilder(
        VolatileIndex=ccy_pair,
        VolatilityType='SABR'
    )

    f3model = f3.ExtendModelWithVolatilitySurface(
        BaseModel=f3model,
        CurveTag=f3.VolatilityCurveTag(val_spec_builder),
        UnderlyingCurveTags=[
            [ccy_pair, 'SABRAlpha'],
            [ccy_pair, 'SABRBeta'],
            [ccy_pair, 'SABRRho'],
            [ccy_pair, 'SABRNu']
        ],
        VolatilityType='SABR'
    )

    # fixed_beta = f3.CreateDateValueMarketData(
    #     DateValueName='SABR',
    #     DateValueType='Beta',
    #     Maturities='1y',
    #     Values=1,
    #     MarketConventions='NoScheduleNoHolidays'
    # )
    #
    # f3model = f3.ExtendModelWithMarketData(
    #     BaseModel=f3model,
    #     MarketData=fixed_beta
    # )

    f3model = f3.ExtendModelWithInterpolationCurve(
        BaseModel=f3model,
        CurveTag=[ccy_pair, 'SABRBeta'],
        MarketDataTag=[f'SABRBeta:{ccy_pair}', 'SABRBeta'],
        InterpolationMethod='Linear'
    )

    f3model = f3.ExtendModelWithInterpolationCurve(
        BaseModel=f3model,
        CurveTag=[ccy_pair, 'SABRAlpha'],
        MarketDataTag=[f'SABRAlpha:{ccy_pair}', 'SABRAlpha'],
        InterpolationMethod='Linear'
    )

    f3model = f3.ExtendModelWithInterpolationCurve(
        BaseModel=f3model,
        CurveTag=[ccy_pair, 'SABRRho'],
        MarketDataTag=[f'SABRRho:{ccy_pair}', 'SABRRho'],
        InterpolationMethod='Linear'
    )

    f3model = f3.ExtendModelWithInterpolationCurve(
        BaseModel=f3model,
        CurveTag=[ccy_pair, 'SABRNu'],
        MarketDataTag=[f'SABRNu:{ccy_pair}', 'SABRNu'],
        InterpolationMethod='Linear'
    )

    f3model = f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=f3.VolatilityCurveTag(ccy_pair),
        SourceCurveTag=f3.VolatilityCurveTag(val_spec_builder)
    )

    f3model = f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=f3.VolatilityCurveTag(ccy_pair),
        SourceCurveTag=f3.VolatilityCurveTag(val_spec_builder)
    )

    f3model = f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=f3.VolatilityCurveTag(ccy_pair_inv),
        SourceCurveTag=f3.VolatilityCurveTag(ccy_pair)
    )

    return f3model


def assemble_risk_model_fragment(f3model: F3Object = '${-1}', **kwargs) -> F3Object:
    for ccy in FX_OPTION_CCY:
        ccy_pair = ccy_to_f3pair(ccy)
        f3model = extend_model_with_fx_vol_sabr_fragment(f3model, ccy_pair=ccy_pair)

    return f3model


extensions = (
    assemble_risk_model_fragment,
)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_gbp.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client # type:ignore

from firm_domain.core import Ccy, Tenor
from firm_domain import IRS, TenorBasis, XccyBasis, Rate, FXForward
from firm_f3.mapping import f3instrument_type, f3instrument_strategy_async, f3discount_curve_tag_async, \
    OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.GBP
irs_base = IRS(ccy=ccy, tenor=Tenor.T_5Y)
ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
s3s6 = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_5Y)
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
irs_3m = Rate(ccy, Tenor.T_3M)
irs_6m = Rate(ccy, Tenor.T_6M)

assert irs_base_rate == irs_6m


async def bootstrap_base_ois_dual_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            ois_tag,
            irs_tag
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=True,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(ois_basis), None, None] + ois_tag,
            [f3instrument_type(irs_base), None, None] + irs_tag,
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_irs_3m_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(irs_3m),
        Instruments=await f3instrument_strategy_async(s3s6),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored']
    )


def add_irs_3m_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_3m)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_xccy_discount_curve_async(f3model: F3Object, fx_points_model: bool = False, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    inst = fx_fwd if fx_points_model else xccy
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(inst),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', f'Default{ccy.name}']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_base_ois_dual_curve_async,
    add_ois_curve,
    add_irs_base_curve,
    bootstrap_irs_3m_curve_async,
    add_irs_3m_curve,
    bootstrap_xccy_discount_curve_async,
    add_usd_collateral_discount_curve_async,
)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_hkd.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client # type:ignore

from firm_domain.core import Ccy, Tenor
from firm_domain import IRS, TenorBasis, XccyBasis, Rate, FXForward
from firm_f3.mapping import f3instrument_type, f3instrument_strategy_async, f3discount_curve_tag_async, \
    OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.HKD
irs_base = IRS(ccy=ccy, tenor=Tenor.T_5Y)
ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
s1s3 = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1M, idx_2=Tenor.T_3M)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_5Y)
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
irs_1m = Rate(ccy, Tenor.T_1M)
irs_3m = Rate(ccy, Tenor.T_3M)

assert irs_base_rate == irs_3m


async def bootstrap_base_ois_dual_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            ois_tag,
            irs_tag
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=True,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(irs_base), None, None, *irs_tag],
            [f3instrument_type(ois_basis), None, None, *ois_tag],
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_irs_1m_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(irs_1m),
        Instruments=await f3instrument_strategy_async(s1s3),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored']
    )


def add_irs_1m_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_1m)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_xccy_discount_curve_async(f3model: F3Object, fx_points_model: bool = False, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    inst = fx_fwd if fx_points_model else xccy
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(inst),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', f'Default{ccy.name}']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_base_ois_dual_curve_async,
    add_ois_curve,
    add_irs_base_curve,
    bootstrap_irs_1m_curve_async,
    add_irs_1m_curve,
    bootstrap_xccy_discount_curve_async,
    add_usd_collateral_discount_curve_async,
)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_huf.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain.core import Ccy, Tenor
from firm_domain import IRS, TenorBasis, XccyBasis, Rate, FXForward
from firm_f3.mapping import f3instrument_type, f3instrument_strategy_async, f3discount_curve_tag_async, \
    OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.HUF
irs_base = IRS(ccy=ccy, tenor=Tenor.T_5Y)
ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
s3s6 = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_5Y)
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
irs_3m = Rate(ccy, Tenor.T_3M)
irs_6m = Rate(ccy, Tenor.T_6M)

assert irs_base_rate == irs_6m


async def bootstrap_base_ois_dual_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            ois_tag,
            irs_tag
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=True,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(irs_base), None, None, *irs_tag],
            [f3instrument_type(ois_basis), None, None, *ois_tag],
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_xccy_discount_curve_async(f3model: F3Object, fx_points_model: bool = False, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    inst = fx_fwd if fx_points_model else xccy
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(inst),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', 'DefaultUSD']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


async def bootstrap_irs_3m_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(irs_3m),
        Instruments=await f3instrument_strategy_async(s3s6),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored']
    )


def add_irs_3m_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_3m)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


extensions = (
    bootstrap_base_ois_dual_curve_async,
    add_ois_curve,
    add_irs_base_curve,
    bootstrap_xccy_discount_curve_async,
    add_usd_collateral_discount_curve_async,
    bootstrap_irs_3m_curve_async,
    add_irs_3m_curve,
)

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_idr.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain import FXForward
from firm_domain.core import Ccy, Tenor
from firm_f3.mapping import f3instrument_strategy_async, f3discount_curve_tag_async, OvernightUSD

INTERP_METHOD = 'LogLinear'

ccy = Ccy.IDR
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)


async def bootstrap_fx_fwd_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(fx_fwd),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', 'DefaultUSD']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_fx_fwd_discount_curve_async,
    add_usd_collateral_discount_curve_async,
)

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_ils.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain.core import Ccy, Tenor
from firm_domain import IRS, XccyBasis, Rate, TenorBasis, FXForward
from firm_f3.mapping import f3instrument_type, f3instrument_strategy_async, f3discount_curve_tag_async, \
    OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.ILS
irs_base = IRS(ccy=ccy, tenor=Tenor.T_5Y)
ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_5Y)
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
irs_3m = Rate(ccy, Tenor.T_3M)

assert irs_base_rate == irs_3m


async def bootstrap_base_ois_dual_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            ois_tag,
            irs_tag
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=True,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(irs_base), None, None, *irs_tag],
            [f3instrument_type(ois_basis), None, None, *ois_tag],
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_xccy_discount_curve_async(f3model: F3Object, fx_points_model: bool = False, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    inst = fx_fwd if fx_points_model else xccy
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(inst),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', 'DefaultUSD']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_base_ois_dual_curve_async,
    add_ois_curve,
    add_irs_base_curve,
    bootstrap_xccy_discount_curve_async,
    add_usd_collateral_discount_curve_async,
)

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_ino.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain.core import Ccy, Tenor
from firm_domain import Rate, OIS, CrossCurrencySwap, FXForward
from firm_f3.mapping import f3instrument_strategy_async, f3discount_curve_tag_async, OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.INO
irs_base = OIS(ccy=ccy, tenor=Tenor.T_5Y)
irs_base_rate = Rate(ccy, Tenor.T_1D)
ccs = CrossCurrencySwap(ccy=ccy, tenor=Tenor.T_1Y)
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)


async def bootstrap_base_irs_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(irs_base_rate),
        Instruments=await f3instrument_strategy_async(irs_base),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, "Anchored"],
        AdvancedConfiguration=['TargetMethod', 'DefaultUSD']
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_ccs_discount_curve_async(f3model: F3Object, fx_points_model: bool = False, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    inst = fx_fwd if fx_points_model else ccs
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(inst),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['BoundConstraints', 'GreaterThanZero'],
            ['TargetMethod', 'DefaultUSD']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_base_irs_curve_async,
    add_irs_base_curve,
    bootstrap_ccs_discount_curve_async,
    add_usd_collateral_discount_curve_async,
)

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_inr.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain import Rate, OIS, CrossCurrencySwap, FXForward
from firm_domain.core import Ccy, Tenor
from firm_f3.mapping import f3instrument_strategy_async, f3discount_curve_tag_async, OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.INR
irs_base = OIS(ccy=ccy, tenor=Tenor.T_5Y)
irs_base_rate = Rate(ccy, Tenor.T_1D)
ccs = CrossCurrencySwap(ccy=ccy, tenor=Tenor.T_1Y)
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)


async def bootstrap_base_irs_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(irs_base_rate),
        Instruments=await f3instrument_strategy_async(irs_base),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, "Anchored"],
        AdvancedConfiguration=['TargetMethod', 'DefaultUSD']
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_ccs_discount_curve_async(f3model: F3Object, fx_points_model: bool = False, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    inst = fx_fwd if fx_points_model else ccs
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(inst),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['BoundConstraints', 'GreaterThanZero'],
            ['TargetMethod', 'DefaultUSD']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_base_irs_curve_async,
    add_irs_base_curve,
    bootstrap_ccs_discount_curve_async,
    add_usd_collateral_discount_curve_async,
)

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_jpy.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client # type:ignore

from firm_domain.core import Ccy, Tenor
from firm_domain import IRS, TenorBasis, XccyBasis, Rate, FXForward
from firm_f3.mapping import f3instrument_type, f3instrument_strategy_async, f3discount_curve_tag_async, \
    OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.JPY
irs_base = IRS(ccy=ccy, tenor=Tenor.T_5Y)
ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
s3s6 = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_5Y)
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
irs_3m = Rate(ccy, Tenor.T_3M)
irs_6m = Rate(ccy, Tenor.T_6M)

assert irs_base_rate == irs_6m


async def bootstrap_base_ois_dual_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            ois_tag,
            irs_tag
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=True,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(ois_basis), None, None] + ois_tag,
            [f3instrument_type(irs_base), None, None] + irs_tag,
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_irs_3m_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(irs_3m),
        Instruments=await f3instrument_strategy_async(s3s6),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored']
    )


def add_irs_3m_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_3m)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_xccy_discount_curve_async(f3model: F3Object, fx_points_model: bool = False, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    inst = fx_fwd if fx_points_model else xccy
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(inst),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', 'DefaultUSD']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


def bootstrap_6m_vol_cube(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    jpy_swaption_tag_suffix = 'VanillaSwaption:FullCashSingleCurrencyCollateralInJPY'
    jpy_swaption_tag_prefix = 'VanillaSwaption:IRS:6m:JPY LIBOR:6m:Relative:'

    jpy_swaption_tags = {0: jpy_swaption_tag_prefix + '0',
                         0.0025: jpy_swaption_tag_prefix + '0.0025',
                         -0.0025: jpy_swaption_tag_prefix + '-0.0025',
                         0.005: jpy_swaption_tag_prefix + '0.005',
                         -.005: jpy_swaption_tag_prefix + '-0.005',
                         0.01: jpy_swaption_tag_prefix + '0.01',
                         -0.01: jpy_swaption_tag_prefix + '-0.01'}

    return f3.ExtendModelWithInterpolatedVolatilityCube(
        BaseModel=f3model,
        CurveTag=['IRS:6m:JPY LIBOR:6m', 'NormalVolatility'],
        MarketDataTags=[
            [jpy_swaption_tags[0], jpy_swaption_tag_suffix],
            [jpy_swaption_tags[0.0025], jpy_swaption_tag_suffix],
            [jpy_swaption_tags[-0.0025], jpy_swaption_tag_suffix],
            [jpy_swaption_tags[0.005], jpy_swaption_tag_suffix],
            [jpy_swaption_tags[-0.005], jpy_swaption_tag_suffix],
            [jpy_swaption_tags[0.01], jpy_swaption_tag_suffix],
            [jpy_swaption_tags[-0.01], jpy_swaption_tag_suffix]
        ],
        ThreeDimInterpolationMethod='Linear',
        VolatilityConvention='Normal',
        Axes=['UnderlyingMaturity', 'OptionExpiry', 'Strike']
    )


def add_6m_vol_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = ['IRS:6m:JPY LIBOR:6m', 'Volatility']
    source_tag = ['IRS:6m:JPY LIBOR:6m', 'NormalVolatility']
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_base_ois_dual_curve_async,
    add_ois_curve,
    add_irs_base_curve,
    bootstrap_irs_3m_curve_async,
    add_irs_3m_curve,
    bootstrap_xccy_discount_curve_async,
    add_usd_collateral_discount_curve_async,
    bootstrap_6m_vol_cube,
    add_6m_vol_curve,
)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_krw.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain.core import Ccy, Tenor
from firm_domain import IRS, XccyBasis, Rate, FXForward
from firm_f3.mapping import f3instrument_type, f3instrument_strategy_async, f3discount_curve_tag_async, \
    OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.KRW
irs_base = IRS(ccy=ccy, tenor=Tenor.T_1Y)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_1Y)
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)

irs_base_rate = Rate(ccy, irs_base.idx)
irs_3m = Rate(ccy, Tenor.T_3M)

assert irs_base_rate == irs_3m


async def bootstrap_base_ois_dual_curve_async(f3model: F3Object, fx_points_model: bool = False, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    discount_tag, irs_tag = await f3discount_curve_tag_async(ccy.name, irs_base_rate)
    inst = fx_fwd if fx_points_model else xccy

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            discount_tag,
            irs_tag
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyNumeraireValue',
        UseHints=True,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(irs_base), None, None] + irs_tag,
            [f3instrument_type(inst), None, None] + discount_tag
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base, inst),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='DefaultUSD'
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


def bootstrap_3m_vol_cube(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    krw_swaption_tag_suffix = 'VanillaSwaption'
    krw_swaption_tag_prefix = 'VanillaSwaption:IRS:3m:KRWCD:3m:Relative:'

    krw_swaption_tags = {0: krw_swaption_tag_prefix + '0',
                         0.0025: krw_swaption_tag_prefix + '0.0025',
                         -0.0025: krw_swaption_tag_prefix + '-0.0025',
                         0.005: krw_swaption_tag_prefix + '0.005',
                         -.005: krw_swaption_tag_prefix + '-0.005',
                         0.01: krw_swaption_tag_prefix + '0.01',
                         -0.01: krw_swaption_tag_prefix + '-0.01'}

    return f3.ExtendModelWithInterpolatedVolatilityCube(
        BaseModel=f3model,
        CurveTag=['IRS:3m:KRWCD:3m', 'NormalVolatility'],
        MarketDataTags=[
            [krw_swaption_tags[0], krw_swaption_tag_suffix],
            [krw_swaption_tags[0.0025], krw_swaption_tag_suffix],
            [krw_swaption_tags[-0.0025], krw_swaption_tag_suffix],
            [krw_swaption_tags[0.005], krw_swaption_tag_suffix],
            [krw_swaption_tags[-0.005], krw_swaption_tag_suffix],
            [krw_swaption_tags[0.01], krw_swaption_tag_suffix],
            [krw_swaption_tags[-0.01], krw_swaption_tag_suffix]
        ],
        ThreeDimInterpolationMethod='Linear',
        VolatilityConvention='Normal',
        Axes=['UnderlyingMaturity', 'OptionExpiry', 'Strike']
    )


def add_3m_vol_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = ['IRS:3m:KRWCD:3m', 'Volatility']
    source_tag = ['IRS:3m:KRWCD:3m', 'NormalVolatility']
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_base_ois_dual_curve_async,
    add_irs_base_curve,
    add_usd_collateral_discount_curve_async,
    bootstrap_3m_vol_cube,
    add_3m_vol_curve,
)

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_mxn.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain import FXForward
from firm_domain.core import Ccy, Tenor
from firm_f3.mapping import f3instrument_strategy_async, f3discount_curve_tag_async, OvernightUSD

INTERP_METHOD = 'LogLinear'

ccy = Ccy.MXN
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)


async def bootstrap_fx_fwd_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(fx_fwd),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', 'DefaultUSD']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_fx_fwd_discount_curve_async,
    add_usd_collateral_discount_curve_async,
)

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_myr.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain import IRS, Rate, FXForward
from firm_domain.core import Ccy, Tenor
from firm_f3.mapping import f3instrument_strategy_async, f3discount_curve_tag_async, OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.MYR
irs_base = IRS(ccy=ccy, tenor=Tenor.T_5Y)
irs_base_rate = Rate(ccy, irs_base.idx)
irs_3m = Rate(ccy, Tenor.T_3M)

assert irs_base_rate == irs_3m

fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)


async def bootstrap_base_irs_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(irs_base_rate),
        Instruments=await f3instrument_strategy_async(irs_base),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, "Anchored"],
        AdvancedConfiguration=['TargetMethod', 'DefaultUSD']
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_fx_fwd_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(fx_fwd),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', f'Default{ccy.name}']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_base_irs_curve_async,
    add_irs_base_curve,
    bootstrap_fx_fwd_discount_curve_async,
    add_usd_collateral_discount_curve_async,
)

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_nok.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain.core import Ccy, Tenor
from firm_domain import IRS, TenorBasis, XccyBasis, Rate, FXForward
from firm_f3.mapping import f3instrument_type, f3instrument_strategy_async, f3discount_curve_tag_async, \
    OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.NOK
irs_base = IRS(ccy=ccy, tenor=Tenor.T_5Y)
ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
s3s6 = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_5Y)
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
irs_3m = Rate(ccy, Tenor.T_3M)
irs_6m = Rate(ccy, Tenor.T_6M)

assert irs_base_rate == irs_6m


async def bootstrap_base_ois_dual_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            ois_tag,
            irs_tag
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=True,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(irs_base), None, None, *irs_tag],
            [f3instrument_type(ois_basis), None, None, *ois_tag],
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_xccy_discount_curve_async(f3model: F3Object, fx_points_model: bool = False, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    inst = fx_fwd if fx_points_model else xccy
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(inst),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', 'DefaultUSD']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


async def bootstrap_irs_3m_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(irs_3m),
        Instruments=await f3instrument_strategy_async(s3s6),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored']
    )


def add_irs_3m_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_3m)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


extensions = (
    bootstrap_base_ois_dual_curve_async,
    add_ois_curve,
    add_irs_base_curve,
    bootstrap_xccy_discount_curve_async,
    add_usd_collateral_discount_curve_async,
    bootstrap_irs_3m_curve_async,
    add_irs_3m_curve,
)

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_nto.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain import IRS, Rate, FXForward
from firm_domain.core import Ccy, Tenor
from firm_f3.mapping import f3instrument_strategy_async, f3discount_curve_tag_async, OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.NTO
irs_base = IRS(ccy=ccy, tenor=Tenor.T_5Y)
irs_base_rate = Rate(ccy, irs_base.idx)
irs_3m = Rate(ccy, Tenor.T_3M)

assert irs_base_rate == irs_3m

fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)


async def bootstrap_base_irs_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(irs_base_rate),
        Instruments=await f3instrument_strategy_async(irs_base),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, "Anchored"],
        AdvancedConfiguration=['TargetMethod', 'DefaultUSD']
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_fx_fwd_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(fx_fwd),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', f'Default{ccy.name}']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


def bootstrap_3m_vol_cube(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    nto_swaption_tag_suffix = 'ParYieldCashSettledSwaption:FullCashSingleCurrencyCollateralInUSD'
    nto_swaption_tag_prefix = 'ParYieldCashSettledSwaption:IRS:3m:NTO LIBOR:3m:Relative:'
    nto_swaption_tags = {0: nto_swaption_tag_prefix + '0',
                         0.0025: nto_swaption_tag_prefix + '0.0025',
                         -0.0025: nto_swaption_tag_prefix + '-0.0025',
                         0.005: nto_swaption_tag_prefix + '0.005',
                         -.005: nto_swaption_tag_prefix + '-0.005',
                         0.01: nto_swaption_tag_prefix + '0.01',
                         -0.01: nto_swaption_tag_prefix + '-0.01'}

    return f3.ExtendModelWithInterpolatedVolatilityCube(
        BaseModel=f3model,
        CurveTag=['IRS:3m:NTO LIBOR:3m', 'NormalVolatility'],
        MarketDataTags=[
            [nto_swaption_tags[0], nto_swaption_tag_suffix],
            [nto_swaption_tags[0.0025], nto_swaption_tag_suffix],
            [nto_swaption_tags[-0.0025], nto_swaption_tag_suffix],
            [nto_swaption_tags[0.005], nto_swaption_tag_suffix],
            [nto_swaption_tags[-0.005], nto_swaption_tag_suffix],
            [nto_swaption_tags[0.01], nto_swaption_tag_suffix],
            [nto_swaption_tags[-0.01], nto_swaption_tag_suffix]
        ],
        ThreeDimInterpolationMethod='Linear',
        VolatilityConvention='Normal',
        Axes=['UnderlyingMaturity', 'OptionExpiry', 'Strike']
    )


def add_3m_vol_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = ['IRS:3m:NTO LIBOR:3m', 'Volatility']
    source_tag = ['IRS:3m:NTO LIBOR:3m', 'NormalVolatility']
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )



extensions = (
    bootstrap_base_irs_curve_async,
    add_irs_base_curve,
    bootstrap_fx_fwd_discount_curve_async,
    add_usd_collateral_discount_curve_async,
    bootstrap_3m_vol_cube,
    add_3m_vol_curve,
)

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_nzd.py
----------------------------------------
from firm_domain.core import Tenor, Ccy
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client # type:ignore

from firm_domain import IRS, TenorBasis, XccyBasis, Rate, FXForward
from firm_f3.mapping import f3instrument_type, f3instrument_strategy_async, f3discount_curve_tag_async, \
    OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.NZD
irs_base = IRS(ccy=ccy, tenor=Tenor.T_5Y)
ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_5Y)
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
irs_3m = Rate(ccy, Tenor.T_3M)

assert irs_base_rate == irs_3m


async def bootstrap_base_ois_dual_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            ois_tag,
            irs_tag
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=True,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(ois_basis), None, None] + ois_tag,
            [f3instrument_type(irs_base), None, None] + irs_tag,
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_xccy_discount_curve_async(f3model: F3Object, fx_points_model: bool = False, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    inst = fx_fwd if fx_points_model else xccy
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(inst),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', 'DefaultUSD']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_base_ois_dual_curve_async,
    add_ois_curve,
    add_irs_base_curve,
    bootstrap_xccy_discount_curve_async,
    add_usd_collateral_discount_curve_async,
)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_php.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain import FXForward
from firm_domain.core import Ccy, Tenor
from firm_f3.mapping import f3instrument_strategy_async, f3discount_curve_tag_async, OvernightUSD

INTERP_METHOD = 'LogLinear'

ccy = Ccy.PHP
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)


async def bootstrap_fx_fwd_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(fx_fwd),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', 'DefaultUSD']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_fx_fwd_discount_curve_async,
    add_usd_collateral_discount_curve_async,
)

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_pln.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain.core import Ccy, Tenor
from firm_domain import IRS, TenorBasis, XccyBasis, Rate, FXForward
from firm_f3.mapping import f3instrument_type, f3instrument_strategy_async, f3discount_curve_tag_async, \
    OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.PLN
irs_base = IRS(ccy=ccy, tenor=Tenor.T_5Y)
ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
s3s6 = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_5Y)
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
irs_3m = Rate(ccy, Tenor.T_3M)
irs_6m = Rate(ccy, Tenor.T_6M)

assert irs_base_rate == irs_6m


async def bootstrap_base_ois_dual_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            ois_tag,
            irs_tag
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=True,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(irs_base), None, None, *irs_tag],
            [f3instrument_type(ois_basis), None, None, *ois_tag],
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_xccy_discount_curve_async(f3model: F3Object, fx_points_model: bool = False, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    inst = fx_fwd if fx_points_model else xccy
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(inst),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', 'DefaultUSD']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


async def bootstrap_irs_3m_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(irs_3m),
        Instruments=await f3instrument_strategy_async(s3s6),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored']
    )


def add_irs_3m_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_3m)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def bootstrap_6m_vol_cube(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    pln_swaption_tag_suffix = 'VanillaSwaption:FullCashSingleCurrencyCollateralInUSD'
    pln_swaption_tag_prefix = 'VanillaSwaption:IRS:12m:Wibor:6m:Relative:'

    pln_swaption_tags = {0: pln_swaption_tag_prefix + '0',
                         0.0025: pln_swaption_tag_prefix + '0.0025',
                         -0.0025: pln_swaption_tag_prefix + '-0.0025',
                         0.005: pln_swaption_tag_prefix + '0.005',
                         -.005: pln_swaption_tag_prefix + '-0.005',
                         0.01: pln_swaption_tag_prefix + '0.01',
                         -0.01: pln_swaption_tag_prefix + '-0.01'}

    return f3.ExtendModelWithInterpolatedVolatilityCube(
        BaseModel=f3model,
        CurveTag=['IRS:12m:Wibor:6m', 'NormalVolatility'],
        MarketDataTags=[
            [pln_swaption_tags[0], pln_swaption_tag_suffix],
            [pln_swaption_tags[0.0025], pln_swaption_tag_suffix],
            [pln_swaption_tags[-0.0025], pln_swaption_tag_suffix],
            [pln_swaption_tags[0.005], pln_swaption_tag_suffix],
            [pln_swaption_tags[-0.005], pln_swaption_tag_suffix],
            [pln_swaption_tags[0.01], pln_swaption_tag_suffix],
            [pln_swaption_tags[-0.01], pln_swaption_tag_suffix]
        ],
        ThreeDimInterpolationMethod='Linear',
        VolatilityConvention='Normal',
        Axes=['UnderlyingMaturity', 'OptionExpiry', 'Strike']
    )


def add_6m_vol_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = ['IRS:12m:Wibor:6m', 'Volatility']
    source_tag = ['IRS:12m:Wibor:6m', 'NormalVolatility']
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_base_ois_dual_curve_async,
    add_ois_curve,
    add_irs_base_curve,
    bootstrap_xccy_discount_curve_async,
    add_usd_collateral_discount_curve_async,
    bootstrap_irs_3m_curve_async,
    add_irs_3m_curve,
    bootstrap_6m_vol_cube,
    add_6m_vol_curve,
)

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_rub.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain.core import Ccy, Tenor
from firm_domain import CrossCurrencySwap, FXForward
from firm_f3.mapping import f3instrument_strategy_async, f3discount_curve_tag_async, OvernightUSD

INTERP_METHOD = 'LogLinear'

ccy = Ccy.RUB
ccs = CrossCurrencySwap(ccy=ccy, tenor=Tenor.T_1Y)
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)


async def bootstrap_ccs_discount_curve_async(f3model: F3Object, fx_points_model: bool = False, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    inst = fx_fwd if fx_points_model else ccs
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(inst),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['BoundConstraints', 'GreaterThanZero'],
            ['TargetMethod', f'Default{ccy.name}']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_ccs_discount_curve_async,
    add_usd_collateral_discount_curve_async,
)

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_sar.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain.core import Ccy, Tenor
from firm_domain import IRS, XccyBasis, Rate, TenorBasis, FXForward
from firm_f3.mapping import f3instrument_type, f3instrument_strategy_async, f3discount_curve_tag_async, OvernightUSD, \
    f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.SAR
irs_base = IRS(ccy=ccy, tenor=Tenor.T_5Y)
ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_5Y)
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
irs_3m = Rate(ccy, Tenor.T_3M)

assert irs_base_rate == irs_3m


async def bootstrap_base_ois_dual_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            ois_tag,
            irs_tag
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=True,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(irs_base), None, None, *irs_tag],
            [f3instrument_type(ois_basis), None, None, *ois_tag],
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_xccy_discount_curve_async(f3model: F3Object, fx_points_model: bool = False, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    inst = fx_fwd if fx_points_model else xccy
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(inst),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', f'Default{ccy.name}']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )



def bootstrap_3m_vol_cube(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    sar_swaption_tag_suffix = 'VanillaSwaption:FullCashSingleCurrencyCollateralInUSD'
    sar_swaption_tag_prefix = 'VanillaSwaption:IRS:12m:SAIBOR:3m:FullCashSingleCurrencyCollateralInSAR:Relative:'

    sar_swaption_tags = {0: sar_swaption_tag_prefix + '0',
                         0.0025: sar_swaption_tag_prefix + '0.0025',
                         -0.0025: sar_swaption_tag_prefix + '-0.0025',
                         0.005: sar_swaption_tag_prefix + '0.005',
                         -.005: sar_swaption_tag_prefix + '-0.005',
                         0.01: sar_swaption_tag_prefix + '0.01',
                         -0.01: sar_swaption_tag_prefix + '-0.01'}

    return f3.ExtendModelWithInterpolatedVolatilityCube(
        BaseModel=f3model,
        CurveTag=['IRS:12m:SAIBOR:3m', 'NormalVolatility'],
        MarketDataTags=[
            [sar_swaption_tags[0], sar_swaption_tag_suffix],
            [sar_swaption_tags[0.0025], sar_swaption_tag_suffix],
            [sar_swaption_tags[-0.0025], sar_swaption_tag_suffix],
            [sar_swaption_tags[0.005], sar_swaption_tag_suffix],
            [sar_swaption_tags[-0.005], sar_swaption_tag_suffix],
            [sar_swaption_tags[0.01], sar_swaption_tag_suffix],
            [sar_swaption_tags[-0.01], sar_swaption_tag_suffix]
        ],
        ThreeDimInterpolationMethod='Linear',
        VolatilityConvention='Normal',
        Axes=['UnderlyingMaturity', 'OptionExpiry', 'Strike']
    )


def add_3m_vol_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = ['IRS:12m:SAIBOR:3m', 'Volatility']
    source_tag = ['IRS:12m:SAIBOR:3m', 'NormalVolatility']
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )



extensions = (
    bootstrap_base_ois_dual_curve_async,
    add_ois_curve,
    add_irs_base_curve,
    bootstrap_xccy_discount_curve_async,
    add_usd_collateral_discount_curve_async,
    bootstrap_3m_vol_cube,
    add_3m_vol_curve,
)

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_sek.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client # type:ignore

from firm_domain.core import Ccy, Tenor
from firm_domain import IRS, TenorBasis, XccyBasis, Rate, FXForward
from firm_f3.mapping import f3instrument_type, f3instrument_strategy_async, f3discount_curve_tag_async, \
    OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.SEK
irs_base = IRS(ccy=ccy, tenor=Tenor.T_5Y)
ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_5Y)
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
irs_3m = Rate(ccy, Tenor.T_3M)

assert irs_base_rate == irs_3m


async def bootstrap_base_ois_dual_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            ois_tag,
            irs_tag
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=True,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(ois_basis), None, None] + ois_tag,
            [f3instrument_type(irs_base), None, None] + irs_tag,
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_xccy_discount_curve_async(f3model: F3Object, fx_points_model: bool = False, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    inst = fx_fwd if fx_points_model else xccy
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(inst),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', 'DefaultUSD']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_base_ois_dual_curve_async,
    add_ois_curve,
    add_irs_base_curve,
    bootstrap_xccy_discount_curve_async,
    add_usd_collateral_discount_curve_async,
)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_sgd.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain.core import Ccy, Tenor
from firm_domain import IRS, XccyBasis, Rate, TenorBasis, FXForward
from firm_f3.mapping import f3instrument_type, f3instrument_strategy_async, f3discount_curve_tag_async, \
    OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.SGD
irs_base = IRS(ccy=ccy, tenor=Tenor.T_5Y)
ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
s3s6 = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_5Y)
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
rate_6m = Rate(ccy, Tenor.T_6M)
rate_3m = Rate(ccy, Tenor.T_3M)

assert irs_base_rate == rate_6m


async def bootstrap_base_ois_dual_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            ois_tag,
            irs_tag
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=True,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(irs_base), None, None, *irs_tag],
            [f3instrument_type(ois_basis), None, None, *ois_tag],
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def extend_with_irs_3m_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(rate_3m),
        Instruments=await f3instrument_strategy_async(s3s6),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored']
    )


def add_irs_3m_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(rate_3m)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_xccy_discount_curve_async(f3model: F3Object, fx_points_model: bool = False, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    inst = fx_fwd if fx_points_model else xccy
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(inst),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', f'Default{ccy.name}']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_base_ois_dual_curve_async,
    add_ois_curve,
    add_irs_base_curve,
    extend_with_irs_3m_curve_async,
    add_irs_3m_curve,
    bootstrap_xccy_discount_curve_async,
    add_usd_collateral_discount_curve_async,
)

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_thb.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain import IRS, Rate, FXForward
from firm_domain.core import Ccy, Tenor
from firm_f3.mapping import f3instrument_strategy_async, f3discount_curve_tag_async, OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.THB
irs_base = IRS(ccy=ccy, tenor=Tenor.T_5Y)
irs_base_rate = Rate(ccy, irs_base.idx)
irs_6m = Rate(ccy, Tenor.T_6M)

assert irs_base_rate == irs_6m

fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)


async def bootstrap_base_irs_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(irs_base_rate),
        Instruments=await f3instrument_strategy_async(irs_base),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, "Anchored"],
        AdvancedConfiguration=['TargetMethod', 'DefaultUSD']
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_fx_fwd_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(fx_fwd),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', f'Default{ccy.name}']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_base_irs_curve_async,
    add_irs_base_curve,
    bootstrap_fx_fwd_discount_curve_async,
    add_usd_collateral_discount_curve_async,
)

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_try.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain import CrossCurrencySwap, FXForward
from firm_domain.core import Ccy, Tenor
from firm_f3.mapping import f3instrument_strategy_async, f3discount_curve_tag_async, OvernightUSD

INTERP_METHOD = 'LogLinear'

ccy = Ccy.TRY
ccs = CrossCurrencySwap(ccy=ccy, tenor=Tenor.T_1Y)
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)


async def bootstrap_ccs_discount_curve_async(f3model: F3Object, fx_points_model: bool = False, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    inst = fx_fwd if fx_points_model else ccs
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(inst),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['BoundConstraints', 'GreaterThanZero'],
            ['TargetMethod', 'DefaultUSD']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_ccs_discount_curve_async,
    add_usd_collateral_discount_curve_async,
)

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_twd.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain import IRS, Rate, FXForward
from firm_domain.core import Ccy, Tenor
from firm_f3.mapping import f3instrument_strategy_async, f3discount_curve_tag_async, OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.TWD
irs_base = IRS(ccy=ccy, tenor=Tenor.T_5Y)
irs_base_rate = Rate(ccy, irs_base.idx)
irs_3m = Rate(ccy, Tenor.T_3M)

assert irs_base_rate == irs_3m

fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)


async def bootstrap_base_irs_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(irs_base_rate),
        Instruments=await f3instrument_strategy_async(irs_base),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, "Anchored"],
        AdvancedConfiguration=['TargetMethod', 'DefaultUSD']
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_fx_fwd_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(fx_fwd),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', f'Default{ccy.name}']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


def bootstrap_3m_vol_cube(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    twd_swaption_tag_suffix = 'ParYieldCashSettledSwaption:FullCashSingleCurrencyCollateralInUSD'
    twd_swaption_tag_prefix = 'ParYieldCashSettledSwaption:IRS:3m:Taibor:3m:Relative:'
    twd_swaption_tags = {0: twd_swaption_tag_prefix + '0',
                         0.0025: twd_swaption_tag_prefix + '0.0025',
                         -0.0025: twd_swaption_tag_prefix + '-0.0025',
                         0.005: twd_swaption_tag_prefix + '0.005',
                         -.005: twd_swaption_tag_prefix + '-0.005',
                         0.01: twd_swaption_tag_prefix + '0.01',
                         -0.01: twd_swaption_tag_prefix + '-0.01'}

    return f3.ExtendModelWithInterpolatedVolatilityCube(
        BaseModel=f3model,
        CurveTag=['IRS:3m:Taibor:3m', 'NormalVolatility'],
        MarketDataTags=[
            [twd_swaption_tags[0], twd_swaption_tag_suffix],
            [twd_swaption_tags[0.0025], twd_swaption_tag_suffix],
            [twd_swaption_tags[-0.0025], twd_swaption_tag_suffix],
            [twd_swaption_tags[0.005], twd_swaption_tag_suffix],
            [twd_swaption_tags[-0.005], twd_swaption_tag_suffix],
            [twd_swaption_tags[0.01], twd_swaption_tag_suffix],
            [twd_swaption_tags[-0.01], twd_swaption_tag_suffix]
        ],
        ThreeDimInterpolationMethod='Linear',
        VolatilityConvention='Normal',
        Axes=['UnderlyingMaturity', 'OptionExpiry', 'Strike']
    )


def add_3m_vol_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = ['IRS:3m:Taibor:3m', 'Volatility']
    source_tag = ['IRS:3m:Taibro:3m', 'NormalVolatility']
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_base_irs_curve_async,
    add_irs_base_curve,
    bootstrap_fx_fwd_discount_curve_async,
    add_usd_collateral_discount_curve_async,
    bootstrap_3m_vol_cube,
    add_3m_vol_curve,
)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_usd.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client # type:ignore

from firm_domain.core import Ccy, Tenor
from firm_domain import IRS, TenorBasis
from firm_f3.mapping import f3instrument_type, f3instrument_strategy_async, f3discount_curve_tag_async, \
    OvernightUSD, LiborUSD3m, LiborUSD6m, LiborUSD1m, f3index

INTERP_METHOD = 'LogLinear'


async def bootstrap_discount_ois_libor_3m_dual_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    libor = IRS(ccy=Ccy.USD, tenor=Tenor.T_1Y)
    basis = TenorBasis(ccy=Ccy.USD, tenor=Tenor.T_1Y, idx_1=Tenor.T_1D, idx_2=Tenor.T_3M)

    ois_tag, libor_tag = await f3discount_curve_tag_async(OvernightUSD, LiborUSD3m)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            ois_tag,
            libor_tag
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=True,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(libor), None, None] + libor_tag,
            [f3instrument_type(basis), None, None] + ois_tag,
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(libor, basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(OvernightUSD)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_libor_3m_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(LiborUSD3m)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_discount_libor_1m_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    s1s3 = TenorBasis(ccy=Ccy.USD, tenor=Tenor.T_1Y, idx_1=Tenor.T_1M, idx_2=Tenor.T_3M)
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(LiborUSD1m),
        Instruments=await f3instrument_strategy_async(s1s3),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored']
    )


def add_libor_1m_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(LiborUSD1m)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_discount_libor_6m_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    s3s6 = TenorBasis(ccy=Ccy.USD, tenor=Tenor.T_1Y, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M)
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(LiborUSD6m),
        Instruments=await f3instrument_strategy_async(s3s6),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored']
    )


def add_libor_6m_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(LiborUSD6m)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def add_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async('USD')
    source_tag = await f3discount_curve_tag_async(OvernightUSD)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


def bootstrap_3m_vol_cube(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    usd_swaption_tag_suffix = 'VanillaSwaption:FullCashSingleCurrencyCollateralInUSD'
    usd_swaption_tag_prefix = 'VanillaSwaption:IRS:6m:USD LIBOR:3m:Relative:'

    usd_swaption_tags = {0: usd_swaption_tag_prefix + '0',
                         0.0025: usd_swaption_tag_prefix + '0.0025',
                         -0.0025: usd_swaption_tag_prefix + '-0.0025',
                         0.005: usd_swaption_tag_prefix + '0.005',
                         -.005: usd_swaption_tag_prefix + '-0.005',
                         0.01: usd_swaption_tag_prefix + '0.01',
                         -0.01: usd_swaption_tag_prefix + '-0.01'}

    return f3.ExtendModelWithInterpolatedVolatilityCube(
        BaseModel=f3model,
        CurveTag=['IRS:6m:USD LIBOR:3m', 'NormalVolatility'],
        MarketDataTags=[
            [usd_swaption_tags[0], usd_swaption_tag_suffix],
            [usd_swaption_tags[0.0025], usd_swaption_tag_suffix],
            [usd_swaption_tags[-0.0025], usd_swaption_tag_suffix],
            [usd_swaption_tags[0.005], usd_swaption_tag_suffix],
            [usd_swaption_tags[-0.005], usd_swaption_tag_suffix],
            [usd_swaption_tags[0.01], usd_swaption_tag_suffix],
            [usd_swaption_tags[-0.01], usd_swaption_tag_suffix]
        ],
        ThreeDimInterpolationMethod='Linear',
        VolatilityConvention='Normal',
        Axes=['UnderlyingMaturity', 'OptionExpiry', 'Strike']
    )


def add_3m_vol_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = ['IRS:6m:USD LIBOR:3m', 'Volatility']
    source_tag = ['IRS:6m:USD LIBOR:3m', 'NormalVolatility']
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_discount_ois_libor_3m_dual_curve_async,
    add_ois_curve,
    add_libor_3m_curve,
    bootstrap_discount_libor_1m_curve_async,
    add_libor_1m_curve,
    bootstrap_discount_libor_6m_curve_async,
    add_libor_6m_curve,
    add_discount_curve_async,
    bootstrap_3m_vol_cube,
    add_3m_vol_curve
)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\risk_model_zar.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
import firm_f3.f3client  # type:ignore

from firm_domain.core import Ccy, Tenor
from firm_domain import IRS, XccyBasis, Rate, TenorBasis, FXForward
from firm_f3.mapping import f3instrument_type, f3instrument_strategy_async, f3discount_curve_tag_async, \
    OvernightUSD, f3index

INTERP_METHOD = 'LogLinear'

ccy = Ccy.ZAR
irs_base = IRS(ccy=ccy, tenor=Tenor.T_5Y)
ois_basis = TenorBasis(ccy=ccy, tenor=Tenor.T_5Y, idx_1=Tenor.T_1D, idx_2=irs_base.idx)
xccy = XccyBasis(ccy=ccy, tenor=Tenor.T_5Y)
fx_fwd = FXForward(ccy=ccy, tenor=Tenor.T_1Y)

overnight_rate = Rate(ccy, Tenor.T_1D)
irs_base_rate = Rate(ccy, irs_base.idx)
irs_3m = Rate(ccy, Tenor.T_3M)

assert irs_base_rate == irs_3m


async def bootstrap_base_ois_dual_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    ois_tag, irs_tag = await f3discount_curve_tag_async(overnight_rate, irs_base_rate)

    calibration_target = f3.CreateOneDimensionalEntireCurveCalibrationTarget(
        CurveTags=[
            ois_tag,
            irs_tag
        ],
        InterpolationTypes=[
            INTERP_METHOD,
            INTERP_METHOD
        ],
        InitialValueCurves=[
            [1, 'Anchored'],
            [1, 'Anchored']
        ],
        OptimizationObjective='SingleCurrencyValue',
        UseHints=True,
        TimePointMethod=[
            ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None],
            [f3instrument_type(irs_base), None, None, *irs_tag],
            [f3instrument_type(ois_basis), None, None, *ois_tag],
        ]
    )

    return f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=calibration_target,
        InstrumentStrategy=await f3instrument_strategy_async(irs_base, ois_basis),
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod'
    )


def add_ois_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(overnight_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


def add_irs_base_curve(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    f3inst = f3index(irs_base_rate)
    return f3.AddImpliedRateCurveToModel(
        BaseModel=f3model,
        Index=f3inst,
        CollateralAgreement=f3inst
    )


async def bootstrap_xccy_discount_curve_async(f3model: F3Object, fx_points_model: bool = False, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    inst = fx_fwd if fx_points_model else xccy
    return f3.ExtendModelWithBootstrappedCurves(
        BaseModel=f3model,
        TargetCurves=await f3discount_curve_tag_async(ccy.name),
        Instruments=await f3instrument_strategy_async(inst),
        InterpolationMethods=INTERP_METHOD,
        InitialValueCurves=[1, 'Anchored'],
        AdvancedConfiguration=[
            ['OptimizationObjective', 'SingleCurrencyNumeraireValue'],
            ['TargetMethod', f'Default{ccy.name}']
        ]
    )


async def add_usd_collateral_discount_curve_async(f3model: F3Object, **kwargs):
    f3 = firm_f3.f3client.get_platform_client()
    target_tag = await f3discount_curve_tag_async((ccy, OvernightUSD))
    source_tag = await f3discount_curve_tag_async(ccy.name)
    return f3.ExtendModelWithClonedCurve(
        BaseModel=f3model,
        CurveTag=target_tag,
        SourceCurveTag=source_tag
    )


extensions = (
    bootstrap_base_ois_dual_curve_async,
    add_ois_curve,
    add_irs_base_curve,
    bootstrap_xccy_discount_curve_async,
    add_usd_collateral_discount_curve_async,
)

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\__init__.py
----------------------------------------
from firm_f3.fincadutil import get_exp_spline_interp_method

EXP_SPLINE_INTERP_METHOD = get_exp_spline_interp_method(0.1)

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_fragments\__pycache__\__init__.cpython-37.pyc
----------------------------------------
B

    y  dz                   @   s   d dl mZ ed ZdS )     ) get_exp_spline_interp_methodg       ?N)Zfirm_f3.fincadutilr   ZEXP_SPLINE_INTERP_METHOD  r   r    QE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/model_fragments/__init__.py <module>   s   
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_object\base_model.py
----------------------------------------
import asyncio
import datetime
from typing import Callable, List, Set, Optional

import pandas
from firm_f3.core.modelutils import create_collapsed_compounding_valspec
from f3sdk.f3 import F3Object  # type: ignore
from f3sdk.lib.coroutine import wait  # type: ignore

from firm_domain import Ccy, Tenor, Instrument, FXForward
import firm_f3.f3client
from firm_f3.datalayer.bbg_stream import (
    BBGIndexFixings as FixingsLoader,
    BBGCurveMarketDataSnapshot as MarketDataLoader,
    BBGMarketDataSnapshot as FxMarketDataLoader,
)
from firm_f3.core.orm import ModelFragment
from firm_f3.version import __version__

from .interpolation_method import F3Interpolation
from .util import extend_model_with_fixings, extend_model_with_market_data, extend_model_with_fx_market_data
from .meta_model import MetaModel


class BaseModel(metaclass=MetaModel):
    currency: Ccy = None
    numeraire_currency: Ccy = Ccy.USD
    interpolation_method: F3Interpolation = F3Interpolation.ExponentialTensionSpline

    fixings_day_range: int = 200  # calendar days from valuation_date
    fixings_loader = FixingsLoader
    fixings_hook: Callable = None
    market_data_loader = MarketDataLoader
    market_data_hook: Callable = None
    fx_market_data_loader = FxMarketDataLoader
    fx_market_data_hook: Callable = None

    def __init__(self, valuation_date: Optional[datetime.date] = None, currency: Optional[Ccy] = None):
        if valuation_date is None:
            valuation_date = datetime.date.today()
        self.valuation_date = valuation_date
        if currency is None:
            currency = type(self).currency
        self.currency = currency

    def __repr__(self) -> str:
        return f'{type(self).__name__}(valuation_date={self.valuation_date})'

    @property
    def currency_set(self) -> Set[Ccy]:
        return self._currency_set

    async def assemble_fragment_async(self, model: Optional[F3Object] = None) -> F3Object:
        f3 = firm_f3.f3client.get_platform_client()

        if model is None:
            model = f3.CreateEmptyModel(
                BaseDate=self.valuation_date,
                ValuationMethod='Default',
            )

        model = f3.ExtendModelWithValuationSpecification(model, create_collapsed_compounding_valspec())
        model = f3.ExtendModelWithFXRatesCurve(
            BaseModel=model,
            CurveTag=['UniqueFXRatesCurve', 'FXRates'],
            FXMarketDataTag=['UniqueFXRates', 'FXSpotQuotes'],
        )
        return model

    async def publish_fragment_async(self, model: F3Object = None, name_format: str = None) -> ModelFragment:
        if name_format is None:
            name_format = '{}'
        name_format += f'_{__version__}'
        name = name_format.format(type(self).__name__)
        fragment = await self.assemble_fragment_async(model)
        return await ModelFragment(name=name, definition=fragment).save_async()

    _cache_fixings: pandas.DataFrame = None

    @property
    def fixings_instruments(self) -> List[Instrument]:
        return self._fixings_instruments

    async def assemble_fixings_async(self, use_cache: bool = False) -> pandas.DataFrame:
        if use_cache and isinstance(self._cache_fixings, pandas.DataFrame):
            return self._cache_fixings

        instruments = self.fixings_instruments
        if instruments:
            as_of_date = self.valuation_date - datetime.timedelta(days=1)
            start_date = self.valuation_date - datetime.timedelta(days=self.fixings_day_range)
            fixings = await self.fixings_loader.get_many_by_instruments_async(instruments, as_of_date=as_of_date,
                                                                              start_date=start_date)
            fixing_data = await fixings.to_frame_async()

            if callable(self.fixings_hook):
                fixing_data = self.fixings_hook(fixing_data)

            self._cache_fixings = fixing_data
            return fixing_data

    _cache_market_data: pandas.DataFrame = None

    @property
    def market_data_instruments(self) -> List[Instrument]:
        return self._market_data_instruments

    async def assemble_market_data_async(self, use_cache: bool = False) -> pandas.DataFrame:
        if use_cache and isinstance(self._cache_market_data, pandas.DataFrame):
            return self._cache_market_data

        instruments = self.market_data_instruments
        if instruments:
            as_of_date = None if self.valuation_date == datetime.date.today() else self.valuation_date
            markets = await self.market_data_loader.get_many_by_instruments_async(instruments, as_of_date=as_of_date)
            market_data = await markets.to_frame_async()

            if callable(self.market_data_hook):
                market_data = self.market_data_hook(market_data)

            self._cache_market_data = market_data
            return market_data

    async def assemble_fx_market_data_async(self) -> pandas.Series:
        assert isinstance(self.currency, Ccy) and isinstance(self.numeraire_currency, Ccy)
        if self.currency is not self.numeraire_currency:
            inst = FXForward(self.currency, ccy_base=self.numeraire_currency, tenor=Tenor.SPOT)
            as_of_date = None if self.valuation_date == datetime.date.today() else self.valuation_date
            fx_market = await self.fx_market_data_loader.get_many_by_instruments_async([inst], as_of_date=as_of_date)
            fx_market_data = await fx_market.to_series_async()
        else:
            fx_market_data = pandas.Series({'EURUSD': 0.})  # dummy data

        if callable(self.fx_market_data_hook):
            fx_market_data = self.fx_market_data_hook(fx_market_data)
        return fx_market_data

    _cache_model: F3Object = None

    async def assemble_model_async(self, use_cache: bool = False) -> F3Object:
        if use_cache and isinstance(self._cache_model, F3Object):
            return self._cache_model

        model, fixing_data, market_data, fx_market_data = await asyncio.gather(
            self.assemble_fragment_async(),
            self.assemble_fixings_async(use_cache=use_cache),
            self.assemble_market_data_async(use_cache=use_cache),
            self.assemble_fx_market_data_async(),
        )
        if fixing_data is not None:
            model = extend_model_with_fixings(model, fixing_data)
        if market_data is not None:
            model = extend_model_with_market_data(model, market_data)
        model = extend_model_with_fx_market_data(model, fx_market_data)

        self._cache_model = model
        return model

    # make sync API

    def assemble_fragment(self, model: F3Object = None) -> F3Object:
        return wait(self.assemble_fragment_async(model=model))

    def assemble_fixings(self, use_cache: bool = False) -> pandas.DataFrame:
        return wait(self.assemble_fixings_async(use_cache=use_cache))

    def assemble_market_data(self, use_cache: bool = False) -> pandas.DataFrame:
        return wait(self.assemble_market_data_async(use_cache=use_cache))

    def assemble_fx_market_data(self) -> pandas.Series:
        return wait(self.assemble_fx_market_data_async())

    def assemble_model(self, use_cache: bool = False) -> F3Object:
        return wait(self.assemble_model_async(use_cache=use_cache))

    def publish_fragment(self, model: F3Object = None, name_format: str = None) -> ModelFragment:
        return wait(self.publish_fragment_async(model=model, name_format=name_format))


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_object\calculator.py
----------------------------------------
from __future__ import annotations
import datetime
from collections import defaultdict
from typing import Callable, List, Dict

import pandas
from f3sdk.f3 import F3Object  # type: ignore

from firm_domain import Tenor, Instrument, instrument_factory, FXForward, FXForwardOutright
from firm_f3.mapping import f3instrument_type
from firm_f3.evaluate import par_rate_async, raise_if_error
from firm_f3.modelconfig import get_curve_ins_max_tenor
from firm_f3.util.f3utils import make_wait
from .base_model import BaseModel

DEFAULT_RISK_TENORS = (
    Tenor.T_1M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M,
    Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y,
    Tenor.T_6Y, Tenor.T_7Y, Tenor.T_8Y, Tenor.T_9Y, Tenor.T_10Y,
    Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y, Tenor.T_30Y, Tenor.T_60Y
)

DEFAULT_FX_RISK_TENORS = (
    Tenor.T_2D, Tenor.T_1W, Tenor.T_2W,
    Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_4M, Tenor.T_5M, Tenor.T_6M,
    Tenor.T_7M, Tenor.T_8M, Tenor.T_9M, Tenor.T_10M, Tenor.T_11M, Tenor.T_12M,
    Tenor.T_15M, Tenor.T_18M, Tenor.T_21M, Tenor.T_24M,
)

DEFAULT_INFLATION_RISK_TENORS = (
    Tenor.T_1M, Tenor.T_3M, Tenor.T_6M, Tenor.T_9M,
    Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y,
    Tenor.T_6Y, Tenor.T_7Y, Tenor.T_8Y, Tenor.T_9Y, Tenor.T_10Y,
    Tenor.T_12Y, Tenor.T_15Y, Tenor.T_20Y, Tenor.T_30Y,
)


async def derived_quotes_by_instruments_async(instruments: List[Instrument], f3model: F3Object) -> List[float]:
    def is_fx_points(x):
        return isinstance(x, FXForward) and not isinstance(x, FXForwardOutright)

    # noinspection PyUnresolvedReferences
    fx_spot_idx = {(i.ccy_base, i.ccy): None for i in instruments if is_fx_points(i)}

    def par_rate_instruments():
        idx = None
        for idx, i in enumerate(instruments):
            if is_fx_points(i):
                if i.tenor is Tenor.SPOT:
                    # noinspection PyUnresolvedReferences
                    fx_spot_idx[i.ccy_base, i.ccy] = idx
            yield i
        for (ccy_base, ccy), v in fx_spot_idx.items():
            if v is None:
                idx += 1
                fx_spot_idx[ccy_base, ccy] = idx
                yield FXForward(ccy=ccy, ccy_base=ccy_base, tenor=Tenor.SPOT)

    res = await par_rate_async(list(par_rate_instruments()), f3model=f3model)

    def unpack():
        for inst, rate in zip(instruments, res):
            raise_if_error(rate)
            if is_fx_points(inst):
                # noinspection PyUnresolvedReferences
                fx_spot = res[fx_spot_idx[inst.ccy_base, inst.ccy]]
                raise_if_error(fx_spot)
                rate -= fx_spot
            yield rate

    return list(unpack())


class RiskTenorCalculator:
    max_tenors = get_curve_ins_max_tenor()

    def __init__(self, model_factory: Callable[[datetime.date], BaseModel],
                 risk_tenors: List[Tenor] = DEFAULT_RISK_TENORS):
        self.model_factory = model_factory
        self.model_instance = model_factory(datetime.date.today())
        self.risk_tenors = risk_tenors
        self.instruments: List[Instrument] = []

    def __repr__(self) -> str:
        return f'{type(self).__name__}({self.model_factory.__name__})'

    async def get_many_by_instruments_async(self, instruments: List[Instrument],
                                            as_of_date: datetime.date = None) -> RiskTenorCalculator:
        if as_of_date is None:
            as_of_date = datetime.date.today()
        if as_of_date != self.model_instance.valuation_date:
            self.model_instance = self.model_factory(as_of_date)

        def unpack_instruments():
            for inst_type in instruments:
                inst_factory = instrument_factory(inst_type)
                max_tenor = self.max_tenors[inst_type.ccy]
                for t in self.risk_tenors:
                    if t <= max_tenor:
                        try:
                            yield inst_factory(t)
                        except ValueError:
                            pass

        self.instruments = list(unpack_instruments())
        return self

    async def to_dict_async(self) -> Dict:
        model = await self.model_instance.assemble_model_async(use_cache=True)
        res = await derived_quotes_by_instruments_async(self.instruments, f3model=model)
        rv = defaultdict(dict)
        for inst, rate in zip(self.instruments, res):
            rv[f3instrument_type(inst)][inst.tenor] = rate
        return rv

    async def to_frame_async(self) -> pandas.DataFrame:
        raw = await self.to_dict_async()
        return pandas.DataFrame(raw).sort_index()

    get_many_by_instruments = make_wait(get_many_by_instruments_async)
    to_dict = make_wait(to_dict_async)
    to_frame = make_wait(to_frame_async)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_object\dispatcher.py
----------------------------------------
import logging
import datetime
from collections import defaultdict
from functools import singledispatch
from typing import Dict, Tuple, List, Iterable

from f3sdk.f3 import F3Object  # type: ignore
from f3sdk.lib.coroutine import wait  # type: ignore

from firm_domain import Ccy, Trade, IRSTrade, FXForwardTrade, XccyBasisTrade, CrossCurrencySwapTrade, SwaptionTrade, \
    CashFlow, OISTrade, TenorBasisTrade, TRSTrade, FutureTrade
from firm_f3.core.modelutils import get_model_async
from . import instance

logger = logging.getLogger(__name__)


async def gather_models_async(
        trades: Iterable[Trade],
        valuation_date: datetime.date
) -> List[Tuple[F3Object, List[Trade]]]:
    models = await find_models_async(trades, valuation_date=valuation_date)
    rv = defaultdict(list)
    for m, t in zip(models, trades):
        rv[m].append(t)
    return list(rv.items())


def gather_models(trades: Iterable[Trade], valuation_date: datetime.date) -> List[Tuple[F3Object, List[Trade]]]:
    return wait(gather_models_async(trades=trades, valuation_date=valuation_date))


async def find_models_async(trades: Iterable[Trade], valuation_date: datetime.date) -> List[F3Object]:
    if not isinstance(trades, Iterable):
        trades = [trades]

    async def unpack():
        for i, t in enumerate(trades):
            assert isinstance(t, Trade), f'i={i} expected Trade object, got {type(t)} instead'
            yield await _dispatch(t, valuation_date=valuation_date)

    return [i async for i in unpack()]


def find_models(trades: Iterable[Trade], valuation_date: datetime.date) -> List[F3Object]:
    return wait(find_models_async(trades=trades, valuation_date=valuation_date))


DEFAULT_MODELS: Dict[datetime.date, F3Object] = {}


async def _default_model(valuation_date: datetime.date) -> F3Object:
    try:
        model = DEFAULT_MODELS[valuation_date]
    except KeyError:
        logger.debug(f'assemble model for valuation_date={valuation_date}')
        model = DEFAULT_MODELS[valuation_date] = await get_model_async(as_of=valuation_date)
    return model


PLACEHOLDER_MODELS: Dict[datetime.date, F3Object] = {}


async def _placeholder_model(valuation_date: datetime.date) -> F3Object:
    try:
        model = PLACEHOLDER_MODELS[valuation_date]
    except KeyError:
        logger.debug(f'assemble model for valuation_date={valuation_date}')
        model = PLACEHOLDER_MODELS[valuation_date] = await instance.USD.USDModelBasic(
            valuation_date).assemble_model_async()
    return model


RATES_MODELS: Dict[Tuple[datetime.date, Ccy], F3Object] = {}


async def _rates_model(valuation_date: datetime.date, ccy: Ccy) -> F3Object:
    try:
        return RATES_MODELS[valuation_date, ccy]
    except KeyError:
        pass

    try:
        mod = getattr(instance, str(ccy))
        cls = getattr(mod, f'{ccy}Model')
    except AttributeError:
        return await _default_model(valuation_date)

    logger.debug(f'assemble model for valuation_date={valuation_date} ccy={ccy}')
    model = RATES_MODELS[valuation_date, ccy] = await cls(valuation_date).assemble_model_async()
    return model


SWAPTION_MODELS: Dict[Tuple[datetime.date, Ccy], F3Object] = {}


async def _swaption_model(valuation_date: datetime.date, ccy: Ccy) -> F3Object:
    try:
        return SWAPTION_MODELS[valuation_date, ccy]
    except KeyError:
        pass

    if ccy is Ccy.USD:
        logger.debug(f'assemble model for valuation_date={valuation_date} ccy={ccy}')
        model = SWAPTION_MODELS[valuation_date, ccy] = await instance.USD.USDModelSwaption(
            valuation_date).assemble_model_async()
    elif ccy is Ccy.EUR:
        logger.debug(f'assemble model for valuation_date={valuation_date} ccy={ccy}')
        model = SWAPTION_MODELS[valuation_date, ccy] = await instance.EUR.EURModelSwaption(
            valuation_date).assemble_model_async()
    else:
        model = await _default_model(valuation_date)
    return model


@singledispatch
async def _dispatch(trade: Trade, valuation_date: datetime.date) -> F3Object:
    return await _default_model(valuation_date)


@_dispatch.register(TRSTrade)
@_dispatch.register(FutureTrade)
async def _dispatch_by_placeholder_trade(trade, valuation_date: datetime.date) -> F3Object:
    return await _placeholder_model(valuation_date)


@_dispatch.register(OISTrade)
@_dispatch.register(IRSTrade)
@_dispatch.register(CashFlow)
@_dispatch.register(TenorBasisTrade)
async def _dispatch_by_single_ccy_trade(trade, valuation_date: datetime.date) -> F3Object:
    return await _rates_model(valuation_date, trade.ccy)


@_dispatch.register(XccyBasisTrade)
@_dispatch.register(FXForwardTrade)
@_dispatch.register(CrossCurrencySwapTrade)
async def _dispatch_by_dual_ccy_trade(trade, valuation_date: datetime.date) -> F3Object:
    if trade.ccy is Ccy.USD:
        return await _rates_model(valuation_date, trade.ccy_base)
    elif trade.ccy_base is Ccy.USD:
        return await _rates_model(valuation_date, trade.ccy)
    return await _default_model(valuation_date)


@_dispatch.register
async def _dispatch_by_swaption_trade(trade: SwaptionTrade, valuation_date: datetime.date) -> F3Object:
    return await _swaption_model(valuation_date, trade.ccy)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_object\inflation_model.py
----------------------------------------
import asyncio
import datetime
from typing import List
import pandas
from f3sdk.f3 import F3Object  # type: ignore

from firm_domain import Instrument, InflationSwap, InflationIndex, Conventions
import firm_f3.f3client
from firm_f3.mapping import f3index, f3instrument_type, f3seasonality, req_market_data_tag_single
from firm_f3.evaluate import f3_evaluate_async, scalar_handler

from .base_model import BaseModel
from .interpolation_method import F3Interpolation


class InflationSwapMixIn(BaseModel):
    inflation_interpolation_method = F3Interpolation.LogLinear
    inflation_index_fixings_day_range: int = 365 * 5 + 20  # calendar days from valuation_date

    @property
    def inflation_indices(self) -> List[InflationIndex]:
        return [i for i, c in Conventions.INFLATION_INDEX_TO_CCY_MAPPING.items() if c in self.currency_set]

    @property
    def inflation_swap_instruments(self) -> List[InflationSwap]:
        return [InflationSwap(i, tenor=None) for i in self.inflation_indices]

    @property
    def fixings_instruments(self) -> List[Instrument]:
        return self._fixings_instruments + self.inflation_indices

    @property
    def market_data_instruments(self) -> List[Instrument]:
        return self._market_data_instruments + self.inflation_swap_instruments

    async def assemble_fixings_async(self, use_cache: bool = False) -> pandas.DataFrame:
        if use_cache and isinstance(self._cache_fixings, pandas.DataFrame):
            return self._cache_fixings

        instruments = self.fixings_instruments
        if instruments:
            inst = self.inflation_indices
            as_of_date = self.valuation_date
            start_date = self.valuation_date - datetime.timedelta(days=self.inflation_index_fixings_day_range)
            inflation_fixings = await self.fixings_loader.get_many_by_instruments_async(inst, as_of_date=as_of_date,
                                                                                        start_date=start_date)

            inst = instruments[:-len(inst)]
            as_of_date = self.valuation_date - datetime.timedelta(days=1)
            start_date = self.valuation_date - datetime.timedelta(days=self.fixings_day_range)
            rates_fixings = await self.fixings_loader.get_many_by_instruments_async(inst, as_of_date=as_of_date,
                                                                                    start_date=start_date)

            rates_data, inflation_data = await asyncio.gather(
                rates_fixings.to_frame_async(),
                inflation_fixings.to_frame_async(),
            )
            idx_type = type(inflation_data.index[0])
            inflation_data.index = inflation_data.index.values.astype('datetime64[M]').astype(idx_type)
            fixing_data = pandas.concat([rates_data, inflation_data], axis=1, sort=False)

            if callable(self.fixings_hook):
                fixing_data = self.fixings_hook(fixing_data)

            self._cache_fixings = fixing_data
            return fixing_data

    async def assemble_fragment_async(self, model: F3Object = None) -> F3Object:
        if model is None:
            model = await super().assemble_fragment_async()

        f3 = firm_f3.f3client.get_platform_client()
        for idx in self.inflation_indices:
            assert isinstance(idx, InflationIndex)
            index = f3index(idx)
            swap_inst = f3instrument_type(InflationSwap(idx, tenor=None))
            seasonality_inst, seasonality_labels = f3seasonality(idx)
            dummy_data = f3.CreateLabelledValuesMarketData(
                InstrumentType=seasonality_inst,
                Values=[0 for _ in seasonality_labels]
            )

            inf_curve, seasonality_curve, seasonality_data_tag = await f3_evaluate_async([
                f3.InflationCurveTag(index),
                f3.InflationSeasonalityCurveTag(index),
                req_market_data_tag_single(dummy_data),
            ], callback=scalar_handler)

            model = f3.ExtendModelWithBootstrappedCurves(
                BaseModel=model,
                TargetCurves=inf_curve,
                Instruments=f3.CreateElementInstrumentStrategy(swap_inst),
                InterpolationMethods=self.inflation_interpolation_method.name,
                InitialValueCurves=[1, 'Anchored']
            )

            model = f3.ExtendModelWithZeroDimensionalCurve(
                BaseModel=model,
                CurveTag=[index, 'SeasonalAdjustments'],
                MarketDataTag=seasonality_data_tag
            )

            model = f3.ExtendModelWith1dFunctionCurve(
                BaseModel=model,
                CurveTag=[index, 'SeasonalityConverter'],
                OneDimensionalFunction='Exponential'
            )

            model = f3.ExtendModelWithMonthlyInflationSeasonalityCurve(
                BaseModel=model,
                CurveTag=seasonality_curve,
                AdjustmentsTag=[index, 'SeasonalAdjustments'],
                ConverterFunctionTag=[index, 'SeasonalityConverter'],
                Normalize=True
            )

        return model


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_object\interpolation_method.py
----------------------------------------
from enum import Enum


class F3Interpolation(Enum):
    Linear = 'Linear'
    LogLinear = 'LogLinear'
    ExponentialTensionSpline = 'ExponentialTensionSpline_0.10'

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_object\meta_model.py
----------------------------------------
from typing import Tuple, Dict, List, Set
from f3sdk.f3 import F3Object  # type: ignore
from firm_domain import Ccy, Tenor, Instrument, Rate, FXForward

import firm_f3.f3client
from firm_f3.util.utils import flatten
from firm_f3.mapping import f3instrument_strategy_async

from .interpolation_method import F3Interpolation
from .util import extend_model_with_one_dimensional_calibrated_curve_async, \
    extend_model_with_dual_curve_calibration_async


class MetaModel(type):
    numeraire_currency: Ccy
    interpolation_method: F3Interpolation

    def __init__(cls, name, bases: Tuple[type] = None, dct: Dict = None):
        super().__init__(name, bases, dct)
        assert isinstance(cls.numeraire_currency, Ccy)
        assert isinstance(cls.interpolation_method, F3Interpolation)
        cls._currency_set = cls.__currency_set()
        cls._fixings_instruments = cls.__fixings_instruments()
        cls._market_data_instruments = cls.__market_data_instruments()

    def __currency_set(cls) -> Set[Ccy]:
        def unpack():
            for i in cls.mro():
                ccy = getattr(i, 'currency', None)
                if isinstance(ccy, Ccy):
                    yield ccy

        return set(unpack())

    def __fixings_instruments(cls) -> List[Instrument]:
        def unpack():
            quote_currency = set()
            for parent in reversed(cls.mro()):
                try:
                    src = getattr(parent, f'_{parent.__name__}__source_instruments')
                except AttributeError:
                    continue
                for inst in src:
                    if isinstance(inst, Rate):
                        yield inst
                    elif isinstance(inst, str):
                        quote_currency.add(Ccy[inst])

            for ccy in quote_currency:
                if ccy is not cls.numeraire_currency:
                    yield FXForward(ccy, ccy_base=cls.numeraire_currency, tenor=Tenor.SPOT)

        return list(unpack())

    def __market_data_instruments(cls) -> List[Instrument]:
        def unpack():
            unique_inst = set()
            for parent in reversed(cls.mro()):
                try:
                    src = getattr(parent, f'_{parent.__name__}__source_instruments')
                except AttributeError:
                    continue
                for inst in flatten(src.values()):
                    if isinstance(inst, Instrument) and inst not in unique_inst:
                        yield inst
                        unique_inst.add(inst)

        return list(unpack())


class FragmentAssembler:
    def __set_name__(self, owner: type, name: str):
        self.owner = owner
        self.name = name

    def __init__(self, owner: type = None, name: str = None):
        self.__set_name__(owner, name)
        self.instance = None

    def __get__(self, instance, owner: type = None):
        self.instance = instance
        return self

    def __repr__(self):
        if self.instance:
            return f'<bound descriptor {self.owner.__name__}.{self.name} of {self.instance}>'
        return super().__repr__()

    async def __call__(self, model: F3Object = None) -> F3Object:
        if model is None:
            # noinspection PyUnresolvedReferences
            return await super(self.owner, self.instance).assemble_fragment_async()
        return model


class MultiCurveAssembler(FragmentAssembler):
    async def __call__(self, model: F3Object = None) -> F3Object:
        model = await super().__call__(model)
        interpolation_method = getattr(self.owner, 'interpolation_method', F3Interpolation.ExponentialTensionSpline)
        source_instruments = getattr(self.owner, f'_{self.owner.__name__}__source_instruments')

        return await extend_model_with_dual_curve_calibration_async(
            model, target_spec=source_instruments, interpolation_types=interpolation_method)


class MultiCurveConstruction(MetaModel):
    def __init__(cls, name, bases: Tuple[type] = None, dct: Dict = None):
        if hasattr(cls, f'_{cls.__name__}__source_instruments') and 'assemble_fragment_async' not in dct:
            cls.assemble_fragment_async = MultiCurveAssembler(cls, 'assemble_fragment_async')
        MetaModel.__init__(cls, name, bases, dct)


class SingleCurveAssembler(FragmentAssembler):
    async def __call__(self, model: F3Object = None) -> F3Object:
        model = await super().__call__(model)
        interpolation_method = getattr(self.owner, 'interpolation_method', F3Interpolation.ExponentialTensionSpline)
        source_instruments = getattr(self.owner, f'_{self.owner.__name__}__source_instruments')

        for target, instruments in source_instruments.items():
            inst_strategy = await f3instrument_strategy_async(*instruments)
            model = await extend_model_with_one_dimensional_calibrated_curve_async(
                model, target, inst_strategy, interpolation_types=interpolation_method)
            if isinstance(target, str):
                f3 = firm_f3.f3client.get_platform_client()
                model = f3.ExtendModelWithClonedCurve(
                    BaseModel=model,
                    CurveTag=[target, 'DiscountCurve-CollateralRate-USD O/N:1b'],
                    SourceCurveTag=[target, 'DiscountCurve'],
                )
        return model


class SingleCurveConstruction(MultiCurveConstruction):
    def __init__(cls, name, bases: Tuple[type] = None, dct: Dict = None):
        if hasattr(cls, f'_{cls.__name__}__source_instruments') and 'assemble_fragment_async' not in dct:
            cls.assemble_fragment_async = SingleCurveAssembler(cls, 'assemble_fragment_async')
        MetaModel.__init__(cls, name, bases, dct)


if __name__ == '__main__':
    pass
    # from firm_f3.model_object.instance.EUR import *
    # from firm_f3.util.f3ml import *
    #
    # self = EURRiskModelRates()
    # model = self.assemble_model()
    # show(model, './tmp/tmp_old.py')
    #
    # show(model, './tmp/tmp_new.py')

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_object\swaption_model.py
----------------------------------------
import logging
import asyncio
import itertools
from collections import defaultdict
from typing import Callable, List

import pandas
from f3sdk.f3 import F3Object  # type: ignore

from firm_domain import Tenor, Swaption, SabrCoefficient
import firm_f3.f3client
from firm_f3.util.f3utils import make_wait
from firm_f3.mapping import f3instrument_type, f3quote_spec, f3products_from_instruments, f3market_convention_async, \
    f3market_data_tag_async
from firm_f3.evaluate import f3_evaluate_async, scalar_handler, value_product_async, req_valuation_date_single

# from firm_f3.datalayer.swaption_csv import FlatFileMarketDataStream as SwaptionDataLoader
from firm_f3.core.orm import MarketDataStream as SwaptionDataLoader
from .base_model import BaseModel
from .util import extend_model_with_swaption_data

logger = logging.getLogger(__name__)


class SabrSwaptionMixIn(BaseModel):
    swaption_data_instrument: Swaption = None
    swaption_data_loader = SwaptionDataLoader
    swaption_data_hook: Callable = None
    sabr_shift = 0.025
    sabr_beta = 0.5

    _cache_swaption_data: pandas.DataFrame = None

    async def assemble_swaption_data_async(self, use_cache: bool = False) -> pandas.DataFrame:
        if use_cache and isinstance(self._cache_swaption_data, pandas.DataFrame):
            return self._cache_swaption_data

        inst = self.swaption_data_instrument
        if inst is None:
            inst = Swaption(self.currency, expiry=None, tenor=None)
        as_of_date = self.valuation_date
        markets = await self.swaption_data_loader.get_many_by_instruments_async([inst], as_of_date=as_of_date)
        market_data = await markets.to_frame_async()

        if callable(self.swaption_data_hook):
            market_data = self.swaption_data_hook(market_data)

        market_data.columns.name = inst
        self._cache_swaption_data = market_data
        return market_data

    async def assemble_fragment_async(self, model: F3Object = None) -> F3Object:
        if model is None:
            model = await super().assemble_fragment_async()

        f3 = firm_f3.f3client.get_platform_client()
        val_date = req_valuation_date_single(model)
        raw = await self.assemble_swaption_data_async(use_cache=True)
        inst_type = f3instrument_type(raw.columns.name)
        expiry_spec = list(map(lambda x: f3quote_spec(x, val_date), raw.index))
        tenor_spec = list(map(lambda x: f3quote_spec(x, val_date), raw.columns.levels[1]))
        strike_spec = [['ATM', i] for i in raw.columns.levels[0]]

        def market_data_type():
            for strike in strike_spec:
                yield f3.CreateCommonStrikeSwaptionMarketData(
                    InstrumentType=inst_type,
                    Strike=strike,
                )

        vol_tag, market_data_tags, market_conv = await asyncio.gather(
            f3_evaluate_async(f3.VolatilityCurveTag(inst_type), callback=scalar_handler),
            f3market_data_tag_async(*market_data_type()),
            f3market_convention_async(inst_type),
        )

        model = f3.ExtendModelWithInterpolatedVolatilityCube(
            BaseModel=model,
            CurveTag=[vol_tag[0], 'InterpolatedVolatility'],
            MarketDataTags=market_data_tags,
            ThreeDimInterpolationMethod='Linear',
            VolatilityConvention='Normal',
            Axes=['UnderlyingMaturity', 'OptionExpiry', 'Strike'],
        )

        model = f3.ExtendModelWithSimpleInterpolationCurve(
            BaseModel=model,
            CurveTag=['SABRShift', '1dCurve'],
            InterpolationData=[[i, self.sabr_shift] for i in expiry_spec],
            InterpolationMethod='Linear',
        )
        model = f3.ExtendModelWithParameterizedCurves(
            BaseModel=model,
            Expressions='shift(t,T)=shift1d(t)',
            TargetCurves=['shift', 'SABRShift', 'Curve'],
            Parameters=None,
            Functions=['shift1d', 'SABRShift', '1dCurve'],
        )

        model = f3.ExtendModelWithSimpleInterpolationCurve(
            BaseModel=model,
            CurveTag=['Beta', '1dCurve'],
            InterpolationData=[[i, self.sabr_beta] for i in expiry_spec],
            InterpolationMethod='Linear',
        )

        model = f3.ExtendModelWithSimpleInterpolationCurve(
            BaseModel=model,
            CurveTag=['Rho', '1dCurve'],
            InterpolationData=[[i, 0.] for i in expiry_spec],
            InterpolationMethod='Linear',
        )

        model = f3.ExtendModelWithSimpleInterpolationCurve(
            BaseModel=model,
            CurveTag=['Nu', '1dCurve'],
            InterpolationData=[[i, 0.5] for i in expiry_spec],
            InterpolationMethod='Linear',
        )

        def inst_strategy():
            for tenor in tenor_spec:
                yield f3.CreateSwaptionFixedTenorInstrumentStrategyCollectionFromInstrumentType(
                    SwapLength=tenor,
                    Expiries=expiry_spec,
                    Strikes=strike_spec,
                    InstrumentType=inst_type,
                )

        if market_conv is None:
            # jchi@202001
            # if market_conv is not evaluated properly, this could cause the swaption calibration to fail
            logger.warning(f'market_conv=None @ {type(self)}')

        model = f3.ExtendModelWithCalibratedSABRFixedAlphaATMVolatilityCube(
            BaseModel=model,
            CurveTag=vol_tag,
            SourceCurveTag=[vol_tag[0], 'InterpolatedVolatility'],
            UnderlyingMaturities=tenor_spec,
            MarketConvention=market_conv,
            InstrumentStrategies=list(inst_strategy()),
            BetaGuesses=['Beta', '1dCurve', False],
            RhoGuesses=['Rho', '1dCurve', False],
            NuGuesses=['Nu', '1dCurve', False],
            KeepFixed=0,
            Optimizer=f3.CreateLevenbergMarquardtLeastSquaresOptimizer(
                Tolerance=1e-9,
                MaxIterations=30,
                LikelihoodRiskBump=1e-9,
                CollectDiagnostics=False,
                NotionalFactor=None,
            ),
            Constraints=[['Range', -0.98, 0.98],
                         ['Range', 0.001, 0.9]],
            InterpolationMethod='Linear',
            ShiftCurveTag=['SABRShift', 'Curve'],
            UseHints=True,
        )

        return model

    async def assemble_model_async(self, use_cache: bool = False) -> F3Object:
        if use_cache and isinstance(self._cache_model, F3Object):
            return self._cache_model

        model = await super().assemble_model_async(use_cache=False)
        model = extend_model_with_swaption_data(model, self._cache_swaption_data)

        self._cache_model = model
        return model

    async def value_atm_async(self, requests: str, expiry_spec: List[Tenor] = None,
                              tenor_spec: List[Tenor] = None) -> pandas.DataFrame:
        f3 = firm_f3.f3client.get_platform_client()
        inst_type = f3instrument_type(Swaption(self.currency, None, None))

        model, vol_tag = await asyncio.gather(
            self.assemble_model_async(use_cache=True),
            f3_evaluate_async(f3.VolatilityCurveTag(inst_type), callback=scalar_handler),
        )
        val_spec = f3.CreateCurveTagReplacementValuationSpecificationBuilder(
            SourceCurveTag=vol_tag,
            ReplacementCurveTag=[vol_tag[0], 'InterpolatedVolatility'],
        )

        if expiry_spec is None:
            expiry_spec = list(self._cache_swaption_data.index)
        if tenor_spec is None:
            tenor_spec = list(self._cache_swaption_data[0].columns)

        products = [f3products_from_instruments(Swaption(self.currency, exp, tenor), valuation_date=self.valuation_date)
                    for exp, tenor in itertools.product(expiry_spec, tenor_spec)]
        res = await value_product_async(products, f3model=model, valuation_method=val_spec, requests=requests,
                                        callback=scalar_handler)

        raw = defaultdict(dict)
        for (exp, tenor), val in zip(itertools.product(expiry_spec, tenor_spec), res):
            raw[tenor][exp] = val
        return pandas.DataFrame(raw).T.sort_index().T.sort_index()

    async def imply_atm_forward_async(self, expiry_spec: List[Tenor] = None,
                                      tenor_spec: List[Tenor] = None) -> pandas.DataFrame:
        return await self.value_atm_async(requests='OptionForward', expiry_spec=expiry_spec, tenor_spec=tenor_spec)

    async def imply_atm_vol_async(self, expiry_spec: List[Tenor] = None,
                                  tenor_spec: List[Tenor] = None) -> pandas.DataFrame:
        return await self.value_atm_async(requests='OptionImpliedNormalVolatility', expiry_spec=expiry_spec,
                                          tenor_spec=tenor_spec)

    async def value_skew_async(self, requests: str, expiry: Tenor = Tenor.T_1Y, tenor: Tenor = Tenor.T_1Y,
                               strike_spec: List[float] = None) -> pandas.DataFrame:
        if isinstance(expiry, str):
            expiry = Tenor.parse(expiry)
        if isinstance(tenor, str):
            tenor = Tenor.parse(tenor)
        if strike_spec is None:
            strike_spec = [-.02, -.01, -.0075, -.005, -.0025, 0., .0025, .005, .0075, .01, .02]

        f3 = firm_f3.f3client.get_platform_client()
        inst_type = f3instrument_type(Swaption(self.currency, None, None))

        model, vol_tag = await asyncio.gather(
            self.assemble_model_async(use_cache=True),
            f3_evaluate_async(f3.VolatilityCurveTag(inst_type), callback=scalar_handler),
        )
        val_spec = f3.CreateCurveTagReplacementValuationSpecificationBuilder(
            SourceCurveTag=vol_tag,
            ReplacementCurveTag=[vol_tag[0], 'InterpolatedVolatility'],
        )

        products = [
            f3products_from_instruments(Swaption(self.currency, expiry, tenor, stk), valuation_date=self.valuation_date)
            for stk in strike_spec]
        mkt_vol, sabr_vol = await asyncio.gather(
            value_product_async(products, f3model=model, valuation_method=val_spec,
                                requests=requests, callback=scalar_handler),
            value_product_async(products, f3model=model, valuation_method='Default',
                                requests=requests, callback=scalar_handler),
        )
        return pandas.DataFrame(list(map(list, zip(mkt_vol, sabr_vol))), index=strike_spec,
                                columns=['MarketVol', 'SABRVol']).sort_index()

    async def imply_vol_skew_async(self, expiry: Tenor = Tenor.T_1Y, tenor: Tenor = Tenor.T_1Y,
                                   strike_spec: List[float] = None) -> pandas.DataFrame:
        return await self.value_skew_async('OptionImpliedNormalVolatility', expiry=expiry, tenor=tenor,
                                           strike_spec=strike_spec)

    async def imply_sabr_params_async(self, sabr_param: SabrCoefficient = None, *sabr_params) -> pandas.DataFrame:
        if sabr_param is None:
            sabr_param, *sabr_params = 'Rho', 'Nu'

        f3 = firm_f3.f3client.get_platform_client()
        inst_type = f3instrument_type(Swaption(self.currency, None, None))

        model, (vol_tag, _) = await asyncio.gather(
            self.assemble_model_async(use_cache=True),
            f3_evaluate_async(f3.VolatilityCurveTag(inst_type), callback=scalar_handler),
        )
        val_date = req_valuation_date_single(model)
        expiry_spec = list(self._cache_swaption_data.index)
        tenor_spec = list(self._cache_swaption_data.columns.levels[1])

        def model_time(maturity_spec):
            for mat in maturity_spec:
                yield f3.ModelTime(
                    Model=model,
                    Date=f3.MaturityDate(
                        StartDate=self.valuation_date,
                        Maturity=f3quote_spec(mat, val_date),
                        MaturityConvention=inst_type,
                    ),
                )

        expiry, tenors = await f3_evaluate_async(list(model_time(expiry_spec)), list(model_time(tenor_spec)),
                                                 callback=scalar_handler)

        async def job(sabr: SabrCoefficient):
            if isinstance(sabr, str):
                sabr = SabrCoefficient.parse(sabr)

            def req():
                curve_tag = [
                    f'{vol_tag} {sabr.name.lower()}CalibratedSurface',
                    'InternalCalibrationCurve:VolCube:ShiftedSABRFixedAlphaATM'
                ]
                for exp, tenor in itertools.product(expiry, tenors):
                    yield f3.ExtractTwoDimensionalCurveValues(
                        Model=model,
                        CurveTag=curve_tag,
                        EvaluationPointsX=exp,
                        EvaluationPointsY=tenor,
                    )

            values = await f3_evaluate_async(list(req()), callback=scalar_handler)
            raw = defaultdict(dict)
            for (exp, tenor), val in zip(itertools.product(expiry_spec, tenor_spec), values):
                raw[tenor][exp] = val
            return pandas.DataFrame(raw)

        if sabr_params:
            all_params = [sabr_param, *sabr_params]
            res = await asyncio.gather(*(job(i) for i in all_params))
            for v, param in zip(res, all_params):
                v.columns = pandas.MultiIndex.from_product([[param], v.columns])
            df = pandas.concat(res, axis=1)
        else:
            df = await job(sabr_param)
        return df.T.sort_index().T.sort_index()

    assemble_swaption_data = make_wait(assemble_swaption_data_async)
    value_atm = make_wait(value_atm_async)
    imply_atm_forward = make_wait(imply_atm_forward_async)
    imply_atm_vol = make_wait(imply_atm_vol_async)
    value_skew = make_wait(value_skew_async)
    imply_vol_skew = make_wait(imply_vol_skew_async)
    imply_sabr_params = make_wait(imply_sabr_params_async)


def swaption_data_hook_factory(expiry_spec: Callable = None, tenor_spec: Callable = None,
                               strike_spec: Callable = None) -> Callable:
    def all_true(*args):
        return True

    if expiry_spec is None:
        expiry_spec = all_true
    if tenor_spec is None:
        tenor_spec = all_true
    if strike_spec is None:
        strike_spec = all_true

    def swaption_data_hook(df: pandas.DataFrame) -> pandas.DataFrame:
        def unpack():
            for (strike, tenor), v in df.items():
                if strike_spec(strike) and tenor_spec(tenor):
                    yield (strike, tenor), v[list(filter(expiry_spec, v.index))]

        return pandas.DataFrame(dict(unpack()))

    return swaption_data_hook


def swaption_data_sparse_filter_factory(csv_file_path: str) -> Callable:
    def swaption_data_hook(df: pandas.DataFrame) -> pandas.DataFrame:
        csv = pandas.read_csv(csv_file_path, index_col=0)
        strike_config = {k: set(i / 1e4 for i in v) for k, v in csv.iterrows()}

        raw = defaultdict(dict)
        for (strike, tenor), col in df.items():
            for expiry, v in col.items():
                key = f'{expiry}{tenor}'
                if strike == 0 or strike in strike_config[key]:
                    raw[strike, tenor][expiry] = v

        return pandas.DataFrame(raw).T.sort_index().T.sort_index()

    return swaption_data_hook


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_object\template.py
----------------------------------------
import inspect
from importlib import import_module
from functools import singledispatch
from typing import Any, Tuple, List, Dict
from types import ModuleType

from firm_domain import Ccy, Instrument
from .base_model import BaseModel
from .meta_model import MetaModel
from .calculator import RiskTenorCalculator
from . import instance


@singledispatch
def emulate(obj: Any, target_ccy: Ccy = None) -> Any:
    return obj


@emulate.register
def emulate_list(lst: list, target_ccy: Ccy = None) -> List:
    return [emulate(i, target_ccy=target_ccy) for i in lst]


@emulate.register
def emulate_dict(dct: dict, target_ccy: Ccy = None) -> Dict:
    return {emulate(k, target_ccy=target_ccy): emulate(v, target_ccy=target_ccy) for k, v in dct.items()}


@emulate.register
def emulate_ccy(ccy: Ccy, target_ccy: Ccy = None) -> Ccy:
    return target_ccy


@emulate.register
def emulate_str(obj_str: str, target_ccy: Ccy = None) -> str:
    try:
        Ccy[obj_str]
    except KeyError:
        return obj_str
    return target_ccy.name


@emulate.register
def emulate_instrument(inst: Instrument, target_ccy: Ccy = None) -> Instrument:
    if hasattr(inst, 'ccy_base') and inst.ccy is Ccy.USD:
        return inst.replace(ccy_base=target_ccy)
    return inst.replace(ccy=target_ccy)


@emulate.register
def emulate_calculator(cal: RiskTenorCalculator, target_ccy: Ccy = None) -> RiskTenorCalculator:
    model_factory = emulate(cal.model_factory, target_ccy=target_ccy)
    return type(cal)(model_factory=model_factory, risk_tenors=cal.risk_tenors)


def _imply_ccy_from_call_stack() -> Tuple[ModuleType, Ccy]:
    for frame in inspect.stack():
        module = inspect.getmodule(frame[0])
        if inspect.ismodule(module):
            pkg_str, _, ccy_str = module.__name__.rpartition('.')
            try:
                ccy = Ccy[ccy_str]
            except KeyError:
                continue
            if pkg_str == instance.__name__:
                return module, ccy
    raise TypeError('cannot imply Ccy from call stack, please specify target_ccy')


@emulate.register
def emulate_class(cls: MetaModel, target_ccy: Ccy = None) -> MetaModel:
    if issubclass(cls, BaseModel) and cls.currency in (None, Ccy.USD):
        return cls

    assert issubclass(cls, BaseModel)
    source_ccy = cls.currency
    assert isinstance(source_ccy, Ccy)

    if target_ccy is None:
        # jchi@202001
        # when target_ccy is not specified, imply it from the caller's module name
        target_module, target_ccy = _imply_ccy_from_call_stack()
    else:
        assert isinstance(target_ccy, Ccy)
        try:
            target_module = import_module(f'{instance.__name__}.{target_ccy}')
        except ModuleNotFoundError:
            target_module = instance

    new_name = cls.__name__.replace(source_ccy.name, target_ccy.name)
    try:
        return vars(target_module)[new_name]
    except KeyError:
        pass

    bases = tuple(emulate_class(i, target_ccy=target_ccy) for i in cls.__bases__)
    dct = vars(cls)

    def unpack():
        yield '__module__', target_module.__name__
        yield '__qualname__', new_name
        yield 'currency', target_ccy

        try:
            source_instruments = getattr(cls, f'_{cls.__name__}__source_instruments')
        except AttributeError:
            pass
        else:
            yield f'_{new_name}__source_instruments', emulate(source_instruments, target_ccy=target_ccy)

        try:
            market_data_loader = getattr(cls, 'market_data_loader')
        except AttributeError:
            pass
        else:
            yield 'market_data_loader', emulate(market_data_loader, target_ccy=target_ccy)

        for attr in ('interpolation_method',):
            try:
                yield attr, dct[attr]
            except KeyError:
                pass

    new_cls = type(cls)(new_name, bases, dict(unpack()))
    setattr(target_module, new_name, new_cls)
    return new_cls


@emulate.register
def emulate_module(mod: ModuleType, target_ccy: Ccy = None) -> None:
    pkg_str, _, ccy_str = mod.__name__.rpartition('.')
    assert pkg_str == instance.__name__
    source_ccy = Ccy[ccy_str]

    for k, v in vars(mod).items():
        if k.startswith(source_ccy.name) and isinstance(v, MetaModel):
            emulate_class(v, target_ccy=target_ccy)


if __name__ == '__main__':
    pass
    # from firm_f3.model_object.instance.EUR import *
    # from firm_f3.model_object.template import *
    # from firm_f3.model_object.instance import JPY as target_module
    #
    # cls = EURRiskModelFxOutright
    # target_ccy = Ccy.JPY
    # test = emulate(cls, Ccy.JPY)

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_object\util.py
----------------------------------------
import asyncio
from datetime import datetime
from typing import Dict, List, Union

import pandas
from f3sdk.f3 import F3Object  # type: ignore

from firm_domain import Instrument, Rate, Ccy, InflationIndex
from firm_domain.util.datehelper import datetime2date

import firm_f3.f3client
from firm_f3.util.utils import flatten
from firm_f3.mapping import f3index, f3instrument_type, f3quote_spec, mkt_data_tag_override, \
    f3instrument_strategy_async, f3discount_curve_tag_async, f3seasonality

from .interpolation_method import F3Interpolation


def inflation_index_seasonality(sr: pandas.Series) -> pandas.Series:
    pct_change = sr.sort_index(ascending=True).pct_change()
    seasonality = pct_change.groupby(lambda x: x.month).mean()
    return seasonality.sub(seasonality.mean())


def extend_model_with_fixings(model: F3Object, fixings: pandas.DataFrame, ffill: bool = False) -> F3Object:
    if not isinstance(fixings, pandas.DataFrame):
        raise TypeError(f'expect pandas.DataFrame, got {type(fixings)} instead')

    if len(fixings):
        f3 = firm_f3.f3client.get_platform_client()
        for inst, data in fixings.items():
            if ffill:
                data = data.sort_index().ffill()
            data = data.dropna().sort_index(ascending=False)
            model = f3.AddSimpleFixingsCurveToModel(
                BaseModel=model,
                Fixings=[[datetime2date(k), v] for k, v in data.items()],
                Index=f3index(inst),
            )
            if isinstance(inst, InflationIndex):
                seasonality_inst, seasonality_labels = f3seasonality(inst)
                seasonality_data = inflation_index_seasonality(data)
                assert len(seasonality_labels) == len(seasonality_data)
                model = f3.ExtendModelWithMarketData(
                    BaseModel=model,
                    MarketData=f3.CreateLabelledValuesMarketData(
                        InstrumentType=seasonality_inst,
                        Values=list(seasonality_data),
                    )
                )

    return model


def extend_model_with_market_data(model: F3Object, market_data: pandas.DataFrame) -> F3Object:
    if not isinstance(market_data, pandas.DataFrame):
        raise TypeError(f'expect pandas.DataFrame, got {type(market_data)} instead')

    if len(market_data):
        f3 = firm_f3.f3client.get_platform_client()

        val_date = f3.ObjectInfo('Model', model, 'ValuationDate')

        def unpack():
            for inst, data in market_data.items():
                data = data.dropna().sort_index()
                inst_type = f3instrument_type(inst)
                yield f3.CreateCurveMarketData(
                    InstrumentType=inst_type,
                    Maturities=list(map(lambda x: f3quote_spec(x, val_date), data.index)),
                    Quotes=list(data),
                    MarketDataTagMethod=mkt_data_tag_override(inst_type),
                )

        model = f3.ExtendModelWithMarketData(
            BaseModel=model,
            MarketData=f3.CombineMarketDataSets(InputMarketDataSets=list(unpack())),
        )

    return model


def extend_model_with_swaption_data(model: F3Object, market_data: pandas.DataFrame) -> F3Object:
    if not isinstance(market_data, pandas.DataFrame):
        raise TypeError(f'expect pandas.DataFrame, got {type(market_data)} instead')
    assert isinstance(market_data.columns, pandas.MultiIndex), 'expect MultiIndex with levels (strike, tenors)'
    assert isinstance(market_data.columns.name, Instrument), 'expect Instrument specified in columns.name'

    if len(market_data):
        f3 = firm_f3.f3client.get_platform_client()

        val_date = f3.ObjectInfo('Model', model, 'ValuationDate')

        inst = market_data.columns.name
        inst_type = f3instrument_type(inst)
        strike_spec = market_data.columns.levels[0]

        def unpack():
            for strike in strike_spec:
                data = market_data[strike].dropna(how='all')
                yield f3.CreateCommonStrikeSwaptionMarketData(
                    InstrumentType=inst_type,
                    Expiries=list(map(lambda x: f3quote_spec(x, val_date), data.index)),
                    SwapLengths=list(map(lambda x: f3quote_spec(x, val_date), data.columns)),
                    Strike=['ATM', strike],
                    Quotes=[["n/a" if pandas.np.isnan(j) else j for j in i] for i in data.values.tolist()],
                )

        swaption_data = list(unpack())
        model = f3.ExtendModelWithMarketData(
            BaseModel=model,
            MarketData=f3.CombineMarketDataSets(InputMarketDataSets=swaption_data),
        )

    return model


def extend_model_with_fx_market_data(model: F3Object, fx_market_data: pandas.Series) -> F3Object:
    if not isinstance(fx_market_data, pandas.Series):
        raise TypeError(f'expect pandas.Series, got {type(fx_market_data)} instead')

    if len(fx_market_data):
        f3 = firm_f3.f3client.get_platform_client()
        model = f3.ExtendModelWithMarketData(
            BaseModel=model,
            MarketData=f3.CreateFXMarketData(
                FXRateName='UniqueFXRates',
                FXRateType='FXSpotQuotes',
                FXIndices=[f3index(i) for i in fx_market_data.index],
                FXRates=fx_market_data.values.tolist(),
            ),
        )

    return model


async def extend_model_with_dual_curve_calibration_async(
        model: F3Object,
        target_spec: Dict[Rate, List[Instrument]],
        interpolation_types: F3Interpolation = F3Interpolation.ExponentialTensionSpline,
) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    unique_instruments = set(i for i in flatten(target_spec.values()) if isinstance(i, Instrument))
    inst_strategy, curve_tags = await asyncio.gather(
        f3instrument_strategy_async(*unique_instruments),
        f3discount_curve_tag_async(*target_spec),
    )
    curve_tag_mapping = dict(zip(target_spec, curve_tags))

    val_date = f3.ObjectInfo('Model', model, 'ValuationDate')

    def time_point_method(eval_date: datetime):
        yield ['InstrumentType', 'StartMaturity', 'EndMaturity', 'CurveTag', None]
        for target, sources in target_spec.items():
            for source in sources:
                if isinstance(source, (tuple, list)):
                    # jchi@202001
                    # unpack for StartMaturity and EndMaturity
                    source, start, end = source
                else:
                    start, end = None, None
                tag = curve_tag_mapping[target]
                yield [f3instrument_type(source), f3quote_spec(start, eval_date), f3quote_spec(end, eval_date), *tag]

    model = f3.ExtendModelWithCalibratedCurves(
        BaseModel=model,
        CalibrationTarget=f3.CreateOneDimensionalEntireCurveCalibrationTarget(
            CurveTags=curve_tags,
            InterpolationTypes=[interpolation_types.value for _ in range(len(curve_tags))],
            InitialValueCurves=[[1, 'Anchored'] for _ in range(len(curve_tags))],
            BoundConstraints=None,
            OptimizationObjective='SingleCurrencyValue',
            UseHints=True,
            TimePointMethod=list(time_point_method(val_date)),
        ),
        InstrumentStrategy=inst_strategy,
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod='UseModelWideMethod',
    )

    for target in target_spec:
        index = f3index(target)
        model = f3.AddImpliedRateCurveToModel(
            BaseModel=model,
            Index=index,
            CollateralAgreement=index
        )

    return model


def target_method_convention(target: Union[Rate, str]) -> str:
    if isinstance(target, str):
        target_ccy = Ccy[target]
        if target_ccy in (Ccy.EUR, Ccy.GBP, Ccy.AUD):
            return f'Default{target}'
        return 'DefaultUSD'
    return 'UseModelWideMethod'


async def extend_model_with_one_dimensional_calibrated_curve_async(
        f3model: F3Object,
        target: Union[Rate, str],
        inst_strategies: Union[F3Object, List[Instrument]],
        interpolation_types: F3Interpolation = F3Interpolation.ExponentialTensionSpline,
        optimization_objective: str = None,
        bound_constraints: str = None,
        target_method: str = None,
) -> F3Object:
    f3 = firm_f3.f3client.get_platform_client()
    if not isinstance(inst_strategies, F3Object):
        inst_strategies = await f3instrument_strategy_async(*inst_strategies)
    if optimization_objective is None:
        optimization_objective = 'SingleCurrencyNumeraireValue' if isinstance(target, str) else 'SingleCurrencyValue'
    if target_method is None:
        target_method = target_method_convention(target)

    f3model = f3.ExtendModelWithCalibratedCurves(
        BaseModel=f3model,
        CalibrationTarget=f3.CreateOneDimensionalEntireCurveCalibrationTarget(
            CurveTags=await f3discount_curve_tag_async(target),
            InterpolationTypes=interpolation_types.value,
            InitialValueCurves=[1, 'Anchored'],
            BoundConstraints=bound_constraints,
            OptimizationObjective=optimization_objective,
            UseHints=False,
            TimePointMethod=None,
        ),
        InstrumentStrategy=inst_strategies,
        Optimizer='NewtonRaphson_1e-5',
        SourceMethod='Par',
        TargetMethod=target_method,
    )

    if isinstance(target, Rate):
        rate_index = f3index(target)
        f3model = f3.AddImpliedRateCurveToModel(
            BaseModel=f3model,
            Index=rate_index,
            CollateralAgreement=rate_index,
        )

    return f3model


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_object\__init__.py
----------------------------------------

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_object\instance\AUD.py
----------------------------------------
from firm_domain import Ccy, Tenor, Rate, IRS, OIS, FRA, TenorBasis, FXForward, XccyBasis, FXForwardOutright

from firm_f3.model_object.meta_model import SingleCurveConstruction, MultiCurveConstruction
from firm_f3.model_object.base_model import BaseModel
from firm_f3.model_object.swaption_model import SabrSwaptionMixIn
from firm_f3.model_object.calculator import RiskTenorCalculator, DEFAULT_FX_RISK_TENORS
from firm_f3.model_object.interpolation_method import F3Interpolation

from firm_f3.model_object.template import emulate
from . import EUR as template
from .USD import USDModelBasic, USDRiskModelBasic


class AUDModelBasic(BaseModel, metaclass=MultiCurveConstruction):
    currency = Ccy.AUD
    __source_instruments = {
        Rate(currency, Tenor.T_1D): [
            OIS(currency, tenor=None),  # OIS
            TenorBasis(currency, idx_1=Tenor.T_1D, idx_2=Tenor.T_3M, tenor=None),  # OIS-3m basis
        ],
        Rate(currency, Tenor.T_3M): [
            (Rate(currency, Tenor.T_3M), Tenor.T_0D, Tenor.T_2M),  # 3m deposit
            (FRA(currency, tenor=Tenor.T_3M, start=None), Tenor.T_3M, Tenor.T_9M),  # 3m FRA
            (IRS(currency, idx=Tenor.T_3M, tenor=None), Tenor.T_1Y, Tenor.T_3Y),  # 3m IRS
            (TenorBasis(currency, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M, tenor=None), Tenor.T_4Y, max(Tenor)),  # 3s6s
        ],
        Rate(currency, Tenor.T_6M): [
            (Rate(currency, Tenor.T_6M), Tenor.T_0D, Tenor.T_9M),  # 6m deposit
            (TenorBasis(currency, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M, tenor=None), Tenor.T_1Y, Tenor.T_3Y),  # 3s6s
            (IRS(currency, idx=Tenor.T_6M, tenor=None), Tenor.T_4Y, max(Tenor)),  # 6m IRS
        ],
    }


class AUDModelExtended(AUDModelBasic, USDModelBasic, metaclass=SingleCurveConstruction):
    currency = Ccy.AUD
    __source_instruments = {
        Rate(currency, Tenor.T_1M): [
            Rate(currency, Tenor.T_1M),  # 1m deposit
            TenorBasis(currency, idx_1=Tenor.T_1M, idx_2=Tenor.T_3M, tenor=None),  # 1s3s
        ],
        currency.name: [
            FXForward(currency, tenor=None),  # FX points
            XccyBasis(currency, tenor=None),  # Cross Currency Basis
        ],
    }


AUDModel = emulate(template.EURModel)
AUDModelSwaption = emulate(template.EURModelSwaption)


class AUDRiskModelBasic(BaseModel, metaclass=MultiCurveConstruction):
    currency = Ccy.AUD
    __source_instruments = {
        Rate(currency, Tenor.T_3M): [IRS(currency, idx=Tenor.T_3M, tenor=None)],
        Rate(currency, Tenor.T_1D): [TenorBasis(currency, idx_1=Tenor.T_1D, idx_2=Tenor.T_3M, tenor=None)],
        Rate(currency, Tenor.T_6M): [TenorBasis(currency, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M, tenor=None)],
    }
    market_data_loader = RiskTenorCalculator(AUDModelBasic)
    interpolation_method = F3Interpolation.LogLinear


class AUDRiskModelRates(AUDRiskModelBasic, USDRiskModelBasic, metaclass=SingleCurveConstruction):
    currency = Ccy.AUD
    __source_instruments = {
        Rate(currency, Tenor.T_1M): [TenorBasis(currency, idx_1=Tenor.T_1M, idx_2=Tenor.T_3M, tenor=None)],
        currency.name: [XccyBasis(currency, tenor=None)],
    }
    market_data_loader = RiskTenorCalculator(AUDModelExtended)


class AUDRiskModelSwaption(SabrSwaptionMixIn, AUDRiskModelRates):
    pass


class AUDRiskModelFxPoints(AUDRiskModelBasic, USDRiskModelBasic, metaclass=SingleCurveConstruction):
    currency = Ccy.AUD
    __source_instruments = {
        Rate(currency, Tenor.T_1M): [TenorBasis(currency, idx_1=Tenor.T_1M, idx_2=Tenor.T_3M, tenor=None)],
        currency.name: [FXForward(currency, tenor=None)],
    }
    market_data_loader = RiskTenorCalculator(AUDModelExtended, risk_tenors=DEFAULT_FX_RISK_TENORS)


class AUDRiskModelFxOutright(AUDRiskModelBasic, USDRiskModelBasic, metaclass=SingleCurveConstruction):
    currency = Ccy.AUD
    __source_instruments = {
        Rate(currency, Tenor.T_1M): [TenorBasis(currency, idx_1=Tenor.T_1M, idx_2=Tenor.T_3M, tenor=None)],
        currency.name: [FXForwardOutright(currency, tenor=None)],
    }
    market_data_loader = RiskTenorCalculator(AUDModelExtended, risk_tenors=DEFAULT_FX_RISK_TENORS)


if __name__ == '__main__':
    pass
    # import datetime
    # from firm_f3.util.f3ml import show
    # from firm_domain.trade import IRSTrade, XccyBasisTrade, SwaptionTrade, SwaptionType
    # from firm_f3.evaluate import pv, value_product, pv_local, risk_report, risk_report_pvbp_handler, \
    #     risk_report_ir_vega_handler
    # from firm_f3.exceltools.context import irs_risk_map, basis_risk_map, fx_fwd_risk_map
    #
    # # self = AUDModelBasic()
    # # self = AUDModelExtended()
    # # self = AUDModelExtended(datetime.date(2019, 12, 5))
    # # self = AUDModelSwaption()
    # # self = AUDRiskModelRates()
    # # self = AUDRiskModelSwaption()
    # # self = AUDRiskModelFxPoints()
    # self = AUDRiskModelFxOutright()
    # model = self.assemble_model()
    # show(model, './tmp/tmp.py')
    #
    # trade = IRSTrade(datetime.datetime(2019, 12, 5), Ccy.AUD, datetime.date(2019, 12, 7),
    #                  datetime.date(2024, 12, 7), 0.009, 1e6, idx=Tenor.T_6M)
    # trade = IRSTrade(datetime.datetime(2019, 12, 5), Ccy.AUD, datetime.date(2019, 12, 7),
    #                  datetime.date(2024, 12, 7), 0.008, 1e6, idx=Tenor.T_3M)
    # trade = XccyBasisTrade(datetime.datetime(2019, 12, 5), Ccy.AUD, datetime.date(2019, 12, 7),
    #                        datetime.date(2024, 12, 7), 0.002, 1e6, 0.68)
    # trade = SwaptionTrade(datetime.datetime(2019, 12, 5), Ccy.AUD, datetime.date(2020, 6, 5),
    #                       datetime.date(2020, 6, 6), datetime.date(2025, 6, 6), 0.009, SwaptionType.RECEIVER, 1e6)
    #
    # value_product(trade, f3model=model, valuation_method='Default', requests='SingleCurrencyValue')
    # value_product(trade, f3model=model, valuation_method='DefaultUSD', requests='SingleCurrencyValue')
    # pv_local(trade, f3model=model)
    #
    # value_product(trade, f3model=model, valuation_method='Default', requests='NumeraireValue')
    # value_product(trade, f3model=model, valuation_method='DefaultUSD', requests='NumeraireValue')
    # pv(trade, f3model=model)
    #
    # res = risk_report(trade, f3model=model)
    # df = risk_report_pvbp_handler(res)
    # df.columns = [irs_risk_map.get(i) or basis_risk_map.get(i) or fx_fwd_risk_map.get(i) or i for i in df.columns]
    # print(df)
    # print(risk_report_ir_vega_handler(res))

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_object\instance\CHF.py
----------------------------------------
from firm_domain import Ccy, Tenor, Rate, FRA, TenorBasis, FXForward, XccyBasis
from firm_f3.model_object.meta_model import SingleCurveConstruction

from firm_f3.model_object.template import emulate
from . import EUR as template
from .USD import USDModelBasic

CHFModelBasic = emulate(template.EURModelBasic)


class CHFModelExtended(CHFModelBasic, USDModelBasic, metaclass=SingleCurveConstruction):
    currency = Ccy.CHF
    __source_instruments = {
        Rate(currency, Tenor.T_3M): [
            Rate(currency, Tenor.T_3M),  # 3m deposit
            FRA(currency, tenor=Tenor.T_3M, start=None),  # 3m FRA
            TenorBasis(currency, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M, tenor=None),  # 3s6s
        ],
        currency.name: [
            FXForward(currency, tenor=None),  # FX points
            XccyBasis(currency, tenor=None),  # Cross Currency Basis
        ],
    }


CHFModel = emulate(template.EURModel)
CHFModelSwaption = emulate(template.EURModelSwaption)
CHFRiskModelBasic = emulate(template.EURRiskModelBasic)
CHFRiskModelRates = emulate(template.EURRiskModelRates)
CHFRiskModelSwaption = emulate(template.EURRiskModelSwaption)
CHFRiskModelFxPoints = emulate(template.EURRiskModelFxPoints)
CHFRiskModelFxOutright = emulate(template.EURRiskModelFxOutright)
emulate(template)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_object\instance\EUR.py
----------------------------------------
from firm_domain import Ccy, Tenor, Rate, IRS, OIS, FRA, TenorBasis, FXForward, XccyBasis, FXForwardOutright

from firm_f3.model_object.meta_model import SingleCurveConstruction, MultiCurveConstruction
from firm_f3.model_object.base_model import BaseModel
from firm_f3.model_object.swaption_model import SabrSwaptionMixIn
from firm_f3.model_object.calculator import RiskTenorCalculator, DEFAULT_FX_RISK_TENORS
from firm_f3.model_object.interpolation_method import F3Interpolation
from .USD import USDModelBasic, USDRiskModelBasic, JointFragmentMixIn


class EURModelBasic(BaseModel, metaclass=SingleCurveConstruction):
    currency = Ccy.EUR
    __source_instruments = {
        Rate(currency, Tenor.T_1D): [
            OIS(currency, tenor=None),  # OIS
        ],
        Rate(currency, Tenor.T_6M): [
            Rate(currency, Tenor.T_6M),  # 6m deposit
            FRA(currency, tenor=Tenor.T_6M, start=None),  # 6m FRA
            IRS(currency, idx=Tenor.T_6M, tenor=None),  # 6m IRS
        ],
    }


class EURModelExtended(EURModelBasic, USDModelBasic, metaclass=SingleCurveConstruction):
    currency = Ccy.EUR
    __source_instruments = {
        Rate(currency, Tenor.T_3M): [
            Rate(currency, Tenor.T_3M),  # 3m deposit
            TenorBasis(currency, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M, tenor=None),  # 3s6s
        ],
        currency.name: [
            FXForward(currency, tenor=None),  # FX points
            XccyBasis(currency, tenor=None),  # Cross Currency Basis
        ],
    }


class EURModel(JointFragmentMixIn, EURModelExtended):
    pass


class EURModelSwaption(SabrSwaptionMixIn, EURModelExtended):
    pass


class EURRiskModelBasic(BaseModel, metaclass=MultiCurveConstruction):
    currency = Ccy.EUR
    __source_instruments = {
        Rate(currency, Tenor.T_6M): [IRS(currency, idx=Tenor.T_6M, tenor=None)],
        Rate(currency, Tenor.T_1D): [TenorBasis(currency, idx_1=Tenor.T_1D, idx_2=Tenor.T_6M, tenor=None)],
    }
    market_data_loader = RiskTenorCalculator(EURModelBasic)
    interpolation_method = F3Interpolation.LogLinear


class EURRiskModelRates(EURRiskModelBasic, USDRiskModelBasic, metaclass=SingleCurveConstruction):
    currency = Ccy.EUR
    __source_instruments = {
        Rate(currency, Tenor.T_3M): [TenorBasis(currency, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M, tenor=None)],
        currency.name: [XccyBasis(currency, tenor=None)],
    }
    market_data_loader = RiskTenorCalculator(EURModelExtended)


class EURRiskModelSwaption(SabrSwaptionMixIn, EURRiskModelRates):
    pass


class EURRiskModelFxPoints(EURRiskModelBasic, USDRiskModelBasic, metaclass=SingleCurveConstruction):
    currency = Ccy.EUR
    __source_instruments = {
        Rate(currency, Tenor.T_3M): [TenorBasis(currency, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M, tenor=None)],
        currency.name: [FXForward(currency, tenor=None)],
    }
    market_data_loader = RiskTenorCalculator(EURModelExtended, risk_tenors=DEFAULT_FX_RISK_TENORS)


class EURRiskModelFxOutright(EURRiskModelBasic, USDRiskModelBasic, metaclass=SingleCurveConstruction):
    currency = Ccy.EUR
    __source_instruments = {
        Rate(currency, Tenor.T_3M): [TenorBasis(currency, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M, tenor=None)],
        currency.name: [FXForwardOutright(currency, tenor=None)],
    }
    market_data_loader = RiskTenorCalculator(EURModelExtended, risk_tenors=DEFAULT_FX_RISK_TENORS)


if __name__ == '__main__':
    pass
    # import datetime
    # from firm_f3.util.f3ml import show
    # from firm_domain.trade import IRSTrade, XccyBasisTrade, SwaptionTrade, SwaptionType
    # from firm_f3.evaluate import pv, value_product, pv_local, risk_report, risk_report_pvbp_handler, \
    #     risk_report_ir_vega_handler
    # from firm_f3.exceltools.context import irs_risk_map, basis_risk_map, fx_fwd_risk_map
    #
    # # self = EURModelBasic()
    # # self = EURModelExtended()
    # # self = EURModelExtended(datetime.date(2019, 12, 5))
    # # self = EURModelSwaption()
    # # self = EURRiskModelRates()
    # # self = EURRiskModelSwaption()
    # self = EURRiskModelFxOutright()
    # model = self.assemble_model()
    # show(model, './tmp/tmp.py')
    #
    # trade = IRSTrade(datetime.datetime(2019, 12, 5), Ccy.EUR, datetime.date(2019, 12, 7),
    #                  datetime.date(2024, 12, 7), -0.003, 1e6)
    # trade = XccyBasisTrade(datetime.datetime(2019, 12, 5), Ccy.EUR, datetime.date(2019, 12, 7),
    #                        datetime.date(2024, 12, 7), 0.0, 1e6, 1.11)
    # trade = SwaptionTrade(datetime.datetime(2019, 12, 5), Ccy.EUR, datetime.date(2020, 6, 5),
    #                       datetime.date(2020, 6, 6), datetime.date(2025, 6, 6), -0.005, SwaptionType.RECEIVER, 1e6)
    #
    # value_product(trade, f3model=model, valuation_method='Default', requests='SingleCurrencyValue')
    # value_product(trade, f3model=model, valuation_method='DefaultUSD', requests='SingleCurrencyValue')
    # pv_local(trade, f3model=model)
    #
    # value_product(trade, f3model=model, valuation_method='Default', requests='NumeraireValue')
    # value_product(trade, f3model=model, valuation_method='DefaultUSD', requests='NumeraireValue')
    # pv(trade, f3model=model)
    #
    # res = risk_report(trade, f3model=model)
    # df = risk_report_pvbp_handler(res)
    # df.columns = [irs_risk_map.get(i) or basis_risk_map.get(i) or fx_fwd_risk_map.get(i) or i for i in df.columns]
    # print(df)
    # print(risk_report_ir_vega_handler(res))

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_object\instance\GBP.py
----------------------------------------
from firm_f3.model_object.template import emulate
from . import EUR as template

GBPModelBasic = emulate(template.EURModelBasic)
GBPModelExtended = emulate(template.EURModelExtended)
GBPModel = emulate(template.EURModel)
GBPModelSwaption = emulate(template.EURModelSwaption)
GBPRiskModelBasic = emulate(template.EURRiskModelBasic)
GBPRiskModelRates = emulate(template.EURRiskModelRates)
GBPRiskModelSwaption = emulate(template.EURRiskModelSwaption)
GBPRiskModelFxPoints = emulate(template.EURRiskModelFxPoints)
GBPRiskModelFxOutright = emulate(template.EURRiskModelFxOutright)
emulate(template)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_object\instance\JPY.py
----------------------------------------
from firm_f3.model_object.template import emulate
from . import EUR as template

JPYModelBasic = emulate(template.EURModelBasic)
JPYModelExtended = emulate(template.EURModelExtended)
JPYModel = emulate(template.EURModel)
JPYModelSwaption = emulate(template.EURModelSwaption)
JPYRiskModelBasic = emulate(template.EURRiskModelBasic)
JPYRiskModelRates = emulate(template.EURRiskModelRates)
JPYRiskModelSwaption = emulate(template.EURRiskModelSwaption)
JPYRiskModelFxPoints = emulate(template.EURRiskModelFxPoints)
JPYRiskModelFxOutright = emulate(template.EURRiskModelFxOutright)
emulate(template)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_object\instance\USD.py
----------------------------------------
import asyncio
from f3sdk.f3 import F3Object  # type: ignore

import firm_f3.f3client
from firm_domain import Ccy, Tenor, Rate, OIS, TenorBasis, RatesFuture, IRS
from firm_f3.mapping import f3market_data_tag_async

from firm_f3.model_object.meta_model import SingleCurveConstruction
from firm_f3.model_object.base_model import BaseModel
from firm_f3.model_object.swaption_model import SabrSwaptionMixIn
from firm_f3.model_object.inflation_model import InflationSwapMixIn
from firm_f3.model_object.util import extend_model_with_dual_curve_calibration_async
from firm_f3.model_object.calculator import RiskTenorCalculator
from firm_f3.model_object.interpolation_method import F3Interpolation


class USDModelBasic(BaseModel):
    currency = __currency = Ccy.USD
    __source_instruments = {
        Rate(currency, Tenor.T_1D): [
            OIS(currency, tenor=None),  # OIS
            TenorBasis(currency, idx_1=Tenor.T_1D, idx_2=Tenor.T_3M, tenor=None),  # OIS vs Libor 3m basis
        ],
        Rate(currency, Tenor.T_3M): [
            RatesFuture(currency, idx=Tenor.T_3M, tenor=None),  # ED future
            Rate(currency, Tenor.T_3M),  # 3m deposit
            IRS(currency, idx=Tenor.T_3M, tenor=None),  # 3m IRS
        ],
    }
    __hull_white_mean_reversion = 0.03
    __hull_white_volatility = 0.0097

    @property
    def hull_white_mean_reversion(self):
        return self.__hull_white_mean_reversion

    @hull_white_mean_reversion.setter
    def hull_white_mean_reversion(self, v):
        self.__hull_white_mean_reversion = v

    @property
    def hull_white_volatility(self):
        return self.__hull_white_volatility

    @hull_white_volatility.setter
    def hull_white_volatility(self, v):
        self.__hull_white_volatility = v

    async def assemble_fragment_async(self, model: F3Object = None) -> F3Object:
        if model is None:
            model = await super().assemble_fragment_async()

        f3 = firm_f3.f3client.get_platform_client()
        hw_mr_data = f3.CreateLabelledValuesMarketData(
            InstrumentType="LiborUSD3m-HullWhiteMeanReversion",
            Values=self.hull_white_mean_reversion,
        )
        hw_vol_data = f3.CreateCurveMarketData(
            InstrumentType="LiborUSD3m-HullWhiteVolatility",
            Maturities="1y",
            Quotes=self.hull_white_volatility
        )

        model, (hw_mr_tag, hw_vol_tag) = await asyncio.gather(
            extend_model_with_dual_curve_calibration_async(
                model,
                target_spec=self.__source_instruments,
                interpolation_types=F3Interpolation.ExponentialTensionSpline
            ),
            f3market_data_tag_async(hw_mr_data, hw_vol_data),
        )

        model = f3.ExtendModelWithClonedCurve(
            BaseModel=model,
            CurveTag=[self.__currency.name, 'DiscountCurve'],
            SourceCurveTag=[self.__currency.name, 'DiscountCurve-CollateralRate-USD O/N:1b'],
        )

        # Hull-White Convexity Adjustment

        hw_mr_curve = ['USD', "HWFuturesMeanRevCurve"]
        model = f3.ExtendModelWithZeroDimensionalCurve(
            BaseModel=model,
            CurveTag=hw_mr_curve,
            MarketDataTag=hw_mr_tag,
        )
        model = f3.ExtendModelWithMarketData(BaseModel=model, MarketData=hw_mr_data)

        hw_vol_curve = ['USD', "HWFuturesVolCurve"]
        model = f3.ExtendModelWithInterpolationCurve(
            BaseModel=model,
            CurveTag=hw_vol_curve,
            MarketDataTag=hw_vol_tag,
            InterpolationMethod="Linear"
        )
        model = f3.ExtendModelWithMarketData(BaseModel=model, MarketData=hw_vol_data)

        model = f3.ExtendModelWithSingleFactorHullWhiteConvexityAdjustmentCurve(
            BaseModel=model,
            CurveTag=f3.ConvexityAdjustmentCurveTag("LiborUSD3m"),
            Index="LiborUSD3m",
            CompoundingFrequency="Continuous",
            VolatilityCurveTag=hw_vol_curve,
            MeanReversionCurveTag=hw_mr_curve,
        )

        return model


class USDModelExtended(USDModelBasic, metaclass=SingleCurveConstruction):
    currency = Ccy.USD
    __source_instruments = {
        Rate(currency, Tenor.T_1M): [
            Rate(currency, Tenor.T_1M),  # 1m deposit
            TenorBasis(currency, idx_1=Tenor.T_1M, idx_2=Tenor.T_3M, tenor=None),  # 1s3s
        ],
        Rate(currency, Tenor.T_6M): [
            Rate(currency, Tenor.T_6M),  # 6m deposit
            TenorBasis(currency, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M, tenor=None),  # 3s6s
        ],
    }


class USDModel(USDModelExtended):
    async def assemble_fragment_async(self, model: F3Object = None) -> F3Object:
        if model is None:
            model = await BaseModel.assemble_fragment_async(self)
        model = await USDModelBasic.assemble_fragment_async(self, model)
        model = await USDModelExtended.assemble_fragment_async.__get__(self, None)(model)
        return model


class USDModelInflationSwap(InflationSwapMixIn, USDModelExtended):
    pass


class USDModelSwaption(SabrSwaptionMixIn, USDModelBasic):
    pass


class JointFragmentMixIn(USDModelBasic):
    async def assemble_fragment_async(self, model: F3Object = None) -> F3Object:
        if model is None:
            model = await USDModelBasic.assemble_fragment_async(self)

        for typ in reversed(type(self).mro()):
            if issubclass(typ, BaseModel) and typ not in (BaseModel, USDModelBasic) and \
                    not issubclass(typ, JointFragmentMixIn):
                try:
                    assembler = getattr(typ.assemble_fragment_async, '__get__')
                except AttributeError:
                    model = await typ.assemble_fragment_async(self, model)
                else:
                    model = await assembler(self)(model)
        return model


class USDRiskModelBasic(BaseModel):
    currency = __currency = Ccy.USD
    __source_instruments = {
        Rate(currency, Tenor.T_3M): [IRS(currency, idx=Tenor.T_3M, tenor=None)],
        Rate(currency, Tenor.T_1D): [TenorBasis(currency, idx_1=Tenor.T_1D, idx_2=Tenor.T_3M, tenor=None)],
    }
    market_data_loader = RiskTenorCalculator(USDModelBasic)
    interpolation_method = F3Interpolation.LogLinear

    async def assemble_fragment_async(self, model: F3Object = None) -> F3Object:
        if model is None:
            model = await super().assemble_fragment_async()

        model = await extend_model_with_dual_curve_calibration_async(model, target_spec=self.__source_instruments,
                                                                     interpolation_types=self.interpolation_method)
        f3 = firm_f3.f3client.get_platform_client()
        model = f3.ExtendModelWithClonedCurve(
            BaseModel=model,
            CurveTag=[self.__currency.name, 'DiscountCurve'],
            SourceCurveTag=[self.__currency.name, 'DiscountCurve-CollateralRate-USD O/N:1b'],
        )
        return model


class USDRiskModelRates(USDRiskModelBasic, metaclass=SingleCurveConstruction):
    currency = Ccy.USD
    __source_instruments = {
        Rate(currency, Tenor.T_1M): [TenorBasis(currency, idx_1=Tenor.T_1M, idx_2=Tenor.T_3M, tenor=None)],
        Rate(currency, Tenor.T_6M): [TenorBasis(currency, idx_1=Tenor.T_3M, idx_2=Tenor.T_6M, tenor=None)],
    }
    market_data_loader = RiskTenorCalculator(USDModelExtended)


class USDRiskModelSwaption(SabrSwaptionMixIn, USDRiskModelBasic):
    pass


if __name__ == '__main__':
    pass
    # import datetime
    # from firm_f3.util.f3ml import show
    # from firm_domain import IRSTrade, TenorBasisTrade, SwaptionTrade, SwaptionType, InflationSwapTrade, InflationIndex
    # from firm_f3.evaluate import pv, value_product, pv_local, risk_report, dataframe_handler
    #
    # # self = USDModelBasic()
    # # self = USDModelExtended()
    # self = USDModelInflationSwap()
    # # self = USDModelSwaption()
    # # self = USDRiskModelRates()
    # model = self.assemble_model()
    # show(model, './tmp/tmp.py')
    #
    # # trade = IRSTrade(datetime.datetime(2019, 12, 5), Ccy.USD, datetime.date(2019, 12, 7),
    # #                  datetime.date(2024, 12, 7), 0.017, 1e6)
    # # trade = TenorBasisTrade(datetime.datetime(2019, 12, 5), Ccy.USD, datetime.date(2019, 12, 7),
    # #                         datetime.date(2024, 12, 7), 1e6, 0.001, Tenor.T_1M)
    # # trade = SwaptionTrade(datetime.datetime(2019, 12, 5), Ccy.USD, datetime.date(2020, 6, 5),
    # #                       datetime.date(2020, 6, 6), datetime.date(2025, 6, 6), 0.017, SwaptionType.RECEIVER, 1e6)
    # trade = InflationSwapTrade(datetime.datetime(2019, 12, 5), InflationIndex.CPURNSA, datetime.date(2019, 12, 7),
    #                            datetime.date(2024, 12, 7), 0.015, 1e6)
    #
    # value_product(trade, f3model=model, valuation_method='Default', requests='SingleCurrencyValue')
    # value_product(trade, f3model=model, valuation_method='DefaultUSD', requests='SingleCurrencyValue')
    # pv_local(trade, f3model=model)
    #
    # value_product(trade, f3model=model, valuation_method='Default', requests='NumeraireValue')
    # value_product(trade, f3model=model, valuation_method='DefaultUSD', requests='NumeraireValue')
    # pv(trade, f3model=model)
    #
    # res = risk_report(trade, f3model=model)
    # df = dataframe_handler(res)
    # df.to_clipboard()

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_object\instance\__init__.py
----------------------------------------
from . import USD

__all__ = ['USD', 'import_instances']


def import_instances():
    import os
    from importlib import import_module

    _globals = globals()
    dirname = os.path.dirname(__file__)
    for i in os.listdir(dirname):
        if i.endswith('.py') and not i.startswith('_'):
            key = i.replace('.py', '')
            if key not in _globals:
                _globals[key] = import_module(f'{__name__}.{key}')
                __all__.append(key)

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_object\instance\__pycache__\GBP.cpython-37.pyc
----------------------------------------
B

    y  dy                  @   s    d dl mZ ddlmZ eej Zeej  Zeej	 Z
eej
 Zeej
 Zeej Zeej Zeej Zeej Zee  edkr dS )     )  emulate    ) EUR __main__N)Zfirm_f3.model_object.templater     r    templateZ
EURModelBasicZ
GBPModelBasicZEURModelExtendedZGBPModelExtendedZEURModelZGBPModelZEURModelSwaptionZGBPModelSwaptionZEURRiskModelBasicZGBPRiskModelBasicZEURRiskModelRatesZGBPRiskModelRatesZEURRiskModelSwaptionZGBPRiskModelSwaptionZEURRiskModelFxPointsZGBPRiskModelFxPointsZEURRiskModelFxOutrightZGBPRiskModelFxOutright __name__  r	   r	    RE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/model_object/instance/GBP.py <module>   s   









........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_object\instance\__pycache__\JPY.cpython-37.pyc
----------------------------------------
B

    y  dy                  @   s    d dl mZ ddlmZ eej Zeej  Zeej	 Z
eej
 Zeej
 Zeej Zeej Zeej Zeej Zee  edkr dS )     )  emulate    ) EUR __main__N)Zfirm_f3.model_object.templater     r    templateZ
EURModelBasicZ
JPYModelBasicZEURModelExtendedZJPYModelExtendedZEURModelZJPYModelZEURModelSwaptionZJPYModelSwaptionZEURRiskModelBasicZJPYRiskModelBasicZEURRiskModelRatesZJPYRiskModelRatesZEURRiskModelSwaptionZJPYRiskModelSwaptionZEURRiskModelFxPointsZJPYRiskModelFxPointsZEURRiskModelFxOutrightZJPYRiskModelFxOutright __name__  r	   r	    RE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/model_object/instance/JPY.py <module>   s   









........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_object\__pycache__\interpolation_method.cpython-37.pyc
----------------------------------------
B

    y  d                    @   s(   d dl mZ G dd  de Zedkr$dS )     ) Enumc               @   s   e Zd ZdZdZdZdS ) F3Interpolation Linear 	LogLinearzExponentialTensionSpline_0.10N) __name__ 
__module__ __qualname__r   r   ZExponentialTensionSpline  r	   r	    ZE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/model_object/interpolation_method.pyr      s   r    __main__N) enumr   r   r   r	   r	   r	   r
    <module>   s   
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\model_object\__pycache__\__init__.cpython-37.pyc
----------------------------------------
B

    y  d                    @   s   d S )N  r   r   r    NE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/model_object/__init__.py <module>        
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\nimrod\client.py
----------------------------------------
try:
    from nimrod.client.nimrod_client import *
except ImportError:
    from ._client import *

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\nimrod\model_set.py
----------------------------------------
try:
    from nimrod.core.model_set import *
except ImportError:
    from ._model_set import *

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\nimrod\_client.py
----------------------------------------
from __future__ import annotations
from typing import List
import os
import datetime
from pydantic import BaseModel
from firm_f3.util.http_client import HttpClient
from .model_set import Model, ModelSet


class ValidateBase(BaseModel):
    name: str
    triggered_at: datetime.datetime
    modified_at: datetime.datetime


class ValidateModel(ValidateBase):
    model_slug: int

    def to_python(self) -> Model:
        return Model(**vars(self))


class ValidateModelSet(ValidateBase):
    slug: int
    valuation_date: datetime.date
    model_snaps: List[ValidateModel]

    def to_python(self) -> ModelSet:
        def unpack():
            for k, v in vars(self).items():
                if k == 'model_snaps':
                    v = [i.to_python() for i in v]
                yield k, v

        return ModelSet(**dict(unpack()))


HOST_MAPPING = {
    'uat': 'http://firm-jarvis-uat:8850',
    'dev': 'http://localhost:8888',
}


class NimrodClient:
    def __init__(self, env: str = None, as_of: datetime.date = None):
        if env is None:
            try:
                host = os.environ['NIMROD_HOST']
            except KeyError:
                raise KeyError('NIMROD_HOST is not specified')
        else:
            host = HOST_MAPPING.get(env, env)

        params = {}
        if isinstance(as_of, datetime.date):
            params['as_of'] = as_of
        self.conn = HttpClient(host, params)

    def list_methods(self) -> List[str]:
        return self.conn.get.list_methods()

    def _get_model_set(self, model_type: str, as_of: datetime.date = None) -> ModelSet:
        kwd = {}
        if as_of:
            kwd['as_of'] = as_of
        raw = getattr(self.conn.get.model_set, model_type)(**kwd)
        return ValidateModelSet(**raw).to_python()

    def get_market_model_set(self, as_of: datetime.date = None) -> ModelSet:
        return self._get_model_set(model_type='market_model', as_of=as_of)

    def get_rates_risk_model_set(self, as_of: datetime.date = None) -> ModelSet:
        return self._get_model_set(model_type='rates_risk_model', as_of=as_of)

    def get_fx_risk_model_set(self, as_of: datetime.date = None) -> ModelSet:
        return self._get_model_set(model_type='fx_risk_model', as_of=as_of)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\nimrod\_model_set.py
----------------------------------------
from __future__ import annotations
import asyncio
import datetime
from dataclasses import dataclass
from typing import List, Tuple, Iterable, Any

from f3sdk.lib.coroutine import wait  # type: ignore
from f3sdk.f3 import F3Object  # type:ignore

from firm_domain import Trade
from firm_f3.util.reversible_dict import ReversibleDict
from firm_f3.core.modelutils import get_model_by_slug_async


@dataclass
class Base:
    name: str
    triggered_at: datetime.datetime
    modified_at: datetime.datetime


@dataclass
class Model(Base):
    model_slug: int

    async def get_model_async(self) -> F3Object:
        try:
            model = getattr(self, '_model')
        except AttributeError:
            model = await get_model_by_slug_async(self.model_slug)
            setattr(self, '_model', model)
        return model

    def get_model(self) -> F3Object:
        return wait(self.get_model_async())

    def is_handling(self, trade: Trade) -> bool:
        _ = trade
        if self.name == 'default':
            return True
        return False


@dataclass
class ModelSet(Base):
    slug: int
    valuation_date: datetime.date
    model_snaps: List[Model]

    def get(self, key: str) -> Model:
        for model in self.model_snaps:
            if model.name == key:
                return model
        else:
            raise KeyError(key)

    def eval_with(self, trades: Iterable[Trade]) -> EvalFuture:
        def unpack():
            for t in trades:
                for m in self.model_snaps:
                    if m.is_handling(t):
                        yield t, m
                        break
                else:
                    raise ValueError(f'no model is handling {t}')

        return EvalFuture(unpack())


class EvalFuture:
    class MissingValue:
        pass

    def __init__(self, trade_model_pairs: Iterable[Tuple[Trade, Model]]):
        self.trade_model_pairs = list(trade_model_pairs)
        self.key_map = ReversibleDict((i, m.model_slug) for i, (_, m) in enumerate(self.trade_model_pairs))
        self.results = [self.MissingValue for _ in self.trade_model_pairs]

    async def gather_models(self) -> List[Tuple[F3Object, List[Trade]]]:
        model_map = {m.model_slug: m for _, m in self.trade_model_pairs}
        f3models = await asyncio.gather(*(m.get_model_async() for m in model_map.values()))

        def unpack():
            for model, indices in zip(f3models, self.key_map.rev.values()):
                trades = [self.trade_model_pairs[i][0] for i in indices]
                yield model, trades

        return list(unpack())

    def set_results(self, results: List[List[Any]]) -> None:
        for res, indices in zip(results, self.key_map.rev.values()):
            for i, v in zip(indices, res):
                self.results[i] = v
        assert not any(v is self.MissingValue for v in self.results)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\nimrod\__init__.py
----------------------------------------
import sys
import warnings

WARNING_MESSAGE = """
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                            !!
!! WARNING firm_f3.nimrod is replaced by independent package nimrod           !!
!! please update your import statement accordingly                            !!
!!                                                                            !!
!! Make sure to run ``pip install nimrod -U`` in terminal                     !!
!! Details for nimrod project:                                                !!
!!     http://firm-bitbucket:7990/projects/BI/repos/firm-f3-nimrod/browse     !!
!!                                                                            !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"""
print(WARNING_MESSAGE)
warnings.warn(WARNING_MESSAGE, DeprecationWarning)
if sys.stdin is not None:
    input('Press any key to confirm ...')

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\nimrod\__pycache__\client.cpython-37.pyc
----------------------------------------
B

    y  db                   @   s.   yd dl T W n ek
r(   ddlT Y nX dS )     ) *    N)Znimrod.client.nimrod_client 
ImportErrorZ _client  r   r    FE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/nimrod/client.py <module>   s   
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\nimrod\__pycache__\model_set.cpython-37.pyc
----------------------------------------
B

    y  d_                   @   s.   yd dl T W n ek
r(   ddlT Y nX dS )     ) *    N)Znimrod.core.model_set 
ImportErrorZ
_model_set  r   r    IE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/nimrod/model_set.py <module>   s   
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\nimrod\__pycache__\__init__.cpython-37.pyc
----------------------------------------
B

    y  d                   @   s>   d dl Z d dlZdZee  e ee  e jdk	r:e d  dS )     Na+  
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                            !!
!! WARNING firm_f3.nimrod is replaced by independent package nimrod           !!
!! please update your import statement accordingly                            !!
!!                                                                            !!
!! Make sure to run ``pip install nimrod -U`` in terminal                     !!
!! Details for nimrod project:                                                !!
!!     http://firm-bitbucket:7990/projects/BI/repos/firm-f3-nimrod/browse     !!
!!                                                                            !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
zPress any key to confirm ...) sys warningsZWARNING_MESSAGE print warn DeprecationWarning stdin input  r	   r	    HE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/nimrod/__init__.py <module>   s   


........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\patch\asia_rates.py
----------------------------------------
from typing import Dict, Set, Tuple, Iterator
from collections import Counter
import datetime
from cerebro.client.portfolio import CerebroPortfolio
from firm_domain import TRSTrade, FutureTrade


def flat_trs(f: CerebroPortfolio) -> bool:
    def unpack():
        for t in f.domain_trades:
            if isinstance(t, TRSTrade):
                key = t.underlying.name, t.maturity
                yield key, t.notional

    cnt: Dict[Tuple[str, datetime.date], float] = Counter()
    for k, v in unpack():
        cnt[k] += v
    return sum(cnt.values()) == 0


def flat_futures(f: CerebroPortfolio) -> bool:
    def unpack():
        for t in f.domain_trades:
            if isinstance(t, FutureTrade):
                key = t.ticker, t.expiry
                yield key, t.quantity

    cnt: Dict[Tuple[str, datetime.date], float] = Counter()
    for k, v in unpack():
        cnt[k] += v
    return sum(cnt.values()) == 0


KNOWN_RISKY_PIDS: Set[int] = {
    34617,  # AUD 3y1y vs 2y2y
    36995,  # HKD 1s3s
    43038,  # SGD 3s6s
    34399,  # INR NDS
    38283,  # INR Onshore IRS
    38282,  # INR Offshore IRS
    39536,  # CNH CCS Vol
    40199,  # CNH CCS hedges
}

EXCLUDE_PIDS: Set[int] = {
    33075,  # ZZZFunding
}


def risky_pid(folio: CerebroPortfolio, ref_datetime: datetime.datetime = None) -> Iterator[int]:
    from firm_f3.exceltools.positions import firm_sophis_trades_enlist

    for _, f in folio.iter_children(exclude=list(EXCLUDE_PIDS)):
        if isinstance(f, CerebroPortfolio) and f.domain_trades:
            if f.pid == 39976:  # 39976 KTB TRS
                if not flat_trs(f):
                    yield f.pid
                    continue
                trade_dct = {i: v for i, v in enumerate(f.domain_trades) if not isinstance(v, TRSTrade)}
            elif f.pid in (31856, 39876):  # 31856 US IVS, 39876 Flaaffy
                if not flat_futures(f):
                    yield f.pid
                    continue
                trade_dct = {i: v for i, v in enumerate(f.domain_trades) if not isinstance(v, FutureTrade)}
            else:
                trade_dct = {i: v for i, v in enumerate(f.domain_trades)}

            net_pos = firm_sophis_trades_enlist(trade_dct, consolidate=True, collapse_to_datetime=ref_datetime)
            if len(net_pos) == 0:
                continue

            net_cash = net_pos.loc[net_pos['TradeType'] == 'CashPosition'][['Currency', 'Notional']]
            net_pos_excl_cash = net_pos.loc[net_pos['TradeType'] != 'CashPosition']
            if len(net_pos_excl_cash):
                yield f.pid
            elif len(net_cash):
                net_cash_balance = net_cash.groupby('Currency').sum()
                net_non_usd_cash = net_cash_balance.loc[net_cash_balance.index != 'USD']
                if net_non_usd_cash.abs().sum().sum() > 2.:
                    yield f.pid


def reduce_folio(folio: CerebroPortfolio, ref_datetime: datetime.datetime = None) -> CerebroPortfolio:
    risky_pids = set(risky_pid(folio, ref_datetime=ref_datetime))
    for _, f in folio.iter_children(exclude=list(EXCLUDE_PIDS)):
        if isinstance(f, CerebroPortfolio) and f.domain_trades and f.pid not in risky_pids:
            f.domain_trades.clear()

    return folio


if __name__ == '__main__':
    pass
    from cerebro.client import CerebroClient

    cerebro_client = CerebroClient('uat')
    cerebro_client.login()

    pid = 30896
    snap = cerebro_client.get_position_snap(pid)
    # %time snap = cerebro_client.get_position_snap(pid)
    portfolio = snap.portfolio

    print(len(portfolio.all_domain_trades))
    reduce_folio(portfolio)
    print(len(portfolio.all_domain_trades))

    pids = set(risky_pid(portfolio))
    print(len(pids))
    print(pids)
    assert pids == KNOWN_RISKY_PIDS

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\patch\risk_mon.py
----------------------------------------
from typing import Any
import os
import pickle
import logging
import datetime
from cerebro.client.validate import PortfolioSnap
from cerebro.client.portfolio import CerebroPortfolio

logger = logging.getLogger(__name__)
DATA_DIR = os.getenv('RISK_MON_CALC_DIR', r'G:\GOG_IT\jchi\RiskMonCalc')


def save(obj: Any):
    filename = datetime.datetime.now().strftime('%Y%m%dT%H%M%S') + '.pickle'
    filepath = os.path.join(DATA_DIR, filename)
    with open(filepath, 'wb') as f:
        pickle.dump(obj, f)


def load() -> Any:
    *_, filename = sorted(os.listdir(DATA_DIR))
    filepath = os.path.join(DATA_DIR, filename)
    with open(filepath, 'rb') as f:
        return pickle.load(f)


class RiskMonCalc(dict):
    __repr__ = object.__repr__


def run() -> RiskMonCalc:
    from firm_f3.exceltools.positions import firm_cerebro_portfolio_refresh, firm_sophis_portfolio_select_trades
    from firm_f3.exceltools.models import nimrod_rates_model, firm_model_valuation_date, firm_model_get, \
        firm_model_data, nimrod_fx_model, nimrod_market_model
    from firm_f3.exceltools.risk_report import firm_risk_report, firm_gamma_risk_report

    pid = 30896
    snap = firm_cerebro_portfolio_refresh(pid)
    assert isinstance(snap, PortfolioSnap)
    folio = snap.portfolio
    assert isinstance(folio, CerebroPortfolio)

    # Market Model
    curr_slug = nimrod_market_model(force_weekday=True)
    curr_val_date = firm_model_valuation_date(curr_slug)
    prev_slug = nimrod_market_model(curr_val_date - datetime.timedelta(days=1), force_weekday=True)
    prev_val_date = firm_model_valuation_date(prev_slug)

    # Consolidated Trades
    trades = firm_sophis_portfolio_select_trades(folio, collapse_trades_to_date=prev_val_date)

    # Rates Risk Model
    curr_rates_slug = nimrod_rates_model(force_weekday=True)
    curr_rates_model = firm_model_get(curr_rates_slug)
    prev_rates_slug = nimrod_rates_model(prev_val_date, force_weekday=True)
    prev_rates_model = firm_model_get(prev_rates_slug)

    # Rates Risk Report
    curr_rates_risk = firm_risk_report([trades], risk_model=[curr_rates_model])
    prev_rates_risk = firm_risk_report([trades], risk_model=[prev_rates_model])

    # Rates Gamma Report
    curr_rates_gamma = firm_gamma_risk_report(trades, risk_model=curr_rates_model, bump=0.0001)
    prev_rates_gamma = firm_gamma_risk_report(trades, risk_model=prev_rates_model, bump=0.0001)

    # Rates Model Data
    curr_rates_mkt_data = firm_model_data(curr_rates_model)
    prev_rates_mkt_data = firm_model_data(prev_rates_model)

    # FX Risk Model
    curr_fx_slug = nimrod_fx_model(force_weekday=True)
    curr_fx_model = firm_model_get(curr_fx_slug)
    prev_fx_slug = nimrod_fx_model(prev_val_date, force_weekday=True)
    prev_fx_model = firm_model_get(prev_fx_slug)

    # FX Risk Report
    curr_fx_risk = firm_risk_report([trades], risk_model=[curr_fx_model])
    prev_fx_risk = firm_risk_report([trades], risk_model=[prev_fx_model])

    # FX Gamma Report
    curr_fx_gamma = firm_gamma_risk_report(trades, risk_model=curr_fx_model, bump=0.0001)
    prev_fx_gamma = firm_gamma_risk_report(trades, risk_model=prev_fx_model, bump=0.0001)

    # FX Model Data
    curr_fx_mkt_data = firm_model_data(curr_fx_model)
    prev_fx_mkt_data = firm_model_data(prev_fx_model)

    return RiskMonCalc(
        snap=snap,
        trades=trades,
        curr_slug=curr_slug,
        prev_slug=prev_slug,
        curr_rates_slug=curr_rates_slug,
        prev_rates_slug=prev_rates_slug,
        curr_rates_risk=curr_rates_risk,
        prev_rates_risk=prev_rates_risk,
        curr_rates_gamma=curr_rates_gamma,
        prev_rates_gamma=prev_rates_gamma,
        curr_rates_mkt_data=curr_rates_mkt_data,
        prev_rates_mkt_data=prev_rates_mkt_data,
        curr_fx_slug=curr_fx_slug,
        prev_fx_slug=prev_fx_slug,
        curr_fx_risk=curr_fx_risk,
        prev_fx_risk=prev_fx_risk,
        curr_fx_gamma=curr_fx_gamma,
        prev_fx_gamma=prev_fx_gamma,
        curr_fx_mkt_data=curr_fx_mkt_data,
        prev_fx_mkt_data=prev_fx_mkt_data,
    )


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\patch\__init__.py
----------------------------------------

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\patch\__pycache__\__init__.cpython-37.pyc
----------------------------------------
B

    y  d                    @   s   d S )N  r   r   r    GE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/patch/__init__.py <module>        
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\reporting\cashflow.py
----------------------------------------
from typing import List, Union, Iterable, Tuple
import pandas as pd
from f3sdk.f3 import F3Object  # type: ignore

from firm_domain import Trade
from firm_f3.evaluate import cashflow_async

async def cashflow_projection_async(trades: Union[Trade, List[Trade]],
                                    f3model: F3Object) -> Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]:
    if not isinstance(trades, Iterable):
        trades = [trades]

    res = pd.concat(await cashflow_async(trades, f3model=f3model))
    res['Certain'] = res.apply(lambda x: x['ImpliedCashflow'] if x['IsFixedFlow'] else 0, axis=1)
    res['Uncertain'] = res.apply(lambda x: 0 if x['IsFixedFlow'] else x['ImpliedCashflow'] , axis=1)
    return (pd.pivot_table(res, index='PaymentCurrency', values='ImpliedCashflow',
                           aggfunc='sum', fill_value=0, columns='PaymentDate'),
            pd.pivot_table(res, index='PaymentCurrency', values='Certain',
                           aggfunc='sum', fill_value=0, columns='PaymentDate'),
            pd.pivot_table(res, index='PaymentCurrency', values='Uncertain',
                           aggfunc='sum', fill_value=0, columns='PaymentDate'))

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\reporting\context.py
----------------------------------------
import pandas

from firm_domain import Tenor
from firm_f3.model_object.calculator import DEFAULT_RISK_TENORS, DEFAULT_FX_RISK_TENORS, DEFAULT_INFLATION_RISK_TENORS

irs_risk_map = {
    'IRS:6m:USD LIBOR:3m': 'USD',
    'IRS:12m:Euribor:6m': 'EUR',
    'IRS:6m:GBP LIBOR:6m': 'GBP',
    'IRS:6m:JPY LIBOR:6m': 'JPY',
    'IRS:3m:BBSW:3m': 'AUD',
    'IRS:6m:BKBM:3m': 'NZD',
    'IRS:6m:RateCompounding:CDOR:3m:3m': 'CAD',
    'IRS:12m:CHF LIBOR:6m': 'CHF',
    'IRS:12m:Stibor:3m': 'SEK',
    'IRS:12m:Nibor:6m': 'NOK',
    'IRS:12m:Bubor:6m': 'HUF',
    'IRS:12m:Wibor:6m': 'PLN',
    'IRS:3m:KRWCD:3m': 'KRW',
    'IRS:3m:RateCompounding:ChinaRepoRate:7d:7d': 'CNY',
    'IRS:3m:Hibor:3m': 'HKD',
    'IRS:6m:SOR:6m': 'SGD',
    'IRS:3m:Taibor:3m': 'TWD',
    'IRS:3m:NTO LIBOR:3m': 'NTO',
    'IRS:12m:Telbor:3m': 'ILS',
    'IRS:3m:Jibar:3m': 'ZAR',
    'IRS:12m:SAIBOR:3m': 'SAR',
    'IRS:3m:Klibor:3m': 'MYR',
    'IRS:6m:Bibor:6m': 'THB',
    'IRS:6m:RateCompounding:INR O/N:1b:1b': 'INR',
    'IRS:6m:RateCompounding:INO O/N:1b:1b': 'INO',
}
irs_risk_format = pandas.DataFrame([], index=list(DEFAULT_RISK_TENORS), columns=list(irs_risk_map))

scenario_risk_map = {k: v for k, v in irs_risk_map.items() if
                     v in ('USD', 'EUR', 'GBP', 'JPY', 'AUD', 'NZD', 'KRW', 'NTO', 'SAR')}
scenario_risk_format = pandas.DataFrame([], index=list(DEFAULT_RISK_TENORS), columns=list(scenario_risk_map))

basis_risk_map = {
    'CrossCurrencySwap:3m:EUR:USD': 'EUR xccy',
    'CrossCurrencySwap:3m:GBP:USD': 'GBP xccy',
    'CrossCurrencySwap:3m:JPY:USD': 'JPY xccy',
    'CrossCurrencySwap:3m:AUD:USD': 'AUD xccy',
    'CrossCurrencySwap:3m:NZD:USD': 'NZD xccy',
    'CrossCurrencySwap:6m:CAD:USD': 'CAD xccy',
    'CrossCurrencySwap:3m:CHF:USD': 'CHF xccy',
    'CrossCurrencySwap:3m:USD:SEK': 'SEK xccy',
    'CrossCurrencySwap:3m:USD:NOK': 'NOK xccy',
    'CrossCurrencySwap:3m:KRW:USD': 'KRW xccy',
    'CrossCurrencySwap:3m:HKD:USD': 'HKD xccy',
    'CrossCurrencySwap:6m:SGD:USD': 'SGD xccy',
    'CrossCurrencySwap:3m:USD:ILS': 'ILS xccy',
    'CrossCurrencySwap:3m:ZAR:USD': 'ZAR xccy',
    'CrossCurrencySwap:3m:USD:SAR': 'SAR xccy',
    'CrossCurrencySwap:3m:EUR:HUF': 'HUF xccy vs EUR',
    'CrossCurrencySwap:3m:EUR:PLN': 'PLN xccy vs EUR',
    'BasisSwap:3m:RateCompounding:USD LIBOR:1m:1mvs3m:USD LIBOR:3m': 'USD 1s3s',
    'BasisSwap:6m:RateCompounding:USD LIBOR:3m:3mvs6m:USD LIBOR:6m': 'USD 3s6s',
    'BasisSwap:6m:Euribor:3mvs6m:Euribor:6m': 'EUR 3s6s',
    'BasisSwap:6m:GBP LIBOR:3mvs6m:GBP LIBOR:6m': 'GBP 3s6s',
    'BasisSwap:6m:JPY LIBOR:3mvs6m:JPY LIBOR:6m': 'JPY 3s6s',
    'BasisSwap:3m:BBSW:1mvs3m:BBSW:3m': 'AUD 1s3s',
    'BasisSwap:6m:BBSW:3mvs6m:BBSW:6m': 'AUD 3s6s',
    'BasisSwap:6m:CHF LIBOR:3mvs6m:CHF LIBOR:6m': 'CHF 3s6s',
    'BasisSwap:6m:Nibor:3mvs6m:Nibor:6m': 'NOK 3s6s',
    'BasisSwap:6m:Bubor:3mvs6m:Bubor:6m': 'HUF 3s6s',
    'BasisSwap:6m:Wibor:3mvs6m:Wibor:6m': 'PLN 3s6s',
    'BasisSwap:3m:Hibor:1mvs3m:Hibor:3m': 'HKD 1s3s',
    'BasisSwap:6m:SOR:3mvs6m:SOR:6m': 'SGD 3s6s',
    'BasisSwap:3m:RateCompounding:USD O/N:1b:1bvs3m:USD LIBOR:3m': 'USD ois',
    'BasisSwap:6m:RateCompounding:EUR O/N:1b:1bvs6m:Euribor:6m': 'EUR ois',
    'BasisSwap:6m:RateCompounding:GBP O/N:1b:1bvs6m:GBP LIBOR:6m': 'GBP ois',
    'BasisSwap:6m:RateCompounding:JPY O/N:1b:1bvs6m:JPY LIBOR:6m': 'JPY ois',
    'BasisSwap:3m:RateCompounding:AUD O/N:1b:1bvs3m:BBSW:3m': 'AUD ois',
    'BasisSwap:3m:RateCompounding:NZD O/N:1b:1bvs3m:BKBM:3m': 'NZD ois',
    'BasisSwap:6m:RateCompounding:CAD O/N:1b:1bvs6m:RateCompounding:CDOR:3m:3m': 'CAD ois',
    'BasisSwap:6m:RateCompounding:CHF O/N:1b:1bvs6m:CHF LIBOR:6m': 'CHF ois',
    'BasisSwap:3m:RateCompounding:SEK O/N:1b:1bvs3m:Stibor:3m': 'SEK ois',
    'BasisSwap:6m:RateCompounding:NOK O/N:1b:6mvs6m:Nibor:6m': 'NOK ois',
    'BasisSwap:3m:RateCompounding:HKD O/N:1b:1bvs3m:Hibor:3m': 'HKD ois',
    'BasisSwap:6m:RateCompounding:SGD O/N:1b:1bvs6m:SOR:6m': 'SGD ois',
    'BasisSwap:3m:RateCompounding:ILS O/N:1b:3mvs3m:Telbor:3m': 'ILS ois',
    'BasisSwap:3m:RateCompounding:ZAR O/N:1b:3mvs3m:Jibar:3m': 'ZAR ois',
    'BasisSwap:3m:RateCompounding:SAR O/N:1b:3mvs3m:SAIBOR:3m': 'SAR ois',
    'BasisSwap:6m:RateCompounding:HUF O/N:1b:1bvs6m:Bubor:6m': 'HUF ois',
    'BasisSwap:6m:RateCompounding:PLN O/N:1b:1bvs6m:Wibor:6m': 'PLN ois',
}
basis_risk_format = pandas.DataFrame([], index=list(DEFAULT_RISK_TENORS), columns=list(basis_risk_map))

ccs_risk_map = {
    'CrossCurrencySwap:3m:USD:CNH': 'CNH ccs',
    'CrossCurrencySwap:12m:USD:RUB': 'RUB ccs',
    'CrossCurrencySwap:6m:USD:INR': 'INR ccs',
    'CrossCurrencySwap:6m:USD:INO': 'INO ccs',
    'CrossCurrencySwap:12m:USD:TRY': 'TRY ccs',
    'CrossCurrencySwap:6m:USD:TWD': 'TWD ccs',
}
ccs_risk_format = pandas.DataFrame([], index=list(DEFAULT_RISK_TENORS), columns=list(ccs_risk_map))

ir_risk_map = {**irs_risk_map, **basis_risk_map, **ccs_risk_map}
ir_risk_format = pandas.DataFrame([], index=list(DEFAULT_RISK_TENORS), columns=list(ir_risk_map))

inf_risk_map = {
    'ZCISwap:12m:InterpolatedInflation:USD:RPI': 'CPURNSA'
}
inf_risk_format = pandas.DataFrame([], index=list(DEFAULT_INFLATION_RISK_TENORS), columns=list(inf_risk_map))

irv_risk_format = pandas.DataFrame([], index=[
    Tenor.T_1M, Tenor.T_3M, Tenor.T_6M, Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_7Y,
    Tenor.T_10Y, Tenor.T_15Y, Tenor.T_20Y, Tenor.T_30Y
], columns=[
    Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_4Y, Tenor.T_5Y, Tenor.T_7Y, Tenor.T_10Y, Tenor.T_15Y,
    Tenor.T_20Y, Tenor.T_30Y
])

fx_risk_map = {
    'FXSpotRawValueExposure': 'Delta',
    'Gamma': 'Gamma',
    'Theta': 'Theta',
}
fx_risk_format = pandas.DataFrame([], index=[
    'EUR', 'GBP', 'JPY', 'AUD', 'NZD', 'CAD', 'SEK', 'HUF/EUR', 'PLN/EUR', 'KRW', 'CNY', 'CNH', 'HKD', 'SGD', 'TWD',
    'NTO', 'ILS', 'ZAR', 'RUB', 'THB', 'MYR', 'INR', 'INO', 'PHP', 'IDR', 'TRY'
], columns=list(fx_risk_map))

fxv_risk_map = {
    'EUR': 'EUR',
    'GBP': 'GBP',
    'JPY': 'JPY',
    'AUD': 'AUD',
    'NZD': 'NZD',
    'KRW': 'KRW',
    'CNH': 'CNH',
    'CNY': 'CNY',
    'HKD': 'HKD',
    'TWD': 'TWD',
    'SGD': 'SGD',
    'PHP': 'PHP',
    'INR': 'INR',
    'IDR': 'IDR',
    'TRY': 'TRY'
}
fxv_risk_format = pandas.DataFrame([], index=[
    Tenor.T_1W, Tenor.T_2W, Tenor.T_1M, Tenor.T_2M, Tenor.T_3M, Tenor.T_6M,
    Tenor.T_1Y, Tenor.T_2Y, Tenor.T_3Y, Tenor.T_5Y
], columns=list(fxv_risk_map))

fx_fwd_risk_map = {
    'FXForward:EUR:USD': 'EUR',
    'FXForward:GBP:USD': 'GBP',
    'FXForward:USD:JPY': 'JPY',
    'FXForward:AUD:USD': 'AUD',
    'FXForward:NZD:USD': 'NZD',
    'FXForward:USD:CAD': 'CAD',
    'FXForward:USD:CHF': 'CHF',
    'FXForward:USD:NOK': 'NOK',
    'FXForward:USD:SEK': 'SEK',
    'FXForward:EUR:HUF': 'HUF/EUR',
    'FXForward:EUR:PLN': 'PLN/EUR',
    'FXNDFwd:USD:KRW': 'KRW',
    'FXNDFwd:USD:CNY': 'CNY',
    'FXForward:USD:CNH': 'CNH',
    'FXForward:USD:HKD': 'HKD',
    'FXForward:USD:SGD': 'SGD',
    'FXNDFwd:USD:TWD': 'TWD',
    'FXNDFwd:USD:NTO': 'NTO',
    'FXForward:USD:THB': 'THB',
    'FXNDFwd:USD:MYR': 'MYR',
    'FXNDFwd:USD:PHP': 'PHP',
    'FXNDFwd:USD:IDR': 'IDR',
    'FXNDFwd:USD:INR': 'INR',
    'FXNDFwd:USD:INO': 'INO',
    'FXForward:USD:ZAR': 'ZAR',
    'FXForward:USD:SAR': 'SAR',
    'FXForward:USD:ILS': 'ILS',
    'FXForward:USD:RUB': 'RUB',
    'FXForward:USD:TRY': 'TRY'
}
fx_fwd_risk_format = pandas.DataFrame([], index=[Tenor.SPOT, *DEFAULT_FX_RISK_TENORS], columns=list(fx_fwd_risk_map))

fx_fwd_tenor_map = {
    '1y': '12m',
    '2y': '24m',
}

if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\reporting\models.py
----------------------------------------
from f3sdk.f3 import F3Object  # type:ignore
from firm_f3.evaluate import apply_composite_bump_scenario

from .context import irs_risk_map


def model_apply_bump_scenario(f3model: object, bump: float) -> object:
    assert isinstance(f3model, F3Object)
    ccy = set(irs_risk_map.values())
    # ccy.add('CNH')  # jchi@201911 bump to get CNH CCS gamma
    return apply_composite_bump_scenario(*ccy, bump=bump, f3model=f3model)

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\reporting\pnlexplain.py
----------------------------------------
import datetime
from typing import Dict, Any, List
import pandas  # type:ignore
from f3sdk.f3 import F3Object  # type:ignore

from cerebro.client.validate import PortfolioSnap
from cerebro.client.portfolio import CerebroPortfolio
import firm_f3.f3client  # type:ignore
from firm_f3 import logging as f3log
from firm_domain import SabrCoefficient, Trade, FxSpotMarketData, Tenor, Ccy
from firm_f3.mapping import f3market_data, initiate_platform_objects, PLATFORM_INDEX_CURVE
from firm_f3.util.utils import timer
from firm_f3.datalayer.sophis import SophisPortfolio
from firm_f3.evaluate.handlers import market_data_irs_handler, market_data_basis_handler, market_data_ccs_handler, \
    market_data_simple_tenor_handler, market_data_fx_spot_handler, market_data_fx_sabr_handler, \
    market_data_fx_fwd_handler
from firm_f3.evaluate import f3_evaluate, pv_async, condensed_market_data_handler, market_data_fixings_handler
from firm_f3.model_object.util import extend_model_with_fixings

from .context import irs_risk_map, irs_risk_format, basis_risk_map, basis_risk_format, ccs_risk_map, ccs_risk_format, \
    ir_risk_map, ir_risk_format, fx_risk_format, fxv_risk_map, fxv_risk_format, fx_fwd_risk_map, fx_fwd_risk_format, \
    fx_fwd_tenor_map
from .riskreport import irs_risk, basis_risk, fx_risk, fxv_risk, irv_vega, risk_report_subset, GammaReportResult


class PnlExplainedReportResult(dict):
    def pnl_cur_vs_ref(self):
        return {k: j - i for k, (i, j, *_) in self.items() if
                isinstance(i, (int, float)) and isinstance(j, (int, float))}

    def pnl_mkt_vs_mkt(self):
        return {k: j - i for k, (_, _, i, j, *_) in self.items() if
                isinstance(i, (int, float)) and isinstance(j, (int, float))}

    def good_morning(self):
        return {k: j - i for k, (i, _, _, _, j, *_) in self.items() if
                isinstance(i, (int, float)) and isinstance(j, (int, float))}

    def fx_pnl(self):
        return {k: j - i for k, (i, *_, j, _) in self.items() if
                isinstance(i, (int, float)) and isinstance(j, (int, float))}

    def ir_pnl(self):
        return {k: j - i for k, (i, *_, j) in self.items() if
                isinstance(i, (int, float)) and isinstance(j, (int, float))}

    def fixings_pnl(self):
        return {k: j - i for k, (_, j, _, _, _, i, *_) in self.items() if
                isinstance(i, (int, float)) and isinstance(j, (int, float))}


def pnl_explained_report(
        trades: object,
        ref_model: object,
        cur_model: object,
        ref_mkt_model: object,
        cur_mkt_model: object,
        ref_market_data: object,
        cur_market_data: object,
        forward_valuation_date: datetime.date,
) -> object:
    f3 = firm_f3.f3client.get_platform_client()
    assert isinstance(trades, (list, dict)), 'trades argument is not Union[list, dict]'
    assert isinstance(ref_model, F3Object), 'ref_model argument is not an F3Object'
    assert isinstance(cur_model, F3Object), 'cur_model argument is not an F3Object'
    assert isinstance(ref_mkt_model, F3Object), 'ref_mkt_model argument is not an F3Object'
    assert isinstance(cur_mkt_model, F3Object), 'cur_mkt_model argument is not an F3Object'
    assert isinstance(ref_market_data, list), 'ref_market_data argument is not an list'
    assert isinstance(cur_market_data, list), 'cur_market_data argument is not an list'
    assert isinstance(forward_valuation_date, datetime.date), 'forward_valuation_date is not a datetime.date'
    if isinstance(trades, dict):
        keys, values = list(zip(*((k, v) for k, v in trades.items() if isinstance(v, (F3Object, Trade)))))
    else:
        keys = list(range(len(trades)))
        values = trades

    initiate_platform_objects()
    fixings = market_data_fixings_handler(ref_market_data)
    fixings.columns = [PLATFORM_INDEX_CURVE[i] for i in fixings.columns]
    ref_md = condensed_market_data_handler(ref_market_data)
    cur_md = condensed_market_data_handler(cur_market_data)
    ref_fx_md = f3market_data(*filter(lambda x: isinstance(x, FxSpotMarketData) or x.name[0].startswith('FX'), ref_md))
    cur_fx_md = f3market_data(*filter(lambda x: isinstance(x, FxSpotMarketData) or x.name[0].startswith('FX'), cur_md))

    fwd_val_spec = f3.CreateForwardValuationSpecification(
        UnderlyingValuationMethod='DefaultUSD',
        Horizon=forward_valuation_date,
        FutureHistory=['Flat', 'IncludeRealizedValue'],
    )

    # PV requests that are split in order to avoid overwhelming the platform
    with timer(f'awaited for 1st/3 batch PV of {len(values)} trades'):
        res_ref, res_cur, res_ref_mkt, res_cur_mkt = f3_evaluate(
            # 1). PV based on previous risk model
            pv_async(values, f3model=ref_model),
            # 2). PV based on current risk model
            pv_async(values, f3model=cur_model),
            # 3). PV based on previous market model
            pv_async(values, f3model=ref_mkt_model),
            # 4). PV based on current market model
            pv_async(values, f3model=cur_mkt_model),
        )
    with timer(f'awaited for 2nd/3 batch PV of {len(values)} trades'):
        res_ref_fwd, res_mkt_fwd = f3_evaluate(
            # 5). PV based on previous risk model forward valuating
            pv_async(values, f3model=ref_model, valuation_method=fwd_val_spec),

            # 6). PV based on previous risk model forward valuating with current market data
            pv_async(values, f3model=extend_model_with_fixings(
                model=f3.ExtendModelWithAllMarketDataFromModel(
                    BaseModel=ref_model,
                    SourceModel=cur_model,
                ),
                fixings=fixings), valuation_method=fwd_val_spec),
        )
    with timer(f'awaited for 3rd/3 batch PV of {len(values)} trades'):
        res_fx_fwd, res_ir_fwd = f3_evaluate(
            # 7). PV based on previous risk model forward valuating with current FX market data overwrite
            pv_async(values, f3model=f3.ExtendModelWithMarketData(
                BaseModel=ref_model,
                MarketData=cur_fx_md
            ), valuation_method=fwd_val_spec),

            # 8). PV based on previous risk model forward valuating with current non-FX data
            pv_async(values, f3model=extend_model_with_fixings(
                model=f3.ExtendModelWithMarketData(
                    BaseModel=f3.ExtendModelWithAllMarketDataFromModel(
                        BaseModel=ref_model,
                        SourceModel=cur_model
                    ),
                    MarketData=ref_fx_md
                ),
                fixings=fixings), valuation_method=fwd_val_spec),
        )
    return PnlExplainedReportResult((k, v) for k, *v in
                                    zip(keys, res_ref, res_cur, res_ref_mkt, res_cur_mkt, res_ref_fwd, res_mkt_fwd,
                                        res_fx_fwd, res_ir_fwd))


def portfolio_pnl(
        risk_report_result: Dict,
        unit: float = 1_000,
        folio: Any = None,
) -> float:
    if isinstance(folio, PortfolioSnap):
        folio = folio.portfolio
    assert isinstance(folio, (SophisPortfolio, CerebroPortfolio))
    return sum(risk_report_subset(risk_report_result, root=folio)) / unit


def irs_market_data(market_data: object, unit: float = 0.01) -> pandas.DataFrame:
    assert isinstance(market_data, list)
    rv = market_data_irs_handler(market_data)

    df, _ = rv.align(irs_risk_format, join='right')
    df.columns = [irs_risk_map.get(i, i) for i in df.columns]
    df.index = [str(i).lower() for i in df.index]
    return df.div(unit).fillna(0)


def basis_market_data(market_data: object, unit: float = 0.0001) -> pandas.DataFrame:
    assert isinstance(market_data, list)
    rv = market_data_basis_handler(market_data)

    df, _ = rv.align(basis_risk_format, join='right')
    df.columns = [basis_risk_map.get(i, i) for i in df.columns]
    df.index = [str(i).lower() for i in df.index]
    return df.div(unit).fillna(0)


def ccs_market_data(market_data: object, unit: float = 0.01) -> pandas.DataFrame:
    assert isinstance(market_data, list)
    rv = market_data_ccs_handler(market_data)

    df, _ = rv.align(ccs_risk_format, join='right')
    df.columns = [ccs_risk_map.get(i, i) for i in df.columns]
    df.index = [str(i).lower() for i in df.index]
    return df.div(unit).fillna(0)


def ir_market_data_change(
        curr_market_data: object,
        prev_market_data: object,
        unit: float = 1e-4,
) -> pandas.DataFrame:
    assert isinstance(curr_market_data, list)
    assert isinstance(prev_market_data, list)
    curr = market_data_simple_tenor_handler(curr_market_data)
    prev = market_data_simple_tenor_handler(prev_market_data)
    rv = curr.sub(prev)

    df, _ = rv.align(ir_risk_format, join='right')
    df.columns = [ir_risk_map.get(i, i) for i in df.columns]
    df.index = [str(i).lower() for i in df.index]
    return df.div(unit)


def fxv_sabr_market_data(market_data: object, sabr_coeff: str, unit: float = 0.01) -> pandas.DataFrame:
    assert isinstance(market_data, list)
    assert sabr_coeff.upper() in [i.name for i in list(SabrCoefficient)], f'invalid SABR coefficient `{sabr_coeff}`'
    rv = market_data_fx_sabr_handler(market_data)

    try:
        rv = rv[f'SABR{sabr_coeff}']
    except KeyError:
        df = fxv_risk_format.copy()
    else:
        df, _ = rv.align(fxv_risk_format, join='right')
    df.columns = [fxv_risk_map.get(i, i) for i in df.columns]
    df.index = [str(i).lower() for i in df.index]
    return df.div(unit).fillna(0)


def fx_spot_market_data(market_data: object, unit: float = 1, index: List[str] = None) -> pandas.DataFrame:
    assert isinstance(market_data, list)
    rv = market_data_fx_spot_handler(market_data)
    if index is None:
        rv = rv[sorted(rv.index, key=lambda x: Ccy[x[:3]])]
    else:
        rv = rv[[i for i in index if i]]
    return rv.div(unit).to_frame()


def fx_fwd_market_data(market_data: object, unit: float = 1, index: List[str] = None) -> pandas.DataFrame:
    def clean_ccy(x: str) -> str:
        left, _, right = x.partition(':')
        if left == 'USD':
            return right
        elif right == 'USD':
            return left
        elif left == 'EUR':
            return f'{right}/{left}'
        return f'{left}:{right}'

    assert isinstance(market_data, list)
    fx_point = market_data_fx_fwd_handler(market_data)
    fx_point.columns = [clean_ccy(i.partition(':')[-1]) for i in fx_point.columns]
    fx_spot = market_data_fx_spot_handler(market_data, return_fx_pairs=True).rename(Tenor.SPOT).to_frame().T
    fx_spot.columns = [clean_ccy(i) for i in fx_spot.columns]
    rv = pandas.concat([fx_spot, fx_point], sort=False)

    if index is None:
        df = rv[sorted(rv.columns, key=lambda x: Ccy[x[:3]])]
    else:
        df = rv[[i for i in index if i]]
    df.index = [fx_fwd_tenor_map.get(str(i).lower(), str(i).lower()) for i in df.index]
    return df.div(unit)


def fx_spot_market_data_change(
        curr_market_data: object,
        prev_market_data: object,
        unit: float = 1,
) -> pandas.Series:
    assert isinstance(curr_market_data, list)
    assert isinstance(prev_market_data, list)
    curr = market_data_fx_spot_handler(curr_market_data)
    prev = market_data_fx_spot_handler(prev_market_data)
    rv = curr.div(prev).sub(1)

    return rv.div(unit)[fx_risk_format.index]


def pnl_explained(
        pnl_report_result: object,
        risk_report_result: object,
        unit: float,
        folio: object,
        ir_step: pandas.DataFrame,
        fx_step: pandas.Series,
) -> pandas.Series:
    if isinstance(folio, PortfolioSnap):
        folio = folio.portfolio
    assert isinstance(folio, (SophisPortfolio, CerebroPortfolio))
    pnl_report_result = pnl_report_result or PnlExplainedReportResult({})

    def unpack():
        assert isinstance(risk_report_result, (list, dict))

        with f3log.debug(False):
            gm_pnl = portfolio_pnl(pnl_report_result.good_morning(), unit=1, folio=folio)
            yield 'Good Morning', gm_pnl

            pnl = fx_risk(
                risk_report_result, GammaReportResult(({}, {}), 1), unit=1, folio=folio).mul(fx_step, axis=0)
            fx_delta_pnl = pnl['Delta'].sum()
            yield 'FX delta', fx_delta_pnl

            fx_pnl = portfolio_pnl(pnl_report_result.fx_pnl(), unit=1, folio=folio)
            fx_gamma_pnl = fx_pnl - gm_pnl - fx_delta_pnl
            yield 'FX gamma', fx_gamma_pnl

            pnl = fxv_risk(risk_report_result, unit=1, folio=folio).mul(fx_step, axis=1)
            fx_vega_pnl = pnl.sum().sum()
            yield 'FX vega', fx_vega_pnl

            pnl = irs_risk(risk_report_result, unit=1, folio=folio).mul(ir_step)
            ir_delta_pnl = pnl.sum().sum()
            yield 'IR delta', ir_delta_pnl

            ir_pnl = portfolio_pnl(pnl_report_result.ir_pnl(), unit=1, folio=folio)
            ir_gamma_pnl = ir_pnl - gm_pnl - ir_delta_pnl
            yield 'IR gamma', ir_gamma_pnl

            pnl = irv_vega(risk_report_result, unit=1, folio=folio)
            if len(pnl):
                ir_vega_pnl = sum(pnl[ccy].sum(axis=1).mul(ir_step[ccy]).sum() for ccy in pnl.columns.levels[0])
            else:
                ir_vega_pnl = 0.
            yield 'IR vega', ir_vega_pnl

            pnl = basis_risk(risk_report_result, unit=1, folio=folio).mul(ir_step)
            ir_basis_pnl = pnl.sum().sum()
            yield 'IR basis', ir_basis_pnl

            yield 'Security basis', None
            yield 'Futures basis', None

            fixings_pnl = portfolio_pnl(pnl_report_result.fixings_pnl(), unit=1, folio=folio)
            yield 'Fixings', fixings_pnl

            cur_vs_ref_pnl = portfolio_pnl(pnl_report_result.pnl_cur_vs_ref(), unit=1, folio=folio)
            explained_pnl = gm_pnl + fx_delta_pnl + fx_gamma_pnl + fx_vega_pnl + ir_delta_pnl + ir_gamma_pnl + \
                            ir_vega_pnl + ir_basis_pnl + fixings_pnl
            yield 'Crosses', cur_vs_ref_pnl - explained_pnl

            yield 'Activity', None

            mkt_vs_mkt_pnl = portfolio_pnl(pnl_report_result.pnl_mkt_vs_mkt(), unit=1, folio=folio)
            yield 'Unexplained', mkt_vs_mkt_pnl - cur_vs_ref_pnl

    return pandas.Series(dict(unpack()), name=folio.pid).div(unit)


def pnl_explained_enlist(
        pnl_report_result: object,
        risk_report_result: object,
        unit: float,
        root: object,
        ir_step: pandas.DataFrame,
        fx_step: pandas.Series,
) -> pandas.DataFrame:
    if isinstance(root, PortfolioSnap):
        root = root.portfolio

    def unpack():
        assert isinstance(root, (SophisPortfolio, CerebroPortfolio))
        with f3log.debug(False):
            for _, folio in root.iter():
                yield pnl_explained(
                    pnl_report_result=pnl_report_result,
                    risk_report_result=risk_report_result,
                    unit=unit,
                    folio=folio,
                    ir_step=ir_step,
                    fx_step=fx_step
                )

    return pandas.DataFrame(unpack()).fillna(0)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\reporting\pricer.py
----------------------------------------
from typing import Dict, List
from f3sdk.f3 import F3Object  # type: ignore

from firm_domain import Trade, FXOptionTrade, SwaptionTrade
from firm_f3.evaluate import pv_async, par_rate, gamma, imp_vol, delta, f3_evaluate


async def _risk_pv_single(
        trades: object,
        f3model: object
) -> Dict[str, float]:
    assert isinstance(trades, (list, dict)), 'trades argument is not Union[list, dict]'
    assert isinstance(f3model, F3Object), 'f3model argument is not an F3Object'
    if isinstance(trades, dict):
        keys, values = list(zip(*((k, v) for k, v in trades.items() if isinstance(v, (F3Object, Trade)))))
    else:
        keys = list(range(len(trades)))
        values = trades
    rv = await pv_async(values, f3model=f3model)
    return dict(zip(keys, rv))


def risk_pv(
        trades: List[object],
        f3model: List[object]
) -> List[Dict[str, float]]:
    assert isinstance(trades, list) and trades
    assert isinstance(f3model, list) and f3model
    if len(f3model) == 1:
        return f3_evaluate(*(_risk_pv_single(i, f3model[0]) for i in trades))
    elif len(trades) == 1:
        return f3_evaluate(*(_risk_pv_single(trades[0], m) for m in f3model))
    assert len(trades) == len(f3model)
    rv = f3_evaluate(*(_risk_pv_single(i, m) for i, m in zip(trades, f3model)))
    if len(rv) == 1:
        # unpack it to a dict instead of a list of 1 dict, which breaks in Excel formula cell
        return rv[0]
    return rv


def risk_par_rate(trades: object, f3model: object) -> Dict[str, float]:
    assert isinstance(trades, (list, dict)), 'trades argument is not Union[list, dict]'
    assert isinstance(f3model, F3Object), 'f3model argument is not an F3Object'
    if isinstance(trades, dict):
        keys, values = list(zip(*((k, v) for k, v in trades.items() if isinstance(v, (F3Object, Trade)))))
    else:
        keys = list(range(len(trades)))
        values = trades
    rv = par_rate(values, f3model=f3model)
    return dict(zip(keys, rv))


def risk_delta(trades: object, f3model: object) -> Dict[str, float]:
    assert isinstance(trades, (list, dict)), 'trades argument is not Union[list, dict]'
    assert isinstance(f3model, F3Object), 'f3model argument is not an F3Object'
    if isinstance(trades, dict):
        keys, values = list(zip(*((k, v) for k, v in trades.items() if isinstance(v, (F3Object, Trade)))))
    else:
        keys = list(range(len(trades)))
        values = trades
    rv = delta(values, f3model=f3model)
    return dict(zip(keys, rv))


def risk_dv01_delta(trades: object, f3model: object) -> Dict[str, float]:
    assert isinstance(trades, (list, dict)), 'trades argument is not Union[list, dict]'
    assert isinstance(f3model, F3Object), 'f3model argument is not an F3Object'
    if isinstance(trades, dict):
        keys, values = list(zip(*((k, v) for k, v in trades.items() if isinstance(v, (F3Object, Trade)))))
    else:
        keys = list(range(len(trades)))
        values = trades
    rv = delta(values, f3model=f3model)
    return {k: v / 1e4 if isinstance(v, (float, int)) else v for k, v in zip(keys, rv)}


def risk_gamma(trades: object, f3model: object) -> Dict[str, float]:
    assert isinstance(trades, (list, dict)), 'trades argument is not Union[list, dict]'
    assert isinstance(f3model, F3Object), 'f3model argument is not an F3Object'
    if isinstance(trades, dict):
        keys, values = list(
            zip(*((k, v) for k, v in trades.items() if isinstance(v, (F3Object, SwaptionTrade, FXOptionTrade)))))
    else:
        keys = list(range(len(trades)))
        values = trades
    rv = gamma(values, f3model=f3model)
    return dict(zip(keys, rv))


def risk_dv01_gamma(trades: object, f3model: object) -> Dict[str, float]:
    assert isinstance(trades, (list, dict)), 'trades argument is not Union[list, dict]'
    assert isinstance(f3model, F3Object), 'f3model argument is not an F3Object'
    if isinstance(trades, dict):
        keys, values = list(
            zip(*((k, v) for k, v in trades.items() if isinstance(v, (F3Object, SwaptionTrade, FXOptionTrade)))))
    else:
        keys = list(range(len(trades)))
        values = trades
    rv = gamma(values, f3model=f3model)
    return {k: v / 1e8 if isinstance(v, (float, int)) else v for k, v in zip(keys, rv)}


def risk_iv(trades: object, f3model: object) -> Dict[str, float]:
    assert isinstance(trades, (list, dict)), 'trades argument is not Union[list, dict]'
    assert isinstance(f3model, F3Object), 'f3model argument is not an F3Object'
    if isinstance(trades, dict):
        keys, values = list(
            zip(*((k, v) for k, v in trades.items() if isinstance(v, (F3Object, SwaptionTrade, FXOptionTrade)))))
    else:
        keys = list(range(len(trades)))
        values = trades
    rv = imp_vol(values, f3model=f3model)
    return dict(zip(keys, rv))


__all__ = [i for i in globals() if i.startswith('risk_')]

if __name__ == '__main__':
    pass
    # import datetime
    # from firm_f3.evaluate import *
    # from firm_f3.exceltools import *
    #
    # # f3model = firm_model_get()
    # f3model = firm_risk_model_get()
    # irs1 = firm_irs(datetime.date(2019, 9, 10), 'USD', datetime.date(2019, 9, 12), datetime.date(2021, 9, 11), 100,
    #                 0.02, '3M')
    # irs2 = firm_irs(datetime.date(2019, 9, 10), 'EUR', datetime.date(2022, 9, 12), datetime.date(2027, 9, 11), 100,
    #                 -0.00165, '6M')
    # swaption1 = firm_swaption(datetime.date(2019, 9, 15), 'EUR', datetime.date(2022, 9, 19), 'Receiver',
    #                           datetime.date(2022, 9, 21), datetime.date(2027, 9, 21), '6M', -0.00165, 100)
    # trades = {'irs1': irs1, 'irs2': irs2, 'swaption1': swaption1}
    #
    # firm_pv(trades, f3model)
    # firm_iv(trades, f3model)
    # firm_dv01_delta(trades, f3model)

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\reporting\riskreport.py
----------------------------------------
from typing import Union, Dict, List, Any, Tuple
from collections import Counter

import pandas  # type:ignore
from f3sdk.f3 import F3Object  # type:ignore

from cerebro.client.validate import PortfolioSnap
from cerebro.client.portfolio import CerebroPortfolio
from firm_domain import Trade, SabrCoefficient, Tenor, Ccy
from firm_f3.util.utils import flattener, timer
from firm_f3.datalayer.sophis import SophisPortfolio
from firm_f3.evaluate import (
    f3_evaluate, risk_report_async, RISK_REPORT_TYPE, risk_report_pvbp_handler, risk_report_ir_vega_handler,
    risk_report_fx_spot_handler, risk_report_fx_sabr_handler, risk_report_ccs_vega_handler,
    risk_report_fx_fwd_outright_handler, apply_fx_spot_scenario_to_model,
)

from .context import (
    irs_risk_map, irs_risk_format, basis_risk_map, basis_risk_format, ccs_risk_map, ccs_risk_format, irv_risk_format,
    fxv_risk_map, fxv_risk_format, scenario_risk_map, scenario_risk_format, fx_fwd_tenor_map, fx_fwd_risk_format,
    fx_risk_format, fx_fwd_risk_map, fx_risk_map, inf_risk_map, inf_risk_format,
)
from .models import model_apply_bump_scenario
from .pricer import risk_pv


async def _risk_report_single(
        trades: object,
        risk_model: object
) -> object:
    assert isinstance(trades, (list, dict)), 'trades argument is not Union[list, dict]'
    assert isinstance(risk_model, F3Object), 'risk_model argument is not an F3Object'
    if isinstance(trades, dict):
        keys, values = list(zip(*((k, v) for k, v in trades.items() if isinstance(v, (F3Object, Trade)))))
    else:
        keys = list(range(len(trades)))
        values = trades
    with timer(f'awaited for risk_report of {len(values)} trades'):
        rv = await risk_report_async(values, f3model=risk_model)
    return dict(zip(keys, rv))


def calc_risk_report(
        trades: List[object],
        risk_model: List[object],
) -> List[object]:
    assert isinstance(trades, list) and trades
    assert isinstance(risk_model, list) and risk_model
    if len(risk_model) == 1:
        return f3_evaluate(*(_risk_report_single(i, risk_model[0]) for i in trades))
    elif len(trades) == 1:
        return f3_evaluate(*(_risk_report_single(trades[0], m) for m in risk_model))
    assert len(trades) == len(risk_model)
    return f3_evaluate(*(_risk_report_single(i, m) for i, m in zip(trades, risk_model)))


class GammaReportResult:
    def __init__(self, res: Tuple[dict, dict], bump_size: float):
        self.res_up, self.res_dn = res
        self.bump_size = bump_size


def gamma_risk_report(
        trades: object,
        risk_model: object,
        bump: float = 0.0001,
) -> object:
    assert bump > 0
    model_up = model_apply_bump_scenario(risk_model, bump=bump)
    model_dn = model_apply_bump_scenario(risk_model, bump=-bump)
    res_up, res_dn = calc_risk_report([trades], [model_up, model_dn])
    return GammaReportResult((res_up, res_dn), bump_size=bump * 10000)


def fx_gamma_risk_report(
        trades: object,
        risk_model: object,
        baseline_market_data: object,
        bump: float = 0.0025,
) -> object:
    assert bump > 0
    model_up = apply_fx_spot_scenario_to_model(risk_model, lambda x: x * (1 + bump), market_data=baseline_market_data)
    model_dn = apply_fx_spot_scenario_to_model(risk_model, lambda x: x * (1 - bump), market_data=baseline_market_data)
    res_up, res_dn = calc_risk_report([trades], [model_up, model_dn])
    return GammaReportResult((res_up, res_dn), bump_size=bump * 10000)


SCENARIOS = {
    '-25bp': -0.0025,
    '-10bp': -0.001,
    '0bp': 0.,
    '10bp': 0.001,
    '25bp': 0.0025,
}


class ScenarioResult(dict):
    pnl: Dict[str, Counter]

    def __init__(self, *args, pnl=None, **kwargs):
        super().__init__(*args, **kwargs)
        self.pnl = pnl


def scenario_risk_report(
        trades: object,
        risk_model: object,
) -> object:
    models = [model_apply_bump_scenario(risk_model, bump=bump) for bump in SCENARIOS.values()]
    reports = calc_risk_report([trades], models)
    pv = risk_pv([trades], models)
    pv_dct = dict(zip(SCENARIOS, map(Counter, pv)))

    def unpack():
        base = pv_dct['0bp']
        for k, v in pv_dct.items():
            if k == '0bp':
                yield k, {}
            else:
                v.subtract(base)
                yield k, v

    return ScenarioResult(zip(SCENARIOS, reports), pnl=dict(unpack()))


def risk_report_subset(
        res: Union[RISK_REPORT_TYPE, Dict[str, RISK_REPORT_TYPE]],
        root: Union[SophisPortfolio, CerebroPortfolio, PortfolioSnap] = None,
        pids: str = None,
) -> RISK_REPORT_TYPE:
    if isinstance(root, PortfolioSnap):
        root = root.portfolio
    if isinstance(root, (SophisPortfolio, CerebroPortfolio)):
        if pids is None:
            # Use case: clear out excel tab for anonymity
            return []
        elif isinstance(pids, str):
            pids = set(map(int, filter(None, pids.split(','))))
        if not pids:
            # Use case: when nothing is selected by the Portfolio Selector, assume to select all
            pids = 'all'

        def unpack():
            for _, folio in root.iter():
                if pids == 'all' or folio.pid in pids:
                    for i in range(len(folio.trades)):
                        uid = f'{folio.pid}|{i}'
                        try:
                            yield res[uid]
                        except KeyError:
                            pass

        # Use case: select sub-portfolio by a SophisPortfolio object (post trade analysis)
        assert isinstance(res, dict), 'risk_report is not a dict'
        return flattener(unpack(), level=1)

    elif root != '-':
        if isinstance(res, dict):
            # Use case: portfolio of trades represented as a key-value mapping (pre trade analysis)
            return flattener(res, level=1)
        elif isinstance(res, list):
            # Use case: a single trade risk report / an already flattened risk report
            return res
    # Use case: return empty list, later rendered into an empty dataframe
    return []


def _consolidate_pv(res: Dict[str, float], root: SophisPortfolio = None):
    if isinstance(root, (SophisPortfolio, CerebroPortfolio)):
        assert isinstance(res, dict)
        rv = Counter()

        for _, folio in root.iter():
            for i, t in enumerate(folio.trades):
                uid = f'{folio.pid}|{i}'
                rv[t.ccy.name] += res.get(uid, 0)

        return rv
    return {}


def ir_scenario(
        scenario_result: object,
        scenario: str,
        unit: float = 1000,
        folio: Any = None
) -> pandas.DataFrame:
    assert isinstance(scenario_result, ScenarioResult)
    risk_report = scenario_result[scenario]

    if isinstance(folio, PortfolioSnap):
        folio = folio.portfolio

    rv = risk_report_pvbp_handler(risk_report_subset(risk_report, root=folio))

    df, _ = rv.align(scenario_risk_format, join='right')
    df.columns = [scenario_risk_map.get(i, i) for i in df.columns]
    df.index = [str(i).lower() for i in df.index]

    pnl_report = scenario_result.pnl[scenario]
    pnl = pandas.Series(_consolidate_pv(pnl_report, root=folio), name='PNL').to_frame().T
    pnl = pnl[list(filter(lambda x: x in df.columns, pnl.columns))]
    df = pandas.concat([pnl, df], sort=False)[df.columns]

    return df.div(unit).fillna(0)


def ir_gamma(
        risk_report_result: object,
        unit: float = 1000,
        folio: Any = None,
        pids: str = None,
) -> pandas.DataFrame:
    assert isinstance(risk_report_result, GammaReportResult)
    rv_up = risk_report_pvbp_handler(risk_report_subset(risk_report_result.res_up, root=folio, pids=pids))
    rv_dn = risk_report_pvbp_handler(risk_report_subset(risk_report_result.res_dn, root=folio, pids=pids))
    rv = rv_up.sub(rv_dn).div(risk_report_result.bump_size * 2)

    risk_format = pandas.concat([irs_risk_format, ccs_risk_format.iloc[:, :1]], axis=1, sort=False)
    risk_map = {**irs_risk_map, **ccs_risk_map}
    df, _ = rv.align(risk_format, join='right')
    df.columns = [risk_map.get(i, i) for i in df.columns]
    df.index = [str(i).lower() for i in df.index]
    df = df.dropna(axis=1, how='all')
    return df.div(unit).fillna(0)


def irs_risk(
        risk_report_result: Union[Dict, List],
        unit: float = 1000,
        folio: Any = None,
        pids: str = None,
) -> pandas.DataFrame:
    rv = risk_report_pvbp_handler(risk_report_subset(risk_report_result, root=folio, pids=pids))

    df, _ = rv.align(irs_risk_format, join='right')
    df.columns = [irs_risk_map.get(i, i) for i in df.columns]
    df.index = [str(i).lower() for i in df.index]
    df = df.dropna(axis=1, how='all')
    return df.div(unit).fillna(0)


def basis_risk(
        risk_report_result: Union[Dict, List],
        unit: float = 1000,
        folio: Any = None,
        pids: str = None,
) -> pandas.DataFrame:
    rv = risk_report_pvbp_handler(risk_report_subset(risk_report_result, root=folio, pids=pids))

    df, _ = rv.align(basis_risk_format, join='right')
    df.columns = [basis_risk_map.get(i, i) for i in df.columns]
    df.index = [str(i).lower() for i in df.index]
    df = df.dropna(axis=1, how='all')
    return df.div(unit).fillna(0)


def ccs_risk(
        risk_report_result: Union[Dict, List],
        unit: float = 1000,
        folio: Any = None,
        pids: str = None,
) -> pandas.DataFrame:
    rv = risk_report_pvbp_handler(risk_report_subset(risk_report_result, root=folio, pids=pids))

    df, _ = rv.align(ccs_risk_format, join='right')
    df.columns = [ccs_risk_map.get(i, i) for i in df.columns]
    df.index = [str(i).lower() for i in df.index]
    df = df.dropna(axis=1, how='all')
    return df.div(unit).fillna(0)


def inflation_risk(
        risk_report_result: Union[Dict, List],
        unit: float = 1000,
        folio: Any = None,
        pids: str = None,
) -> pandas.DataFrame:
    rv = risk_report_pvbp_handler(risk_report_subset(risk_report_result, root=folio, pids=pids))

    df, _ = rv.align(inf_risk_format, join='right')
    df.columns = [inf_risk_map.get(i, i) for i in df.columns]
    df.index = [str(i).lower() for i in df.index]
    return df.div(unit).fillna(0)


def flat_dv01_risk(
        risk_report_result: Union[Dict, List],
        unit: float = 1000,
        folio: Any = None
) -> float:
    rv = risk_report_pvbp_handler(risk_report_subset(risk_report_result, root=folio))
    return rv.sum().sum() / unit


def irv_vega(
        risk_report_result: Union[Dict, List],
        ccy: str = None,
        unit: float = 1000,
        folio: Any = None,
        pids: str = None,
) -> pandas.DataFrame:
    res = risk_report_subset(risk_report_result, root=folio, pids=pids)
    rv = pandas.concat([risk_report_ir_vega_handler(res), risk_report_ccs_vega_handler(res)], axis=1, sort=False)

    if ccy is None:
        rv = rv.sort_index()
        rv.index = [str(i).lower() for i in rv.index]
        return rv

    try:
        rv = rv[ccy]
    except KeyError:
        df = irv_risk_format.copy()
    else:
        df, _ = rv.align(irv_risk_format, join='right')
    df.columns = [str(i).lower() for i in df.columns]
    df.index = [str(i).lower() for i in df.index]
    return df.div(unit).fillna(0)


def flat_irv_vega(
        risk_report_result: Union[Dict, List],
        unit: float = 1000,
        folio: Any = None
) -> float:
    rv = risk_report_ir_vega_handler(risk_report_subset(risk_report_result, root=folio))
    return rv.sum().sum() / unit


def fx_risk(
        risk_report_result: Union[Dict, List],
        gamma_report_result: Any,
        unit: float = 1_000_000,
        folio: Any = None,
        pids: str = None,
) -> pandas.DataFrame:
    if isinstance(risk_report_result, (dict, list)):
        delta = risk_report_fx_spot_handler(risk_report_subset(risk_report_result, root=folio, pids=pids)).rename(
            'Delta')
    else:
        delta = pandas.Series(name='Delta')

    if isinstance(gamma_report_result, GammaReportResult):
        rv_up = risk_report_fx_spot_handler(risk_report_subset(gamma_report_result.res_up, root=folio, pids=pids))
        rv_dn = risk_report_fx_spot_handler(risk_report_subset(gamma_report_result.res_dn, root=folio, pids=pids))
        gamma_up = rv_up.sub(delta).mul(100 / gamma_report_result.bump_size)
        gamma_dn = rv_dn.sub(delta).mul(-100 / gamma_report_result.bump_size)
        gamma = gamma_up.add(gamma_dn).div(2).rename('Gamma')
    else:
        gamma = pandas.Series(name='Gamma')

    theta = pandas.Series(name='Theta')  # jchi@202001 this is place-holding
    rv = pandas.DataFrame([delta, gamma, theta]).T

    if all(rv.shape):
        df = rv.loc[sorted(rv.index, key=lambda x: Ccy[x[:3]])]
    else:
        df = fx_risk_format.copy()
        df.columns = [fx_risk_map.get(i, i) for i in df.columns]
    return df.div(unit).fillna(0)


def flat_fx_risk(
        risk_report_result: Union[Dict, List],
        unit: float = 1_000_000,
        folio: Any = None
) -> float:
    rv = risk_report_fx_spot_handler(risk_report_subset(risk_report_result, root=folio))
    return rv.sum() / unit


def fx_fwd_risk(
        risk_report_result: Union[Dict, List],
        unit: float = 1_000_000,
        folio: Any = None,
        pids: str = None,
) -> pandas.DataFrame:
    if isinstance(risk_report_result, (dict, list)):
        res = risk_report_subset(risk_report_result, root=folio, pids=pids)
        spt = risk_report_fx_spot_handler(res).rename(Tenor.SPOT).to_frame().T
        fwd = risk_report_fx_fwd_outright_handler(res)
        rv = pandas.concat([spt, fwd], sort=False)
    else:
        rv = pandas.DataFrame()

    if all(rv.shape):
        df, _ = rv.align(fx_fwd_risk_format, join='right', axis=0)
        df = df[sorted(rv.columns, key=lambda x: Ccy[x[:3]])]
    else:
        df = fx_fwd_risk_format.copy()
        df.columns = [fx_fwd_risk_map.get(i, i) for i in df.columns]
    df.index = [fx_fwd_tenor_map.get(str(i).lower(), str(i).lower()) for i in df.index]
    return df.div(unit).fillna(0)


def fxv_risk(
        risk_report_result: Union[Dict, List],
        unit: float = 1_000,
        folio: Any = None,
        sabr_coeff: str = 'Alpha',
        pids: str = None,
) -> pandas.DataFrame:
    assert sabr_coeff.upper() in [i.name for i in list(SabrCoefficient)], f'invalid SABR coefficient `{sabr_coeff}`'
    rv = risk_report_fx_sabr_handler(risk_report_subset(risk_report_result, root=folio, pids=pids))

    try:
        rv = rv[f'SABR{sabr_coeff}']
    except KeyError:
        return fxv_risk_format.copy()
    else:
        df, _ = rv.align(fxv_risk_format, join='right')
    df.columns = [fxv_risk_map.get(i, i) for i in df.columns]
    df.index = [str(i).lower() for i in df.index]
    return df.div(unit).fillna(0)


def flat_fxv_risk(
        risk_report_result: Union[Dict, List],
        unit: float = 1_000,
        folio: Any = None
) -> float:
    rv = risk_report_fx_sabr_handler(risk_report_subset(risk_report_result, root=folio))
    return rv.sum().sum() / unit


if __name__ == '__main__':
    pass
    # import datetime
    # from firm_domain import *
    # from ExcelTools import *
    #
    # f3model = firm_model_get()
    # f3risk = firm_risk_model_get()
    #
    # swaption1 = SwaptionTrade(datetime.datetime(2019, 9, 12), Ccy.EUR, datetime.datetime(2022, 9, 12),
    #                           datetime.datetime(2022, 9, 13), datetime.datetime(2027, 9, 12), -0.0022,
    #                           SwaptionType.RECEIVER, -100 * 1e6)
    # swaption2 = SwaptionTrade(datetime.datetime(2019, 9, 12), Ccy.EUR, datetime.datetime(2022, 9, 12),
    #                           datetime.datetime(2022, 9, 13), datetime.datetime(2027, 9, 12), -0.0022,
    #                           SwaptionType.PAYER, -100 * 1e6)
    #
    # firm_pv([swaption1, swaption2], f3model)

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\reporting\__init__.py
----------------------------------------
from .models import *
from .riskreport import *
from .context import *
from .pnlexplain import *
from .pricer import *
from .cashflow import *
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\reporting\__pycache__\models.cpython-37.pyc
----------------------------------------
B

    y  d                   @   s:   d dl mZ d dlmZ ddlmZ ee ed dd  ZdS )	     ) F3Object) apply_composite_bump_scenario    ) irs_risk_map)  f3model bump returnc             C   s*   t | t st tt    }t||| d  S )N)r    r   )  
isinstancer    AssertionError setr    valuesr   )r   r    Zccy  r
    IE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/reporting/models.py model_apply_bump_scenario    s    r   N)	Zf3sdk.f3r   Zfirm_f3.evaluater     contextr    object floatr   r
   r
   r
   r    <module>   s   
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\reporting\__pycache__\__init__.cpython-37.pyc
----------------------------------------
B

    y  d                    @   s4   d dl T d dlT d dlT d dlT d dlT d dlT dS )    ) *N) modelsZ
riskreport  contextZ
pnlexplainZpricerZcashflow  r   r    KE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/reporting/__init__.py <module>   s
   
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\ronan\pv.py
----------------------------------------
import datetime
from typing import List
import requests
from firm_domain import trade
from firm_f3.ronan import RONAN_URL


def encode(t: trade.Trade):
    def unpack():
        for k, v in t.to_dict().items():
            if isinstance(v, datetime.date):
                v = v.isoformat()
            yield k, v

    return dict(unpack())


def pv(trades: List[trade.Trade], model_slug: int = None):
    req = {'model_slug': model_slug, 'trades': list(map(encode, trades))}
    res = requests.post(f'{RONAN_URL}/pv', json=req)
    if res.status_code == 200:
        raw = res.json()
        rv = {i['trade_id']: i['error'] or i['result'] for i in raw['results']}
        return [rv[i] for i in range(len(trades))]
    res.raise_for_status()


if __name__ == '__main__':
    pass
    from firm_domain import Ccy

    test_trades = [
        trade.IRSTrade(datetime.datetime(2019, 11, 25), Ccy.USD, datetime.date(2019, 11, 26),
                       datetime.date(2024, 11, 26), 0.02, 1000),
        trade.CashFlow(datetime.datetime(2019,10,10), Ccy.EUR, datetime.date(2019,11,10), 2000),
        trade.FXForwardTrade(datetime.datetime(2019, 11, 25), Ccy.GBP, datetime.date(2021, 11, 25), 1.3, 3000)
    ]
    test_results = pv(test_trades)

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\ronan\__init__.py
----------------------------------------
import os

HOST_PRD = 'firm-jarvis-prd'
HOST_UAT = 'firm-jarvis-uat'
HOST_DEV = 'firmphkgwks161'


def get_host(env: str = None):
    if env is None:
        env = os.environ.get('RONAN_ENV', 'uat')
    if env.lower() in ('prd', 'prod'):
        host = HOST_PRD
    elif env.lower() == 'uat':
        host = HOST_UAT
    else:
        host = HOST_DEV
    return f'http://{host}:8896'


RONAN_URL = get_host()

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\util\aiotoolz.py
----------------------------------------
import asyncio
from typing import Callable
import toolz


def aio(func: Callable) -> Callable:
    if asyncio.iscoroutinefunction(func):
        return func
    elif asyncio.iscoroutinefunction(getattr(func, '__call__', None)):
        return func

    async def f(*args, **kwargs):
        return func(*args, **kwargs)

    return f


async def identity(x):
    return x


class Compose(toolz.functoolz.Compose):
    async def __call__(self, *args, **kwargs):
        ret = await aio(self.first)(*args, **kwargs)
        for f in self.funcs:
            ret = await aio(f)(ret)
        return ret


def compose(*funcs):
    if not funcs:
        return identity
    if len(funcs) == 1:
        return aio(funcs[0])
    else:
        return Compose(funcs)


async def pipe(data, *funcs):
    for func in funcs:
        data = await aio(func)(data)
    return data


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\util\attribute.py
----------------------------------------

class Attribute:
    def __init__(self, cast=None, storage=None, default=None):
        self.name = None
        if storage is None:
            storage = '__dict__'
        self.storage = storage
        self._default = default
        self._cast = cast

    def __set_name__(self, owner, name):
        self.name = name

    @property
    def default(self):
        if callable(self._default):
            return self._default()
        return self._default

    def __get__(self, instance, owner):
        if instance:
            if self.storage == self.name:
                raise AttributeError
            storage = getattr(instance, self.storage)
            try:
                return storage[self.name]
            except KeyError:
                attr = self.default
                storage[self.name] = attr
            return attr
        return self

    def __set__(self, instance, value):
        if callable(self._cast):
            value = self._cast(value)
        storage = getattr(instance, self.storage)
        storage[self.name] = value


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\util\caching.py
----------------------------------------
import os
import pickle
import datetime
import logging
from firm_f3.config import tmp_dir

"""
Caching objects to the disk
"""

class Cacher(dict):
    logger = logging.getLogger(__name__)
    expiry = datetime.timedelta(hours=24)

    def __init__(self, filename: str = '.cache', dirname: str = tmp_dir):
        super().__init__()
        self.cache_path = cache_path = os.path.join(dirname, filename)
        try:
            ctime = os.path.getctime(cache_path)
        except FileNotFoundError:
            return
        ctime = datetime.datetime.fromtimestamp(ctime)
        if datetime.datetime.now() - ctime > self.expiry:
            self.logger.info(f'remove expired cache at {cache_path} created at {ctime}')
            os.remove(cache_path)

    def load(self):
        try:
            with open(self.cache_path, 'rb') as f:
                cache = pickle.load(f)
        except FileNotFoundError:
            pass
        else:
            assert isinstance(cache, dict)
            self.update(cache)
            self.logger.debug(f'loaded {len(cache)} items from cache')

    def save(self):
        with open(self.cache_path, 'wb') as f:
            pickle.dump(dict(self), f)
        self.logger.info(f'dumped {len(self)} entries at {self.cache_path}')

    def __enter__(self):
        self.load()
        return self

    def __exit__(self, *exc):
        self.save()


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\util\datehelper.py
----------------------------------------
from firm_domain.util.datehelper import *

__all__ = [k for k, v in globals().items() if getattr(v, '__module__', '').startswith('firm_domain')]

import warnings

WARNING_MESSAGE = """
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                            !!
!! WARNING firm_f3.util.datehelper is moved to firm_domain.util.datehelper    !!
!! please update your import statement accordingly                            !!
!!                                                                            !!
!! Make sure to run ``pip install firm-domain`` in terminal                   !!
!! Details for migration:                                                     !!
!!     http://firm-bitbucket:7990/projects/firmSSL/repos/firm-domain/browse   !!
!!                                                                            !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"""
print(WARNING_MESSAGE)
warnings.warn(WARNING_MESSAGE, DeprecationWarning)
try:
    __IPYTHON__  # type: ignore
except NameError:
    pass
else:
    input('Press any key to confirm ...')

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\util\email.py
----------------------------------------
import getpass
import socket
import traceback
import smtplib
import email.message
from typing import Union, List

firm_SMTP_HOST = 'firmPHKGEXG01.baf.local'


class EmailMessage(email.message.EmailMessage):
    def __enter__(self):
        return self

    def __exit__(self, *exc):
        self.send()

    def send(self, conn: smtplib.SMTP = None):
        assert self['To'], 'missing a recipient address'
        assert self['From'], 'missing a sender address'
        if conn is None:
            conn = smtplib.SMTP(firm_SMTP_HOST)
        with conn:
            conn.send_message(self)

    def set_sender(self, addr: str):
        del self['From']
        self['From'] = addr
        return self

    def set_recipients(self, addrs: Union[str, List[str]]):
        if isinstance(addrs, str):
            addrs = addrs.split(',')
        del self['To']
        self['To'] = addrs
        return self

    def append_recipients(self, addrs: Union[str, List[str]]):
        if isinstance(addrs, str):
            addrs = addrs.split(',')
        curr_addrs = self['To']
        if curr_addrs:
            addrs = curr_addrs.split(',') + addrs
        self['To'] = addrs
        return self

    def set_subject(self, subject: str):
        del self['Subject']
        self['Subject'] = subject
        return self

    def set_content(self, *args, **kwargs):
        super().set_content(*args, **kwargs)
        return self

    def set_html_content(self, html_src: str):
        self.add_alternative(html_src, subtype='html')
        return self


def send_error(err, exc_info=False, to_addrs='jchi@firm-partners.com'):
    msg = EmailMessage()
    msg.set_subject('ERROR@{}:{} {}'.format(getpass.getuser(), socket.gethostname(), err))
    if exc_info:
        msg.set_content(traceback.format_exc())
    else:
        msg.set_content(repr(err))
    msg.set_sender('pymail@firm-partners.com').set_recipients(to_addrs).send()


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\util\f3ml.py
----------------------------------------
import os
import logging
from typing import Union, Dict, List, Optional, Any, Tuple, Callable, Iterable

import firm_f3.f3client
import dateutil.parser
import bs4
from firm_f3.core.endpoints import SystemEnvironmentData
from f3sdk.f3 import F3Object
from f3sdk.f3.f3object import Future
from f3sdk.lib.coroutine import wait
from firm_f3.core import endpoints
from firm_f3.core.crud import get_many_async, get_one, get_one_async
from firm_domain.util.fileutils import ensure_dir_exists, string_to_file, rotate_filename

logger = logging.getLogger(__name__)


def to_f3ml(f3_object: Union[Dict, List, F3Object, Future]) -> str:
    if isinstance(f3_object, dict):
        f3ml = "".join(["".join(e.form_f3ml()) for e in f3_object.values()])
    elif isinstance(f3_object, list):
        f3ml = "".join(["".join(e.form_f3ml()) for e in f3_object])
    else:
        f3ml = ''.join(f3_object.form_f3ml())
    return f3ml


async def spy_f3call_async(f3_object: Union[Dict, List, F3Object, Future]) -> Tuple[str, str]:
    f3 = firm_f3.f3client.get_platform_client()
    xml_function: str = to_f3ml(f3_object)
    response = await f3.Platform.Object.get(SystemEnvironmentData)
    xml_sed: str = response['definition']
    return xml_function, xml_sed


async def spy_f3call_tofile_async(f3_object: Union[Dict, List, F3Object, Future], directory: str) -> None:
    xml_function, xml_sed = await spy_f3call_async(f3_object)
    ensure_dir_exists(directory)
    string_to_file(xml_function, rotate_filename(os.path.join(directory, "xml_function.xml")))
    string_to_file(xml_sed, rotate_filename(os.path.join(directory, "xml_sed.xml")))


def parse(src: str, parse_type: str = 'f') -> Any:
    soup = bs4.BeautifulSoup(src, 'lxml')
    for i, v in enumerate(soup.find_all(parse_type)):
        try:
            yield _cast(v)
        except Exception as e:
            logger.error(f'i={i}, f={v}', exc_info=e)


class F3mlSpy:
    def __init__(self, f3obj: Union[F3Object, List[str], str]):
        if isinstance(f3obj, str):
            f3obj = [f3obj]
        if isinstance(f3obj, list):
            # jchi@201907
            # assumes input is an f3ml string, cast it into a F3Object
            f3obj = F3Object('Model', f3obj)
        self.f3obj = f3obj
        self.src = ''.join(f3obj.form_f3ml())

    def __iter__(self):
        return parse(self.src, parse_type='f')

    def to_string(self) -> str:
        return ''.join(self)

    def print(self, file=None) -> None:
        print(self.to_string(), file=file)

    @classmethod
    def load_sed(cls) -> 'F3mlSpy':
        sed = get_one(endpoints.SystemEnvironmentData)
        return cls(sed['definition'])

    @staticmethod
    async def write_sed_to_file_async(filepath: str) -> None:
        ensure_dir_exists(os.path.dirname(filepath))
        sed = await get_one_async(endpoints.SystemEnvironmentData)
        f3ml = sed['definition']
        with open(filepath, 'w') as f:
            f.write(f3ml)

    @staticmethod
    async def write_sed_to_file(filepath: str) -> None:
        return wait(F3mlSpy.write_sed_to_file_async(filepath))

    def write_f3ml_to_file(self, filepath: str) -> None:
        ensure_dir_exists(os.path.dirname(filepath))
        with open(filepath, 'w') as f:
            f.write(''.join(self.f3obj.form_f3ml()))

    def write_to_file(self, filepath: Optional[str] = None) -> None:
        if filepath is None:
            filepath = os.path.join(os.getcwd(), 'spy.py')
        dirname = os.path.dirname(filepath)
        ensure_dir_exists(dirname)
        filepath = os.path.abspath(filepath)
        logger.debug(f'writing to "{filepath}"')
        with open(filepath, 'w') as f:
            f.write(_template_spy.format(self.to_string()))


def _cast(tag: bs4.Tag):
    if isinstance(tag, bs4.Tag):
        if tag.name in ('n', 's', 'm'):
            return tag.text
        elif tag.name in ('r', 'v'):
            return [_cast(i) for i in tag]
        elif tag.name == 'p':
            k, v = list(tag)
            return _cast(k), _cast(v)
        elif tag.name == 'a':
            return dict(_cast(i) for i in tag if not isinstance(i, bs4.NavigableString))
        elif tag.name == 'b':
            if tag.text == 'T':
                return True
            elif tag.text == 'F':
                return False
        elif tag.name == 'd':
            try:
                return float(tag.text)
            except ValueError:
                return dateutil.parser.parse(tag.text).date()
        elif tag.name == 'f':
            k, v = list(tag)
            arguments = _cast(v)
            return _template_function.format(name=_cast(k),
                                             args=', '.join(f'{i}: {type(j).__name__}' for i, j in arguments.items()),
                                             body='\n    '.join(f'{i} = {j}' for i, j in arguments.items()))
        raise ValueError(f'unable to cast tag <{tag.name}>')
    elif isinstance(tag, bs4.NavigableString):
        return tag
    raise ValueError(f'unable to cast object {tag} with type {type(tag)}')


_template_spy = """import datetime

{}

"""

_template_function = """
def {name}({args}):
    {body}

"""


def show(f3obj: Union[F3Object, Iterable[F3Object], str, Iterable[str], Callable], to_file: str = None) -> None:
    if callable(f3obj):
        try:
            f3obj = f3obj(*range(20))
        except TypeError as e:
            _, n, _ = [int(i) for i in str(e).split() if i.isdigit()]
            f3obj = f3obj(*range(n))
    elif isinstance(f3obj, Iterable):
        def unpack():
            for i in f3obj:
                if isinstance(i, F3Object):
                    for j in i.form_f3ml():
                        yield j
                else:
                    yield i
        f3obj = list(unpack())

    spy = F3mlSpy(f3obj)
    if to_file:
        spy.write_to_file(to_file)
    else:
        spy.print()

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\util\f3utils.py
----------------------------------------
import asyncio
from functools import wraps
from typing import Callable
from f3sdk.lib.coroutine import wait  # type: ignore


def make_wait(func: Callable) -> Callable:
    assert asyncio.iscoroutinefunction(func)
    assert func.__name__.endswith('_async')

    @wraps(func, assigned=('__module__', '__doc__', '__annotations__'))
    def f(*args, **kwargs):
        return wait(func(*args, **kwargs))

    f.__name__ = func.__name__[:-len('_async')]
    f.__qualname__ = func.__qualname__[:-len('_async')]
    return f


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\util\fileutils.py
----------------------------------------
from firm_domain.util.fileutils import *

__all__ = [k for k, v in globals().items() if getattr(v, '__module__', '').startswith('firm_domain')]

import warnings

WARNING_MESSAGE = """
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                            !!
!! WARNING firm_f3.util.fileutils is moved to firm_domain.util.fileutils      !!
!! please update your import statement accordingly                            !!
!!                                                                            !!
!! Make sure to run ``pip install firm-domain`` in terminal                   !!
!! Details for migration:                                                     !!
!!     http://firm-bitbucket:7990/projects/firmSSL/repos/firm-domain/browse   !!
!!                                                                            !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"""
print(WARNING_MESSAGE)
warnings.warn(WARNING_MESSAGE, DeprecationWarning)
try:
    __IPYTHON__  # type: ignore
except NameError:
    pass
else:
    input('Press any key to confirm ...')

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\util\funcutils.py
----------------------------------------
import time
import asyncio
import logging
import inspect
from typing import Callable
from functools import wraps
from firm_f3 import logging as f3log


def inspect_arguments(
        f: Callable = None,
        prod: bool = False,
        logger: logging.Logger = None,
        exclude: tuple = (),
        inspect_return: bool = True
) -> Callable:
    if logger is None:
        logger = logging.getLogger(__name__)

    def wrapper(func: Callable) -> Callable:
        if prod:
            return func
        sig = inspect.signature(func)

        def unpack_locals(args: tuple, kwd: dict):
            n = len(args)
            for i, (k, v) in enumerate(sig.parameters.items()):
                if k not in exclude:
                    if i < n:
                        yield k, args[i]
                    else:
                        yield k, kwd.get(k, v.default)

        if asyncio.iscoroutinefunction(func):
            async def wrapped(*args, **kwargs):
                if f3log.DEBUG:
                    logger.debug(f'{func.__name__} <- {dict(unpack_locals(args, kwargs))}')
                rv = await func(*args, **kwargs)
                if inspect_return and f3log.DEBUG:
                    logger.debug(f'{func.__name__} -> {rv}')
                return rv
        else:
            def wrapped(*args, **kwargs):
                if f3log.DEBUG:
                    logger.debug(f'{func.__name__} <- {dict(unpack_locals(args, kwargs))}')
                rv = func(*args, **kwargs)
                if inspect_return and f3log.DEBUG:
                    logger.debug(f'{func.__name__} -> {rv}')
                return rv

        return wraps(func)(wrapped)

    if callable(f):
        return wrapper(f)
    return wrapper


class RetryException(Exception):
    pass


def retry(
        f: Callable = None,
        max_retries: int = 3,
        cooldown: int = 0,
        error_handler: Callable = None
) -> Callable:
    assert isinstance(max_retries, int) and max_retries > 0
    assert isinstance(cooldown, int) and cooldown >= 0
    if error_handler is None:
        error_handler = logging.getLogger(__name__).error

    def wrapper(func: Callable) -> Callable:
        sig = inspect.signature(func)

        @wraps(func)
        def wrapped(*args, **kwargs):
            cnt = 1

            if 'max_retries' not in sig.parameters:
                _max_retries = kwargs.pop('max_retries', max_retries)
            else:
                _max_retries = max_retries

            if 'cooldown' not in sig.parameters:
                _cooldown = kwargs.pop('cooldown', cooldown)
            else:
                _cooldown = cooldown

            while True:
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if cnt < _max_retries:
                        error_handler(e)
                    elif cnt == _max_retries:
                        raise RetryException(f'exceptions after {_max_retries} retries') from e
                cnt += 1
                time.sleep(_cooldown)

        return wrapped

    if callable(f):
        return wrapper(f)
    return wrapper


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\util\http_client.py
----------------------------------------
from __future__ import annotations
from typing import Callable, Any, Dict
from functools import partial
import requests


class Method:
    def __init__(self, url: str, kwd: Dict[str, Any], conn: Callable):
        self.__url = url
        self.__kwd = kwd
        self.__conn = conn

    def __getattr__(self, item) -> Method:
        try:
            return super().__getattribute__(item)
        except AttributeError:
            return Method(f'{self.__url}/{item}', self.__kwd, self.__conn)

    def __call__(self, **kwargs) -> Any:
        res = self.__conn(self.__url, params={**self.__kwd, **kwargs})
        if not res.ok or res.status_code != 200:
            err = res.json()
            raise ValueError(err['detail'])

        return res.json()


class HttpClient:
    def __init__(self, host: str, params: Dict[str, Any] = None, **extra):
        self.host = host
        self.params = params or {}
        self.extra = extra

    @property
    def get(self):
        return Method(self.host, self.params, partial(requests.get, **self.extra))

    @property
    def post(self):
        return Method(self.host, self.params, partial(requests.post, **self.extra))

    @property
    def put(self):
        return Method(self.host, self.params, partial(requests.put, **self.extra))

    @property
    def delete(self):
        return Method(self.host, self.params, partial(requests.delete, **self.extra))


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\util\reversible_dict.py
----------------------------------------
from typing import Callable


class ReversibleDict(dict):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.rev = {}
        for k, v in self.items():
            self.rev.setdefault(v, set()).add(k)

    def __delitem__(self, key):
        v = self[key]
        self.rev[v].remove(key)
        if not self.rev[v]:
            del self.rev[v]
        super().__delitem__(key)

    def __setitem__(self, key, value):
        try:
            del self[key]
        except KeyError:
            pass
        super().__setitem__(key, value)
        self.rev.setdefault(value, set()).add(key)

    def lookup(self, v, key: Callable = None):
        keys = self.rev[v]
        if len(keys) == 1:
            return next(iter(keys))
        if callable(key):
            return key(keys)
        return keys


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\util\utils.py
----------------------------------------
import os
import logging
import datetime
import traceback
from contextlib import contextmanager
from collections import defaultdict
from typing import Callable, Iterable, List, Dict, Any, Optional, Union, TypeVar, Mapping, Tuple

import pandas
from pandas import DataFrame  # type:ignore
import getpass

from firm_domain.util.fileutils import ensure_dir_exists, rotate_filename
from firm_f3.logging import DEBUG

_logger = logging.getLogger(__name__)


def add_username_suffix(s: str) -> str:
    return f"{s}_{getpass.getuser()}"


TK = TypeVar('TK')
TK1 = TypeVar('TK1')
TK2 = TypeVar('TK2')
TV = TypeVar('TV')


def groupby(data: List[TV], get_key_function: Callable[[TV], TK]) -> Dict[TK, List[TV]]:
    """
    Group by function which doesn't require sorting
    """
    groups: Dict[TK, List[TV]] = defaultdict(list)
    for d in data:
        k = get_key_function(d)
        groups[k].append(d)
    return groups


def parse_enum_value(enum_class, enum_value):
    matches = [x for x in enum_class if x.value == 'o']
    if len(matches) > 1:
        raise Exception(f"Multiple enums found for value '{enum_value}'")
    if len(matches) == 0:
        raise Exception(f"No enums found for value '{enum_value}'")
    return matches[0]


def get_from_dictionary(dict: Dict, key_path: List[Any], default_value=None) -> Any:
    pth = key_path.copy()
    val = dict
    while len(pth) > 0:
        key = pth.pop(0)
        if key not in val:
            if isinstance(default_value, BaseException):
                return Exception(f'Unable to access {".".join(key_path)}. Key `{key}` does not exist')
            return default_value
        val = val[key]
    return val


def test_get_from_dictionary():
    d = {1: {10: 100, 20: 200, 30: 300}, 2: {22: 222}}
    assert get_from_dictionary(d, []) == d


def chunks_list(l: List[Any], n: int) -> Iterable[List[Any]]:
    """
    Yield successive n-sized chunks from l.
    """
    for i in range(0, len(l), n):
        yield l[i:i + n]


def chunks_dict(l: Dict[Any, Any], n: int) -> Iterable[Dict[Any, Any]]:
    """
    Yield successive n-sized chunks from l.
    """
    sub = dict()
    for k, v in l.items():
        sub[k] = v
        if len(sub) == n:
            yield sub
            sub = dict()
    if len(sub) > 0:
        yield sub


def get_index_by_name(columns: List[str], column: str):
    try:
        return columns.index(column)
    except ValueError:
        raise ValueError(f"Unable to find column '{column}' in list of columns {','.join(columns)}")


class disable_logging:
    """
    Temporarily disables logging for all logging below specified level
    """

    def __init__(self, level: int = logging.WARN):
        self.level = level

    def __enter__(self):
        logging.disable(self.level)

    def __exit__(self, exc_type, exc_val, exc_tb):
        logging.disable(logging.NOTSET)


def flatten(it: Iterable, level: int = -1) -> Iterable:
    assert isinstance(level, int)
    if isinstance(it, dict):
        it = it.values()
    for i in it:
        if level != 0 and isinstance(i, Iterable) and not isinstance(i, str):
            for j in flatten(i, level=level - 1):
                yield j
        else:
            yield i


def flattener(x: Iterable, level: int = -1) -> List:
    return list(flatten(x, level=level))


def test_flattener():
    assert flattener([[1, 2, 3], [4, 5, 6]]) == [1, 2, 3, 4, 5, 6]


def filter_dict(d: Dict[TK, TV], filter: Callable[[TK], bool]) -> Dict[TK, TV]:
    """
    Filters dictionary based on the key
    """
    return {k: v for k, v in d.items() if filter(k)}


def transpose_dictionary(dct: Mapping[TK1, Mapping[TK2, TV]]) -> Mapping[TK2, Mapping[TK1, TV]]:
    d = defaultdict(dict)
    for key1, inner in dct.items():
        for key2, value in inner.items():
            d[key2][key1] = value
    return d


@contextmanager
def timer(msg: str = '',
          logger: logging.Logger = None,
          logstart: bool = DEBUG,
          loglevel: int = logging.INFO,
          logthreshold: datetime.timedelta = datetime.timedelta(seconds=0)):
    if not isinstance(logger, logging.Logger):
        logger = _logger
    if msg:
        msg += ', '
    if logstart:
        logger.debug(f'{msg}starts ...')

    now = datetime.datetime.utcnow()

    exception = None
    try:
        yield
    except BaseException as ex:
        exception = ex
        raise ex
    finally:
        duration = datetime.datetime.utcnow() - now
        if duration < logthreshold:
            loglevel = logging.DEBUG
        duration_ms = int(duration.seconds * 1e3 + duration.microseconds * 1e-3)
        if loglevel == logging.INFO:
            logmethod = logger.info
        elif loglevel == logging.DEBUG:
            logmethod = logger.debug
        else:
            raise Exception("invalid log level in timer(), only debug/info supported")
        if exception is not None:
            logmethod(f'{msg}time elapsed {duration_ms} ms (caught exception)')
        else:
            logmethod(f'{msg}time elapsed {duration_ms} ms')


def contains_none(*args) -> bool:
    for arg in args:
        if arg is None:
            return True
    return False


def return_or_raise(ex: BaseException, exception_as_data: bool) -> BaseException:
    if exception_as_data:
        return ex
    raise ex


def apply_function(f: Callable, *args) -> Union[None, BaseException, Any]:
    """
    If any of the arguments is BaseException, return that BaseException
    Otherwise, If any of the arguments is missing (None), return None
    Otherwise, return result of function f(*args)
    """
    for arg in args:
        if isinstance(arg, BaseException):
            return arg
    for arg in args:
        if arg is None:
            return arg
    return f(*args)


def apply_function_diff(lhs, rhs) -> Union[None, BaseException, Any]:
    return apply_function(lambda a, b: a - b, lhs, rhs)


def test_apply_function():
    ex = Exception("I am exception")
    missing = None
    a = 1
    b = 2
    c = 3
    f = lambda x, y, z: x + y + z
    assert apply_function(f, ex, ex, 1) == ex
    assert apply_function(f, None, 1, ex) == ex
    assert apply_function(f, 1, 1, None) == None
    assert apply_function(f, 1, None, 2) == None
    assert apply_function(f, 1, 2, 3) == 6
    assert apply_function_diff(1, 2) == -1


def extract_exception(*args) -> Optional[Exception]:
    """
    If any of the arguments is a BaseException, this function will extract and return it.
    This is useful when handling exceptions as data in asyncio.gather(..., return_exceptions=True) calls

    example usage:

    value_c: Union[Float,Exception] = extract_exception(value_a, value_b) or value_a + value_b

    """
    for arg in args:
        if isinstance(arg, Exception):
            return arg
    return None


def dump_dataframe(df: DataFrame, directory: str, filestem: str, index: bool = True):
    assert isinstance(filestem, str)
    assert isinstance(df, DataFrame)

    ensure_dir_exists(directory)
    df.to_csv(rotate_filename(os.path.join(directory, f"{filestem}.txt")), sep='\t', index=index)

    with open(rotate_filename(os.path.join(directory, f"{filestem}.dtypes.txt")), 'w') as writer:
        for k, v in df.dtypes.items():
            print(k, v, file=writer)

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\util\utils_test.py
----------------------------------------
import unittest
from datetime import datetime
from typing import List, Dict, Callable, Any

from firm_domain.util.datehelper import parse_f3_timestamp
from firm_domain.market_date import MarketDate
from firm_domain.util.fileutils import JsonSerialiserBase, JsonSerialiser
from firm_f3.util.utils import filter_dict, chunks_dict, chunks_list, flattener
from math import nan


class SerialisableClass:
    def __init__(self):
        pass

    def as_json_object(self, serialiser: JsonSerialiserBase):
        return [100, 200]


class TestPojo(unittest.TestCase):

    def test(self):
        def formatter(x):
            if not isinstance(x, (int, float)):
                return x
            return "%0.4f" % x

        serialiser = JsonSerialiser()
        assert serialiser.serialise(1) == 1
        assert serialiser.serialise([1, 2, 3]) == [1, 2, 3]
        assert serialiser.serialise({3, 2, 1}) == {1, 2, 3}
        assert serialiser.serialise([1, 2, ['a', 'b']]) == [1, 2, ['a', 'b']]
        assert serialiser.serialise([1, 2, [None, nan]]) == [1, 2, [None, "NaN"]]
        assert serialiser.serialise([1, 2, [SerialisableClass()]]) == [1, 2, [[100, 200]]]
        assert serialiser.serialise({1: 10, 2: 20, 3: SerialisableClass()}) == {1: 10, 2: 20, 3: [100, 200]}
        assert serialiser.serialise({1.1: 10, 2: 20, 3: SerialisableClass()}) == {1.1: 10, 2: 20, 3: [100, 200]}
        serialiser = JsonSerialiser(key_fmter=formatter)
        assert serialiser.serialise({1.1: 10, 2: 20, 3: SerialisableClass()}) == {"1.1000": 10, "2.0000": 20,
                                                                                  "3.0000": [100, 200]}


class TestUtils(unittest.TestCase):

    def test_filter_dict(self):
        d = {1: 100, 2: 200, 3: 300, 4: 400}
        d2 = filter_dict(d, lambda k: k >= 2)
        assert d2 == {2: 200, 3: 300, 4: 400}

    def test_chunks_list(self):
        inp: List[int] = [1, 2, 3, 4, 5, 6, 7]
        out: List[List[int]] = list(chunks_list(inp, 3))
        assert out == [[1, 2, 3], [4, 5, 6], [7]]

    def test_chunks_dict(self):
        inp: Dict[int, int] = {1: 100, 2: 200, 3: 300, 4: 400, 5: 500, 6: 600}
        out: List[Dict[int, int]] = list(chunks_dict(inp, 3))
        assert out == [{1: 100, 2: 200, 3: 300}, {4: 400, 5: 500, 6: 600}]

        inp: Dict[int, int] = {7: 700, 1: 100, 2: 200, 3: 300, 4: 400, 5: 500, 6: 600}
        out: List[Dict[int, int]] = list(chunks_dict(inp, 3))
        assert out == [{7: 700, 1: 100, 2: 200}, {3: 300, 4: 400, 5: 500}, {6: 600}]

    def test_flattener(self):
        inp = {100: [1, 11, 111], 200: [2, 22, 222], 300: [3, 33, 333]}
        out = flattener(inp)
        assert out == [1, 11, 111, 2, 22, 222, 3, 33, 333]

        inp = {100: [1, 11, [1111, 1112]], 200: [2, 22, 222], 300: [3, 33, 333]}
        out = flattener(inp)
        assert out == [1, 11, 1111, 1112, 2, 22, 222, 3, 33, 333]
        out = flattener(inp, level=2)
        assert out == [1, 11, 1111, 1112, 2, 22, 222, 3, 33, 333]
        out = flattener(inp, level=1)
        assert out == [1, 11, [1111, 1112], 2, 22, 222, 3, 33, 333]

    def test_parse_f3_timestamp(self):
        timestamp = '2019-09-04T22:15:03Z'
        date = parse_f3_timestamp(timestamp)
        assert date == datetime(2019, 9, 4, 22, 15, 3)

        timestamp = '2019-09-04T22:15:03.987Z'
        date = parse_f3_timestamp(timestamp)
        assert date == datetime(2019, 9, 4, 22, 15, 3, microsecond=987000)

        timestamp = '2019-09-04T22:15:03.000987Z'
        date = parse_f3_timestamp(timestamp)
        assert date == datetime(2019, 9, 4, 22, 15, 3, microsecond=987)

        timestamp = '2019-09-04T22:15:03.987000Z'
        date = parse_f3_timestamp(timestamp)
        assert date == datetime(2019, 9, 4, 22, 15, 3, microsecond=987000)

    def test_marketdate(self):
        m = MarketDate.CreateIntraday()
        assert m.is_latest_intraday
        assert m.timestamp.microsecond % 1000 == 0

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\util\xml.py
----------------------------------------
from typing import Union
try:
    import lxml.etree as et # type: ignore
    _Element = et._Element
except ImportError:
    import xml.etree.ElementTree as et # type: ignore
    _Element = et.Element


def xml2dict(src: Union[str, _Element], ns_mapper: dict = None) -> dict:
    if isinstance(src, str):
        if src.endswith('.xml'):
            tree = et.parse(src)
            root = tree.getroot()
        else:
            if et.__package__ == 'lxml':
                # lxml.etree.fromstring accepts bytes input only
                src = src.encode()
            root = et.fromstring(src)
    elif isinstance(src, _Element):
        root = src
    else:
        raise TypeError

    ns_mapper = ns_mapper or {}

    def _map_ns(base_tag: str):
        if base_tag.startswith('{'):
            head, _, tail = base_tag.partition('}')
            try:
                new_tag = ns_mapper[head + _]
            except KeyError:
                pass
            else:
                base_tag = new_tag + tail
        return base_tag

    def _unique_tag(base_tag: str, tracker: set):
        base_tag = _map_ns(base_tag)
        tag, i = base_tag, 1
        while tag in tracker:
            tag = f'{base_tag}_{i}'
            i += 1
        return tag

    def _element2dict(element: _Element):
        def unpack():
            tag_tracker = set()
            for child in element:
                tag = _unique_tag(child.tag, tag_tracker)
                tag_tracker.add(tag)
                if len(child) == 0:
                    text = child.text
                    if isinstance(text, str):
                        text = text.strip()
                    yield tag, text
                else:
                    yield tag, _element2dict(child)

        dct = dict(unpack())
        if element.attrib:
            # jchi@201906
            # element.attrib is an lxml.etree._Attrib object (non pickle-able), cast it to dict
            dct['_attrib'] = dict(element.attrib)
        return dct

    return _element2dict(root)


if __name__ == '__main__':
    pass

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\util\__init__.py
----------------------------------------
from .utils import *

__all__ = [k for k, v in globals().items() if getattr(v, '__module__', '').startswith(__name__)]

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\util\__pycache__\aiotoolz.cpython-37.pyc
----------------------------------------
B

    y  d                   @   sd   d dl Z d dlmZ d dlZeed dd Zdd   ZG dd	  d	ejj  Z d
d
  Zdd
  Z	e
dkr`dS )     N) Callable) func returnc                s4   t     r  S t  t  dd   r$  S   fdd }|S )N __call__c                  s
     | | S )N  ) args kwargs)r   r    FE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/util/aiotoolz.py f   s    zaio.<locals>.f)  asyncio iscoroutinefunction  getattr)r   r
   r   )r   r	    aio   s    
r   c                 s   | S )Nr   ) xr   r   r	    identity   s    r   c               @   s   e Zd Zdd  ZdS )  Composec                 s<   t | j || I d H }x | jD ]}t | | I d H }qW |S )N)r    first funcs) selfr    r    retr
   r   r   r	   r      s    zCompose.__call__N) __name__ 
__module__ __qualname__r   r   r   r   r	   r      s   r   c              G   s,   | st S t|  dkr t| d  S t|  S d S )N    r   )r    lenr   r   )r   r   r   r	     compose   s
    r   c                 s$   x|D ]}t | |  I d H } qW | S )N)r   ) datar   r   r   r   r	    pipe'   s    
r    __main__)
r
    typingr   Ztoolzr   r   Z	functoolzr   r   r   r   r   r   r   r	    <module>   s   	
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\util\__pycache__\attribute.cpython-37.pyc
----------------------------------------
B

    y  dM                  @   s   G d d  d Z edkrdS )c               @   s:   e Zd Zddd Zdd  Zedd    Zdd	  Z d
d
  ZdS )
 	AttributeNc             C   s(   d | _ |d krd}|| _|| _|| _d S )N __dict__) name  storage _default _cast) self castr     default  r
    GE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/util/attribute.py __init__   s    zAttribute.__init__c             C   s
   || _ d S )N)r   )r     ownerr   r
   r
   r
    __set_name__
   s    zAttribute.__set_name__c             C   s   t | j r|    S | jS )N) callabler   )r    r
   r
   r
   r	      s    
zAttribute.defaultc             C   sX   |rT| j | jkrt t|| j  }y
|| j S  tk
rN   | j}||| j< Y nX |S | S )N)r   r    AttributeError  getattr KeyErrorr	   )r     instancer
   r    attrr
   r
   r
     __get__   s    
zAttribute.__get__c             C   s.   t | j r|  | }t|| j }||| j< d S )N)r   r   r   r   r   )r    r    valuer   r
   r
   r
     __set__!   s    

zAttribute.__set__)NNN)	 __name__ 
__module__ __qualname__r   r    propertyr	   r   r   r
   r
   r
   r
   r      s
   

r    __main__N)r   r   r
   r
   r
   r
    <module>   s   &
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\util\__pycache__\datehelper.cpython-37.pyc
----------------------------------------
B

    y  d                   @   sf   d dl T dd  e     D  Zd dlZdZee  e  ee  ye	 W n e
k
rX   Y n
X e
d  dS )      ) *c             C   s&   g | ]\}}t |d d  d r| qS ) 
__module__  Z
firm_domain)  getattr 
startswith) .0 k v  r
    HE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/util/datehelper.py 
<listcomp>   s    r   Na+  
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                            !!
!! WARNING firm_f3.util.datehelper is moved to firm_domain.util.datehelper    !!
!! please update your import statement accordingly                            !!
!!                                                                            !!
!! Make sure to run ``pip install firm-domain`` in terminal                   !!
!! Details for migration:                                                     !!
!!     http://firm-bitbucket:7990/projects/firmSSL/repos/firm-domain/browse   !!
!!                                                                            !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
zPress any key to confirm ...)Zfirm_domain.util.datehelper  globals items  __all__ warningsZWARNING_MESSAGE print warn DeprecationWarningZ
__IPYTHON__ 	NameError inputr
   r
   r
   r
    <module>   s   

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\util\__pycache__\fileutils.cpython-37.pyc
----------------------------------------
B

    y  d                   @   sf   d dl T dd  e     D  Zd dlZdZee  e  ee  ye	 W n e
k
rX   Y n
X e
d  dS )      ) *c             C   s&   g | ]\}}t |d d  d r| qS ) 
__module__  Z
firm_domain)  getattr 
startswith) .0 k v  r
    GE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/util/fileutils.py 
<listcomp>   s    r   Na+  
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                            !!
!! WARNING firm_f3.util.fileutils is moved to firm_domain.util.fileutils      !!
!! please update your import statement accordingly                            !!
!!                                                                            !!
!! Make sure to run ``pip install firm-domain`` in terminal                   !!
!! Details for migration:                                                     !!
!!     http://firm-bitbucket:7990/projects/firmSSL/repos/firm-domain/browse   !!
!!                                                                            !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
zPress any key to confirm ...)Zfirm_domain.util.fileutils  globals items  __all__ warningsZWARNING_MESSAGE print warn DeprecationWarningZ
__IPYTHON__ 	NameError inputr
   r
   r
   r
    <module>   s   

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\util\__pycache__\reversible_dict.cpython-37.pyc
----------------------------------------
B

    y  du                  @   s(   d dl mZ G dd  de Zedkr$dS )     ) Callablec                   sD   e Zd Z  fdd Z  fdd Z  fdd Zd
ed d	d
 Z    ZS ) ReversibleDictc                sD   t   j||  i | _x*|    D ]\}}| j |t    |  qW d S )N)  super __init__ rev items 
setdefault set add) self args kwargs k v) 	__class__   ME:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/util/reversible_dict.pyr      s    zReversibleDict.__init__c                s:   | | }| j |  |  | j | s*| j |= t   |  d S )N)r    remover    
__delitem__)r
    keyr   )r   r   r   r   
   s
    
zReversibleDict.__delitem__c                sH   y
| |= W n t k
r   Y nX t   ||  | j |t    |  d S )N)  KeyErrorr    
__setitem__r   r   r	   r
   )r
   r    value)r   r   r   r      s    
zReversibleDict.__setitem__N)r   c             C   s6   | j | }t| dkr"tt|  S t| r2|| S |S )N    )r    len next iter callable)r
   r   r    keysr   r   r    lookup   s    
zReversibleDict.lookup)N)	 __name__ 
__module__ __qualname__r   r   r   r   r    
__classcell__r   r   )r   r   r      s    r    __main__N) typingr    dictr   r    r   r   r   r    <module>   s   
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\util\__pycache__\__init__.cpython-37.pyc
----------------------------------------
B

    y  dw                   @   s    d dl T dd  e     D  ZdS )    ) *c             C   s&   g | ]\}}t |d d  t r| qS ) 
__module__  )  getattr 
startswith __name__) .0 k v  r
    FE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/util/__init__.py 
<listcomp>   s    r
   N) utils  globals items  __all__r
   r
   r
   r    <module>   s   
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\__pycache__\firm_data_client.cpython-37.pyc
----------------------------------------
B

    y  d                   @   s    U d dl Z d dlmZmZ d dlZd dlZe   aee	ef e
d< ee	e	f d dd Z
e	e	d  dd	 Zde	d
 dd
 Z
dd  ZdS )     N) Dict Any _firm_client_dictionary) returnc              C   sz   t   } tj d }|d k	r"|| d< tj d }|d k	r>|| d< tj d }|d k	rZ|| d< tj d  }|d k	rv|| d< | S )	NZfirm_DATA_CLIENT_KEY keyZfirm_DATA_CLIENT_CERTIFICATEZ
certificateZfirm_DATA_CLIENT_TRUST trustZfirm_DATA_CLIENT_PASSWORD password) dict os  environ get) o val  r    IE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/firm_data_client.py get_environ_params
   s    r   ) envr   c             C   sB   t j d }|s| S tdd  | d D   }| |  }|s>| S |S )NZfirm_DATA_CLIENT_ENV_MAPPINGc             S   s   g | ]}|  d   qS ) :) split) .0 ir   r   r    
<listcomp>   s    z#map_environment.<locals>.<listcomp> ,)r
   r
   r   r	   r   )r     mappingZmappedr   r   r    map_environment   s    
r    prd) firm_client_envc             C   s^   t |  } |   }t  }|tk rVtj d d k	rBtj j| f| t|< ntj	j| f| t|< t| S )NZfirm_DATA_CLIENT_USESECURE)
r   r   r   r
   r
   r    
atom_clientZ
client_secureZfirmDataClient client)r   r    paramsr   r   r    firm_connect&   s    r    c              C   s*   xt    D ]\} }|    q
W t     d S )N)r    items shutdown clear) k vr   r   r    firm_disconnect_all5   s    r&   )r   )r
    typingr   r   Zatom_client.clientr   Zatom_client.client_securer	   r    str __annotations__r   r   r    r&   r   r   r   r    <module>   s    

........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\__pycache__\crud.cpython-37.pyc
----------------------------------------
B

    y  d                  @   s,   d dl T ddlZdZee  e ee  dS )    ) *     Na   
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                   !!
!! WARNING firm_f3.crud is moved to firm_f3.core.crud                !!
!! please update your import statement accordingly                   !!
!!                                                                   !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
)Z	core.crud warnings msg print warn DeprecationWarning  r	   r	    =E:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/crud.py <module>   s   	
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\__pycache__\endpoints.cpython-37.pyc
----------------------------------------
B

    y  d                  @   s,   d dl T ddlZdZee  e ee  dS )    ) *     Na   
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                   !!
!! WARNING firm_f3.endpoints is moved to firm_f3.core.endpoints      !!
!! please update your import statement accordingly                   !!
!!                                                                   !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
)Zcore.endpoints warnings msg print warn DeprecationWarning  r	   r	    BE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/endpoints.py <module>   s   	
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\__pycache__\mappings.cpython-37.pyc
----------------------------------------
B

    y  d                  @   sh   d Z ddlmZ dejd Zdejd Z dejd Z	d ej
d Z
dejd Z
d	ejd Zd
ejd Zd
S )z 
Our current object names by category
Naming convention <more specific identifier>_<object name>_<tail/ref/namespace>
e.g. EURUSD-Forward-PointsAtPremium_MktData_snap_prd_intraday
     ) 	endpoints 
ModelFragment) nameZendpoint 
ModelRecipe 
ModelStream 
ModelSnapshotZFixingZMktData_streamZMktData_snapN)  __doc__Zfirm_f3.corer    epr   ZMODEL_FRAGMENTr   ZMODEL_RECIPEr   ZMODEL_STREAMr    ZMODEL_SNAPSHOTZIndexFixingsZINDEX_FIXINGZMarketDataStreamZMARKET_DATA_STREAMZMarketDataSnapshotZMARKET_DATA_SNAPSHOT  r
   r
    AE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/mappings.py <module>   s   
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\__pycache__\modelutils.cpython-37.pyc
----------------------------------------
B

    y  d                   @   s,   d dl T ddlZdZee  e ee  dS )    ) *     Na   
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                   !!
!! WARNING firm_f3.modelutils is moved to firm_f3.core.modelutils    !!
!! please update your import statement accordingly                   !!
!!                                                                   !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
)Zcore.modelutils warnings msg print warn DeprecationWarning  r	   r	    CE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/modelutils.py <module>   s   	
........................................
File Path: C:\Users\generich\OneDrive\Documents\4-Work\generic\Systematic\spreadsheets\firm_f3\__pycache__\__init__.cpython-37.pyc
----------------------------------------
B

    y  d                    @   sF   d dl mZ yddlmZ ddlZW n ek
r8   Y n
X eej_ dS )    ) 
__version__     ) 
AtomClientN)  versionr   Zatom_client.clientr   Z
atom_client 
ImportError clientZfirmDataClient  r   r    AE:\firm\Dev\systematic\venv\Lib\site-packages\firm_f3/__init__.py <module>   s   
........................................

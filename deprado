import numpy as np
import pandas as pd
import scipy.stats as scipy_stats
import warnings


def deprado_estimated_sharpe(returns, axis=0):
    """
    Estimate the sharpe without any annualization factor.

    Example:
    --------
    >>> import numpy as np
    >>> from data_analysis.data_analysis.deprado import deprado_estimated_sharpe
    >>> df = np.random.normal(0, 1, (2520, 10))
    >>> print("Sharpe for 2d array: /n", deprado_estimated_sharpe(df))
    >>> ds = np.random.normal(0, 1, 2520)
    >>> print("Sharpe for 1d array: /n", deprado_estimated_sharpe(ds))

    :param returns:
    :param axis:
    :return:
    """
    assert isinstance(returns, (pd.Series, pd.DataFrame, np.ndarray)), f"Cannot process `returns` of type {type(returns)}"

    if isinstance(returns, (pd.DataFrame, pd.Series)):
        returns = returns.values  # convert to numpy array

    # `returns` can only be np.ndarray
    if returns.ndim in (1, 2):
        dim_returns = returns.ndim
    else:
        raise TypeError(f"Dimension of input returns cannot be {returns.ndim}")

    if dim_returns == 1:
        # output singular value
        return np.nanmean(returns, axis=axis) / np.nanstd(returns, ddof=1)
    else:
        # output 1d array
        return np.nanmean(returns, axis=axis) / np.nanstd(returns, ddof=1, axis=axis)


def estimated_sharpe_ratio_stdev(
        returns=None,
        *,
        n=None,
        skew=None,
        kurtosis=None,
        sr=None,
        axis=0,
) -> float:
    """
    Calculate sharpe ratio's estimated standard deviation under I.I.D returns assumption with finite variance.

    Example:
    --------
    >>> import numpy as np
    >>> from data_analysis_toolbox.deprado import estimated_sharpe_ratio_stdev
    >>> input_returns = np.random.normal(0, 1, (2520, 10))
    >>> print(estimated_sharpe_ratio_stdev(input_returns))  # standard deviation for sharpe ratio without annualization
    >>> input_returns = np.random.normal(0, 1, 2520)
    >>> print(estimated_sharpe_ratio_stdev(input_returns))

    :param returns:
    :param n: number of observation
    :param skew:
    :param kurtosis:
    :param sr: float, non-annualized sharpe ratio
    :param axis: int,
    :return:
    """
    assert isinstance(returns, (pd.Series, pd.DataFrame, np.ndarray)), f"`returns` cannot be of type {type(returns)}"

    if isinstance(returns, (pd.Series, pd.DataFrame)):
        _returns = returns.values
    else:
        _returns = returns

    assert _returns.ndim in (1, 2), f"only accept 1d input not shape {_returns.shape}"

    if n is None:
        n = _returns.shape[0]

    if skew is None:
        skew = scipy_stats.skew(_returns, axis=axis)

    if kurtosis is None:
        kurtosis = scipy_stats.kurtosis(_returns, fisher=False, axis=axis)

    if sr is None:
        sr = deprado_estimated_sharpe(_returns, axis=axis)  #

    sr_std = np.sqrt((1 + (0.5 * sr ** 2) - (skew * sr) + (((kurtosis - 3) / 4) * sr ** 2)) / (n - 1))

    return sr_std


def probabilistic_sharpe_ratio(
        returns=None,
        sr_benchmark: float = 0.0,
        *,
        sr=None,
        sr_std=None,
        axis: int = 0,
) -> (float, float, float):
    """
    Get the probabilistic sharpe ratio.

    Assuming that the real sharpe is 0, PSR is equivalent to the probability that the empirical sharpe ratio is
    above a benchmark level `sr_benchmark`, the benchmark level is usually set as 0 by default.

    Example:
    --------
    >>> import numpy as np
    >>> from data_analysis_toolbox.deprado import probabilistic_sharpe_ratio
    >>> returns = np.random.normal(0, 1, (2520, 10))
    >>> print(probabilistic_sharpe_ratio(returns=returns, sr_benchmark=0.0))
    >>> returns = np.random.normal(0, 1, 2520)
    >>> print(probabilistic_sharpe_ratio(returns=returns, sr_benchmark=0.0))

    :param returns:
    :param sr_benchmark:
    :param sr:
    :param sr_std:
    :param axis:
    :return:
    """

    assert isinstance(returns, (pd.Series, pd.DataFrame, np.ndarray)), f"`returns` cannot be of type {type(returns)}"

    if sr is None:
        sr = deprado_estimated_sharpe(returns, axis=axis)

    if sr_std is None:
        sr_std = estimated_sharpe_ratio_stdev(returns, sr=sr, axis=axis)

    psr = scipy_stats.norm.cdf((sr - sr_benchmark) / sr_std)

    return psr, sr_benchmark, sr_std


def num_independent_trials(
        trials_returns=None,
        *,
        m=None,
        p=None,
        verbose=False,
) -> int:
    """
    Calculate the number of independent trials.

    Shape: (T, N) where T is the length of input return series, and N is the total amount of trials.

    Example:
    --------
    >>> import numpy as np
    >>> from data_analysis_toolbox.deprado import num_independent_trials
    >>> trials_returns = np.random.normal(0, 1, (2520, 10))
    >>> print(num_independent_trials(trials_returns=trials_returns))
    >>> trials_returns = np.random.normal(0, 1, (2520, 3))
    >>> trials_returns[:, 0] = np.nan  # include one nan columns, will raise a warning
    >>> print(np.isnan(trials_returns))  # input return series have nan elements
    >>> print(num_independent_trials(trials_returns))
    >>> trials_returns[:, 0] = 0  # include one 0 colums, correlation matrix will have nan
    >>> print(np.isnan(trials_returns).any())  # no nan now
    >>> print(num_independent_trials(trials_returns))

    :param trials_returns: pd.DataFrame, np.ndarray, all trial returns
    :param m: int, number of total trials
    :param p: float, average correlation between all trials
    :param verbose: bool,
    :return:
    """

    if isinstance(trials_returns, pd.DataFrame):
        trials_returns = trials_returns.values
    else:
        assert isinstance(trials_returns, np.ndarray), f"input `trials_returns` cannot be of type: {type(trials_returns)}"

    if m is None:
        m = trials_returns.shape[1]

    if p is None:
        corr_matrix = np.corrcoef(trials_returns.T)
        if np.isnan(corr_matrix).any():
            warnings.warn("Input return series' correlation matrix has NaN, please check! DSR calculation will use nanmean.")
        p = np.nanmean(corr_matrix[np.triu_indices_from(corr_matrix, 1)])

        if verbose:
            print(f"corr_matrix is of shape: {corr_matrix.shape}")

    n = p + (1 - p) * m

    n = int(n) + 1  # round up

    return n


def expected_maximum_sr(
        trials_returns=None,
        expected_mean_sr=0.0,
        *,
        independent_trials=None,
        trials_sr_std=None,
) -> float:
    """
    Compute the expected maximum Sharpe ratio (Analytically).

    Example:
    --------
    >>> import numpy as np
    >>> from data_analysis_toolbox.deprado import expected_maximum_sr
    >>> trials_returns = np.random.normal(0, 1, (2520, 10))
    >>> print(expected_maximum_sr(trials_returns=trials_returns))  # output sharpe is without any annualization
    >>> trials_returns[:, 0] = 0
    >>> print(expected_maximum_sr(trials_returns=trials_returns))

    :param trials_returns: pd.DataFrame, All trials returns, not only the independent trials.
    :param expected_mean_sr: float, Expected mean SR, usually 0. We assume that random strategies will have a mean SR
        of 0, expressed in the same frequency as the other parameters.
    :param independent_trials: int, Number of independent trials, must be between 1 and `trials_returns.shape[1]`
    :param trials_sr_std: float, Standard deviation fo the Estimated sharpe ratios of all trials,
        expressed in the same frequency as the other parameters.
    :return: float, the expected max sharpe ratio
    """
    emc = 0.5772156649  # Euler-Mascheroni constant

    if independent_trials is None:
        independent_trials = num_independent_trials(trials_returns)

    if trials_sr_std is None:
        srs = deprado_estimated_sharpe(trials_returns)
        if np.isnan(srs).any():
            warnings.warn("calculated sharpes contains NaN, please check your input returns series. We use np.nanstd")
        trials_sr_std = np.nanstd(srs)  # calculate the estimated sharpe ratio across trials

    maxZ = (1 - emc) * scipy_stats.norm.ppf(1 - 1. / independent_trials) + emc * scipy_stats.norm.ppf(
        1 - 1. / (independent_trials * np.e))
    expected_max_sr = expected_mean_sr + (trials_sr_std * maxZ)

    return expected_max_sr


def deflated_sharpe_ratio(
        trials_returns=None,
        returns_selected=None,
        expected_mean_sr=0.0,
        *,
        expected_max_sr=None,
) -> (float, float, float):
    """
    Calculate the deflated sharpe ratio (DSR).

    DFS = PSR(SR⁰) = probability that SR^ > SR⁰
    SR^ = sharpe ratio estimated with `returns`, or `sr`
    SR⁰ = `max_expected_sr`

    Reference:
    https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2460551

    Example:
    --------
    >>> import numpy as np
    >>> from data_analysis_toolbox.deprado import deflated_sharpe_ratio, deprado_estimated_sharpe
    >>> trials_returns = np.random.normal(0, 1, (2520, 10))
    >>> trials_perfs = deprado_estimated_sharpe(trials_returns) * np.sqrt(252)
    >>> idx_selected = np.argmax(trials_perfs)
    >>> returns_selected = trials_returns[:, idx_selected]
    >>> # output sharpe is without any annualization
    >>> print(deflated_sharpe_ratio(trials_returns=trials_returns, returns_selected=returns_selected))

    :param trials_returns: pd.DataFrame, all trials returns
    :param returns_selected: pd.Series
    :param expected_mean_sr: float, expected mean sharpe ratio for each single trial, usually assume to be 0 i.e. no
        signal, expressed in the same frequency as the other parameters
    :param expected_max_sr: float, the expected maximum sharpe ratio after running multiple trials,
        expressed in the same frequency as the other parameters
    :return: (dsr, sr_benchmark, sr_std): (float, float, float), deflated sharpe ratio, expected max sharpe ratio,
        sharpe ratio standard deviation.
    """
    if expected_max_sr is None:
        expected_max_sr = expected_maximum_sr(trials_returns, expected_mean_sr)

    dsr, _, sr_std = probabilistic_sharpe_ratio(returns=returns_selected, sr_benchmark=expected_max_sr)

    return dsr, expected_max_sr, sr_std

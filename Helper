import datetime
import logging
import os
from typing import Sequence, Union, Dict, Tuple

import pandas

from sylo.com.progress_bar import progress_bar
from sylo.datetime.date import date_offset

logger = logging.getLogger(__name__)
ALLOCATION_HOME = r'G:\BFAM_FO\Systematic\Data Storage\Capital_allocation'
BACKTEST_PNL_HOME = r'G:\BFAM_FO\Systematic\Data Storage\Strategy_Level_PnL'
LIVE_PNL_HOME = r'G:\BFAM_FO\Systematic\Data Storage\Strategy_Level_PnL'


def get_allocation(asof: datetime.date = None, filename: str = '{}_daily_weights.csv',
                   file_dir: str = None) -> Dict[str, float]:
    if file_dir is None:
        file_dir = ALLOCATION_HOME
    if asof is None:
        if '{}' in filename:
            _filename = filename
            head, tail = _filename.split('{}')
            for filename in sorted(os.listdir(file_dir), reverse=True):
                if filename.startswith(head) and filename.endswith(tail) and filename[len(head):-len(tail)].isdigit():
                    break
            else:
                raise FileNotFoundError(f'no allocation file with name pattern "{_filename}"')
    elif isinstance(asof, datetime.date):
        filename = filename.format(asof.strftime('%Y%m%d'))
    else:
        raise TypeError(asof)
    try:
        raw = pandas.read_csv(os.path.join(file_dir, filename), index_col=0)
    except FileNotFoundError as e:
        raise FileNotFoundError(f'no allocation file with name "{filename}"') from e
    raw.index = (i[:-9] if i.endswith('_backtest') else i for i in raw.index)
    return raw.iloc[:, 0].to_dict()


def get_backtest_frame(
        strategies: Union[str, Sequence[str]] = None,
        start_date: datetime.date = None,
        end_date: datetime.date = None,
        allocation: Union[Dict[str, float], datetime.date] = None,
        filename: str = '{}_backtest.csv',
        file_dir: str = None,
) -> pandas.DataFrame:
    if file_dir is None:
        file_dir = BACKTEST_PNL_HOME
    if not isinstance(allocation, dict):
        allocation = get_allocation(allocation)
    if strategies is None:
        strategies = list(allocation)
    elif isinstance(strategies, str):
        strategies = [strategies]

    def unpack():
        for strategy in strategies:
            _filename = filename.format(strategy)
            try:
                raw = pandas.read_csv(os.path.join(file_dir, _filename), index_col=0, parse_dates=True, dayfirst=True)
            except FileNotFoundError as e:
                raise FileNotFoundError(f'no backtest file with name "{_filename}"') from e
            sr = raw['PnL']
            if len(sr):
                if start_date or end_date:
                    sr = sr.loc[start_date:end_date]
                sr = sr.mul(allocation.get(strategy, 1.)).cumsum()
            yield strategy, sr

    frame = pandas.DataFrame(dict(unpack()))
    for k, v in frame.items():
        v.loc[v.first_valid_index():v.last_valid_index()] = v.loc[v.first_valid_index():v.last_valid_index()].ffill()
    return frame


def get_live_pnl(
        strategies: Union[str, Sequence[str]] = None,
        start_date: datetime.date = None,
        end_date: datetime.date = None,
        filename: str = '{}.csv',
        file_dir: str = None,
) -> pandas.DataFrame:
    if file_dir is None:
        file_dir = LIVE_PNL_HOME
    if strategies is None:
        strategies = list(get_allocation())
    elif isinstance(strategies, str):
        strategies = [strategies]

    def unpack():
        for strategy in strategies:
            _filename = filename.format(strategy)
            try:
                raw = pandas.read_csv(os.path.join(file_dir, _filename), index_col=0, parse_dates=True, dayfirst=True)
            except FileNotFoundError as e:
                raise FileNotFoundError(f'no live pnl file with name "{_filename}"') from e
            sr = raw['PV Live']
            if len(sr):
                sr = sr.diff()
                if start_date or end_date:
                    sr = sr.loc[start_date:end_date]
            yield strategy, sr.cumsum()

    frame = pandas.DataFrame(dict(unpack()))
    for k, v in frame.items():
        v.loc[v.first_valid_index():v.last_valid_index()] = v.loc[v.first_valid_index():v.last_valid_index()].ffill()
    return frame


def get_minmax_envelope(
        strategies: Union[str, Sequence[str]] = None,
        start_date: datetime.date = None,
        end_date: datetime.date = None,
        backtest_allocation: Union[Dict[str, float], datetime.date, float] = None,
        backtest_start_date: datetime.date = None,
        backtest_end_date: datetime.date = None,
        backtest_condition_value_range: Tuple[float, float] = None,
        backtest_condition_nearest_values: int = None,
        envelope_periods: int = None,
        ffill_missing_forward_history: bool = True,
        unit: float = 1_000,
        sorted_minmax: bool = False,
        off_live_bt_live: bool = False
) -> pandas.DataFrame:
    live = get_live_pnl(strategies, start_date=start_date, end_date=end_date)
    live_first, live_last = live.first_valid_index(), live.last_valid_index()
    if isinstance(backtest_allocation, (float, int)):
        backtest_allocation = {i: backtest_allocation for i in live}
    bt_raw = get_backtest_frame(list(live), start_date=backtest_start_date, allocation=backtest_allocation)
    if backtest_end_date is None:
        backtest_end_date = live_first
    bt, bt_live = bt_raw.loc[:backtest_end_date], bt_raw.loc[live_first:live_last]

    def unpack():
        # noinspection PyArgumentList
        _live = live.ffill().fillna(0.).diff().sum(axis=1)
        _bt_ = _bt = bt.ffill().fillna(0.).diff().sum(axis=1)
        _bt_live = bt_live.ffill().fillna(0.).diff().sum(axis=1)
        _bt_sorted = _bt.sort_values() if sorted_minmax else None
        _bt_paths = None
        if backtest_condition_value_range or backtest_condition_nearest_values:
            ltd_len, ltd = len(_live) - 1, _live.sum()
            if ltd_len > 0:
                if ltd_len == 1:
                    _bt_paths = _bt.shift(-1).dropna()
                else:
                    _bt_paths = _bt.rolling(window=ltd_len).sum().shift(-ltd_len + 1).dropna()
                if backtest_condition_value_range:
                    lower, higher = (ltd + i for i in backtest_condition_value_range)
                    _bt_paths = _bt_paths[(lower <= _bt_paths) & (_bt_paths <= higher)]
                if backtest_condition_nearest_values:
                    idx = _bt_paths.sub(ltd).abs().sort_values().iloc[:backtest_condition_nearest_values].index
                    _bt_paths = _bt_paths[idx]
        i, dt, vv = 0, start_date, 0.
        for i, (dt, v) in enumerate(_live.items()):
            vv += v
            if i == 0:
                vv = _min = _max = 0.
                _mean = _median = 0.
            else:
                if i > 1:
                    _bt_ = _bt.rolling(window=i).sum().shift(-i + 1)
                if _bt_paths is not None:
                    _bt_ = _bt_[_bt_paths.index]
                _min, _max = _bt_.min(), _bt_.max()
                _mean, _median = _bt_.mean(), _bt_.median()

            # jchi@2022-03-29
            # per Adel's request to add sorted min-max envelope
            extra = {'bt_mean': _mean, 'bt_median': _median}
            if sorted_minmax:
                if i < 2:
                    extra['sorted_min'] = _min
                    extra['sorted_max'] = _max
                else:
                    extra['sorted_min'] = _bt_sorted.head(i).sum()
                    extra['sorted_max'] = _bt_sorted.tail(i).sum()
            if off_live_bt_live:
                yield dt, {'bt_min': _min, 'bt_max': _max, **extra}
            else:
                yield dt, {'bt_min': _min, 'live': vv, 'bt_live': _bt_live.loc[:dt].sum(), 'bt_max': _max, **extra}
        # extend envelope beyond live if envelope_periods is specified
        if envelope_periods and envelope_periods > i:
            if dt is None:
                dt = datetime.date.today() - datetime.timedelta(days=1)
            for j in range(i, envelope_periods):
                dt = date_offset(dt, offset='1b')
                if j == 0:
                    _min = _max = 0.
                    _mean = _median = 0.
                else:
                    if j > 1:
                        _bt_ = _bt.rolling(window=j).sum().shift(-j + 1)
                    if _bt_paths is not None:
                        _bt_ = _bt_[_bt_paths.index]
                    # jchi@2022-04-29
                    # fill the nans due to missing forward history
                    if ffill_missing_forward_history:
                        for k in _bt_[_bt_.isna()].index:
                            _bt_[k] = _bt[k:].sum()
                    _min, _max = _bt_.min(), _bt_.max()
                    _mean, _median = _bt_.mean(), _bt_.median()

                # jchi@2022-03-29
                # per Adel's request to add sorted min-max envelope
                extra = {'bt_mean': _mean, 'bt_median': _median}
                if sorted_minmax:
                    if i < 2:
                        extra['sorted_min'] = _min
                        extra['sorted_max'] = _max
                    else:
                        extra['sorted_min'] = _bt_sorted.head(j).sum()
                        extra['sorted_max'] = _bt_sorted.tail(j).sum()

                yield dt, {'bt_min': _min, 'live': None, 'bt_live': None, 'bt_max': _max, **extra}

    frame = pandas.DataFrame(dict(unpack())).T
    if unit:
        frame /= unit
    return frame


def get_minmax_summary(
        strategies: Sequence[str] = None,
        start_date: datetime.date = None,
        end_date: datetime.date = None,
        backtest_allocation: Union[Dict[str, float], datetime.date, float] = None,
        backtest_start_date: datetime.date = None,
        backtest_end_date: datetime.date = None,
        unit: float = 1_000,
) -> pandas.DataFrame:
    live = get_live_pnl(strategies, start_date=start_date, end_date=end_date)
    if isinstance(backtest_allocation, (float, int)):
        backtest_allocation = {i: backtest_allocation for i in live}
    if backtest_end_date is None:
        backtest_end_date = live.first_valid_index()
    bt = get_backtest_frame(list(live), start_date=backtest_start_date, end_date=backtest_end_date,
                            allocation=backtest_allocation)
    # noinspection PyArgumentList
    live['total'], bt['total'] = live.ffill().sum(axis=1), bt.ffill().sum(axis=1)

    def unpack():
        for k, v in progress_bar(live.items(), total=live.shape[1]):
            _live, _bt = v.dropna(), bt[k].dropna()
            rolling_bt = _bt.diff().rolling(len(_live)).sum()
            yield k, {
                'live': _live.iloc[-1],
                'live_dd': _live.sub(_live.cummax()).min(),
                'bt_dd': _bt.rolling(len(_live)).apply(lambda x: x.sub(x.cummax()).min()).min(),
                'bt_min': rolling_bt.min(),
                'bt_max': rolling_bt.max(),
                'bt_mean': rolling_bt.mean(),
                'bt_median': rolling_bt.median(),
            }

    frame = pandas.DataFrame(dict(unpack())).T
    if unit:
        frame /= unit
    return frame


def get_sharpe_envelope(
        strategies: Union[str, Sequence[str]] = None,
        start_date: datetime.date = None,
        end_date: datetime.date = None,
        backtest_allocation: Union[Dict[str, float], datetime.date, float] = None,
        backtest_start_date: datetime.date = None,
        backtest_end_date: datetime.date = None,
        envelope_periods: int = None,
        sharpe_min_periods: int = 20,
        sharpe_annual_day_count: int = 252,
) -> pandas.DataFrame:
    live = get_live_pnl(strategies, start_date=start_date, end_date=end_date)
    live_first, live_last = live.first_valid_index(), live.last_valid_index()
    if isinstance(backtest_allocation, (float, int)):
        backtest_allocation = {i: backtest_allocation for i in live}
    bt_raw = get_backtest_frame(list(live), start_date=backtest_start_date, allocation=backtest_allocation)
    if backtest_end_date is None:
        backtest_end_date = live_first
    bt, bt_live = bt_raw.loc[:backtest_end_date], bt_raw.loc[live_first:live_last]
    annual_factor = sharpe_annual_day_count ** 0.5

    def unpack():
        # noinspection PyArgumentList
        _live, _bt = live.ffill().fillna(0.).diff().sum(axis=1), bt.ffill().fillna(0.).diff().sum(axis=1)
        _bt_live = bt_live.ffill().fillna(0.).diff().sum(axis=1)
        i, dt = sharpe_min_periods, start_date
        for vv in _live.expanding():
            i, dt = len(vv), vv.last_valid_index()
            if i < sharpe_min_periods:
                continue
            live_sharpe = vv.mean() / vv.std() * annual_factor
            bt_live_sharpe = _bt_live[:dt].mean() / _bt_live[:dt].std() * annual_factor
            rolling = _bt.rolling(window=i)
            rolling_sharpe = rolling.mean().div(rolling.std()).mul(annual_factor)
            yield dt, {'bt_min': rolling_sharpe.min(), 'live': live_sharpe, 'bt_live': bt_live_sharpe,
                       'bt_max': rolling_sharpe.max(), 'bt_mean': rolling_sharpe.mean(),
                       'bt_median': rolling_sharpe.median()}
        # extend envelope beyond live if envelope_periods is specified
        if envelope_periods and envelope_periods > i:
            if dt is None:
                dt = datetime.date.today() - datetime.timedelta(days=1)
            for j in range(i, envelope_periods):
                dt = date_offset(dt, offset='1b')
                if j < sharpe_min_periods:
                    continue
                rolling = _bt.rolling(window=j)
                rolling_sharpe = rolling.mean().div(rolling.std()).mul(annual_factor)
                yield dt, {'bt_min': rolling_sharpe.min(), 'live': None, 'bt_live': None,
                           'bt_max': rolling_sharpe.max(), 'bt_mean': rolling_sharpe.mean(),
                           'bt_median': rolling_sharpe.median()}

    frame = pandas.DataFrame(dict(unpack())).T
    return frame


def get_bt_hist(
        strategies: Union[str, Sequence[str]] = None,
        start_date: datetime.date = None,
        end_date: datetime.date = None,
        backtest_allocation: Union[Dict[str, float], datetime.date, float] = None,
        backtest_start_date: datetime.date = None,
        backtest_end_date: datetime.date = None,
        backtest_condition_value_range: Tuple[float, float] = None,
        backtest_condition_nearest_values: int = None,
        relative_to_ltd: bool = True,
        return_raw: bool = False,
        unit: float = 1_000,
) -> pandas.DataFrame:
    live = get_live_pnl(strategies, start_date=start_date, end_date=end_date)
    if isinstance(backtest_allocation, (float, int)):
        backtest_allocation = {i: backtest_allocation for i in live}
    if backtest_end_date is None:
        backtest_end_date = live.first_valid_index()
    bt = get_backtest_frame(list(live), start_date=backtest_start_date, end_date=backtest_end_date,
                            allocation=backtest_allocation)
    if 'total' not in bt:
        # noinspection PyArgumentList
        bt['total'] = bt.ffill().sum(axis=1)
    if 'total' not in live:
        # noinspection PyArgumentList
        live['total'] = live.ffill().sum(axis=1)

    def unpack():
        for key, val in bt.items():
            _live, _bt = live[key], val.dropna().ffill().diff()
            ltd = _live.loc[_live.last_valid_index()]
            _start_date = start_date or _live.first_valid_index()
            if isinstance(_start_date, datetime.datetime):
                _start_date = _start_date.date()
            _end_date = end_date or _live.last_valid_index()
            if isinstance(_end_date, datetime.datetime):
                _end_date = _end_date.date()
            _window = int((_end_date - _start_date).days / 7 * 5)
            _bt_ = _bt.rolling(_window).sum().shift(-_window + 1)
            if backtest_condition_value_range or backtest_condition_nearest_values:
                ltd_len = len(_live) - 1
                if ltd_len > 0:
                    if ltd_len == 1:
                        _bt_paths = _bt.shift(-1).dropna()
                    else:
                        _bt_paths = _bt.rolling(window=ltd_len).sum().shift(-ltd_len + 1).dropna()
                    if backtest_condition_value_range:
                        lower, higher = (ltd + i for i in backtest_condition_value_range)
                        _bt_paths = _bt_paths[(lower <= _bt_paths) & (_bt_paths <= higher)]
                    if backtest_condition_nearest_values:
                        idx = _bt_paths.sub(ltd).abs().sort_values().iloc[:backtest_condition_nearest_values].index
                        _bt_paths = _bt_paths[idx]
                    _bt_ = _bt_[_bt_paths.index]
            if relative_to_ltd:
                _bt_ -= ltd
            yield key, _bt_.dropna().sort_values().reset_index(drop=True)

    raw = pandas.DataFrame(dict(unpack()))
    if unit:
        raw /= unit
    if return_raw:
        return raw
    return pandas.DataFrame({
        'mean': raw.mean(),
        'std': raw.std(),
        'skew': raw.skew(),
        'kurtosis': raw.kurtosis(),
        'count': raw.count(),
    })


class Strategy:
    XCCY = 'ccyswap_meanreversion'
    XCCY_RL = 'ccyswap_reload'
    SWAP = 'swap'
    SWAP_1 = 'swap_1'
    SWAPTION = 'swaption'
    PAT_1 = 'equities_pattern'
    PAT_2 = 'equities_pattern_2'
    TRF = 'trf'
    FX_1 = 'fx_spot_1'
    FX_POINTS = 'fx_points'
    A_H = 'a_h'
    SWAP_G10_BASKET = 'swap_g10_basket'


if __name__ == '__main__':
    pass
    from notebooks.params import REF_DATE, BT_START_DATE, WEIGHTS, DISTANCE

    bt_frame = get_backtest_frame()
    live_frame = get_live_pnl()

    df = get_minmax_envelope(strategies=list(WEIGHTS), start_date=REF_DATE, envelope_periods=252,
                             backtest_allocation=WEIGHTS, backtest_start_date=BT_START_DATE)
    df.plot()
    df = get_minmax_envelope(strategies=list(WEIGHTS), start_date=REF_DATE, envelope_periods=252,
                             backtest_allocation=WEIGHTS, backtest_start_date=BT_START_DATE,
                             backtest_condition_value_range=DISTANCE)
    df.plot()

    df = get_sharpe_envelope(strategies=list(WEIGHTS), start_date=REF_DATE, envelope_periods=252,
                             backtest_allocation=WEIGHTS, backtest_start_date=BT_START_DATE)
    df.plot()

    df = get_minmax_summary(start_date=REF_DATE)
    print(df)

    df = get_bt_hist(strategies=list(WEIGHTS), start_date=REF_DATE, end_date=datetime.date(REF_DATE.year, 12, 31),
                     backtest_allocation=WEIGHTS, backtest_start_date=BT_START_DATE,
                     backtest_condition_value_range=DISTANCE, return_raw=False)
    print(df)
    df = get_bt_hist(strategies=list(WEIGHTS), start_date=REF_DATE, end_date=datetime.date(REF_DATE.year, 12, 31),
                     backtest_allocation=WEIGHTS, backtest_start_date=BT_START_DATE,
                     backtest_condition_value_range=DISTANCE, return_raw=True)
    df.hist()

import datetime
import logging
from typing import Iterable, Sequence, Dict, List, Set, Tuple

from sylo.mdp import MarketDataProviderType, BPipeMarketDataProvider, BConMarketDataProvider
from sylo.mdp.rs_bbg import RedshiftMarketDataProvider
from . import forex_cfg as fx
from .forex import Forex, ticker_to_eod_timedelta, resolve_reference_date

logger = logging.getLogger(__name__)


def set_quote_data_in_batch(forex_objs: Iterable[Forex]) -> Sequence[Forex]:
    def unpack():
        mdp: Dict[int, MarketDataProviderType] = {}
        raw: Dict[int, List[Forex]] = {}
        tickers: Dict[int, Set[str]] = {}
        fields: Dict[int, Set[str]] = {}
        for forex in forex_objs:
            _id = id(forex.market_data_provider)
            mdp[_id] = forex.market_data_provider
            raw.setdefault(_id, []).append(forex)
            tickers.setdefault(_id, set()).update(forex.get_live_tickers().values())
            fields.setdefault(_id, set()).update(forex.live_field_names)
        for _id, objs in raw.items():
            market_data_provider = mdp[_id]
            reference_datetime = datetime.datetime.now()
            logger.debug(f'fetching live data in batch -> {len(tickers[_id])} tickers and {len(fields[_id])} fields')
            data = market_data_provider.bdp(securities=tickers[_id], fields=fields[_id])
            data = data.groupby(level=0).apply(lambda x: (x.max() + x.min()) / 2)
            for forex in objs:
                _tickers = {v: k for k, v in forex.get_live_tickers().items()}
                _data = data[[i for i in _tickers if i in data.index]].rename(_tickers)
                forex.set_quote_data(_data, reference_datetime=reference_datetime, copy=False)
                yield forex

    return list(unpack())


def set_quote_data_history_in_batch(forex_objs: Iterable[Forex]) -> Sequence[Forex]:
    def unpack():
        mdp: Dict[int, MarketDataProviderType] = {}
        raw: Dict[int, List[Forex]] = {}
        tickers: Dict[int, Set[str]] = {}
        fields: Dict[int, Set[str]] = {}
        start_dates: Dict[int, Set[datetime.date]] = {}
        end_dates: Dict[int, Set[datetime.date]] = {}
        for forex in forex_objs:
            _id = id(forex.market_data_provider)
            mdp[_id] = forex.market_data_provider
            raw.setdefault(_id, []).append(forex)
            tickers.setdefault(_id, set()).update(forex.get_history_tickers().values())
            fields.setdefault(_id, set()).update(forex.history_field_names)
            start_dates.setdefault(_id, set()).add(forex.history_start)
            end_dates.setdefault(_id, set()).add(forex.reference_datetime.date())
        for _id, objs in raw.items():
            if not start_dates[_id]:
                raise ValueError('history_start not specified ...')
            market_data_provider = mdp[_id]
            ref_datetime = datetime.datetime.now()
            logger.debug(f'fetching history data in batch -> {len(tickers[_id])} tickers and {len(fields[_id])} fields')
            data = market_data_provider.bdh(
                securities=tickers[_id],
                fields=fields[_id],
                start_date=min(start_dates[_id]),
                end_date=max(end_dates[_id]),
            )
            data = data.groupby(level=0, axis=1).apply(lambda x: x.max(axis=1).add(x.min(axis=1)).div(2))
            data.sort_index(inplace=True)
            for forex in objs:
                _tickers = {v: k for k, v in forex.get_history_tickers().items()}
                _data = data[[i for i in _tickers if i in data]].rename(_tickers, axis=1)
                _data.dropna(axis=0, how='all', inplace=True)
                if isinstance(market_data_provider,
                              (BPipeMarketDataProvider, BConMarketDataProvider, RedshiftMarketDataProvider)):
                    ref_time: datetime.timedelta = ticker_to_eod_timedelta(f'_ {forex.history_data_source} _')
                    if forex.history_data_source[1:].isdigit():  # BFIX
                        _data.index += ref_time
                        bfix_time = int(forex.history_data_source[1:])
                        if bfix_time > 170:
                            # bfix business day moves forward after 5pm local time, shift back to align with wall time
                            _data = _data.shift(-1)
                    else:  # BGN
                        ref_date = resolve_reference_date(ref_datetime)
                        _data.index = [i + ref_time if i < ref_date else ref_datetime for i in _data.index]
                forex.set_quote_data_history(_data, copy=False)
                yield forex

    return list(unpack())


def get_outright_quotes_live(currency_tenors: Iterable[Tuple[str, str]], **kwargs) -> Dict[Tuple[str, str], float]:
    forex_objs: Dict[Tuple[str, str], fx.Forex] = {}
    for currency, tenor in currency_tenors:
        if tenor == '0b':
            tenor = '1m'
        tenors = {'0b', '0b/' + tenor, tenor}
        forex_objs[currency, tenor] = forex = getattr(fx, f'{currency}x')(**kwargs)
        forex.quote_tickers = {k: v for k, v in forex.quote_tickers.items() if k in tenors}
    set_quote_data_in_batch(forex_objs.values())
    return {(i, j): v.quote_data[j] for (i, j), v in forex_objs.items()}


def get_swap_quotes_live(currency_tenors: Iterable[Tuple[str, str, str]],
                         **kwargs) -> Dict[Tuple[str, str, str], float]:
    forex_objs: Dict[Tuple[str, str, str], fx.Forex] = {}
    for currency, tenor1, tenor2 in currency_tenors:
        tenors = {'0b', '0b/' + tenor1, tenor1, '0b/' + tenor2, tenor2}
        forex_objs[currency, tenor1, tenor2] = forex = getattr(fx, f'{currency}x')(**kwargs)
        forex.quote_tickers = {k: v for k, v in forex.quote_tickers.items() if k in tenors}
    set_quote_data_in_batch(forex_objs.values())
    return {(i, j, k): v.quote_data[k] - v.quote_data[j] for (i, j, k), v in forex_objs.items()}


if __name__ == '__main__':
    pass

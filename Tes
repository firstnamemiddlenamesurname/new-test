import datetime
import logging
import os
from typing import Sequence

import nbformat
from nbconvert import HTMLExporter
from nbconvert.preprocessors import ExecutePreprocessor

from sylo.com import email

logger = logging.getLogger(__name__)
NOTEBOOK_EXT = '.ipynb'
IMPORT_DIR = os.path.join(os.path.dirname(__file__), 'notebooks')
EXPORT_DIR = os.path.join(os.path.dirname(__file__), 'exported')


def export_ipynb_to_html(filename: str, import_dir: str = None, export_dir: str = None, export_filename: str = None,
                         timestamp: str = '%Y%m%dT%H%M') -> str:
    if not filename.endswith(NOTEBOOK_EXT):
        raise ValueError(f'invalid file extension "{filename}"')
    run_timestamp = datetime.datetime.now()

    if import_dir is None:
        import_dir = os.getenv('NOTEBOOKS_IMPORT_DIR', IMPORT_DIR)
    with open(os.path.join(import_dir, filename), 'r') as f:
        nb = nbformat.read(f, as_version=4)

    ep = ExecutePreprocessor(timeout=-1, kernel_name='python3')
    ep.preprocess(nb)

    html_exporter = HTMLExporter()
    html_exporter.exclude_input = True
    html, _ = html_exporter.from_notebook_node(nb)

    if export_dir is None:
        export_dir = os.getenv('NOTEBOOKS_EXPORT_DIR', EXPORT_DIR)
    if not os.path.exists(export_dir):
        if os.path.dirname(export_dir) != os.path.dirname(__file__):
            raise FileNotFoundError(f'No such directory: "{export_dir}"')
        os.mkdir(export_dir)
    if export_filename is None:
        export_filename = filename[:-len(NOTEBOOK_EXT)] + '_{}.html'
    if timestamp:
        export_filename = export_filename.format(run_timestamp.strftime(timestamp))
    export_path = os.path.join(export_dir, export_filename)
    logger.info(f'exporting to "{export_path}"')
    with open(export_path, "w", encoding='utf-8') as f:
        f.write(html)
    return export_path


def export_to_email(filepaths: Sequence[str] = None, timestamp: str = '%Y-%m-%d'):
    if filepaths and all(map(os.path.exists, filepaths)):
        to_addresses = os.getenv('NOTEBOOKS_EXPORT_EMAIL_TO')
        subject = os.getenv('NOTEBOOKS_EXPORT_EMAIL_SUBJECT')
        if to_addresses:
            if subject and timestamp:
                subject = subject.format(datetime.datetime.now().strftime(timestamp))
            email.send_email(
                subject=subject,
                from_addr=os.getenv('NOTEBOOKS_EXPORT_EMAIL_FROM'),
                to_addrs=to_addresses,
                cc_addrs=os.getenv('NOTEBOOKS_EXPORT_EMAIL_CC'),
                bcc_addrs=os.getenv('NOTEBOOKS_EXPORT_EMAIL_BCC'),
                attachments=filepaths,
            )


def main():
    import_dir = os.getenv('NOTEBOOKS_IMPORT_DIR', IMPORT_DIR)
    import_filename = os.getenv('NOTEBOOK_IMPORT_FILENAME')
    export_filename = os.getenv('NOTEBOOK_EXPORT_FILENAME')

    def unpack():
        for filename in os.listdir(import_dir):
            if import_filename and filename != import_filename:
                continue
            elif filename.endswith(NOTEBOOK_EXT):
                while True:
                    try:
                        yield export_ipynb_to_html(filename=filename, import_dir=import_dir,
                                                   export_filename=export_filename)
                        break
                    except OSError as e:
                        logger.error('', exc_info=e)
                        if input('do you want to retry? (y/n)').lower() != 'y':
                            break

    export_to_email(list(unpack()))


def backfill_main():
    date_str1, date_str2 = os.environ['REF_DATE_RANGE'].split('_')
    date1 = datetime.date.today() if date_str1 == 'TODAY' else datetime.datetime.strptime(date_str1, '%Y-%m-%d').date()
    date2 = datetime.date.today() if date_str2 == 'TODAY' else datetime.datetime.strptime(date_str2, '%Y-%m-%d').date()
    start_date, end_date = min(date1, date2), max(date1, date2)
    date_exclude = os.getenv('REF_DATE_EXCLUDE', '')
    while end_date >= start_date:
        if end_date.weekday() < 5 and end_date.isoformat() not in date_exclude:
            os.environ['REF_DATE'] = end_date.isoformat()
            main()
        end_date -= datetime.timedelta(days=1)


if __name__ == '__main__':
    from app.config.config import init_config

    try:
        init_config()
        if 'REF_DATE_RANGE' in os.environ:
            backfill_main()
        else:
            main()
    except Exception as exc:
        logger.error('', exc_info=exc)
        input('press enter to exit ...')
